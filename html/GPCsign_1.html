<div class="container">

<table style="width: 100%;"><tr>
<td>gpcm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit and/or create a Gaussian Process Classification (GPC) model</h2>

<h3>Description</h3>

<p><code>gpcm</code> is used to fit GPC models. When parameters are known, the function creates a model using given parameters. Otherwise, they are estimated by Maximum Likelihood. In both cases, the result is a <code>gpcm</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gpcm(f, Xf, covtype = "matern5_2", noise.var = 1e-6,
     coef.cov = NULL, coef.m = NULL, multistart = 1,
     seed = NULL, lower = NULL, upper = NULL, nsimu = 100,
     normalize = TRUE, X.mean = NULL, X.std = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a vector containing the binary observations (+/-1) corresponding to the class labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xf</code></td>
<td>
<p>a matrix representing the design of experiments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covtype</code></td>
<td>
<p>a character string specifying the covariance structure for the latent GP. Default is <code>matern_5_2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise.var</code></td>
<td>
<p>variance value standing for the homogeneous nugget effect. Default is 1e-6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.cov</code></td>
<td>
<p>an optional vector containing the values for covariance parameters for the latent GP. (See below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.m</code></td>
<td>
<p>an optional scalar corresponding to the mean value of the latent GP. If both <code>coef.cov</code> and <code>coef.m</code> are provided, no covariance parameter estimation is performed. If at least one of them is missing, both are estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multistart</code></td>
<td>
<p>an optional integer indicating the number of initial points from which running the <code>BFGS</code> for covariance parameter optimization. The multiple optimizations
will be performed in parallel provided that a parallel backend is registered (see package future)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>to fix the seed, default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>(see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p><code>lower</code>, <code>upper</code>: bounds for the covariance parameters (scalars or vectors), if <code>NULL</code> they are set to 0.2 and 3, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsimu</code></td>
<td>
<p>the number of samples of the latent process at observation points <code>Xf</code> to generate. Must be a non-null integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>a logical parameter indicating whether to normalize the input matrix <code>Xf</code>. If <code>TRUE</code>, the matrix will be normalized using <code>X.mean</code> and <code>X.std</code> values if given; otherwise, the mean and standard deviation are computed and used for normalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.mean</code></td>
<td>
<p>(see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.std</code></td>
<td>
<p>optional vectors containing mean and  standard deviation values for each column of the input matrix. If they are not provided, they are computed from the input matrix <code>Xf</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The generation of the matrix of samples of the latent process <code>Z_obs</code> is done using Gibbs sampling. See <code>rtmvnorm</code> function in <code>tmvtnorm</code> package.
</p>


<h3>Value</h3>

<p>An object of class <code>gpcm</code>. See <code>gpcm-class</code>.
</p>


<h3>Author(s)</h3>

<p>Morgane MENZ, Céline HELBERT, Victor PICHENY, François BACHOC. Contributors: Naoual SERRAJI.
</p>


<h3>References</h3>

<p>Bachoc, F., Helbert, C. &amp; Picheny, V. Gaussian process optimization with failures: classification and convergence proof. <em>J Glob Optim</em> <b>78</b>, 483–506 (2020). <a href="https://doi.org/10.1007/s10898-020-00920-0">doi:10.1007/s10898-020-00920-0</a>.
</p>
<p>Kotecha, J. H., Djuric, P. M. (1999). Gibbs Sampling Approach For Generation of Truncated Multivariate Gaussian Random Variables. <em>IEEE Computer Society</em>, 1757–1760.
</p>
<p>Wilhelm, S. tmvtnorm: Truncated Multivariate Normal and Student t Distribution. R package version 	1.6. <a href="https://CRAN.R-project.org/package=tmvtnorm">https://CRAN.R-project.org/package=tmvtnorm</a>.
</p>
<p>Roustant, O., Ginsbourger, D. &amp; Deville, Y. Contributors: Chevalier, C. , Richet, Y. DiceKriging: Kriging Methods for Computer Experiments. R package version 1.6.0. <a href="https://CRAN.R-project.org/package=DiceKriging">https://CRAN.R-project.org/package=DiceKriging</a>.
</p>
<p>Byrd, R. H., Lu, P., Nocedal, J. and Zhu, C. (1995). A limited memory algorithm for bound constrained optimization. <em>SIAM Journal on Scientific Computing</em>, <b>16</b>, 1190–1208. <a href="https://doi.org/10.1137/0916069">doi:10.1137/0916069</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># ----------------------------------
# A 1D example - sinusoidal function
# ----------------------------------
sinusoidal_function &lt;- function(x) {
  sin(4 * pi * x)
}

# Design of Experiments Xf and the corresponding signs f
Xf &lt;- as.matrix(c(0.07, 0.19, 0.42, 0.56, 0.81, 0.90))
f &lt;- rep(1, length(Xf))
f[(sinusoidal_function(Xf) &lt; 0)] &lt;- -1

# GPC model
GPCmodel &lt;- gpcm(f, Xf, multistart = 3)

# Graphics of predictions
x &lt;- as.matrix(seq(0, 1, length.out = 101))
result &lt;- predict(object = GPCmodel, newdata = x)
probabilities &lt;- result$prob
index &lt;- match(Xf, x)
plot(x, probabilities, pch = "-")
points(Xf[f == 1], probabilities[index[f == 1]], pch = 20, col = "blue")
points(Xf[f == -1], probabilities[index[f == -1]], pch = 20, col = "red")
abline(h = 0.5, lty = 2)
legend("topright",title = "DoE Xf",title.cex = 0.7, legend = c("+", "-"), 
     col = c("blue", "red"), pch = 20)


# ----------------------------------
# A 2D example - Branin-Hoo function
# ----------------------------------

# 30-points DoE, and the corresponding response
d &lt;- 2
nb_PX &lt;- 30
require(DiceDesign)
X &lt;- lhsDesign(nb_PX, d, seed = 123)$design
Xopt &lt;- maximinSA_LHS(X, T0 = 10, c = 0.99, it = 10000)
x &lt;- Xopt$design
require(DiceKriging)
fx &lt;- apply(x, 1, branin)
f &lt;- ifelse(fx &lt; 14, -1, 1)
Xf &lt;- as.matrix(x)

# Fit and create a GPC model without parallelisation
t0 &lt;- proc.time()
GPCmodel &lt;- gpcm(f, Xf, multistart = 3, seed = 123)
t1 = proc.time() - t0
cat(" time elapsed : ",t1[3])
print(GPCmodel)

# Graphics - Predict probabilities
ngrid &lt;- 50
x.grid &lt;- seq(0, 1., length.out = ngrid)
grid &lt;- as.matrix(expand.grid(x.grid, x.grid))
probabilities &lt;- predict(GPCmodel, newdata = grid, light.return = TRUE)
filled.contour(x.grid, x.grid, matrix(probabilities, ngrid, ngrid),
               color.palette = function(n) hcl.colors(n, "RdYlBu", rev = FALSE),
               main = "probabilities map",
               plot.axes = {
                 axis(1)
                 axis(2)
                 points(Xf[f == 1, 1], Xf[f == 1, 2], col = "blue", pch = 21, bg = "blue")
                 points(Xf[f == -1, 1], Xf[f == -1, 2], col = "red", pch = 21, bg = "red")
               }
)

# Fit and create a GPC model with parallelisation
## Use multisession futures
require(future)
plan(multisession)
t0 = proc.time()
GPCmodel2 &lt;-  gpcm(f,Xf, multistart = 3, seed = 123 )
t1 = proc.time() - t0
cat(" time elapsed : ",t1[3])
print(GPCmodel2)
## Explicitly close multisession workers by switching plan
plan(sequential)

</code></pre>


</div>