<div class="container">

<table style="width: 100%;"><tr>
<td>estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate a model</h2>

<h3>Description</h3>

<p>Estimates parameters for a dynamic network model via maximum likelihood
implementing the iterative Newton-Raphson procedure as describe in
Stadtfeld and Block (2017).
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate(
  x,
  model = c("DyNAM", "REM", "DyNAMi"),
  subModel = c("choice", "rate", "choice_coordination"),
  estimationInit = NULL,
  preprocessingInit = NULL,
  preprocessingOnly = FALSE,
  envir = new.env(),
  progress = getOption("progress"),
  verbose = getOption("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a formula that defines at the left-hand side the dependent
network (see <code>defineDependentEvents()</code>) and at the right-hand side the
effects and the variables for which the effects are expected to occur
(see <code>vignette("goldfishEffects")</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a character string defining the model type.
Current options include <code>"DyNAM"</code>, <code>"DyNAMi"</code> or <code>"REM"</code>
</p>

<dl>
<dt>DyNAM</dt>
<dd>
<p>Dynamic Network Actor Models
(Stadtfeld, Hollway and Block, 2017 and Stadtfeld and Block, 2017)</p>
</dd>
<dt>DyNAMi</dt>
<dd>
<p>Dynamic Network Actor Models for interactions
(Hoffman et al., 2020)</p>
</dd>
<dt>REM</dt>
<dd>
<p>Relational Event Model (Butts, 2008)</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subModel</code></td>
<td>
<p>a character string defining the submodel type.
Current options include <code>"choice"</code>, <code>"rate"</code> or
<code>"choice_coordination"</code>
</p>

<dl>
<dt>choice</dt>
<dd>
<p>a multinomial receiver choice model <code>model = "DyNAM"</code>
(Stadtfeld and Block, 2017), or the general Relational event model
<code>model = "REM"</code> (Butts, 2008).
A multinomial group choice model <code>model = "DyNAMi"</code> (Hoffman et al., 2020)</p>
</dd>
<dt>choice_coordination</dt>
<dd>
<p>a multinomial-multinomial model for coordination
ties <code>model = "DyNAM"</code> (Stadtfeld, Hollway and Block, 2017)</p>
</dd>
<dt>rate</dt>
<dd>
<p>A individual activity rates model <code>model = "DyNAM"</code>
(Stadtfeld and Block, 2017).
Two rate models, one for individuals joining groups and one for individuals
leaving groups, jointly estimated <code>model = "DyNAMi"</code>(Hoffman et al., 2020)</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimationInit</code></td>
<td>
<p>a list containing lower level technical parameters
for estimation. It may contain:
</p>

<dl>
<dt>initialParameters</dt>
<dd>
<p>a numeric vector.
It includes initial parameters of the estimation.
Default is set to NULL.</p>
</dd>
<dt>fixedParameters</dt>
<dd>
<p>a numeric vector. It specifies which component of
the coefficient parameters (intercept included) is fixed and the value
it takes during estimation, e.g., if the vector is <code>c(2, NA)</code> then
the first component of the parameter is fixed to 2 during the
estimation process. Default is set to <code>NULL</code>, i.e. all parameters are
estimated. Note that it must be consistent with <code>initialParameters</code>.</p>
</dd>
<dt>maxIterations</dt>
<dd>
<p>maximum number of iterations of the Gauss/Fisher
scoring method for the estimation. Default is set to 20.</p>
</dd>
<dt>maxScoreStopCriterion</dt>
<dd>
<p>maximum absolute score criteria for successful
convergence. Default value is 0.001</p>
</dd>
<dt>initialDamping</dt>
<dd>
<p>a numeric vector used to declare the initial damping
factor for each parameter.
It controls the size of the update step during the iterative estimation
process. The default is set to 30 when the formula has windowed effects or
10 in another case, see <code>vignette("goldfishEffects")</code>.</p>
</dd>
<dt>dampingIncreaseFactor</dt>
<dd>
<p>a numeric value. It controls the factor that
increases the damping of the parameters when improvements in the estimation
are found.</p>
</dd>
<dt>dampingDecreaseFactor</dt>
<dd>
<p>a numeric value. Controls the factor that
decreases the damping of the parameters when no improvements in the
estimation are found.</p>
</dd>
<dt>returnIntervalLogL</dt>
<dd>
<p>a logical value. Whether to keep the
log-likelihood of each event from the final iteration of the Gauss/Fisher
estimation method.</p>
</dd>
<dt>engine</dt>
<dd>
<p>a string indicating the estimation engine to be used.
Current options include <code>"default"</code>, <code>"default_c"</code>, and <code>"gather_compute"</code>.
The default value is <code>"default"</code>, it is an estimation routine implemented in
pure <code>R</code> code.
<code>"default_c"</code> uses a <code>C</code> implementation of the <code>"default"</code> routine.
<code>"gather_compute"</code> uses a <code>C</code> implementation with a different data
structure that reduces the time but it can increase the memory usage.</p>
</dd>
<dt>startTime</dt>
<dd>
<p>a numerical value or a date-time character with the same
time-zone formatting as the times in event that indicates the starting time
to be considered during estimation.
<em>Note:</em> it is only use during preprocessing</p>
</dd>
<dt>endTime</dt>
<dd>
<p>a numerical value or a date-time character with the same
time-zone formatting as the times in event that indicates the end time
to be considered during estimation.
<em>Note:</em> it is only use during preprocessing</p>
</dd>
<dt>opportunitiesList</dt>
<dd>
<p>a list containing for each dependent event
the list of available nodes for the choice model, this list should be
the same length as the dependent events list (ONLY for choice models).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preprocessingInit</code></td>
<td>
<p>a <code>preprocessed.goldfish</code> object computed for
the current formula, allows skipping the preprocessing step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preprocessingOnly</code></td>
<td>
<p>logical indicating whether only preprocessed
statistics should be returned rather than a <code>result.goldfish</code> object
with the estimated coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>an <code>environment</code> where <code>formula</code> objects and their linked
objects are available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>logical indicating whether should print a minimal output
to the console of the progress of the preprocessing and estimation processes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical indicating whether should print
very detailed intermediate results of the iterative Newton-Raphson procedure;
slows down the routine significantly.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Missing data is imputed during the preprocessing stage.
For network data missing values are replaced by a zero value,
it means that is assuming a not tie/event explicitly.
For attributes missing values are replaced by the mean value,
if missing values are presented during events updates they are replace by
the mean of the attribute in that moment of time.
</p>


<h3>Value</h3>

<p>returns an object of <code>class()</code> <code>"result.goldfish"</code>
when <code>preprocessingOnly = FALSE</code> or
a preprocessed statistics object of class <code>"preprocessed.goldfish"</code>
when <code>preprocessingOnly = TRUE</code>.
</p>
<p>An object of class <code>"result.goldfish"</code> is a list including:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>a numeric vector with the coefficients estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardErrors</code></td>
<td>

<p>a numeric vector with the standard errors of the coefficients estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLikelihood</code></td>
<td>
<p>the log-likelihood of the estimated model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finalScore</code></td>
<td>

<p>a vector with the final score reach by the parameters during estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finalInformationMatrix</code></td>
<td>

<p>a matrix with the final values of the negative Fisher information matrix.
The inverse of this matrix gives the variance-covariance matrix for the
parameters estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>a list with two elements.
The first element (<code>isConverged</code>) is a logical value that indicates
the convergence of the model.
The second element (<code>maxAbsScore</code>) reports the final maximum absolute
score in the final iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIterations</code></td>
<td>

<p>an integer with the total number of iterations performed during the
estimation process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nEvents</code></td>
<td>

<p>an integer reporting the number of events considered in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>

<p>a matrix with a description of the effects used for model fitting.
It includes the name of the object used to calculate the effects and
additional parameter description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula with the information of the model fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a character value of the model type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subModel</code></td>
<td>
<p>a character value of the subModel type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rightCensored</code></td>
<td>

<p>a logical value indicating if the estimation process considered
right-censored events.
Only it is considered for DyNAM-rate (<code>model = "DyNAM"</code> and
<code>subModel = "rate"</code>) or REM (<code>model = "REM"</code>) models,
and when the model includes the intercept.</p>
</td>
</tr>
</table>
<h3>DyNAM</h3>

<p>The actor-oriented models that the goldfish package implements have been
called Dynamic Network Actor Models (DyNAMs).
The model is a two-step process. In the first step, the waiting time until
an actor <code class="reqn">i</code> initiates the next relational event is modeled
(<code>model = "DyNAM"</code> and <code>subModel = "rate"</code>) by an exponential
distribution depending on the actor activity rate.
In the second step, the conditional probability of <code class="reqn">i</code> choosing
<code class="reqn">j</code> as the event receiver is modeled (<code>model = "DyNAM"</code> and
<code>subModel = "choice"</code>) by a multinomial probability distribution
with a linear predictor.
These two-steps are assumed to be conditionally independent given
the process state (Stadtfeld, 2012),
due to this assumption is possible to estimate these components by
different calls of the <code>estimate</code> function.
</p>


<h3>Waiting times</h3>

<p>When DyNAM-rate (<code>model = "DyNAM"</code> and <code>subModel = "rate"</code>) model
is used to estimate the first step component of the process, or the REM
<code>model = "REM"</code> model is used.
It is important to add a time intercept to model the waiting times between
events, in this way the algorithm considers the right-censored intervals
in the estimation process.
</p>
<p>In the case that the intercept is not included in the formula.
The model reflects the likelihood of an event being the next in the sequence.
This specification is useful for scenarios where the researcher doesn't have
access to the exact interevent times.
For this ordinal case the likelihood of an event is merely a
multinomial probability (Butts, 2008).
</p>


<h3>References</h3>

<p>Butts C. (2008). A Relational Event Framework for Social Action.
<em>Sociological Methodology 38 (1)</em>.
<a href="https://doi.org/10.1111/j.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>
</p>
<p>Hoffman, M., Block P., Elmer T., and Stadtfeld C. (2020).
A model for the dynamics of face-to-face interactions in social groups.
<em>Network Science</em>, 8(S1), S4-S25. <a href="https://doi.org/10.1017/nws.2020.3">doi:10.1017/nws.2020.3</a>
</p>
<p>Stadtfeld, C. (2012). Events in Social Networks: A Stochastic Actor-oriented
Framework for Dynamic Event Processes in Social Networks.
<em>KIT Scientific Publishing</em>. <a href="https://doi.org/10.5445/KSP/1000025407">doi:10.5445/KSP/1000025407</a>
</p>
<p>Stadtfeld, C., and Block, P. (2017). Interactions, Actors, and Time:
Dynamic Network Actor Models for Relational Events.
<em>Sociological Science 4 (1)</em>, 318-52. <a href="https://doi.org/10.15195/v4.a14">doi:10.15195/v4.a14</a>
</p>
<p>Stadtfeld, C., Hollway, J., and Block, P. (2017).
Dynamic Network Actor Models: Investigating Coordination Ties Through Time.
<em>Sociological Methodology 47 (1)</em>. <a href="https://doi.org/10.1177/0081175017709295">doi:10.1177/0081175017709295</a>
</p>


<h3>See Also</h3>

<p><code>defineDependentEvents()</code>, <code>defineGlobalAttribute()</code>,
<code>defineNetwork()</code>, <code>defineNodes()</code>, <code>linkEvents()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># A multinomial receiver choice model
data("Social_Evolution")
callNetwork &lt;- defineNetwork(nodes = actors, directed = TRUE)
callNetwork &lt;- linkEvents(
  x = callNetwork, changeEvent = calls,
  nodes = actors
)
callsDependent &lt;- defineDependentEvents(
  events = calls, nodes = actors,
  defaultNetwork = callNetwork
)



mod01 &lt;- estimate(callsDependent ~ inertia + recip + trans,
  model = "DyNAM", subModel = "choice",
  estimationInit = list(engine = "default_c")
)
summary(mod01)

# A individual activity rates model
mod02 &lt;- estimate(callsDependent ~ 1 + nodeTrans + indeg + outdeg,
  model = "DyNAM", subModel = "rate",
  estimationInit = list(engine = "default_c")
)
summary(mod02)


# A multinomial-multinomial choice model for coordination ties
data("Fisheries_Treaties_6070")
states &lt;- defineNodes(states)
states &lt;- linkEvents(states, sovchanges, attribute = "present")
states &lt;- linkEvents(states, regchanges, attribute = "regime")
states &lt;- linkEvents(states, gdpchanges, attribute = "gdp")

bilatnet &lt;- defineNetwork(bilatnet, nodes = states, directed = FALSE)
bilatnet &lt;- linkEvents(bilatnet, bilatchanges, nodes = states)

contignet &lt;- defineNetwork(contignet, nodes = states, directed = FALSE)
contignet &lt;- linkEvents(contignet, contigchanges, nodes = states)

createBilat &lt;- defineDependentEvents(
  events = bilatchanges[bilatchanges$increment == 1, ],
  nodes = states, defaultNetwork = bilatnet
)

partnerModel &lt;- estimate(
  createBilat ~
    inertia(bilatnet) +
    indeg(bilatnet, ignoreRep = TRUE) +
    trans(bilatnet, ignoreRep = TRUE) +
    tie(contignet) +
    alter(states$regime) +
    diff(states$regime) +
    alter(states$gdp) +
    diff(states$gdp),
  model = "DyNAM", subModel = "choice_coordination",
  estimationInit = list(initialDamping = 40, maxIterations = 30)
)
summary(partnerModel)


</code></pre>


</div>