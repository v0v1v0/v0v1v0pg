<div class="container">

<table style="width: 100%;"><tr>
<td>read_bed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read a BED file</h2>

<h3>Description</h3>

<p>BED files use 0-based coordinate starts, while gggenomes uses 1-based start
coordinates. BED file coordinates are therefore transformed into 1-based
coordinates during import.
</p>


<h3>Usage</h3>

<pre><code class="language-R">read_bed(file, col_names = def_names("bed"), col_types = def_types("bed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">⁠http://⁠</code>,
<code style="white-space: pre;">⁠https://⁠</code>, <code style="white-space: pre;">⁠ftp://⁠</code>, or <code style="white-space: pre;">⁠ftps://⁠</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code>clipboard()</code> will read from the system clipboard.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_names</code></td>
<td>
<p>column names to use. Defaults to <code>def_names("bed")</code>
compatible with canonical bed files. <code>def_names()</code> can easily be
combined with extra columns: <code>col_names = c(def_names("bed"), "more", "things")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code>cols()</code> specification, or
a string. See <code>vignette("readr")</code> for more details.
</p>
<p>If <code>NULL</code>, all column types will be inferred from <code>guess_max</code> rows of the
input, interspersed throughout the file. This is convenient (and fast),
but not robust. If the guessed types are wrong, you'll need to increase
<code>guess_max</code> or supply the correct types yourself.
</p>
<p>Column specifications created by <code>list()</code> or <code>cols()</code> must contain
one column specification for each column. If you only want to read a
subset of the columns, use <code>cols_only()</code>.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
</p>

<ul>
<li>
<p> c = character
</p>
</li>
<li>
<p> i = integer
</p>
</li>
<li>
<p> n = number
</p>
</li>
<li>
<p> d = double
</p>
</li>
<li>
<p> l = logical
</p>
</li>
<li>
<p> f = factor
</p>
</li>
<li>
<p> D = date
</p>
</li>
<li>
<p> T = date time
</p>
</li>
<li>
<p> t = time
</p>
</li>
<li>
<p> ? = guess
</p>
</li>
<li>
<p> _ or - = skip
</p>
</li>
</ul>
<p>By default, reading a file without a column specification will print a
message showing what <code>readr</code> guessed they were. To remove this message,
set <code>show_col_types = FALSE</code> or set <code>options(readr.show_col_types = FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters, passed to <code>read_tsv</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>tibble
</p>


</div>