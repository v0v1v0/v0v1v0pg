<div class="container">

<table style="width: 100%;"><tr>
<td>gena.crossover</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Crossover</h2>

<h3>Description</h3>

<p>Crossover method (algorithm) to be used in the
genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gena.crossover(
  parents,
  fitness = NULL,
  prob = 0.8,
  method = "local",
  par = NULL,
  iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>parents</code></td>
<td>
<p>numeric matrix which rows are parents i.e. vectors of 
parameters values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitness</code></td>
<td>
<p>numeric vector which <code>i</code>-th element is the value of 
<code>fn</code> at point <code>population[i, ]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>probability of crossover.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>crossover method to be used for making children.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Denote <code>parents</code> by <code class="reqn">C^{parent}</code> which <code>i</code>-th row 
<code>parents[i, ]</code> is a chromosome <code class="reqn">c_{i}^{parent}</code> i.e. the vector of 
parameter values of the function being optimized <code class="reqn">f(.)</code> that is
provided via <code>fn</code> argument of <code>gena</code>.
The elements of chromosome <code class="reqn">c_{ij}^{parent}</code> are genes 
representing parameters values.
</p>
<p>Crossover algorithm determines the way parents produce children. 
During crossover each of randomly selected pairs of parents 
<code class="reqn">c_{i}^{parent}</code>, <code class="reqn">c_{i + 1}^{parent}</code>
produce two children 
<code class="reqn">c_{i}^{child}</code>, <code class="reqn">c_{i + 1}^{child}</code>, 
where <code class="reqn">i</code> is odd. Each pair of parents is selected with 
probability <code>prob</code>. If pair of parents have not been selected
for crossover then corresponding children and parents are coincide i.e. 
<code class="reqn">c_{i}^{child}=c_{i}^{parent}</code> and
<code class="reqn">c_{i+1}^{child}=c_{i+1}^{parent}</code>.
</p>
<p>Argument <code>method</code> determines particular crossover algorithm to 
be applied. Denote by <code class="reqn">\tau</code> the vector of parameters used by the 
algorithm. Note that <code class="reqn">\tau</code> corresponds to <code>par</code>.
</p>
<p>If <code>method = "split"</code> then each gene of the first child will
be equiprobably picked from the first or from the second parent. So 
<code class="reqn">c_{ij}^{child}</code> may be equal to <code class="reqn">c_{ij}^{parent}</code>
or <code class="reqn">c_{(i+1)j}^{parent}</code> with equal probability. The second
child is the reversal of the first one in a sense that if the first child 
gets particular gene of the first (second) parent then the second child gets
this gene from the first (second) parent i.e. if
<code class="reqn">c_{ij}^{child}=c_{ij}^{parent}</code> then 
<code class="reqn">c_{(i+1)j}^{child}=c_{(i+1)j}^{parent}</code>; if 
<code class="reqn">c_{ij}^{child}=c_{(i+1)j}^{parent}</code> then 
<code class="reqn">c_{(i+1)j}^{child}=c_{ij}^{parent}</code>.
</p>
<p>If <code>method = "arithmetic"</code> then:
</p>
<p style="text-align: center;"><code class="reqn">c_{i}^{child}=\tau_{1}c_{i}^{parent}+
\left(1-\tau_{1}\right)c_{i+1}^{parent}</code>
</p>

<p style="text-align: center;"><code class="reqn">c_{i+1}^{child}=\left(1-\tau_{1}\right)c_{i}^{parent}+
\tau_{1}c_{i+1}^{parent}</code>
</p>

<p>where <code class="reqn">\tau_{1}</code> is <code>par[1]</code>. By default <code>par[1] = 0.5</code>.
</p>
<p>If <code>method = "local"</code> then the procedure is the same as 
for "arithmetic" method but <code class="reqn">\tau_{1}</code> is a uniform random
value between 0 and 1.
</p>
<p>If <code>method = "flat"</code> then <code class="reqn">c_{ij}^{child}</code> is a uniform
random number between <code class="reqn">c_{ij}^{parent}</code> and 
<code class="reqn">c_{(i+1)j}^{parent}</code>. 
Similarly for the second child <code class="reqn">c_{(i+1)j}^{child}</code>.
</p>
<p>For more information on crossover algorithms
please see Kora, Yadlapalli (2017).
</p>


<h3>Value</h3>

<p>The function returns a matrix which rows are children.
</p>


<h3>References</h3>

<p>P. Kora, P. Yadlapalli. (2017). 
Crossover Operators in Genetic Algorithms: A Review.
<em>International Journal of Computer Applications</em>, 162 (10), 34-36,
&lt;doi:10.5120/ijca2017913370&gt;.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Randomly initialize the parents
set.seed(123)
parents.n &lt;- 10
parents &lt;- gena.population(pop.n = parents.n,
                           lower = c(-5, -5), 
                           upper = c(5, 5))
                           
# Perform the crossover
children &lt;- gena.crossover(parents = parents,
                           prob = 0.6,
                           method = "local")
print(children)
</code></pre>


</div>