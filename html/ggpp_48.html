<div class="container">

<table style="width: 100%;"><tr>
<td>geom_label_s</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Linked Text</h2>

<h3>Description</h3>

<p>Linked text geometries are most useful for adding data labels to
plots. 'geom_text_s()' and 'geom_label_s()' add text to the plot and for
nudged positions link the original location to the nudged text with a
segment or arrow.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_label_s(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = c("text", "box"),
  color.target = colour.target,
  default.alpha = NA,
  alpha.target = "all",
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  segment.linewidth = 0.5,
  add.segments = TRUE,
  box.padding = 1e-06,
  point.padding = 1e-06,
  min.segment.length = 0,
  arrow = NULL,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_text_s(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "text",
  color.target = colour.target,
  default.alpha = NA,
  alpha.target = "all",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  arrow = NULL,
  check_overlap = FALSE,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Set of aesthetic mappings created by
<code>aes</code>. If specified and with <code>inherit.aes = TRUE</code>
(the default), it is combined with the default mapping at the top level of
the plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. There
are three types of arguments you can use here:
</p>
 <ul>
<li>
<p> Aesthetics: to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. </p>
</li>
<li>
<p> Other arguments to the
layer, for example you override the default <code>stat</code> associated with the
layer. </p>
</li>
<li>
<p> Other arguments passed on to the stat. </p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nudge_x, nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.colour, default.color</code></td>
<td>
<p>A colour definition to use for elements
not targeted by the colour aesthetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colour.target, color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>box.padding, point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code>arrow</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size.unit</code></td>
<td>
<p>How the 'size' aesthetic is interpreted: as millimetres
('"mm"', default), points ('"pt"'), centimetres ('"cm"'), inches ('"in"'),
or picas ('"pc"').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes a legend if any aesthetics are mapped.
<code>FALSE</code> never includes it, and <code>TRUE</code> always includes it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default
plot specification, e.g., <code>borders</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> takes place at draw
time and in the order of the data, thus its action depends of the size at
which the plot is drawn.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Geometries <code>geom_text_s()</code> and <code>geom_label_s()</code> have an
interface similar to that of <code>geom_text</code> and
<code>geom_label</code>, but support additional features.
Similarly to <code>geom_text_repel()</code> and <code>geom_label_repel()</code> when
used together with position functions defined in package 'ggpp' they draw a
segment linking the label at a displaced position to the original position,
usually a point corresponding to an observation to which the label refers.
Another difference is that they allow control of to which graphical
elements the mappings to colour and alpha aesthetics are applied.
Differently to <code>geom_label()</code>, <code>geom_label_s()</code> obeys aesthetic
mappings to <code>linewidth</code> and <code>linetype</code> applied to the line at the
edge of the label box. These features are reflected in the plot key, except
for the segment, assumed not to be used to display information
only in coordination with other graphic elements.
</p>
<p>In <code>geom_label_s()</code> the default <code>fill</code> is similar to
<code>"white"</code> but with its <code>alpha</code> component set to 0.75. This
differs from <code>"white"</code> used in <code>geom_label()</code>: the default fill
is semitransparent with the intention that accidental occlusion of
observations is obvious irrespective of the order in which layers are added
to the plot.
</p>
<p>Layer functions <code>geom_text_s()</code> and <code>geom_label_s()</code> use by
default <code>position_nudge_keep</code> which is backwards compatible
with <code>position_nudge</code>. In contrast to
<code>position_nudge</code>, <code>position_nudge_keep</code>
and all other position functions defined in packages 'ggpp' and 'ggrepel'
keep the original coordinates, thus allowing the plotting of connecting
segments and arrows.
</p>
<p>Differently to <code>geom_text_repel()</code> and <code>geom_label_repel()</code>,
<code>geom_text_s()</code> and <code>geom_label_s()</code> do not make use of
additional aesthetics for the segments or boxes, but instead allow the
choice of which elements are targeted by the aesthetics and which are
rendered in a default colour. In the grammar of graphics using the same
aesthetic with multiple meanings is not allowed, thus, the approach used in
the geometry layer functions from package 'ggpp' attempts to enforce this.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Plot boundaries and clipping</h3>

<p>Note that when you change the scale
limits for <em>x</em> and/or <em>y</em> of a plot, text labels stay the same
size, as determined by the <code>size</code> aesthetic, given in millimetres. The
actual size as seen in the plotted output is decided during the rendering
of the plot to a graphics device. Limits are expanded only to include the
anchor point of the labels because the "width" and "height" of a text
element are 0 (as seen by ggplot2). Text labels do have height and width,
but in grid units, not data units.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Differences from earlier versions</h3>

<p>The user interface is for the most part stable starting from 'ggpp' (==
0.5.7). In 'ggpp' (== 0.5.0) support for aesthetics related to segments was
removed, and replaced by parameters and a new mechanism for targeting the
usual <code>colour</code> and <code>alpha</code> aesthetics to text, border, and
segment.
</p>


<h3>Aesthetics</h3>

<p>Layer functions <code>geom_text_s()</code> and
<code>geom_label_s()</code> require aesthetics <code>x</code>, <code>y</code> and
<code>label</code> and support aesthetics: <code>alpha</code>, <code>colour</code>,
<code>group</code>, <code>size</code> (of text), <code>family</code>, <code>fontface</code>,
<code>lineheight</code>, <code>hjust</code> and <code>vjust</code>. In addition,
<code>geom_text_s</code> supports <code>angle</code> and <code>geom_label_s</code> supports
<code>fill</code>, <code>linewidth</code> and <code>linetype</code>. See
<code>aes_colour_fill_alpha</code>,
<code>aes_linetype_size_shape</code>,
<code>aes_position</code>, and
<code>aes_group_order</code>.
</p>
<p>In 'ggplot2' <code>linewidth</code> when applied to the border of the box drawn
by <code>geom_label()</code> is given in points rather than in mm because of a
historical error in the code. In other geometries such as
<code>geom_segment()</code> <code>linewidth</code> is given in mm. As in
<code>geom_label_s()</code> it is important to remain consistent among
different <code>linewidth</code> specifications, mm are used both for the box
border and linking segment. To imitate the behaviour of <code>geom_label()</code>
a correction factor of 0.75 (more exactly 1 pt = 0.7528 mm) can be used for
the line width of the border of the box.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code>position_nudge_keep</code>,
<code>position_dodge_keep</code>, <code>position_jitter_keep</code>,
<code>position_nudge_center</code>, <code>position_nudge_line</code>,
<code>position_nudge_to</code>, <code>position_dodgenudge</code>,
<code>position_jitternudge</code>, and <code>position_stacknudge</code>
for examples and details of their use.
</p>


<h3>See Also</h3>

<p><code>geom_text</code>, <code>geom_label</code>
and other documentation of package 'ggplot2'.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
my.cars &lt;- mtcars[c(TRUE, FALSE, FALSE, FALSE), ]
my.cars$name &lt;- rownames(my.cars)

# no nudging
ggplot(my.cars, aes(wt, mpg, label = name)) +
  geom_text_s() +
  expand_limits(x = c(2, 6))

# base plot
p &lt;- ggplot(my.cars, aes(wt, mpg, label = name)) +
       geom_point()

# Using nudging
p +
  geom_text_s(nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_x = -0.12) +
  expand_limits(x = 1.5)
p +
  geom_text_s(nudge_x = 0.12,
              arrow = arrow(length = grid::unit(1.5, "mm")),
              point.padding = 0.4) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_y = 0.1, nudge_x = 0.07) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_y = 1, angle = 90) +
  expand_limits(y = 30)
p +
  geom_text_s(angle = 90, nudge_y = 1,
              arrow = arrow(length = grid::unit(1.5, "mm")),
              colour.target = "segment", colour = "red") +
  expand_limits(y = 30)
p +
  geom_text_s(aes(colour = factor(cyl)),
              angle = 90, nudge_y = 1,
              arrow = arrow(length = grid::unit(1.5, "mm")),
              alpha.target = "segment", alpha = 0.3) +
  expand_limits(y = 30)

p +
  geom_label_s(nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_label_s(nudge_x = 0.12, linetype = "dotted", linewidth = 0.3) +
  expand_limits(x = 6.2)
p +
  geom_label_s(aes(colour = factor(cyl)),
               nudge_x = 0.12,
               colour.target = "box",
               linewidth = 0.5,
               label.r = unit(0, "lines")) +
  expand_limits(x = 6.2)
p +
  geom_label_s(nudge_x = 0.12, linewidth = 0) +
  expand_limits(x = 6.2)

# No segments
p +
  geom_label_s(nudge_x = 0.05, segment.linewidth = 0) +
  expand_limits(x = 6.2)

# Nudging away from arbitrary point
p +
  geom_label_s(hjust = "outward_1", nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_label_s(hjust = "inward_3", nudge_y = 0.4)

p +
  geom_label_s(nudge_y = 1, angle = 90) +
  expand_limits(y = 30)

# Add aesthetic mappings and adjust arrows
p +
  geom_text_s(aes(colour = factor(cyl)),
              angle = 90,
              nudge_y = 1,
              arrow = arrow(angle = 20,
                            length = grid::unit(1.5, "mm"),
                            ends = "first",
                            type = "closed")) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(y = 27)

p +
  geom_text_s(aes(colour = factor(cyl)),
              angle = 90,
              nudge_y = 1,
              arrow = arrow(angle = 20,
                            length = grid::unit(1.5, "mm"),
                            ends = "first",
                            type = "closed")) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(y = 27)

p +
  geom_label_s(aes(colour = factor(cyl)),
              colour.target = c("box", "text"),
              nudge_x = 0.3,
              arrow = arrow(angle = 20,
                            length = grid::unit(1/3, "lines"))) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(x = 7)

p +
  geom_label_s(aes(colour = factor(cyl)),
              nudge_x = 0.3,
              colour.target = c("box", "segment"),
              linewidth = 0.5,
              arrow = arrow(angle = 20,
                            length = grid::unit(1/3, "lines"))) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(x = 7)

p +
  geom_label_s(aes(colour = factor(cyl), fill = factor(cyl)),
              nudge_x = 0.3,
              alpha.target = "box",
              alpha = 0.1,
              linewidth = 0.5,
              arrow = arrow(angle = 20,
                            length = grid::unit(1/3, "lines"))) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(x = 7)#' # Scale height of text, rather than sqrt(height)

p +
  geom_text_s(aes(size = wt), nudge_x = -0.1) +
  scale_radius(range = c(3,6)) + # override scale_area()
    expand_limits(x = c(1.8, 5.5))

</code></pre>


</div>