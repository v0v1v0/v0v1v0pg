<div class="container">

<table style="width: 100%;"><tr>
<td>logitx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate an autoregressive logit model with covariates</h2>

<h3>Description</h3>

<p>Estimate a dynamic Autoregressive (AR) logit model with covariates ('X') by maximising the logit likelihood.
</p>


<h3>Usage</h3>

<pre><code class="language-R">logitx(y, intercept = TRUE, ar = NULL, ewma = NULL, xreg = NULL, 
    vcov.type = c("ordinary", "robust"), lag.length = NULL, 
    initial.values = NULL, lower = -Inf, upper = Inf, control = list(), 
    eps.tol = .Machine$double.eps, solve.tol = .Machine$double.eps,
    singular.ok = TRUE, plot = NULL)

dlogitx(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a binary numeric vector, time-series or <code>zoo</code> object. Missing values in the beginning and at the end of the series is allowed, as they are removed with the <code>na.trim</code> command</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical. <code>TRUE</code>, the default, includes an intercept in the logit specification, whereas <code>FALSE</code> does not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar</code></td>
<td>
<p>either <code>NULL</code> (default) or an integer vector, say, <code>c(2,4)</code> or <code>1:4</code>. The AR-lags to include in the logit specification. If <code>NULL</code>, then no lags are included</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ewma</code></td>
<td>
<p>either <code>NULL</code> (default) or a <code>list</code> with arguments sent to the <code>eqwma</code> function. In the latter case a lagged moving average of <code>y</code> is included as a regressor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>
<p>either <code>NULL</code> (default) or a numeric vector or matrix, say, a <code>zoo</code> object, of covariates. Note that, if both <code>y</code> and <code>xreg</code> are <code>zoo</code> objects, then their samples are chosen to match</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.type</code></td>
<td>
<p>character vector of length 1, either "ordinary" (default) or "robust". Partial matching is allowed. If "ordinary", then the ordinary variance-covariance matrix is used for inference. If "robust", then a robust coefficient-covariance of the Newey and West (1987) type is used </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.length</code></td>
<td>
<p><code>NULL</code> or an integer that determines the lag-length used in the robust coefficient covariance. If <code>lag.length</code> is an integer, then it is ignored unless <code>method = 3</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.values</code></td>
<td>
<p><code>NULL</code> or a numeric vector with the initial parameter values passed on to the optimisation routine, <code>nlminb</code>. If <code>NULL</code>, the default, then the values are chosen automatically </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code>nlminb</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>numeric vector, either of length 1 or the number of parameters to be estimated, see <code>nlminb</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a <code>list</code> passed on to the control argument of <code>nlminb</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.tol</code></td>
<td>
<p>numeric, a small value that ensures the fitted zero-probabilities are not too small when the log-transformation is applied when computing the log-likelihood </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solve.tol</code></td>
<td>
<p>numeric value passed on to the <code>tol</code> argument of <code>solve</code>, which is called whenever the coefficient-coariance matrix is computed. The value controls the toleranse for detecting linear dependence between columns when inverting a matrix </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>singular.ok</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), then the regressors causing the singularity are dropped (using <code>dropvar</code>) before estimation. If <code>FALSE</code>, singularity returns error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p><code>NULL</code> or logical. If <code>TRUE</code>, then a plot is produced. If <code>NULL</code> (default), then the value set by <code>options</code> determines whether a plot is produced or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed on to <code>logitx</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function estimates a dynamic Autoregressive (AR) logit model with (optionally) covariates ('X') by maximising the logit likelihood. The estimated model is an augmented version of the model considered by Kauppi and Saikkonen (2008). Also, they considered estimation is by maximisation of the probit likelihood. Here, by contrast, estimation is by maximisation of the logit likelihood.
</p>


<h3>Value</h3>

<p>A list of class 'logitx'.</p>


<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a></p>


<h3>References</h3>

<p>Heikki Kauppi and Pentti Saikkonen (2008): 'Predicting U.S. Recessions with Dynamic Binary Response Models'. The Review of Economics and Statistics 90, pp. 777-791
</p>
<p>Whitney K. Newey and Kenned D. West (1987): 'A Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix', Econometrica 55, pp. 703-708
</p>


<h3>See Also</h3>

<p>Methods: <code>coef.logitx</code>, <code>fitted.logitx</code>, <code>gets.logitx</code>, <br><code>logLik.logitx</code>, <code>plot.logitx</code>, <code>print.logitx</code>, <code>summary.logitx</code>, <code>toLatex.logitx</code> and <code>vcov.logitx</code><br></p>
<p>Related functions: <code>logitxSim</code>, <code>logit</code>, <code>nlminb</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##simulate from ar(1):
set.seed(123) #for reproducibility
y &lt;- logitxSim(100, ar=0.3)

##estimate ar(1) and store result:
mymod &lt;- logitx(y, ar=1)

##estimate ar(4) and store result:
mymod &lt;- logitx(y, ar=1:4)

##create some more data, estimate new model:
x &lt;- matrix(rnorm(5*100), 100, 5)
mymod &lt;- logitx(y, ar=1:4, xreg=x)

</code></pre>


</div>