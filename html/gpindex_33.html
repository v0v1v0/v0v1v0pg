<div class="container">

<table style="width: 100%;"><tr>
<td>generalized_mean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized mean</h2>

<h3>Description</h3>

<p>Calculate a weighted generalized mean.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generalized_mean(r)

arithmetic_mean(x, w = NULL, na.rm = FALSE)

geometric_mean(x, w = NULL, na.rm = FALSE)

harmonic_mean(x, w = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A finite number giving the order of the generalized mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length as
<code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing values in <code>x</code> and <code>w</code> be removed? By
default missing values in <code>x</code> or <code>w</code> return a missing value.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>generalized_mean()</code> returns a function to compute the
generalized mean of <code>x</code> with weights <code>w</code> and exponent <code>r</code>
(i.e., <code class="reqn">\prod_{i = 1}^{n} x_{i}^{w_{i}}</code> when <code class="reqn">r = 0</code> and
<code class="reqn">\left(\sum_{i = 1}^{n} w_{i} x_{i}^{r}\right)^{1 / r}</code>
otherwise). This is also called the power mean, HÃ¶lder mean, or <code class="reqn">l_p</code>
mean. See Bullen (2003, p. 175) for a definition, or
<a href="https://en.wikipedia.org/wiki/Generalized_mean">https://en.wikipedia.org/wiki/Generalized_mean</a>. The generalized mean
is the solution to the optimal prediction problem: choose <code class="reqn">m</code> to
minimize <code class="reqn">\sum_{i = 1}^{n} w_{i} \left[\log(x_{i}) - \log(m)
\right]^2</code> when <code class="reqn">r = 0</code>, <code class="reqn">\sum_{i =
1}^{n} w_{i} \left[x_{i}^r - m^r \right]^2</code> otherwise.
</p>
<p>The functions <code>arithmetic_mean()</code>, <code>geometric_mean()</code>, and
<code>harmonic_mean()</code> compute the arithmetic, geometric, and harmonic (or
subcontrary) means, also known as the Pythagorean means. These are the most
useful means for making price indexes, and correspond to setting
<code>r = 1</code>, <code>r = 0</code>, and <code>r = -1</code> in <code>generalized_mean()</code>.
</p>
<p>Both <code>x</code> and <code>w</code> should be strictly positive (and finite),
especially for the purpose of making a price index. This is not enforced,
but the results may not make sense if the generalized mean is not defined.
There are two exceptions to this.
</p>

<ol>
<li>
<p> The convention in Hardy et al. (1952, p. 13) is used in cases where <code>x</code>
has zeros: the generalized mean is 0 whenever <code>w</code> is strictly positive and
<code>r</code> &lt; 0. (The analogous convention holds whenever at least one element of <code>x</code>
is <code>Inf</code>: the generalized mean is <code>Inf</code> whenever <code>w</code> is strictly positive
and <code>r</code> &gt; 0.)
</p>
</li>
<li>
<p> Some authors let <code>w</code> be non-negative and sum to 1 (e.g., Sydsaeter
et al., 2005, p. 47). If <code>w</code> has zeros, then the corresponding element
of <code>x</code> has no impact on the mean whenever <code>x</code> is strictly
positive. Unlike <code>weighted.mean()</code>, however,
zeros in <code>w</code> are not strong zeros, so infinite values in <code>x</code> will
propagate even if the corresponding elements of <code>w</code> are zero.
</p>
</li>
</ol>
<p>The weights are scaled to sum to 1 to satisfy the definition of a
generalized mean. There are certain price indexes where the weights should
not be scaled (e.g., the Vartia-I index); use <code>sum()</code> for
these cases.
</p>
<p>The underlying calculation returned by <code>generalized_mean()</code> is mostly
identical to <code>weighted.mean()</code>, with one
important exception: missing values in the weights are not treated
differently than missing values in <code>x</code>. Setting <code>na.rm = TRUE</code>
drops missing values in both <code>x</code> and <code>w</code>, not just <code>x</code>. This
ensures that certain useful identities are satisfied with missing values in
<code>x</code>. In most cases <code>arithmetic_mean()</code> is a drop-in replacement
for <code>weighted.mean()</code>.
</p>


<h3>Value</h3>

<p><code>generalized_mean()</code> returns a function:
</p>
<pre>function(x, w = NULL, na.rm = FALSE){...}</pre>
<p>This computes the generalized mean of order <code>r</code> of <code>x</code> with
weights <code>w</code>.
</p>
<p><code>arithmetic_mean()</code>, <code>geometric_mean()</code>, and
<code>harmonic_mean()</code> each return a numeric value for the generalized means
of order 1, 0, and -1.
</p>


<h3>Note</h3>

<p><code>generalized_mean()</code> can be defined on the extended real line, so
that <code>r = -Inf / Inf</code> returns <code>min()</code>/<code>max()</code>, to agree with the
definition in, e.g., Bullen (2003). This is not implemented, and <code>r</code>
must be finite.
</p>
<p>There are a number of existing functions for calculating <em>unweighted</em>
geometric and harmonic means, namely the <code>geometric.mean()</code> and
<code>harmonic.mean()</code> functions in the <span class="pkg">psych</span> package, the
<code>geomean()</code> function in the <span class="pkg">FSA</span> package, the <code>GMean()</code> and
<code>HMean()</code> functions in the <span class="pkg">DescTools</span> package, and the
<code>geoMean()</code> function in the <span class="pkg">EnvStats</span> package. Similarly, the
<code>ci_generalized_mean()</code> function in the <span class="pkg">Compind</span> package
calculates an <em>unweighted</em> generalized mean.
</p>


<h3>References</h3>

<p>Bullen, P. S. (2003). <em>Handbook of Means and Their Inequalities</em>.
Springer Science+Business Media.
</p>
<p>Fisher, I. (1922). <em>The Making of Index Numbers</em>. Houghton Mifflin
Company.
</p>
<p>Hardy, G., Littlewood, J. E., and Polya, G. (1952). <em>Inequalities</em> (2nd
edition). Cambridge University Press.
</p>
<p>IMF, ILO, Eurostat, UNECE, OECD, and World Bank. (2020).
<em>Consumer Price Index Manual: Concepts and Methods</em>.
International Monetary Fund.
</p>
<p>Lord, N. (2002). Does Smaller Spread Always Mean Larger Product?
<em>The Mathematical Gazette</em>, 86(506): 273-274.
</p>
<p>Sydsaeter, K., Strom, A., and Berck, P. (2005).
<em>Economists' Mathematical Manual</em> (4th edition). Springer.
</p>


<h3>See Also</h3>

<p><code>transmute_weights()</code> transforms the weights to turn a generalized
mean of order <code class="reqn">r</code> into a generalized mean of order <code class="reqn">s</code>.
</p>
<p><code>factor_weights()</code> calculates the weights to factor a mean of
products into a product of means.
</p>
<p>price_indexes and <code>quantity_index()</code> for simple
wrappers that use <code>generalized_mean()</code> to calculate common indexes.
</p>
<p><code>back_period()</code>/<code>base_period()</code> for a simple utility
function to turn prices in a table into price relatives.
</p>
<p>Other means: 
<code>extended_mean()</code>,
<code>lehmer_mean()</code>,
<code>nested_mean()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 1:3
w &lt;- c(0.25, 0.25, 0.5)

#---- Common generalized means ----

# Arithmetic mean

arithmetic_mean(x, w) # same as weighted.mean(x, w)

# Geometric mean

geometric_mean(x, w) # same as prod(x^w)

# Harmonic mean

harmonic_mean(x, w) # same as 1 / weighted.mean(1 / x, w)

# Quadratic mean / root mean square

generalized_mean(2)(x, w)

# Cubic mean
# Notice that this is larger than the other means so far because
# the generalized mean is increasing in r

generalized_mean(3)(x, w)

#---- Comparing the Pythagorean means ----

# The dispersion between the arithmetic, geometric, and harmonic
# mean usually increases as the variance of 'x' increases

x &lt;- c(1, 3, 5)
y &lt;- c(2, 3, 4)

var(x) &gt; var(y)

arithmetic_mean(x) - geometric_mean(x)
arithmetic_mean(y) - geometric_mean(y)

geometric_mean(x) - harmonic_mean(x)
geometric_mean(y) - harmonic_mean(y)

# But the dispersion between these means is only bounded by the
# variance (Bullen, 2003, p. 156)

arithmetic_mean(x) - geometric_mean(x) &gt;= 2 / 3 * var(x) / (2 * max(x))
arithmetic_mean(x) - geometric_mean(x) &lt;= 2 / 3 * var(x) / (2 * min(x))

# Example by Lord (2002) where the dispersion decreases as the variance
# increases, counter to the claims by Fisher (1922, p. 108) and the
# CPI manual (par. 1.14)

x &lt;- (5 + c(sqrt(5), -sqrt(5), -3)) / 4
y &lt;- (16 + c(7 * sqrt(2), -7 * sqrt(2), 0)) / 16

var(x) &gt; var(y)

arithmetic_mean(x) - geometric_mean(x)
arithmetic_mean(y) - geometric_mean(y)

geometric_mean(x) - harmonic_mean(x)
geometric_mean(y) - harmonic_mean(y)

# The "bias" in the arithmetic and harmonic indexes is also smaller in
# this case, counter to the claim by Fisher (1922, p. 108)

arithmetic_mean(x) * arithmetic_mean(1 / x) - 1
arithmetic_mean(y) * arithmetic_mean(1 / y) - 1

harmonic_mean(x) * harmonic_mean(1 / x) - 1
harmonic_mean(y) * harmonic_mean(1 / y) - 1

#---- Missing values ----

w[2] &lt;- NA

arithmetic_mean(x, w, na.rm = TRUE) # drop the second observation
weighted.mean(x, w, na.rm = TRUE) # still returns NA

</code></pre>


</div>