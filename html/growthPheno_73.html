<div class="container">

<table style="width: 100%;"><tr>
<td>splitSplines</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adds the fits, and optionally growth rates computed from derivatives, after 
fitting splines to a response for an individual stored in a <code>data.frame</code> 
in long format</h2>

<h3>Description</h3>

<p>Uses <code>fitSpline</code> to fit a spline to a subset of the values 
of <code>response</code> and stores the fitted values in <code>data</code>. 
The subsets are those values with the same levels combinations 
of the <code>factor</code>s listed in <code>individuals</code>. The degree of smoothing 
is controlled by the tuning parameters <code>df</code> and <code>lambda</code>, 
related to the penalty, and by <code>npspline.segments</code>. The <code>smoothing.method</code> 
provides for <code>direct</code> and <code>logarithmic</code> smoothing. 
</p>
<p>The derivatives of the fitted spline can also be obtained, and the 
Absolute and Relative Growth Rates ( AGR and RGR) computed using them, provided 
<code>correctBoundaries</code> is <code>FALSE</code>. Otherwise, growth rates can be 
obtained by difference using <code>splitContGRdiff</code>.
</p>
<p>The handling of missing values in the observations is controlled via 
<code>na.x.action</code> and <code>na.y.action</code>. If there are not 
at least four distinct, nonmissing x-values, a warning is issued and 
all smoothed values and derivatives are set to <code>NA</code>. 
</p>
<p>The function <code>probeSmoothing</code> can be used to investgate the effect 
the smoothing parameters (<code>smoothing.method</code>, <code>df</code> or  
<code>lambda</code>) on the smooth that results.
</p>
<p><strong>Note: this function is soft deprecated and may be removed in 
future versions. <br> Use <code>byIndv4Times_SplinesGRs</code>.</strong>
</p>


<h3>Usage</h3>

<pre><code class="language-R">splitSplines(data, response, response.smoothed = NULL, x, 
             individuals = "Snapshot.ID.Tag", INDICES = NULL,
             smoothing.method = "direct", smoothing.segments = NULL, 
             spline.type = "NCSS", df=NULL, lambda = NULL, 
             npspline.segments = NULL, 
             correctBoundaries = FALSE, 
             deriv = NULL, suffices.deriv = NULL, extra.rate = NULL, 
             sep = ".", 
             na.x.action="exclude", na.y.action = "exclude", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.frame</code> containing the column to be smoothed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> that is to be smoothed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response.smoothed</code></td>
<td>
<p>A <code>character</code> specifying the name of the column 
containing the values of the smoothed response variable, corresponding 
to <code>response</code>. If <code>response.smoothed</code> is <code>NULL</code>, then 
<code>response.smoothed</code> is set to the <code>response</code> to which 
<code>.smooth</code> is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> that contains the values of the predictor variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>individuals</code></td>
<td>
<p>A <code>character</code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of <code>response</code> 
that correspond to the <code>response</code> values for an individual 
(e.g. plant, pot, cart, plot or unit) that are to be smoothed 
separately. If the columns corresponding to <code>individuals</code> 
are not <code>factor</code>(s) then they will be coerced to 
<code>factor</code>(s). The subsets are formed 
using <code>split</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>INDICES</code></td>
<td>
<p>A pseudonym for <code>individuals</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing.method</code></td>
<td>
<p>A <code>character</code> giving the smoothing method 
to use. The two possibilites are (i) <code>"direct"</code>, for directly 
smoothing the observed <code>response</code>, and (ii) <code>"logarithmic"</code>, for 
smoothing the <code>log</code>-transformed <code>response</code> and then 
back-transforming by taking the exponentional of the fitted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing.segments</code></td>
<td>
<p>A named <code>list</code>, each of whose components 
is a numeric pair specifying the first and last values of an 
<code>x</code>-interval whose data is to be subjected as an entity to smoothing 
using splines. The separate smooths will be combined to form a whole 
smooth for each individual. If <code>smoothing.segments</code> is <code>NULL</code>, 
the data is not segmented for smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.type</code></td>
<td>
<p>A <code>character</code> giving the type of spline  
to use. Currently, the possibilites are (i) <code>"NCSS"</code>, for natural 
cubic smoothing splines, and (ii) <code>"PS"</code>, for P-splines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>A <code>numeric</code> specifying, for natural cubic smoothing splines 
(<code>NCSS</code>), the desired equivalent number of degrees of freedom of the 
smooth (trace of the smoother matrix). Lower values result in more smoothing. 
If <code>df = NULL</code>, the amount of smoothing can be controlled by setting 
<code>lambda</code>. If both <code>df</code> and <code>lambda</code> are <code>NULL</code>, smoothing 
is controlled by the default arguments for <code>smooth.spline</code>, and any 
that you supply via the ellipsis (...) argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A <code>numeric</code> specifying the positive penalty to apply. 
The amount of smoothing decreases as <code>lamda</code> decreases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npspline.segments</code></td>
<td>
<p>A <code>numeric</code> specifying, for P-splines (<code>PS</code>), 
the number of equally spaced segments between <code>min(x)</code> and <code>max(x)</code>, 
excluding missing values, to use in constructing the B-spline basis for the 
spline fitting. If <code>npspline.segments</code> is NULL, <code>npspline.segments</code> 
is set to the maximum of 10 and <code>ceiling((nrow(data)-1)/2)</code> i.e. there will 
be at least 10 segments and, for more than 22 <code>x</code> values, there will be 
half as many segments as there are <code>x</code> values. The amount of smoothing 
decreases as <code>npspline.segments</code> increases. When the data has been 
segmented for smoothing (<code>smoothing.segments</code> is not <code>NULL</code>), 
an <code>npspline.segments</code> value can be supplied for each segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correctBoundaries</code></td>
<td>
<p>A <code>logical</code> indicating whether the fitted spline 
values are to have the method of Huang (2001) applied 
to them to correct for estimation bias at the end-points. Note that 
<code>spline.type</code> must be <code>NCSS</code> and <code>lambda</code> and <code>deriv</code> 
must be <code>NULL</code> for <code>correctBoundaries</code> to be set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv</code></td>
<td>
<p>A <code>numeric</code> specifying one or more orders of derivatives 
that are required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffices.deriv</code></td>
<td>
<p>A <code>character</code> giving the characters to be 
appended to the names of the derivatives. If <code>NULL</code> 
and the derivative is to be retained then <code>smooth.dv</code> 
is appended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra.rate</code></td>
<td>
<p>A named <code>character</code> nominating a single growth 
rate (<code>AGR</code> or <code>RGR</code>) to be computed using the first 
derivative, which one being dependent on the <code>smoothing.method</code>. 
The name of this element will used as a suffix to be appended to 
the response when naming the resulting growth rate (see Examples). 
If unamed, <code>AGR</code> or <code>RGR</code> will be used, as appropriate. 
Note that, for the <code>smoothing.method</code> set to <code>direct</code>, 
the first derivative is the AGR and so <code>extra.rate</code> must be set 
to <code>RGR</code>, which is computed as the <code>AGR / smoothed response</code>. 
For the <code>smoothing.method</code> set to <code>logarithmic</code>, 
the first derivative is the RGR and so <code>extra.rate</code> must be set 
to <code>AGR</code>, which is computed as the <code>RGR * smoothed response</code>. 
Make sure that <code>deriv</code> includes one so that the first derivative 
is available for calculating the <code>extra.rate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>A <code>character</code> giving the separator to use when the 
levels of <code>individuals</code> are combined. This is needed to avoid 
using a <code>character</code> that occurs in a <code>factor</code> to delimit 
levels when the levels of <code>individuals</code> are combined to identify 
subsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.x.action</code></td>
<td>
<p>A <code>character</code> string that specifies the action to 
be taken when values of <code>x</code> are <code>NA</code>. The possible 
values are <code>fail</code>, <code>exclude</code> or <code>omit</code>. 
For <code>exclude</code> and <code>omit</code>, predictions and derivatives 
will only be obtained for nonmissing values of <code>x</code>. 
The difference between these two codes is that for <code>exclude</code> the returned 
<code>data.frame</code> will have as many rows as <code>data</code>, the 
missing values have been incorporated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.y.action</code></td>
<td>
<p>A <code>character</code> string that specifies the action to 
be taken when values of <code>y</code>, or the <code>response</code>, are 
<code>NA</code>.  The possible values are <code>fail</code>, <code>exclude</code>, 
<code>omit</code>, <code>allx</code>, <code>trimx</code>, <code>ltrimx</code> or 
<code>rtrimx</code>. For  all options, except <code>fail</code>, missing 
values in <code>y</code> will be removed before smoothing. 
For <code>exclude</code> and <code>omit</code>, predictions 
and derivatives will be obtained only for nonmissing values of 
<code>x</code> that do not have missing <code>y</code> values. Again, the 
difference between these two is that, only for <code>exclude</code> 
will the missing values be incorporated into the 
returned <code>data.frame</code>. For <code>allx</code>, predictions and 
derivatives will be obtained for all nonmissing <code>x</code>. 
For <code>trimx</code>, they will be obtained for all nonmissing 
<code>x</code> between the first and last nonmissing <code>y</code> values 
that have been ordered for <code>x</code>; for <code>ltrimx</code> and 
<code>utrimx</code> either the lower or upper missing <code>y</code> 
values, respectively, are trimmed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>allows for arguments to be passed to <code>smooth.spline</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>data.frame</code> containing  <code>data</code> to which has been 
added a column with the fitted smooth, the name of the column being 
<code>response.smoothed</code>. If <code>deriv</code> is not <code>NULL</code>, 
columns containing the values of the derivative(s) will be added 
to <code>data</code>; the name each of these columns will be the value of 
<code>response.smoothed</code> with <code>.dvf</code> appended, where <code>f</code> 
is the order of the derivative, or  the value of <code>response.smoothed</code> 
with the corresponding element of <code>suffices.deriv</code> appended. 
If <code>RGR</code> is not <code>NULL</code>, the RGR is calculated as the ratio 
of value of the first derivative of the fitted spline and the fitted 
value for the spline. 
Any pre-existing smoothed and derivative columns in <code>data</code> will be 
replaced. The ordering of the <code>data.frame</code> for the <code>x</code> 
values will be preserved as far as is possible; the main difficulty 
is with the handling of missing values by the function <code>merge</code>. 
Thus, if missing values in <code>x</code> are retained, they will occur at 
the bottom of each subset of <code>individuals</code> and the order will be 
problematic when there are missing values in <code>y</code> and 
<code>na.y.action</code> is set to <code>omit</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Eilers, P.H.C and Marx, B.D. (2021) <em>Practical smoothing: the joys of P-splines</em>. Cambridge University Press, Cambridge.
</p>
<p>Huang, C. (2001) Boundary corrected cubic smoothing splines. <em>Journal of Statistical Computation and Simulation</em>, <b>70</b>, 107-121.</p>


<h3>See Also</h3>

<p><code>fitSpline</code>, <code>probeSmoothing</code>, <code>splitContGRdiff</code>, 
<code>smooth.spline</code>, <code>predict.smooth.spline</code>, <br><code>split</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(exampleData)
#smoothing with growth rates calculated using derivates
longi.dat &lt;- splitSplines(longi.dat, response="PSA", x="xDAP", 
                          individuals = "Snapshot.ID.Tag", 
                          df = 4, deriv=1, suffices.deriv="AGRdv", 
                          extra.rate = c(RGRdv = "RGR"))
#Use P-splines
longi.dat &lt;- splitSplines(longi.dat, response="PSA", x="xDAP", 
                          individuals = "Snapshot.ID.Tag", 
                          spline.type = "PS", lambda = 0.1, npspline.segments = 10, 
                          deriv=1, suffices.deriv="AGRdv", 
                          extra.rate = c(RGRdv = "RGR"))
#with segmented smoothing
longi.dat &lt;- splitSplines(longi.dat, response="PSA", x="xDAP", 
                          individuals = "Snapshot.ID.Tag", 
                          smoothing.segments = list(c(28,34), c(35,42)), df = 5)
</code></pre>


</div>