<div class="container">

<table style="width: 100%;"><tr>
<td>geom_arrowsegment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Line segments with flexible arrows</h2>

<h3>Description</h3>

<p>The basic <code>geom_arrowsegment()</code> is equivalent to <code>geom_segment(arrow = arrow())</code>.
(It is assumed that the user wants some kind of arrow.) The extended functionality
is to allow free placement of the arrowhead anywhere along the segment, and also
multiple arrowheads, and to allow a fill aesthetic (which will only be visible for
closed arrowheads).
</p>
<p>The function works by dividing the line up into 1 or more segment grobs, each of
which is generated by <code>grid::arrow()</code> except potentially the last (the one closest
to the point (<code>xend</code>, <code>yend</code>)). The vector <code>arrow_positions</code>, whose entries must
lie between 0 and 1, defines where each arrow segment ends, as a proportional
position along the line. If the last entry of <code>arrow_positions</code> is 1, then the last
grob has an arrow; otherwise it does not.
</p>
<p>The function is designed with the expectation that arrows point from (<code>x</code>, <code>y</code>) to
(<code>xend</code>, <code>yend</code>) but the <code>arrows</code> argument will happily accept <code>arrow(ends = "first")</code>
or <code>arrow(ends = "both")</code> if you prefer. Just remember that the final segment is
only an arrow at all if the last entry of <code>arrow_positions</code> is 1.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_arrowsegment(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  arrows = list(arrow()),
  arrow_fills = NULL,
  arrow_positions = 1,
  lineend = "butt",
  linejoin = "round",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrows</code></td>
<td>
<p>Either an arrow generated by <code>grid::arrow()</code> of a list of such arrows. In
the former case or if the list has length 1, the arrowhead so defined is used every
time; otherwise the list is expected to have the same length as
<code>arrow_positions</code> and each segment defined by that argument is ended by the respective
element of this one. The default is <code>grid::arrow()</code> with default parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow_fills</code></td>
<td>
<p>A vector of fill colours for the arrowheads, behaves as
the <code>arrow_fill</code> option in <code>geom_segment</code>. This will overrule a fill aesthetic in
the same way that specifying a single <code>fill</code> outside <code>aes</code> specification will.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow_positions</code></td>
<td>
<p>A vector of distinct points on the unit interval. 0 is not
permitted but arbitrarily small values are; 1 is permitted. The default behaviour is that
arrowheads will be placed proportionally along the line connecting (<code>x</code>, <code>y</code>)
to (<code>xend</code>,<code>yend</code>) at these points.
In more detail: The first arrow segment begins at (<code>x</code>, <code>y</code>) and ends a proportional
distance along the straight line joining (<code>x</code>, <code>y</code>) and (<code>xend</code>, <code>yend</code>) equal to the first
entry of this vector. The second bridges the first two entries, and so on. If the final
entry is 1 then the last segment is an arrow (and hence usually an arrowhead will be
placed at the end of the line). If it is not, then  the last segment is simply a line.
These will be sorted into order from 0 to 1 if they are not already.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A ggproto object
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 library(ggplot2)
 library(magrittr)
 library(tidyr)

 # Generate some dummy data

 ten.points &lt;- data.frame(line.no = rep(1:5, each = 2), x = runif(10), y = runif(10),
                          position = rep(c("start", "end"), 5))
 five.segments &lt;- ten.points %&gt;% pivot_wider(names_from = position, values_from = c(x,y))

 # Default behaviour

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end))

 # Midpoint arrowheads

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                      arrow_positions = 0.5)

 # Double arrows

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                      arrow_positions = c(0.25, 0.75))

 # Double arrows, last arrowhead at the end point

 ggplot(five.segments) +
    geom_point(data = ten.points, aes(x = x, y = y)) +
    geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                      arrow_positions = c(0.25, 1))

 # Double arrowheads of varying appearance and position

 ggplot(five.segments) +
     geom_point(data = ten.points, aes(x = x, y = y)) +
     geom_arrowsegment(aes(x = x_start, xend = x_end, y = y_start, yend = y_end),
                       arrow_positions = c(0.25, 0.75),
                       arrows = list(arrow(angle = 45, type = "closed"),
                                     arrow(angle = 25, ends = "both")),
                       arrow_fills = "indianred")

</code></pre>


</div>