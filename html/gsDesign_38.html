<div class="container">

<table style="width: 100%;"><tr>
<td>gsSurvCalendar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Time-to-event endpoint design with calendar timing of analyses</h2>

<h3>Description</h3>

<p>Time-to-event endpoint design with calendar timing of analyses
</p>


<h3>Usage</h3>

<pre><code class="language-R">gsSurvCalendar(
  test.type = 4,
  alpha = 0.025,
  sided = 1,
  beta = 0.1,
  astar = 0,
  sfu = gsDesign::sfHSD,
  sfupar = -4,
  sfl = gsDesign::sfHSD,
  sflpar = -2,
  calendarTime = c(12, 24, 36),
  spending = c("information", "calendar"),
  lambdaC = log(2)/6,
  hr = 0.6,
  hr0 = 1,
  eta = 0,
  etaE = NULL,
  gamma = 1,
  R = 12,
  S = NULL,
  minfup = 18,
  ratio = 1,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>test.type</code></td>
<td>
<p>Test type. See <code>gsSurv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Type I error rate. Default is 0.025 since 1-sided
testing is default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sided</code></td>
<td>
<p><code>1</code> for 1-sided testing, <code>2</code> for 2-sided testing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Type II error rate. Default is 0.10
(90% power); <code>NULL</code> if power is to be computed based on
other input values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>astar</code></td>
<td>
<p>Normally not specified. If <code>test.type = 5</code>
or <code>6</code>, <code>astar</code> specifies the total probability
of crossing a lower bound at all analyses combined. This
will be changed to <code>1 - alpha</code> when default value of
<code>0</code> is used. Since this is the expected usage,
normally <code>astar</code> is not specified by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfu</code></td>
<td>
<p>A spending function or a character string
indicating a boundary type (that is, <code>"WT"</code> for
Wang-Tsiatis bounds, <code>"OF"</code> for O'Brien-Fleming bounds and
<code>"Pocock"</code> for Pocock bounds). For one-sided and symmetric
two-sided testing is used to completely specify spending
(<code>test.type = 1</code>, <code>2</code>), <code>sfu</code>. The default value is
<code>sfHSD</code> which is a Hwang-Shih-DeCani spending function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfupar</code></td>
<td>
<p>Real value, default is <code>-4</code> which is an
O'Brien-Fleming-like conservative bound when used with the
default Hwang-Shih-DeCani spending function. This is a
real-vector for many spending functions. The parameter
<code>sfupar</code> specifies any parameters needed for the spending
function specified by <code>sfu</code>; this will be ignored for
spending functions (<code>sfLDOF</code>, <code>sfLDPocock</code>)
or bound types (<code>"OF"</code>, <code>"Pocock"</code>)
that do not require parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sfl</code></td>
<td>
<p>Specifies the spending function for lower
boundary crossing probabilities when asymmetric,
two-sided testing is performed
(<code>test.type = 3</code>, <code>4</code>, <code>5</code>, or <code>6</code>).
Unlike the upper bound,
only spending functions are used to specify the lower bound.
The default value is <code>sfHSD</code> which is a
Hwang-Shih-DeCani spending function. The parameter
<code>sfl</code> is ignored for one-sided testing
(<code>test.type = 1</code>) or symmetric 2-sided testing
(<code>test.type = 2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sflpar</code></td>
<td>
<p>Real value, default is <code>-2</code>, which, with the
default Hwang-Shih-DeCani spending function, specifies a
less conservative spending rate than the default for the
upper bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calendarTime</code></td>
<td>
<p>Vector of increasing positive numbers
with calendar times of analyses. Time 0 is start of
randomization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spending</code></td>
<td>
<p>Select between calendar-based spending and
information-based spending.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaC</code></td>
<td>
<p>Scalar, vector or matrix of event hazard
rates for the control group; rows represent time periods while
columns represent strata; a vector implies a single stratum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hr</code></td>
<td>
<p>Hazard ratio (experimental/control) under the
alternate hypothesis (scalar).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hr0</code></td>
<td>
<p>Hazard ratio (experimental/control) under the null
hypothesis (scalar).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>Scalar, vector or matrix of dropout hazard rates
for the control group; rows represent time periods while
columns represent strata; if entered as a scalar, rate is
constant across strata and time periods; if entered as a
vector, rates are constant across strata.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etaE</code></td>
<td>
<p>Matrix dropout hazard rates for the experimental
group specified in like form as <code>eta</code>; if <code>NULL</code>,
this is set equal to <code>eta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>A scalar, vector or matrix of rates of entry by
time period (rows) and strata (columns); if entered as a
scalar, rate is constant across strata and time periods;
if entered as a vector, rates are constant across strata.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>A scalar or vector of durations of time periods for
recruitment rates specified in rows of <code>gamma</code>. Length is the
same as number of rows in <code>gamma</code>. Note that when variable
enrollment duration is specified (input <code>T = NULL</code>), the final
enrollment period is extended as long as needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>A scalar or vector of durations of piecewise constant
event rates specified in rows of <code>lambda</code>, <code>eta</code> and <code>etaE</code>;
this is <code>NULL</code> if there is a single event rate per stratum
(exponential failure) or length of the number of rows in <code>lambda</code>
minus 1, otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minfup</code></td>
<td>
<p>A non-negative scalar less than the maximum value
in <code>calendarTime</code>. Enrollment will be cut off at the
difference between the maximum value in <code>calendarTime</code>
and <code>minfup</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>Randomization ratio of experimental treatment
divided by control; normally a scalar, but may be a vector with
length equal to number of strata.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer value controlling grid for numerical
integration as in Jennison and Turnbull (2000); default is 18,
range is 1 to 80. Larger values provide larger number of grid
points and greater accuracy. Normally <code>r</code> will not be changed by
the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance for error passed to the <code>gsDesign</code> function.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># First example: while timing is calendar-based, spending is event-based
x &lt;- gsSurvCalendar() %&gt;% toInteger()
gsBoundSummary(x)

# Second example: both timing and spending are calendar-based
# This results in less spending at interims and leaves more for final analysis
y &lt;- gsSurvCalendar(spending = "calendar") %&gt;% toInteger()
gsBoundSummary(y)

# Note that calendar timing for spending relates to planned timing for y
# rather than timing in y after toInteger() conversion

# Values plugged into spending function for calendar time
y$usTime
# Actual calendar fraction from design after toInteger() conversion
y$T / max(y$T)
</code></pre>


</div>