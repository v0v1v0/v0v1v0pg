<div class="container">

<table style="width: 100%;"><tr>
<td>fftfilt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>FFT-based FIR filtering</h2>

<h3>Description</h3>

<p>FFT-based FIR filtering using the overlap-add method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fftfilt(b, x, n = NULL)

## Default S3 method:
fftfilt(b, x, n = NULL)

## S3 method for class 'Ma'
fftfilt(b, x, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>moving average (Ma) coefficients of a FIR filter, specified as a
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the input signal to be filtered. If x is a matrix, its columns are
filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>FFT length, specified as a positive integer. The FFT size must be an
even power of 2 and must be greater than or equal to the length of
<code>filt</code>. If the specified <code>n</code> does not meet these criteria, it is
automatically adjusted to the nearest value that does. If <code>n = NULL</code>
(default), then the overlap-add method is not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function combines two important techniques to speed up filtering of long
signals, the overlap-add method, and FFT convolution. The overlap-add method
is used to break long signals into smaller segments for easier processing or
preventing memory problems. FFT convolution uses the overlap-add method
together with the Fast Fourier Transform, allowing signals to be convolved by
multiplying their frequency spectra. For filter kernels longer than about 64
points, FFT convolution is faster than standard convolution, while producing
exactly the same result.
</p>
<p>The overlap-add technique works as follows. When an <code>N</code> length signal is
convolved with a filter kernel of length <code>M</code>, the output signal is
<code>N + M - 1</code> samples long, i.e., the signal is expanded 'to the right'.
The signal is then broken into <code>k</code> smaller segments, and the convolution
of each segment with the f kernel will have a result of length <code>N / k +
M -1</code>. The individual segments are then added together. The rightmost <code>M
- 1</code> samples overlap with the leftmost <code>M - 1</code> samples of the next
segment. The overlap-add method produces exactly the same output signal as
direct convolution.
</p>
<p>FFT convolution uses the principle that multiplication in the frequency
domain corresponds to convolution in the time domain. The input signal is
transformed into the frequency domain using the FFT, multiplied by the
frequency response of the filter, and then transformed back into the time
domain using the inverse FFT. With FFT convolution, the filter kernel can be
made very long, with very little penalty in execution time.
</p>


<h3>Value</h3>

<p>The filtered signal, returned as a vector or matrix with the same
dimensions as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Kurt Hornik, <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a>,<br>
adapted by John W. Eaton.<br>
Conversion to R by Tom Short,<br>
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Overlap-add_method">https://en.wikipedia.org/wiki/Overlap-add_method</a>.
</p>


<h3>See Also</h3>

<p><code>filter</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">t &lt;- seq(0, 1, len = 10000)                          # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
filt &lt;- rep(0.1, 10)                                 # filter kernel
y1 &lt;- filter(filt, 1, x)                             # use normal convolution
y2 &lt;- fftfilt(filt, x)                               # FFT convolution
plot(t, x, type = "l")
lines(t, y1, col = "red")
lines(t, y2, col = "blue")

## use 'filter' with different classes
t &lt;- seq(0, 1, len = 10000)                          # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
ma &lt;- Ma(rep(0.1, 10))                               # filter kernel
y1 &lt;- filter(ma, x)                                  # convulution filter
y2 &lt;- fftfilt(ma, x)                                 # FFT filter
all.equal(y1, y2)                                    # same result

</code></pre>


</div>