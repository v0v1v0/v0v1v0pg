<div class="container">

<table style="width: 100%;"><tr>
<td>genaDiff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numeric Differentiation</h2>

<h3>Description</h3>

<p>Numeric estimation of the gradient and Hessian.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gena.grad(
  fn,
  par,
  eps = sqrt(.Machine$double.eps) * abs(par),
  method = "central-difference",
  fn.args = NULL
)

gena.hessian(
  fn = NULL,
  gr = NULL,
  par,
  eps = sqrt(.Machine$double.eps) * abs(par),
  fn.args = NULL,
  gr.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>function for which gradient or Hessian should be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>point (parameters' value) at which <code>fn</code> should be 
differentiated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>numeric vector representing increment of the <code>par</code>. 
So <code>eps[i]</code> represents increment of <code>par[i]</code>. If <code>eps</code> is
a constant then all increments are the same.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>numeric differentiation method: "central-difference" or
"forward-difference".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn.args</code></td>
<td>
<p>list containing arguments of <code>fn</code> except <code>par</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>gradient function of <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr.args</code></td>
<td>
<p>list containing arguments of <code>gr</code> except <code>par</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is possible to substantially improve numeric Hessian accuracy 
by using analytical gradient <code>gr</code>. If both <code>fn</code> and <code>gr</code>
are provided then only <code>gr</code> will be used. If only <code>fn</code> is provided 
for <code>gena.hessian</code> then <code>eps</code> will be transformed to 
<code>sqrt(eps)</code> for numeric stability purposes.
</p>


<h3>Value</h3>

<p>Function <code>gena.grad</code> returns a vector that is a gradient of 
<code>fn</code> at point <code>par</code> calculated via <code>method</code> numeric 
differentiation approach using increment <code>eps</code>.
</p>
<p>Function <code>gena.hessian</code> returns a matrix that is a Hessian of 
<code>fn</code> at point <code>par</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Consider the following function
fn &lt;- function(par, a = 1, b = 2)
{
  val &lt;- par[1] * par[2] - a * par[1] ^ 2 - b * par[2] ^ 2
}

# Calculate the gradient at point (2, 5) respect to 'par' 
# when 'a = 1' and 'b = 1'
par &lt;- c(2, 5)
fn.args = list(a = 1, b = 1)
gena.grad(fn = fn, par = par, fn.args = fn.args)

# Calculate Hessian at the same point
gena.hessian(fn = fn, par = par, fn.args = fn.args)

# Repeat calculation of the Hessian using analytical gradient
gr &lt;- function(par, a = 1, b = 2)
{
  val &lt;- c(par[2] - 2 * a * par[1],
           par[1] - 2 * b * par[2])
}
gena.hessian(gr = gr, par = par, gr.args = fn.args)

</code></pre>


</div>