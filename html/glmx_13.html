<div class="container">

<table style="width: 100%;"><tr>
<td>glmx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Linear Models with Extra Parameters</h2>

<h3>Description</h3>

<p>Estimation of generalized linear models with extra parameters,
e.g., parametric links, or families with additional parameters
(such as negative binomial).
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmx(formula, data, subset, na.action, weights, offset,
  family = negative.binomial, xlink = "log", control = glmx.control(...),
  model = TRUE, y = TRUE, x = FALSE, ...)

glmx.fit(x, y, weights = NULL, offset = NULL,
  family = negative.binomial, xlink = "log", control = glmx.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>symbolic description of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, subset, na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of case weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>optional numeric vector(s) with an a priori known component to be
included in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>function that returns a <code>"family"</code> object, i.e.,
<code>family(x)</code> needs to be a <code>"family"</code> object when
<code>x</code> is the numeric vector of extra parameters (by default assumed
to be 1-dimensional).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlink</code></td>
<td>
<p>link object or a character that can be passed to <code>make.link</code>.
It should link the extra parameters to real parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control arguments as returned by <code>glmx.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, y, x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.
For <code>glmx.fit</code>, <code>x</code> should be a numeric regressor matrix
and <code>y</code> should be the response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>control arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>glmx</code> is a convenience interface that estimates generalized
linear models (GLMs) with extra parameters. Examples would be binary response models
with parametric link functions or count regression using a negative binomial family
(which has one additional parameter).
</p>
<p>Hence, <code>glmx</code> needs a <code>family</code> argument which is a family-generating function
depending on one numeric argument for the extra parameters. Then, either profile-likelihood
methods can be used for optimizing the extra parameters or all parameters can be
optimized jointly.
</p>
<p>If the generated <code>family</code> contains a list element <code>loglik.extra</code> for the
derivative of the log-likelihood with respect to the extra parameters (i.e., score/gradient
contributions), then this is used in the optimization process. This should be a
<code>function(y, mu, extra)</code> depending on the observed response <code>y</code>, the estimated
mean <code>mu</code>, and the <code>extra</code> parameters.
</p>


<h3>Value</h3>

<p><code>glmx</code> returns an object of class <code>"glmx"</code>, i.e., a list with components as follows.
<code>glmx.fit</code> returns an unclassed list with components up to <code>converged</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"glm"</code> and <code>"extra"</code>
containing the coefficients from the respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a vector of deviance residuals,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>list of <code>optim</code> outputs for maximizing the <code>"profile"</code>
and <code>"full"</code> log-likelihood, respectively,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>the list of offset vectors used (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>number of estimated parameters,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p>estimate of the dispersion parameter (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a list with elements <code>"glm"</code> and <code>"extra"</code> where the former
contains the <code>"family"</code> object at the optimal extra parameters and
the latter the family-generating function,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlink</code></td>
<td>
<p>the link object for the extra parameters,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control options used,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original function call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the formula,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the terms object for the model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>the levels of the categorical regressors,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the response vector (if <code>y = TRUE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the model matrix (if <code>x = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>glmx.control</code>, <code>hetglm</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## artificial data from geometric regression
set.seed(1)
d &lt;- data.frame(x = runif(200, -1, 1))
d$y &lt;- rnbinom(200, mu = exp(0 + 3 * d$x), size = 1)

### negative binomial regression ###

## negative binomial regression via glmx
if(require("MASS")) {
m_nb1 &lt;- glmx(y ~ x, data = d,
  family = negative.binomial, xlink = "log", xstart = 0)
summary(m_nb1)

## negative binomial regression via MASS::glm.nb
m_nb2 &lt;- glm.nb(y ~ x, data = d)
summary(m_nb2)

## comparison
if(require("lmtest")) {
logLik(m_nb1)
logLik(m_nb2)
coeftest(m_nb1)
coeftest(m_nb2)
exp(coef(m_nb1, model = "extra"))
m_nb2$theta
exp(coef(m_nb1, model = "extra")) * sqrt(vcov(m_nb1, model = "extra"))
m_nb2$SE.theta
}}

## if the score (or gradient) contribution of the extra parameters
## is supplied, then estimation can be speeded up:
negbin &lt;- function(theta) {
  fam &lt;- negative.binomial(theta)
  fam$loglik.extra &lt;- function(y, mu, theta) digamma(y + theta) - digamma(theta) +
    log(theta) + 1 - log(mu + theta) - (y + theta)/(mu + theta)
  fam
}
m_nb3 &lt;- glmx(y ~ x, data = d,
  family = negbin, xlink = "log", xstart = 0, profile = FALSE)
all.equal(coef(m_nb1), coef(m_nb3), tolerance = 1e-7)


### censored negative binomial hurdle regression (0 vs. &gt; 0) ###

## negative binomial zero hurdle part via glmx
nbbin &lt;- function(theta) binomial(link = nblogit(theta))
m_hnb1 &lt;- glmx(factor(y &gt; 0) ~ x, data = d,
  family = nbbin, xlink = "log", xstart = 0)
summary(m_hnb1)

## negative binomial hurdle regression via pscl::hurdle
## (see only zero hurdle part)
if(require("pscl")) {
m_hnb2 &lt;- hurdle(y ~ x, data = d, dist = "negbin", zero.dist = "negbin")
summary(m_hnb2)
}
</code></pre>


</div>