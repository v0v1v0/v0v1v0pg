<div class="container">

<table style="width: 100%;"><tr>
<td>predict.grpnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Predict Method for grpnet Fits
</h2>

<h3>Description</h3>

<p>Obtain predictions from a fit group elastic net regularized GLM (grpnet) object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'grpnet'
predict(object, 
        newx,
        newdata,
        s = NULL,
        type = c("link", "response", "class", "terms", 
                 "importance", "coefficients", "nonzero", "groups", 
                 "ncoefs", "ngroups", "norm", "znorm"),
        ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>Object of class "grpnet"
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newx</code></td>
<td>

<p>Matrix of new <code>x</code> scores for prediction (default S3 method). Must have <code class="reqn">p</code> columns arranged in the same order as the <code>x</code> matrix used to fit the model. Ignored for the last six types of predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>Data frame of new <code>data</code> scores for prediction (S3 "formula" method). Must contain all variables in the <code>formula</code> used to fit the model. Ignored for the last six types of predictions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>Lambda value(s) at which predictions should be obtained. Default uses <code>s = object$lambda</code>. Interpolation is used for <code>s</code> values that are not included in <code>object$lambda</code>.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>Type of prediction to return. "link" gives predictions on the link scale (<code class="reqn">\eta</code>). "response" gives predictions on the mean scale (<code class="reqn">\mu</code>). "class" gives predicted class labels (for "binomial" and "multinomial" families). "terms" gives the predictions for each term (group) in the model (<code class="reqn">\eta_k</code>). "importance" gives the variable importance index for each term (group) in the model. "coefficients" returns the coefficients used for predictions. "nonzero" returns a list giving the indices of non-zero coefficients for each <code>s</code>. "groups" returns a list giving the labels of non-zero groups for each <code>s</code>. "ncoefs" returns the number of non-zero coefficients for each <code>s</code>. "ngroups" returns the number of non-zero groups for each <code>s</code>. "norm" returns the L2 norm of each group's (raw) coefficients for each <code>s</code>. "znorm" returns the L2 norm of each group's standardized coefficients for each <code>s</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments (ignored)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>type == "link"</code>, the predictions for each <code class="reqn">\lambda</code> have the form
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\eta_\lambda = \mathbf{X}_{\mathrm{new}} \boldsymbol\beta_\lambda</code>
</p>

<p>where <code class="reqn">\mathbf{X}_{\mathrm{new}}</code> is the argument <code>newx</code> (or the design matrix created from <code>newdata</code> by applying <code>object$formula</code>) and <code class="reqn">\boldsymbol\beta_\lambda</code> is the coefficient vector corresponding to <code class="reqn">\lambda</code>.
</p>
<p>When <code>type == "response"</code>, the predictions for each <code class="reqn">\lambda</code> have the form
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\mu_\lambda = g^{-1}(\boldsymbol\eta_\lambda) </code>
</p>

<p>where <code class="reqn">g^{-1}(\cdot)</code> is the inverse link function stored in <code>object$family$linkinv</code>.
</p>
<p>When <code>type == "class"</code>, the predictions for each <code class="reqn">\lambda</code> have the form
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_\lambda = \arg\max_l \boldsymbol\mu_\lambda(l) </code>
</p>

<p>where <code class="reqn">\boldsymbol\mu_\lambda(l)</code> gives the predicted probability that each observation belongs to the <code class="reqn">l</code>-th category (for <code class="reqn">l = 1,\ldots,m</code>) using the regularization parameter <code class="reqn">\lambda</code>. 
</p>
<p>When <code>type == "terms"</code>, the groupwise predictions for each <code class="reqn">\lambda</code> have the form
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol\eta_{k\lambda} = \mathbf{X}_k^{\mathrm{(new)}} \boldsymbol\beta_{k\lambda}</code>
</p>
<p> where <code class="reqn">\mathbf{X}_k^{\mathrm{(new)}}</code> is the portion of the argument <code>newx</code> (or the design matrix created from <code>newdata</code> by applying <code>object$formula</code>) that corresponds to the <code class="reqn">k</code>-th term/group, and <code class="reqn">\boldsymbol\beta_{k\lambda}</code> are the corresponding coefficients.
</p>
<p>When <code>type == "importance"</code>, the variable importance indices are defined as 
</p>
<p style="text-align: center;"><code class="reqn">\pi_k = \left( \boldsymbol\eta_{k\lambda}^\top \mathbf{C} \boldsymbol\eta_{0\lambda} \right) \left( \boldsymbol\eta_{0\lambda}^\top \mathbf{C} \boldsymbol\eta_{0\lambda} \right)^{-1}</code>
</p>

<p>where <code class="reqn">\mathbf{C} = (\mathbf{I}_n - \frac{1}{n} \mathbf{1}_n \mathbf{1}_n^\top)</code> denotes a centering matrix, and <code class="reqn">\boldsymbol\eta_{0\lambda} = \sum_{k=1}^K \boldsymbol\eta_{k\lambda}</code>. Note that <code class="reqn">\sum_{k=1}^K \pi_k = 1</code>, but some <code class="reqn">\pi_k</code> could be negative. When they are positive, <code class="reqn">\pi_k</code> gives the approximate proportion of model (explained) variation that is attributed to the <code class="reqn">k</code>-th term.
</p>


<h3>Value</h3>

<p>Depends on three factors... <br>
1. the exponential family distribution <br>
2. the length of the input <code>s</code> <br>
3. the <code>type</code> of prediction requested
</p>
<p>For most response variables, the typical output will be...
</p>
<table>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>a matrix of dimension <code>c(newnobs, length(s))</code> if <code>length(s) &gt; 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>a vector of length <code>newnobs</code> if length(s) == 1</p>
</td>
</tr>
</table>
<p>For multinomial response variables, the typical output will be... 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>an array of dimension <code>c(newnobs, length(object$ylev), length(s))</code> if <code>type %in% c("link", "response")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>a matrix of dimension <code>c(newobs, length(s))</code> if <code>type == "class"</code></p>
</td>
</tr>
</table>
<p>Note: if <code>type == "class"</code>, then the output will be the same class as <code>object$ylev</code>. Otherwise, the output will be real-valued (or integer for the counts).
</p>
<p>If <code>type == "terms"</code> and <code>family != "multinomial"</code>, the output will be...
</p>
<table>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>an array of dimension <code>c(newnobs, nterms, length(s))</code> if <code>length(s) &gt; 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>a matrix of dimension <code>c(newnobs, nterms)</code> if <code>length(s) == 1</code></p>
</td>
</tr>
</table>
<p>If <code>type == "terms"</code> and <code>family == "multinomial"</code>, the output will be a list of length <code>length(object$ylev)</code> where each element gives the terms for the corresponding response class.
</p>
<p>If <code>type == "importance"</code> and <code>family != "multinomial"</code>, the output will be...
</p>
<table>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>a matrix of dimension <code>c(nterms, length(s))</code> if <code>length(s) &gt; 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>*</code></td>
<td>
<p>a vector of length <code>nterms</code> if <code>length(s) == 1</code></p>
</td>
</tr>
</table>
<p>If <code>type == "importance"</code> and <code>family == "multinomial"</code>, the output will be a list of length <code>length(object$ylev)</code> where each element gives the importance for the corresponding response class. If <code>length(s) == 1</code>, the output will be simplified to matrix.
</p>
<p>If <code>type == "coefficients"</code>, the output will be the same as that produced by <code>coef.grpnet</code>.
</p>
<p>If <code>type == "nonzero"</code>, the output will be a list of length <code>length(s)</code> where each element is a vector of integers (indices).
</p>
<p>If <code>type == "groups"</code>, the output will be a list of length <code>length(s)</code> where each element is a vector of characters (<code>term.labels</code>).
</p>
<p>If <code>type %in% c("ncoefs", "ngroups")</code>, the output will be a vector of length <code>length(s)</code> where each element is an integer.
</p>
<p>If <code>type == "norm"</code>, the output will be a matrix of dimension <code>c(K, length(s))</code>, where each cell gives the L2 norm for the corresponding group and smoothing parameter. Note that <code>K</code> denotes the number of groups.
</p>


<h3>Note</h3>

<p>Some internal code (e.g., used for the interpolation) is borrowed from the <code>predict.glmnet</code> function in the <b>glmnet</b> package (Friedman, Hastie, &amp; Tibshirani, 2010).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Friedman, J.,  Hastie, T., &amp; Tibshirani, R. (2010). Regularization paths for generalized linear models via coordinate descent. <em>Journal of Statistical Software, 33</em>(1), 1-22. <a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>
</p>
<p>Helwig, N. E. (2024). Versatile descent algorithms for group regularization and variable selection in generalized linear models. <em>Journal of Computational and Graphical Statistics</em>. <a href="https://doi.org/10.1080/10618600.2024.2362232">doi:10.1080/10618600.2024.2362232</a>
</p>


<h3>See Also</h3>

<p><code>grpnet</code> for fitting grpnet regularization paths
</p>
<p><code>predict.cv.grpnet</code> for predicting from <code>cv.grpnet</code> objects
</p>


<h3>Examples</h3>

<pre><code class="language-R">######***######   family = "gaussian"   ######***######

# load data
data(auto)

# fit model (formula method, response = mpg)
mod &lt;- grpnet(mpg ~ ., data = auto)

# get fitted values for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto)

# get fitted values at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, s = c(1.5, 1, 0.5))

# compare rmse for solutions
rmse.path &lt;- sqrt(colMeans((auto$mpg - fit.path)^2))
rmse.some &lt;- sqrt(colMeans((auto$mpg - fit.some)^2))
plot(log(mod$lambda), rmse.path, cex = 0.5)
points(log(c(1.5, 1, 0.5)), rmse.some, pch = 0, col = "red")



######***######   family = "binomial"   ######***######

# load data
data(auto)

# redefine origin (Domestic vs Foreign)
auto$origin &lt;- ifelse(auto$origin == "American", "Domestic", "Foreign")

# fit model (formula method, response = origin with 2 levels)
mod &lt;- grpnet(origin ~ ., data = auto, family = "binomial")

# get predicted classes for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto, type = "class")

# get predicted classes at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, type = "class", s = c(.15, .1, .05))

# compare misclassification rate for solutions
miss.path &lt;- 1 - colMeans(auto$origin == fit.path)
miss.some &lt;- 1 - colMeans(auto$origin == fit.some)
plot(log(mod$lambda), miss.path, cex = 0.5)
points(log(c(.15, .1, .05)), miss.some, pch = 0, col = "red")



######***######   family = "multinomial"   ######***######

# load data
data(auto)

# fit model (formula method, response = origin with 3 levels)
mod &lt;- grpnet(origin ~ ., data = auto, family = "multinomial")

# get predicted classes for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto, type = "class")

# get predicted classes at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, type = "class", s = c(.1, .01, .001))

# compare misclassification rate for solutions
miss.path &lt;- 1 - colMeans(auto$origin == fit.path)
miss.some &lt;- 1 - colMeans(auto$origin == fit.some)
plot(log(mod$lambda), miss.path, cex = 0.5)
points(log(c(.1, .01, .001)), miss.some, pch = 0, col = "red")



######***######   family = "poisson"   ######***######

# load data
data(auto)

# fit model (formula method, response = horsepower)
mod &lt;- grpnet(horsepower ~ ., data = auto, family = "poisson")

# get fitted values for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto, type = "response")

# get fitted values at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, type = "response", s = c(15, 10, 5))

# compare rmse for solutions
rmse.path &lt;- sqrt(colMeans((auto$horsepower - fit.path)^2))
rmse.some &lt;- sqrt(colMeans((auto$horsepower - fit.some)^2))
plot(log(mod$lambda), rmse.path, cex = 0.5)
points(log(c(15, 10, 5)), rmse.some, pch = 0, col = "red")



######***######   family = "negative.binomial"   ######***######

# load data
data(auto)

# fit model (formula method, response = horsepower)
mod &lt;- grpnet(horsepower ~ ., data = auto, family = "negative.binomial")

# get fitted values for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto, type = "response")

# get fitted values at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, type = "response", s = c(0.1, 0.01, 0.001))

# compare rmse for solutions
rmse.path &lt;- sqrt(colMeans((auto$horsepower - fit.path)^2))
rmse.some &lt;- sqrt(colMeans((auto$horsepower - fit.some)^2))
plot(log(mod$lambda), rmse.path, cex = 0.5)
points(log(c(0.1, 0.01, 0.001)), rmse.some, pch = 0, col = "red")



######***######   family = "Gamma"   ######***######

# load data
data(auto)

# fit model (formula method, response = mpg)
mod &lt;- grpnet(mpg ~ ., data = auto, family = "Gamma")

# get fitted values for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto, type = "response")

# get fitted values at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, type = "response", s = c(0.1, 0.01, 0.001))

# compare rmse for solutions
rmse.path &lt;- sqrt(colMeans((auto$mpg - fit.path)^2))
rmse.some &lt;- sqrt(colMeans((auto$mpg - fit.some)^2))
plot(log(mod$lambda), rmse.path, cex = 0.5)
points(log(c(0.1, 0.01, 0.001)), rmse.some, pch = 0, col = "red")



######***######   family = "inverse.gaussian"   ######***######

# load data
data(auto)

# fit model (formula method, response = mpg)
mod &lt;- grpnet(mpg ~ ., data = auto, family = "inverse.gaussian")

# get fitted values for regularization path (output = 392 x 100 matrix)
fit.path &lt;- predict(mod, newdata = auto, type = "response")

# get fitted values at 3 particular points (output = 392 x 3 matrix)
fit.some &lt;- predict(mod, newdata = auto, type = "response", s = c(0.005, 0.001, 0.0001))

# compare rmse for solutions
rmse.path &lt;- sqrt(colMeans((auto$mpg - fit.path)^2))
rmse.some &lt;- sqrt(colMeans((auto$mpg - fit.some)^2))
plot(log(mod$lambda), rmse.path, cex = 0.5)
points(log(c(0.005, 0.001, 0.0001)), rmse.some, pch = 0, col = "red")

</code></pre>


</div>