<div class="container">

<table style="width: 100%;"><tr>
<td>GPADF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rotation Optimization</h2>

<h3>Description</h3>

<p>Derivative free gradient projection rotation optimization routine used by various rotation
objective.
</p>


<h3>Usage</h3>

<pre><code class="language-R">    GPForth.df(A, Tmat=diag(ncol(A)), normalize = FALSE, eps=1e-5, 
       maxit=1000, method="varimax", methodArgs=NULL)
    GPFoblq.df(A, Tmat=diag(ncol(A)), normalize = FALSE, eps=1e-5, 
       maxit=1000, method="quartimin", methodArgs=NULL)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>initial factor loadings matrix for which the rotation 
criterian is to be optimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>convergence is assumed when the norm of the gradient is smaller
than eps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations allowed in the main loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>rotation objective criterian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methodArgs</code></td>
<td>
<p>a list ofmethodArgs arguments passed to the rotation objective</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Derivative free gradient projection rotation optimization routines can be used to
rotate a loadings matrix. The rotation criteria in the <code>GPArotation</code> package
require a derivative to operate. In certain cases, the derivative is complex
or non-existent. The derivative free gradient projection method provides a numerical
alternative to the <code>GPArotation</code> package. 
The functions in the package <code>GPArotateDF</code> follow most of the functionality
and logic as in the <code>GPArotation</code> package. Please consult the documentation 
in <code>GPArotation</code> for further details. 
</p>
<p>The argument <code>method</code> can be used to specify a string indicating
the rotation objective. <code>GPFoblq</code> defaults to <code>"quartimin"</code> 
and <code>GPForth</code> defaults to <code>"varimax"</code>. Available rotation objective functions
include <code>"ff.bentler"</code>, <code>"ff.cf"</code>, <code>"ff.cubimax"</code>, <code>"ff.entropy"</code>, 
<code>"ff.fss"</code>, <code>"ff.geomin"</code>, <code>"ff.infomax"</code>, <code>"ff.oblimax"</code>,
<code>"ff.pst"</code>, <code>"ff.quartimax"</code>,<code>"ff.quartimin"</code>, <code>"ff.simplimax"</code>, 
<code>"ff.target"</code>, and <code>"ff.varimax"</code>. 
Most of the rotation criteria are avaible in the GPArotation pacakage 
except for <code>cubimax</code> and <code>Forced Simple Structure</code>.
</p>
<p>The rotation criteria are in the functions prefixed by "ff." that are used 
in the actual function call. The <code>ff.*</code> function call
would typically not be used directly, but are needed for rotation. Since
these are illustrative of computation, these are all exported
from the package namespace. 
New criteria for use with derivative free GP rotation do require a function of the type
<code>ff.newCriterionName</code> that provides value for complexity <code>f</code>, and name of method.
</p>
<p>Some rotation criteria (including <code>"simplimax"</code>, <code>"pst"</code>, 
<code>"target"</code>, <code>"cf"</code>, <code>"fss"</code>) require one or more additional arguments. 
Check GPArotation documentation for details or see <code>ff.fss</code>. 
</p>
<p>The argument normalize gives an indication of if and how any normalization should 
be done before rotation, and then undone after rotation. If normalize is FALSE 
(the default) no normalization is done. If normalize is TRUE then Kaiser normalization 
is done. (So squared row entries of normalized A sum to 1.0. This is sometimes 
called Horst normalization.) If normalize is a vector of length equal to the 
number of indicators (= number of rows of A) then the colums are divided by 
normalize before rotation and multiplied by normalize after rotation. 
If normalize is a function then it should take A as an argument and return a vector 
which is used like the vector above.
</p>


<h3>Value</h3>

<p>A GPArotation object which is a list with elements 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>The rotated loadings, one column for each factor. If randomStarts
were requested then this is the rotated loadings matrix with the 
lowest criterion value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th</code></td>
<td>
<p>The rotation matrix, loadings %*% t(Th) = A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Table</code></td>
<td>
<p>A matrix recording the iterations of the rotation optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>A logical indicating if convergence was obtained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPForth.df.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>The gradient of the objective function at the rotated loadings.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.</p>


<h3>References</h3>

<p>Jennrich, R.I. (2004). Derivative free gradient projection algorithms for rotation. 
<em>Psychometrika</em>, <b>69</b>, 475–480.
</p>
<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676–696.
</p>


<h3>See Also</h3>

<p><code>cubimax.df</code>
<code>fssQ.df</code>
<code>fssT.df</code>
<code>ff.bentler</code>, 
<code>ff.cf</code>, 
<code>ff.cubimax</code>, 
<code>ff.entropy</code>,
<code>ff.fss</code>, 
<code>ff.geomin</code>, 
<code>ff.infomax</code>, 
<code>ff.oblimax</code>, 
<code>ff.pst</code>,
<code>ff.quartimax</code>,
<code>ff.quartimin</code>, 
<code>ff.simplimax</code>, 
<code>ff.target</code>, 
<code>ff.varimax</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # GPRSorth and rotation name 
  data("Harman", package = "GPArotation")
  GPForth.df(Harman8, method = "quartimax")
  GPForth.df(Harman8, method = "cubimax")
  GPForth.df(Harman8, method = "varimax")
  GPFoblq.df(Harman8, method = "quartimin")

  # displaying results of factor analysis rotation output
  origdigits &lt;- options("digits")
  Abor.unrotated &lt;- factanal(factors = 2, covmat = ability.cov, rotation = "none")
  Abor &lt;- GPFoblq.df(loadings(Abor.unrotated), method = "quartimin")
  Abor
  print(Abor)
  print(Abor, Table = TRUE)
  print(Abor, digits = 2)
  summary(Abor)
  options(digits = origdigits$digits)
  </code></pre>


</div>