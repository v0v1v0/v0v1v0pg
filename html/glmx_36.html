<div class="container">

<table style="width: 100%;"><tr>
<td>hetglm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Heteroscedastic Binary Response GLMs</h2>

<h3>Description</h3>

<p>Fit heteroscedastic binary response models via maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hetglm(formula, data, subset, na.action, weights, offset,
  family = binomial(link = "probit"),
  link.scale = c("log", "sqrt", "identity"),
  control = hetglm.control(...),
  model = TRUE, y = TRUE, x = FALSE, ...)

hetglm.fit(x, y, z = NULL, weights = NULL, offset = NULL,
  family = binomial(), link.scale = "log", control = hetglm.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code>
or <code>y ~ x | z</code>; for details see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, subset, na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of case weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>optional numeric vector(s) with an a priori known component to be
included in the linear predictor(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>family object (including the link function of the mean model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link.scale</code></td>
<td>
<p>character specification of the link function in
the latent scale model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control arguments specified via
<code>hetglm.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, y, x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.
For <code>hetglm.fit</code>, <code>x</code> should be a numeric regressor matrix
and <code>y</code> should be the numeric response vector (with values in (0,1)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>numeric matrix. Regressor matrix for the precision model, defaulting
to an intercept only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>hetglm.control</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"hetglm"</code>, including methods to the generic functions
<code>print</code>, <code>summary</code>, <code>coef</code>, 
<code>vcov</code>, <code>logLik</code>, <code>residuals</code>, 
<code>predict</code>, <code>terms</code>, <code>update</code>,
<code>model.frame</code>, <code>model.matrix</code>,
<code>estfun</code> and <code>bread</code> (from the <span class="pkg">sandwich</span> package), and
<code>coeftest</code> (from the <span class="pkg">lmtest</span> package).  
</p>


<h3>Value</h3>

<p><code>hetglm</code> returns an object of class <code>"hetglm"</code>, i.e., a list with components as follows.
<code>hetglm.fit</code> returns an unclassed list with components up to <code>converged</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the coefficients from the respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>output from the <code>optim</code> call for maximizing the log-likelihood,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method argument passed to the <code>optim</code> call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>the control arguments passed to the <code>optim</code> call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>the list of offset vectors used (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.null</code></td>
<td>
<p>residual degrees of freedom in the homoscedastic null model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom in the fitted model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik.null</code></td>
<td>
<p>log-likelihood of the homoscedastic null model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p>estimate of the dispersion parameter (if any),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the family object used,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the link objects for the respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original function call,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the original formula,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>a list with elements <code>"mean"</code>, <code>"scale"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>a list with elements <code>"mean"</code>, <code>"scale"</code> and
<code>"full"</code> containing the levels of the categorical regressors,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the response vector (if <code>y = TRUE</code>),</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>Formula</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate artifical binary data from a latent
## heteroscedastic normally distributed variable
set.seed(48)
n &lt;- 200
x &lt;- rnorm(n)
ystar &lt;- 1 + x +  rnorm(n, sd = exp(x))
y  &lt;- factor(ystar &gt; 0) 

## visualization
par(mfrow = c(1, 2))
plot(ystar ~ x, main = "latent")
abline(h = 0, lty = 2)
plot(y ~ x, main = "observed")

## model fitting of homoscedastic model (m0a/m0b)
## and heteroscedastic model (m)
m0a &lt;- glm(y ~ x, family = binomial(link = "probit"))
m0b &lt;- hetglm(y ~ x | 1)
m &lt;- hetglm(y ~ x)

## coefficient estimates
cbind(heteroscedastic = coef(m),
  homoscedastic = c(coef(m0a), 0))

## summary of correct heteroscedastic model
summary(m)



## Generate artificial binary data with a single binary regressor
## driving the heteroscedasticity in a model with two regressors
set.seed(48)
n &lt;- 200
x &lt;- rnorm(n)
z &lt;- rnorm(n)
a &lt;- factor(sample(1:2, n, replace = TRUE))
ystar &lt;- 1 + c(0, 1)[a] + x + z + rnorm(n, sd = c(1, 2)[a])
y  &lt;- factor(ystar &gt; 0) 

## fit "true" heteroscedastic model
m1 &lt;- hetglm(y ~ a + x + z | a)

## fit interaction model
m2 &lt;- hetglm(y ~ a/(x + z) | 1)

## although not obvious at first sight, the two models are
## nested. m1 is a restricted version of m2 where the following
## holds: a1:x/a2:x == a1:z/a2:z
if(require("lmtest")) lrtest(m1, m2)

## both ratios are == 2 in the data generating process
c(x = coef(m2)[3]/coef(m2)[4], z = coef(m2)[5]/coef(m2)[6])



if(require("AER")) {

## Labor force participation example from Greene
## (5th edition: Table 21.3, p. 682)
## (6th edition: Table 23.4, p. 790)

## data (including transformations)
data("PSID1976", package = "AER")
PSID1976$kids &lt;- with(PSID1976, factor((youngkids + oldkids) &gt; 0,
  levels = c(FALSE, TRUE), labels = c("no", "yes")))
PSID1976$fincome &lt;- PSID1976$fincome/10000

## Standard probit model via glm()
lfp0a &lt;- glm(participation ~ age + I(age^2) + fincome + education + kids,
  data = PSID1976, family = binomial(link = "probit"))

## Standard probit model via hetglm() with constant scale
lfp0b &lt;- hetglm(participation ~ age + I(age^2) + fincome + education + kids | 1,
  data = PSID1976)

## Probit model with varying scale
lfp1 &lt;- hetglm(participation ~ age + I(age^2) + fincome + education + kids | kids + fincome,
  data = PSID1976)

## Likelihood ratio and Wald test
lrtest(lfp0b, lfp1)
waldtest(lfp0b, lfp1)

## confusion matrices
table(true = PSID1976$participation,
  predicted = fitted(lfp0b) &lt;= 0.5)
table(true = PSID1976$participation,
  predicted = fitted(lfp1) &lt;= 0.5)



## Adapted (and somewhat artificial) example to illustrate that
## certain models with heteroscedastic scale can equivalently
## be interpreted as homoscedastic scale models with interaction
## effects.

## probit model with main effects and heteroscedastic scale in two groups
m &lt;- hetglm(participation ~ kids + fincome | kids, data = PSID1976)

## probit model with interaction effects and homoscedastic scale
p &lt;- glm(participation ~ kids * fincome, data = PSID1976,
   family = binomial(link = "probit"))

## both likelihoods are equivalent
logLik(m)
logLik(p)

## intercept/slope for the kids=="no" group
coef(m)[c(1, 3)]
coef(p)[c(1, 3)]

## intercept/slope for the kids=="yes" group
c(sum(coef(m)[1:2]), coef(m)[3]) / exp(coef(m)[4])
coef(p)[c(1, 3)] + coef(p)[c(2, 4)]

## Wald tests for the heteroscedasticity effect in m and the 
## interaction effect in p are very similar
coeftest(m)[4,]
coeftest(p)[4,]

## corresponding likelihood ratio tests are equivalent
## (due to the invariance of the MLE)
m0 &lt;- hetglm(participation ~ kids + fincome | 1, data = PSID1976)
p0 &lt;- glm(participation ~ kids + fincome, data = PSID1976,
  family = binomial(link = "probit"))
lrtest(m0, m)
lrtest(p0, p)

}
</code></pre>


</div>