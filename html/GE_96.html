<div class="container">

<table style="width: 100%;"><tr>
<td>gemOLG_PureExchange</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Basic Overlapping Generations Pure Exchange Model (see Samuelson, 1958)</h2>

<h3>Description</h3>

<p>This is the basic overlapping generations pure exchange model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gemOLG_PureExchange(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>As Samuelson (1958) wrote, break each life up into thirds.
Agents get 50 units of payoff in period 1 and 50 units in period 2; in period 3 they retire and get nothing.
Suppose there are three agents in each period, namely age1, age2 and age3.
In the next period, the present age1 will become age2, the present age2 will become age3,
the present age3 will disappear and a new age1 will appear.
Let c1, c2 and c3 denote the consumption of an agent in each period.
Suppose the utility function is (c1 * c2 * c3)^(1 / 3), which is actually the same as log(c1) + log(c2) + log(c3).
In each period, age1 and age2 will exchange their payoffs of the present period and the next period.
Age2 will sell some present payoff and buy some future payoff as pension, and for age1, it's the opposite.
Age3 simply receives the pension and need not take part in the exchange.
Hence only two agents participate in the pure exchange economy.
In the exchange process, the utility function of age1 is c1^(1 / 3) * x2^(2 / 3), wherein x2 is the revenue of the next period,
and the utility function of age2 is c2^(1 / 2) * c3^(1 / 2).
</p>


<h3>Note</h3>

<p>We can also suppose only age2 gets payoff and age1 does not.
</p>


<h3>References</h3>

<p>Samuelson, P. A. (1958) An Exact Consumption-Loan Model of Interest with or without the Social Contrivance of Money. Journal of Political Economy, vol. 66(6): 467-482.
</p>


<h3>See Also</h3>


<p><code>gemOLG_TimeCircle</code>

</p>


<h3>Examples</h3>

<pre><code class="language-R">
#### the basic overlapping generations (inefficient) exchange model in sequential form.
dst.age1 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 3, 2 / 3),
  "payoff1", "payoff2"
)

dst.age2 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 2, 1 / 2),
  "payoff1", "payoff2"
)

policy.supply &lt;- function(time, state) {
  pension &lt;- (state$last.A[, 2] * state$last.z[2])[2]
  if (time &gt; 1) state$S[1, 2] &lt;- 50 - pension
  state
}

ge &lt;- sdm2(
  A = list(dst.age1, dst.age2),
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    50, 50,
    50, 0
  ), 2, 2, TRUE),
  names.commodity = c("payoff1", "payoff2"),
  names.agent = c("age1", "age2"),
  numeraire = "payoff1",
  policy = list(policy.supply, policyMarketClearingPrice),
  maxIteration = 1,
  numberOfPeriods = 20,
  ts = TRUE
)

ge$p # c(1, 3 / 2 + sqrt(13) / 2)
ge$ts.p
ge$S
ge$D
ge$DV

#### the basic overlapping generations exchange model in timeline form.
m &lt;- 15 # the number of generations
n &lt;- m + 1 # the number of commodity kinds

names.commodity &lt;- paste0("payoff", 1:n)
names.agent &lt;- paste0("gen", 1:m)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:m) {
  S0Exg[k:(k + 1), k] &lt;- 50
}

dstl.consumer &lt;- list()
for (k in 1:(m - 1)) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = rep(1 / 3, 3),
    paste0("payoff", k:(k + 2))
  )
}

dstl.consumer[[m]] &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  paste0("payoff", m:(m + 1))
)

ge &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, n, m),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

round(addmargins(ge$D, 2), 2)
round(addmargins(ge$S, 2), 2)
growth_rate(ge$p) + 1 # 3 / 2 + sqrt(13) / 2

#### Assume that in the timeline model, each consumer lives for four periods or more.
nl &lt;- 4 # the number of life periods
payoff &lt;- c(rep(100 / (nl - 1), nl - 1), 1e-10) # the lifetime payoffs
m &lt;- 20 # the number of generations
n &lt;- m + nl - 1 # the number of commodity kinds

names.commodity &lt;- paste0("payoff", 1:n)
names.agent &lt;- paste0("gen", 1:m)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:m) {
  S0Exg[k:(k + nl - 1), k] &lt;- payoff
}

dstl.consumer &lt;- list()
for (k in 1:m) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = rep(1 / nl, nl),
    paste0("payoff", k:(k + nl - 1))
  )
}

ge &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, n, m),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

round(addmargins(ge$D, 2), 2)
round(addmargins(ge$S, 2), 2)
growth_rate(ge$p) + 1

</code></pre>


</div>