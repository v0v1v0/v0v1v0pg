<div class="container">

<table style="width: 100%;"><tr>
<td>stabsel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Stability Selection
</h2>

<h3>Description</h3>

<p>Selection of influential variables or model components with error control.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## a method to compute stability selection paths for fitted mboostLSS models
## S3 method for class 'mboostLSS'
stabsel(x, cutoff, q, PFER, mstop = NULL,
        folds = subsample(model.weights(x), B = B),
        B = ifelse(sampling.type == "MB", 100, 50),
        assumption = c("unimodal", "r-concave", "none"),
        sampling.type = c("SS", "MB"),
        papply = mclapply, verbose = TRUE, FWER, eval = TRUE, ...)
## a method to get the selected parameters
## S3 method for class 'stabsel_mboostLSS'
selected(object, parameter = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an fitted model of class <code>"mboostLSS"</code> or <code>"nc_mboostLSS"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. Preferably a value between 0.6
and 0.9 should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>number of (unique) selected variables (or groups of variables
depending on the model) that are selected on each subsample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PFER</code></td>
<td>
<p>upper bound for the per-family error rate. This
specifies the amount of falsely selected base-learners, which is
tolerated. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstop</code></td>
<td>
<p>mstop value to use, if no value is supplied the mstop value of the fitted model is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p> a weight matrix with number of rows equal to the number
of observations, see <code>cvrisk</code> and
<code>subsample</code>. Usually one should not
change the default here as subsampling with a fraction of <code class="reqn">1/2</code>
is needed for the error bounds to hold. One usage scenario where
specifying the folds by hand might be the case when one has
dependent data (e.g. clusters) and thus wants to draw clusters
(i.e., multiple rows together) not individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assumption</code></td>
<td>
<p> Defines the type of assumptions on the
distributions of the selection probabilities and simultaneous
selection probabilities. Only applicable for
<code>sampling.type = "SS"</code>. For <code>sampling.type = "MB"</code> we
always use code"none".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling.type</code></td>
<td>
<p> use sampling scheme of of Shah &amp; Samworth
(2013), i.e., with complementarty pairs (<code>sampling.type = "SS"</code>),
or the original sampling scheme of Meinshausen &amp; Buehlmann (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p> number of subsampling replicates. Per default, we use 50
complementary pairs for the error bounds of Shah &amp; Samworth (2013)
and 100 for the error bound derived in  Meinshausen &amp; Buehlmann
(2010). As we use <code class="reqn">B</code> complementray pairs in the former case
this leads to <code class="reqn">2B</code> subsamples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>papply</code></td>
<td>
<p> (parallel) apply function, defaults to
<code>mclapply</code>. Alternatively, <code>parLapply</code>
can be used. In the latter case, usually more setup is needed (see
example of <code>cvrisk</code> for some details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical (default: <code>TRUE</code>) that determines wether
<code>warnings</code> should be issued. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FWER</code></td>
<td>
<p> deprecated. Only for compatibility with older versions,
use PFER instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval</code></td>
<td>
<p> logical. Determines whether stability selection is
evaluated (<code>eval = TRUE</code>; default) or if only the parameter
combination is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> a object of class <code>"stabsel_mboostLSS"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p> select one or multiple effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to parallel apply methods such as
<code>mclapply</code> and to <code>cvrisk</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Stability selection is to be preferably used with non-cyclic <code>gamboostLSS</code> 
models, as proposed by Thomas et al. (2018). In this publication, the combination 
of package <span class="pkg">gamboostLSS</span> with stability selection was devoloped and is 
investigated in depth. 
</p>
<p>For details on stability selection see <code>stabsel</code> in package 
<span class="pkg">stabs</span> and Hofner et al. (2014).
</p>


<h3>Value</h3>

<p>An object of class <code>stabsel</code> with a special <code>print</code> method.
The object has the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>phat</code></td>
<td>
<p>selection probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected</code></td>
<td>
<p>elements with maximal selection probability greater
<code>cutoff</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max</code></td>
<td>
<p>maximum of selection probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>cutoff used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>average number of selected variables used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PFER</code></td>
<td>
<p>per-family error rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling.type</code></td>
<td>
<p>the sampling type used for stability selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assumption</code></td>
<td>
<p>the assumptions made on the selection
probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>B. Hofner, L. Boccuto and M. Goeker (2015),
Controlling false discoveries in high-dimensional situations: Boosting
with stability selection. <em>BMC Bioinformatics</em>, <b>16:144</b>.
</p>
<p>N. Meinshausen and P. Buehlmann (2010), Stability selection.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 417–473.
</p>
<p>R.D. Shah and R.J. Samworth (2013), Variable selection with error
control: another look at stability selection. <em>Journal of the Royal
Statistical Society, Series B</em>, <b>75</b>, 55–80.
</p>
<p>Thomas, J., Mayr, A., Bischl, B., Schmid, M., Smith, A., and Hofner, B. (2018), 
Gradient boosting for distributional regression - faster tuning and improved 
variable selection via noncyclical updates. 
<em>Statistics and Computing</em>. 28: 673-687. 
<a href="https://doi.org/10.1007/s11222-017-9754-6">doi:10.1007/s11222-017-9754-6</a><br>
(Preliminary version: <a href="https://arxiv.org/abs/1611.10171">https://arxiv.org/abs/1611.10171</a>).
</p>


<h3>See Also</h3>

<p><code>stabsel</code> and
<code>stabsel_parameters</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### Data generating process:
set.seed(1907)
x1 &lt;- rnorm(500)
x2 &lt;- rnorm(500)
x3 &lt;- rnorm(500)
x4 &lt;- rnorm(500)
x5 &lt;- rnorm(500)
x6 &lt;- rnorm(500)
mu    &lt;- exp(1.5 +1 * x1 +0.5 * x2 -0.5 * x3 -1 * x4)
sigma &lt;- exp(-0.4 * x3 -0.2 * x4 +0.2 * x5 +0.4 * x6)
y &lt;- numeric(500)
for( i in 1:500)
    y[i] &lt;- rnbinom(1, size = sigma[i], mu = mu[i])
dat &lt;- data.frame(x1, x2, x3, x4, x5, x6, y)

### linear model with y ~ . for both components: 400 boosting iterations
model &lt;- glmboostLSS(y ~ ., families = NBinomialLSS(), data = dat,
                     control = boost_control(mstop = 400),
                     center = TRUE, method = "noncyclic")

### Do not test the following code per default on CRAN as it takes some time to run:

#run stability selection 
(s &lt;- stabsel(model, q = 5, PFER = 1))
#get selected effects
selected(s)

#visualize selection frequencies 
plot(s)

### END (don't test automatically)

</code></pre>


</div>