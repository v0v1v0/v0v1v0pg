<div class="container">

<table style="width: 100%;"><tr>
<td>stat_label_peaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Label peaks and valleys.</h2>

<h3>Description</h3>

<p><code>stat_labels_peaks</code> finds at which x positions local maxima are located,
and adds labels and colors to the data wihtout subsetting. To find local
minima, you can use <code>stat_labels_valleys</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_label_peaks(
  mapping = NULL,
  data = NULL,
  geom = "text",
  position = "identity",
  ...,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  chroma.type = "CMF",
  label.fmt = "%.3g",
  x.label.fmt = label.fmt,
  y.label.fmt = label.fmt,
  label.fill = "",
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE
)

stat_label_valleys(
  mapping = NULL,
  data = NULL,
  geom = "text",
  position = "identity",
  ...,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  chroma.type = "CMF",
  label.fmt = "%.3g",
  x.label.fmt = label.fmt,
  y.label.fmt = label.fmt,
  label.fill = "",
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code> or <code>aes_</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>span</code></td>
<td>
<p>a peak is defined as an element in a sequence which is greater
than all other elements within a window of width span centered at that
element. The default value is 5, meaning that a peak is bigger than two
consequtive neighbors on each side. Default: 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_threshold</code></td>
<td>
<p>numeric value between 0.0 and 1.0 indicating the size
threshold below which peaks will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>logical flag: if TRUE, an element must be strictly greater than
all other values in its window to be considered a peak. Default: FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chroma.type</code></td>
<td>
<p>character one of "CMF" (color matching function) or "CC"
(color coordinates) or a <code>chroma_spct</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
values into character strings by means of function <code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $x$-values into character strings by means of function
<code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $y$-values into character strings by means of function
<code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fill</code></td>
<td>
<p>character string ot use for labels not at peaks or valleys
being highlighted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These stats use <code>geom_text</code> by default as it is the geom most
likely to work well in almost any situation without need of tweaking. These
statistics work best with <code>geom_text_repel</code> and
<code>geom_label_repel</code> from package 'ggrepel' as they are designed so that
peak or valley labels will not overlapT any observation in the whole data
set. Default aesthetics set by these stats allow their direct use with
<code>geom_text</code>, <code>geom_label</code>, <code>geom_line</code>, <code>geom_rug</code>,
<code>geom_hline</code> and <code>geom_vline</code>. The formatting of the labels
returned can be controlled by the user.
</p>


<h3>Value</h3>

<p>The original data with additional computed variables added.
</p>


<h3>Computed variables</h3>

 <dl>
<dt>x.label</dt>
<dd>
<p>x-value at a peak (or
valley) formatted as character or otherwise the
value passed to <code>label.fill</code> which defaults to an
empty string (<code>""</code>).</p>
</dd>
<dt>y.label</dt>
<dd>
<p>y-value at the peak (or valley) formatted as character or
otherwise the value passed to <code>label.fill</code> which defaults to an
empty string (<code>""</code>).</p>
</dd>
<dt>wl.color</dt>
<dd>
<p>At peaks and valleys,
color definition calculated by assuming that x-values are wavelengths
expressed in nanometres, otherwise, <code>rgb(1, 1, 1, 0)</code> (transparent
white).</p>
</dd> </dl>
<h3>Default aesthetics</h3>

<p>Set by the statistic and available to geoms.
</p>
 <dl>
<dt>label</dt>
<dd>
<p>..x.label..</p>
</dd> <dt>xintercept</dt>
<dd>
<p>..x..</p>
</dd>
<dt>yintercept</dt>
<dd>
<p>..y..</p>
</dd> <dt>color</dt>
<dd>
<p>black_or_white(..wl.color..)</p>
</dd>
<dt>fill</dt>
<dd>
<p>..wl.color..</p>
</dd> </dl>
<h3>Required aesthetics</h3>

<p>Required by the statistic and need to be set
with <code>aes()</code>. </p>
 <dl>
<dt>x</dt>
<dd>
<p>numeric, wavelength in nanometres</p>
</dd>
<dt>y</dt>
<dd>
<p>numeric, a spectral quantity</p>
</dd> </dl>
<h3>Note</h3>

<p>These stats work nicely together with geoms <code>geom_text_repel</code> and
<code>geom_label_repel</code> from package <code>ggrepel</code> to
solve the problem of overlapping labels by displacing them. To discard
overlapping labels use <code>check_overlap = TRUE</code> as argument to
<code>geom_text</code>. By default the labels are character values suitable to be
plotted as is, but with a suitable <code>label.fmt</code> labels suitable for
parsing by the geoms (e.g. into expressions containing greek letters or
super or subscripts) can be also easily obtained.
</p>


<h3>See Also</h3>

<p><code>stat_peaks</code>, <code>stat_valleys</code> and
<code>find_peaks</code>, which is used internally.
</p>
<p>Other stats functions: 
<code>stat_color()</code>,
<code>stat_find_qtys()</code>,
<code>stat_find_wls()</code>,
<code>stat_peaks()</code>,
<code>stat_spikes()</code>,
<code>stat_wb_box()</code>,
<code>stat_wb_column()</code>,
<code>stat_wb_contribution()</code>,
<code>stat_wb_hbar()</code>,
<code>stat_wb_irrad()</code>,
<code>stat_wb_label()</code>,
<code>stat_wb_mean()</code>,
<code>stat_wb_relative()</code>,
<code>stat_wb_sirrad()</code>,
<code>stat_wb_total()</code>,
<code>stat_wl_strip()</code>,
<code>stat_wl_summary()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# ggplot() methods for spectral objects set a default mapping for x and y.
ggplot(sun.spct) + geom_line() +
  stat_label_peaks(hjust = "left", span = 31, angle = 90, color = "red")
ggplot(sun.spct) + geom_line() +
  stat_label_valleys(hjust = "right", span = 21, angle = 90, color = "blue")

ggplot(sun.spct) + geom_line() +
  stat_peaks(span = 41, shape = 21, size = 3) +
  stat_label_peaks(span = 41, geom = "label", label.fmt = "%3.0f nm") +
  scale_fill_identity() +
  scale_color_identity() +
  expand_limits(y = c(NA, 1))

# using 'ggrepel' to avoid overlaps
# too slow for CRAN checks
## Not run: 
library(ggrepel)

ggplot(sun.spct) + geom_line() +
  stat_peaks(span = 41, shape = 21, size = 3) +
  stat_label_peaks(span = 41, geom = "label_repel", segment.colour = "red",
                   nudge_y = 0.12, label.fmt = "%3.0f nm", vjust = 1) +
  scale_fill_identity() +
  scale_color_identity() +
  expand_limits(y = c(NA, 1))

## End(Not run)

</code></pre>


</div>