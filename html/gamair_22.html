<div class="container">

<table style="width: 100%;"><tr>
<td>ch7</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Code for Chapter 7: GAMs in Practice: mgcv</h2>

<h3>Description</h3>

<p>R code from Chapter 7 of the second edition of ‘Generalized Additive Models: An Introduction with R’ is in the examples section below.
</p>


<h3>Author(s)</h3>

<p>Simon Wood &lt;simon@r-project.org&gt;
</p>
<p>Maintainer: Simon Wood &lt;simon@r-project.org&gt;
</p>


<h3>References</h3>

<p>Wood, S.N. (2017) <em>Generalized Additive Models: An Introduction with R</em>, CRC
</p>


<h3>See Also</h3>

<p><code>mgcv</code>, <code>ch7.solutions</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(gamair); library(mgcv)
## NOTE: Examples are marked 'Not run' to save CRAN check time

## 7.1.1 using smooth constructors

library(mgcv); library(MASS) ## load for mcycle data.
## set up a smoother...
sm &lt;- smoothCon(s(times,k=10),data=mcycle,knots=NULL)[[1]]
## use it to fit a regression spline model...
beta &lt;- coef(lm(mcycle$accel~sm$X-1))
with(mcycle,plot(times,accel)) ## plot data
times &lt;- seq(0,60,length=200)  ## create prediction times
## Get matrix mapping beta to spline prediction at 'times'
Xp &lt;- PredictMat(sm,data.frame(times=times))
lines(times,Xp%*%beta) ## add smooth to plot

## Not run: 
## 7.2 Brain scan
## 7.2.1 preliminary modelling
require(gamair); require(mgcv); data(brain)
brain &lt;- brain[brain$medFPQ&gt;5e-3,] # exclude 2 outliers
m0 &lt;- gam(medFPQ~s(Y,X,k=100),data=brain)
gam.check(m0)

e &lt;- residuals(m0); fv &lt;- fitted(m0)
lm(log(e^2)~log(fv))

m1&lt;-gam(medFPQ^.25~s(Y,X,k=100),data=brain)
gam.check(m1)
m2&lt;-gam(medFPQ~s(Y,X,k=100),data=brain,family=Gamma(link=log))
mean(fitted(m1)^4);mean(fitted(m2));mean(brain$medFPQ)

m2
vis.gam(m2,plot.type="contour",too.far=0.03,
        color="gray",n.grid=60,zlim=c(-1,2))

## 7.2.2 additive?
m3 &lt;- gam(medFPQ~s(Y,k=30)+s(X,k=30),data=brain,
          family=Gamma(link=log))
m3
AIC(m2,m3)

## 7.2.3 isotropic or tensor 
tm &lt;- gam(medFPQ~te(Y,X,k=10),data=brain,family=Gamma(link=log))
tm1 &lt;- gam(medFPQ ~ s(Y,k=10,bs="cr") + s(X,bs="cr",k=10) +
           ti(X,Y,k=10), data=brain, family=Gamma(link=log))
AIC(m2,tm,tm1)
anova(tm1)

## 7.2.4 Detecting symmetry
brain$Xc &lt;- abs(brain$X - 64.5)
brain$right &lt;- as.numeric(brain$X&lt;64.5)
m.sy &lt;- gam(medFPQ~s(Y,Xc,k=100),data=brain,
            family=Gamma(link=log))
m.as &lt;- gam(medFPQ~s(Y,Xc,k=100)+s(Y,Xc,k=100,by=right),
            data=brain,family=Gamma(link=log))
m.sy
m.as

anova(m.as)

vis.gam(m.sy,plot.type="contour",view=c("Xc","Y"),too.far=.03,
        color="gray",n.grid=60,zlim=c(-1,2),main="both sides")
vis.gam(m.as,plot.type="contour",view=c("Xc","Y"),
        cond=list(right=0),too.far=.03,color="gray",n.grid=60,
        zlim=c(-1,2),main="left side")
vis.gam(m.as,plot.type="contour",view=c("Xc","Y"),
        cond=list(right=1),too.far=.03,color="gray",n.grid=60,
        zlim=c(-1,2),main="right side")

## 7.2.5 Comparing surfaces
brain1 &lt;- brain
mu &lt;- fitted(m2)
n&lt;-length(mu)
ind &lt;- brain1$X&lt;60 &amp; brain1$Y&lt;20
mu[ind] &lt;- mu[ind]/3
set.seed(1)
brain1$medFPQ &lt;- rgamma(rep(1,n),mu/m2$sig2,scale=m2$sig2)

brain2=rbind(brain,brain1)
brain2$sample1 &lt;- c(rep(1,n),rep(0,n))
brain2$sample0 &lt;- 1 - brain2$sample1

m.same&lt;-gam(medFPQ~s(Y,X,k=100),data=brain2,
            family=Gamma(link=log))
m.diff&lt;-gam(medFPQ~s(Y,X,k=100)+s(Y,X,by=sample1,k=100),
            data=brain2,family=Gamma(link=log))
AIC(m.same,m.diff)
anova(m.diff)

## 7.2.6 Prediction
predict(m2)[1:5]
pv &lt;- predict(m2,se=TRUE)
pv$fit[1:5]
pv$se[1:5]

predict(m2,type="response")[1:5]
pv &lt;- predict(m2,type="response",se=TRUE)
pv$se[1:5]

pd &lt;- data.frame(X=c(80.1,68.3),Y=c(41.8,41.8))
predict(m2,newdata=pd)
predict(m2,newdata=pd,type="response",se=TRUE)

predict(m3,newdata=pd,type="terms",se=TRUE)

Xp &lt;- predict(m2,newdata=pd,type="lpmatrix")
fv &lt;- Xp%*%coef(m2)
fv
d &lt;- t(c(1,-1))
d%*%fv
d%*%Xp%*%m2$Vp%*%t(Xp)%*%t(d)

## 7.2.7 Variance of non-linear function

ind &lt;- brain$region==1&amp; ! is.na(brain$region)
Xp &lt;- predict(m2,newdata=brain[ind,],type="lpmatrix")
set.seed(8) ## for repeatability
br &lt;- rmvn(n=1000,coef(m2),vcov(m2)) # simulate from posterior
mean.FPQ&lt;-rep(0,1000)
for (i in 1:1000)
{ lp &lt;- Xp%*%br[i,]  # replicate linear predictor
  mean.FPQ[i] &lt;- mean(exp(lp)) # replicate region 1 mean FPQ
}
mean.FPQ &lt;- colMeans(exp(Xp%*%t(br)))

## 7.3 Retinopathy
require(gamair); require(mgcv); data(wesdr)
k &lt;- 7
b &lt;- gam(ret ~ s(dur,k=k) + s(gly,k=k) + s(bmi,k=k) + 
         ti(dur,gly,k=k) + ti(dur,bmi,k=k) + ti(gly,bmi,k=k),
         select=TRUE, data=wesdr, family=binomial(), method="ML")
b

## 7.4 Air pollution
data(chicago)
ap0 &lt;- gam(death~s(time,bs="cr",k=200)+pm10median+so2median+
           o3median+tmpd,data=chicago,family=poisson)
gam.check(ap0)

par(mfrow=c(2,1))
plot(ap0,n=1000)  # n increased to make plot smooth
plot(ap0,residuals=TRUE,n=1000)

chicago$death[3111:3125]

ap1&lt;-gam(death~s(time,bs="cr",k=200)+s(pm10median,bs="cr")+
     s(so2median,bs="cr")+s(o3median,bs="cr")+s(tmpd,bs="cr"),
     data=chicago,family=poisson)

## 7.4.1 single index

lagard &lt;- function(x,n.lag=6) {
  n &lt;- length(x); X &lt;- matrix(NA,n,n.lag)
  for (i in 1:n.lag) X[i:n,i] &lt;- x[i:n-i+1] 
  X
}
dat &lt;- list(lag=matrix(0:5,nrow(chicago),6,byrow=TRUE),
            death=chicago$death,time=chicago$time)
dat$pm10 &lt;- lagard(chicago$pm10median)
dat$tmp &lt;- lagard(chicago$tmpd)
dat$o3 &lt;- lagard(chicago$o3median)

si &lt;- function(theta,dat,opt=TRUE) {
## Return ML if opt==TRUE or fitted gam otherwise.
  alpha &lt;- c(1,theta) ## alpha defined via unconstrained theta
  kk &lt;- sqrt(sum(alpha^2)); alpha &lt;- alpha/kk  ## ||alpha||=1
  o3 &lt;- dat$o3%*%alpha; tmp &lt;- dat$tmp%*%alpha
  pm10 &lt;- dat$pm10%*%alpha ## re-weight lagged covariates
  b&lt;- bam(dat$death~s(dat$time,k=200,bs="cr")+s(pm10,bs="cr")+
          te(o3,tmp,k=8),family=poisson) ## fit model
  cat(".") ## give user something to watch
  if (opt) return(b$gcv.ubre) else {
    b$alpha &lt;- alpha  ## add alpha to model object
    b$J &lt;- outer(alpha,-theta/kk^2) ## get dalpha_i/dtheta_j
    for (j in 1:length(theta)) b$J[j+1,j] &lt;- b$J[j+1,j] + 1/kk
    return(b)
  }
} ## si

## WARNING: the next line takes around half an hour to run

f1 &lt;- optim(rep(1,5),si,method="BFGS",hessian=TRUE,dat=dat)

apsi &lt;- si(f1$par,dat,opt=FALSE)
apsi$alpha

## 7.4.2 distributed lag...

apl &lt;- bam(death~s(time,bs="cr",k=200)+te(pm10,lag,k=c(10,5))+
       te(o3,tmp,lag,k=c(8,8,5)),family=poisson,data=dat)

## 7.5 Egg survey - less than a minute
## 7.5.1 Model development
data(mack)
mack$log.net.area &lt;- log(mack$net.area)

gmtw &lt;- gam(egg.count ~ s(lon,lat,k=100) + s(I(b.depth^.5))+ 
       s(c.dist) + s(salinity) + s(temp.surf) + s(temp.20m)+
       offset(log.net.area),data=mack,family=tw,method="REML",
       select=TRUE)
gm2 &lt;- gam(egg.count ~ s(lon,lat,k=100) + s(I(b.depth^.5)) + 
         s(c.dist) + s(temp.20m) + offset(log.net.area),
         data=mack,family=tw,method="REML")
gm2

## 7.5.2 model predictions
par(mfrow=c(1,3))
data(mackp); data(coast)
mackp$log.net.area &lt;- rep(0,nrow(mackp))
lon &lt;- seq(-15,-1,1/4); lat &lt;- seq(44,58,1/4)
zz&lt;-array(NA,57*57); zz[mackp$area.index]&lt;-predict(gm2,mackp)  
image(lon,lat,matrix(zz,57,57),col=gray(0:32/32),
      cex.lab=1.5,cex.axis=1.4)
contour(lon,lat,matrix(zz,57,57),add=TRUE)
lines(coast$lon,coast$lat,col=1)

set.seed(4) ## make reproducable
br1 &lt;- rmvn(n=1000,coef(gm2),vcov(gm2))
Xp &lt;- predict(gm2,newdata=mackp,type="lpmatrix")
mean.eggs1 &lt;- colMeans(exp(Xp%*%t(br1)))
hist(mean.eggs1)

## 7.5.3 alternative

gmgr &lt;- gam(egg.count ~s(lon,lat,k=100)+s(lon,lat,by=temp.20m)
        +s(lon,lat,by=I(b.depth^.5)) +offset(log.net.area),
        data=mack,family=tw,method="REML")

## 7.6 Larks - about a minute
library(gamair); data(bird)
bird$n &lt;- bird$y/1000;bird$e &lt;- bird$x/1000
m1 &lt;- gam(crestlark~s(e,n,k=100),data=bird,family=binomial,
          method="REML")
m1

m2 &lt;- gam(crestlark ~ s(e,n,bs="ds",m=c(1,.5),k=100),data=bird,family=binomial,
          method="REML")
	  
REML &lt;- r &lt;- 1:10*10 
for (i in 1:length(r)) { 
  mt &lt;- gam(crestlark ~ s(e,n,bs="gp",m=c(3,r[i]),k=100),
        data=bird,family=binomial,method="REML")
  REML[i] &lt;- mt$gcv.ubre
  if (i==1||REML[i]==REML0) { m3 &lt;- mt; REML0 &lt;- REML[i]}
}
AIC(m1,m2,m3)

bird$tet.n &lt;- bird$N &lt;- rep(1,nrow(bird))
bird$N[is.na(as.vector(bird$crestlark))] &lt;- NA
ba &lt;- aggregate(data.matrix(bird), by=list(bird$QUADRICULA),
                FUN=sum, na.rm=TRUE)
ba$e &lt;- ba$e/ba$tet.n; ba$n &lt;- ba$n/ba$tet.n

m10 &lt;- gam(cbind(crestlark,N-crestlark) ~ s(e,n,k=100),
           data=ba, family=binomial, method="REML")
library(geoR)
coords&lt;-matrix(0,nrow(ba),2);coords[,1]&lt;-ba$e;coords[,2]&lt;-ba$n
gb&lt;-list(data=residuals(m10,type="d"),coords=coords)
plot(variog(gb,max.dist=100))
plot(fitted(m10),residuals(m10))

## 7.7.1 Sole egg GAMM
## Chapter 3 preliminaries...
data(sole)
sole$off &lt;- log(sole$a.1-sole$a.0)# model offset term
sole$a&lt;-(sole$a.1+sole$a.0)/2     # mean stage age
solr&lt;-sole                        # make copy for rescaling
solr$t&lt;-solr$t-mean(sole$t)
solr$t&lt;-solr$t/var(sole$t)^0.5
solr$la&lt;-solr$la-mean(sole$la)
solr$lo&lt;-solr$lo-mean(sole$lo)

## GAMM fit...
solr$station &lt;- factor(with(solr,paste(-la,-lo,-t,sep="")))     
som &lt;- gamm(eggs~te(lo,la,t,bs=c("tp","tp"),k=c(25,5),d=c(2,1))
            +s(t,k=5,by=a)+offset(off), family=quasipoisson,
            data=solr,random=list(station=~1))
som$gam
som1 &lt;- bam(eggs~te(lo,la,t,bs=c("tp","tp"),k=c(25,5),d=c(2,1))
            + s(t,k=5,by=a)+offset(off)+s(station,bs="re"),
	        family=quasipoisson,data=solr)
gam.vcomp(som1)
som$lme
## boundary and knots for soap...
bnd &lt;- list(list(lo=c(-6.74,-5.72,-5.7 ,-5.52,-5.37,-5.21,-5.09,-5.02,
          -4.92,-4.76,-4.64,-4.56,-4.53,-4.3,-4.16,-3.8 ,-3.8,-5.04,-6.76,
	  -6.74),
          la=c(50.01,50.02,50.13,50.21,50.24,50.32,50.41,50.54,50.59,50.64,
	  50.74,50.86,51.01,51  ,51.2,51.22,51.61,51.7,51.7,50.01)))

knt &lt;- list(lo=c(-4.643,-5.172,-5.638,-6.159,-6.665,-6.158,-5.656,-5.149,
  -4.652,-4.154,-3.901,-4.146,-4.381,-4.9,-5.149,-5.37,-5.866,-6.36,-6.635,
  -6.12,-5.626,-5.117,-4.622,-4.695,-4.875,-5.102,-5.609,-5.652,-5.141,
  -5.354,-5.843,-6.35,-6.628,-6.127,-5.63,-5.154,-5.356,-5.652,-5.853,
  -6.123),
   la=c(51.626,51.61,51.639,51.638,51.376,51.377,51.373,51.374,51.374,
   51.376,51.379,51.226,51.129,51.194,51.083,51.147,51.129,51.151,50.901,
   50.891,50.959,50.958,50.942,50.728,50.676,50.818,50.825,50.684,50.693,
   50.568,50.564,50.626,50.397,50.451,50.443,50.457,50.325,50.193,50.322,
   50.177))
   
sole$station &lt;- solr$station ## station to sole data

som2 &lt;- bam(eggs ~ te(lo,la,t,bs=c("sw","cr"),k=c(40,5),
            d=c(2,1),xt=list(list(bnd=bnd),NULL)) +
            s(t,k=5,by=a) + offset(off) + s(station,bs="re"),
            knots=knt, family=quasipoisson, data=sole)

## 7.7.2 Cairo temperature
data(cairo)
ctamm &lt;- gamm(temp~s(day.of.year,bs="cc",k=20)+s(time,bs="cr"),
         data=cairo,correlation=corAR1(form=~1|year))
summary(ctamm$gam)
intervals(ctamm$lme,which="var-cov")
ctamm$gam$sig2/ctamm$gam$sp
plot(ctamm$gam,scale=0,pages=1)

REML &lt;- rho &lt;- 0.6+0:20/100
for (i in 1:length(rho)) {
  ctbam &lt;- bam(temp~s(day.of.year,bs="cc",k=20)+s(time,bs="cr"),
               data=cairo,rho=rho[i])
  REML[i] &lt;- ctbam$gcv.ubre
}
rho[REML==min(REML)]

## 7.7.3 Fully Bayesian
## Not currently included (requires editing of JAGS file)

## 7.7.4 Random wiggly curves
data(sitka)
sitka$id.num &lt;- as.factor(sitka$id.num)
b &lt;- gamm(log.size~s(days) + ozone + ozone:days +
          s(days,id.num,bs="fs",k=5),data=sitka)
plot(b$gam,pages=1)


## 7.8 survival
require(survival)
data(pbc) ## loads pbcseq also
pbc$status1 &lt;- as.numeric(pbc$status==2)
pbc$stage &lt;- factor(pbc$stage)
b0 &lt;- gam(time ~ trt+sex+stage+s(sqrt(protime))+s(platelet)+ 
          s(age)+s(bili)+s(albumin)+s(sqrt(ast))+s(alk.phos),
          weights=status1,family=cox.ph,data=pbc)

b &lt;- gam(time ~ trt+sex+s(sqrt(protime))+s(platelet)+ 
          s(age)+s(bili)+s(albumin),
          weights=status1,family=cox.ph,data=pbc)

anova(b)
par(mfrow=c(2,3))
plot(b); plot(b$linear.predictors,residuals(b))

par(mfrow=c(1,1))
## create prediction data frame...
np &lt;- 300
newd &lt;- data.frame(matrix(0,np,0))
for (n in names(pbc)) newd[[n]] &lt;- rep(pbc[[n]][25],np)
newd$time &lt;- seq(0,4500,length=np)
## predict and plot the survival function... 
fv &lt;- predict(b,newdata=newd,type="response",se=TRUE)
plot(newd$time,fv$fit,type="l",ylim=c(0.,1),xlab="time",
     ylab="survival",lwd=2)
## add crude one s.e. intervals...
lines(newd$time,fv$fit+fv$se.fit,col="grey")
lines(newd$time,fv$fit-fv$se.fit,col="grey")
## and intervals based on cumulative hazard s.e...
se &lt;- fv$se.fit/fv$fit
lines(newd$time,exp(log(fv$fit)+se))
lines(newd$time,exp(log(fv$fit)-se))

## 7.8.1 time dependent
## copy functions from ?cox.pht in mgcv...

app &lt;- function(x,t,to) {
## wrapper to approx for calling from apply...
   y &lt;- if (sum(!is.na(x))&lt;1) rep(NA,length(to)) else
        approx(t,x,to,method="constant",rule=2)$y
   if (is.factor(x)) factor(levels(x)[y],levels=levels(x)) else y
} ## app

tdpois &lt;- function(dat,event="z",et="futime",t="day",
                             status="status1",id="id") {
## dat is data frame. id is patient id; et is event time; t is
## observation time; status is 1 for death 0 otherwise;
## event is name for Poisson response.
   if (event %in% names(dat)) warning("event name in use")
   require(utils) ## for progress bar
   te &lt;- sort(unique(dat[[et]][dat[[status]]==1])) ## event times
   sid &lt;- unique(dat[[id]])
   prg &lt;- txtProgressBar(min = 0, max = length(sid), initial = 0,
              char = "=",width = NA, title="Progress", style = 3)
   ## create dataframe for poisson model data
   dat[[event]] &lt;- 0; start &lt;- 1
   dap &lt;- dat[rep(1:length(sid),length(te)),]
   for (i in 1:length(sid)) { ## work through patients
     di &lt;- dat[dat[[id]]==sid[i],] ## ith patient's data
     tr &lt;- te[te &lt;= di[[et]][1]] ## times required for this patient
     ## Now do the interpolation of covariates to event times...
     um &lt;- data.frame(lapply(X=di,FUN=app,t=di[[t]],to=tr))
     ## Mark the actual event...
     if (um[[et]][1]==max(tr)&amp;&amp;um[[status]]==1) um[[event]][nrow(um)] &lt;- 1 
     um[[et]] &lt;- tr ## reset time to relevant event times
     dap[start:(start-1+nrow(um)),] &lt;- um ## copy to dap
     start &lt;- start + nrow(um)
     setTxtProgressBar(prg, i)
   }
   close(prg)
   dap[1:(start-1),]
} ## tdpois

## model fitting...

data(pbc)
pbcseq$status1 &lt;- as.numeric(pbcseq$status==2) ## deaths
pb &lt;- tdpois(pbcseq) ## conversion
pb$tf &lt;- factor(pb$futime) ## add factor for event time

b &lt;- bam(z ~ tf - 1  +  trt + s(sqrt(protime)) + s(platelet) + 
         s(age) + s(bili) + s(albumin) + s(sqrt(ast)),
         family=poisson,data=pb,discrete=TRUE,nthreads=2)

chaz &lt;- tapply(fitted(b),pb$id,sum) ## cum. hazard by subject
d &lt;- tapply(pb$z,pb$id,sum) ## censoring indicator
mrsd &lt;- d - chaz ## Martingale residuals
drsd &lt;- sign(mrsd)*sqrt(-2*(mrsd + d*log(chaz))) ## deviance

te &lt;- sort(unique(pb$futime)) ## event times
di &lt;- pbcseq[pbcseq$id==25,] ## data for subject 25
## interpolate to te using app from ?cox.pht...
pd &lt;- data.frame(lapply(X=di,FUN=app,t=di$day,to=te)) 
pd$tf &lt;- factor(te)
X &lt;- predict(b,newdata=pd,type="lpmatrix")
eta &lt;- drop(X%*%coef(b)); H &lt;- cumsum(exp(eta))
J &lt;- apply(exp(eta)*X,2,cumsum)
se &lt;- diag(J%*%vcov(b)%*%t(J))^.5
par(mfrow=c(1,2))
plot(stepfun(te,c(1,exp(-H))),do.points=FALSE,ylim=c(0.7,1),
     ylab="S(t)",xlab="t (days)",main="",lwd=2)
lines(stepfun(te,c(1,exp(-H+se))),do.points=FALSE)
lines(stepfun(te,c(1,exp(-H-se))),do.points=FALSE)
rug(pbcseq$day[pbcseq$id==25]) ## measurement times

er &lt;- pbcseq[pbcseq$id==25,]
plot(er$day,er$ast);lines(te,pd$ast)

## 7.9 Location scale

library(MASS);library(mgcv)
b &lt;- gam(list(accel~s(times,bs="ad"),~s(times,bs="ad")),
         family=gaulss,data=mcycle)

## 7.9.1 Extreme rainfall
library(mgcv);library(gamair);data(swer)
b0 &lt;- gam(list(exra ~ s(nao)+ s(elevation)+ climate.region+
                      te(N,E,year,d=c(2,1),k=c(20,5)),
      ~ s(year)+ s(nao)+ s(elevation)+ climate.region+ s(N,E),
	      ~ s(elevation)+ climate.region),family=gevlss,data=swer)

b &lt;- gam(list(exra~ s(nao)+s(elevation)+climate.region+s(N,E),
         ~ s(year)+ s(elevation)+ climate.region+ s(N,E),
	        ~ climate.region),family=gevlss,data=swer)
plot(b,scale=0,scheme=c(1,1,3,1,1,3),contour.col="white",pages=1)

mu &lt;- fitted(b)[,1];rho &lt;- fitted(b)[,2]; xi &lt;- fitted(b)[,3]
fv &lt;- mu + exp(rho)*(gamma(1-xi)-1)/xi

Fi.gev &lt;- function(z,mu,sigma,xi) { ## GEV inverse cdf.
  xi[abs(xi)&lt;1e-8] &lt;- 1e-8 ## approximate xi=0, by small xi
  x &lt;- mu + ((-log(z))^-xi-1)*sigma/xi
}
mb &lt;- coef(b);Vb &lt;- vcov(b) ## posterior mean and cov
b1 &lt;- b ## copy fitted model object to modify
n.rep &lt;- 1000; br &lt;- rmvn(n.rep,mb,Vb) ## posterior sim
n &lt;- length(fitted(b))
sim.dat &lt;- cbind(data.frame(rep(0,n*n.rep)),swer$code)
for (i in 1:n.rep) {
  b1$coefficients &lt;- br[i,] ## copy sim coefs to gam object
  X &lt;- predict(b1,type="response");ii &lt;- 1:n + (i-1)*n
  sim.dat[ii,1] &lt;- Fi.gev(runif(n),X[,1],exp(X[,2]),X[,3])
}

stm &lt;- tapply(sim.dat[,1],sim.dat[,2],mean)
st98 &lt;- tapply(sim.dat[,1],sim.dat[,2],quantile,probs=0.98)

## 7.10 Multivariate
library(mgcv); library(gamair); data(mpg)
b &lt;- gam(list(city.mpg ~ fuel +style +drive +s(weight) +s(hp)
                         + s(make,bs="re"),
                hw.mpg ~ fuel +style +drive +s(weight) +s(hp)
                         + s(make,bs="re")),
               family = mvn(d=2) , data = mpg)

b1 &lt;- gam(list(city.mpg ~ fuel +style +drive +s(hp) +s(weight)
                          + s(make,bs="re"),
                 hw.mpg ~ fuel +style +drive +s(make,bs="re"),
                    1+2 ~ s(weight) +s(hp) -1),
               family = mvn(d=2) , data = mpg)

## 7.11 FDA
## 7.11.1 scalar-on-function
data(gas)
b &lt;- gam(octane~s(nm,by=NIR,k=50),data=gas)
par(mfrow=c(1,2))
plot(b,scheme=1,col=1)
plot(fitted(b),gas$octane)

## Prostate...
data(prostate)
b &lt;- gam(type ~ s(MZ,by=intensity,k=100),family=ocat(R=3),
         data=prostate,method="ML")
par(mfrow=c(1,3))
plot(b,rug=FALSE,scheme=1,xlab="Daltons",ylab="f(D)",
     cex.lab=1.6,cex.axis=1.4)
pb &lt;- predict(b,type="response") ## matrix of class probs
plot(factor(prostate$type),pb[,3])
qq.gam(b,rep=100,lev=.95)

prostate$type1 &lt;- prostate$type - 1 ## recode for multinom
b1 &lt;- gam(list(type1 ~ s(MZ,by=intensity,k=100),
               ~ s(MZ,by=intensity,k=100)),
          family=multinom(K=2),data=prostate)
plot(b1,pages=1,scheme=1,rug=FALSE)

## 7.11.2 Canadian weather
require(gamair);require(lattice);data(canWeather)
xyplot(T~time|region,data=CanWeather,type="l",groups=place)

aic &lt;- reml &lt;- rho &lt;- seq(0.9,0.99,by=.01)
for (i in 1:length(rho)) {
  b &lt;- bam(T ~ region + s(time,k=20,bs="cr",by=region) +
           s(time,k=40,bs="cr",by=latitude),
           data=CanWeather,AR.start=time==1,rho=rho[i])
  aic[i] &lt;- AIC(b); reml[i] &lt;- b$gcv.ubre
}

## End(Not run)

</code></pre>


</div>