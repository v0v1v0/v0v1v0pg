<div class="container">

<table style="width: 100%;"><tr>
<td>SingletonUniqueContributor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Unique contributor singleton function</h2>

<h3>Description</h3>

<p>Function for <code>GaussSuppressionFromData</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">SingletonUniqueContributor(
  data,
  freqVar = NULL,
  nUniqueVar = NULL,
  charVar = NULL,
  removeCodes = character(0),
  integerSingleton = length(charVar) &gt; 0,
  x,
  primary = integer(0),
  whenPrimaryMatters = warning,
  whenNoVar = TRUE,
  specialMultiple = TRUE,
  rowGroupsPackage = "base",
  ...
)

SingletonUniqueContributor0(data, numVar, dominanceVar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input data, possibly pre-aggregated within <code>GaussSuppressionFromData</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqVar</code></td>
<td>
<p>A single variable holding counts (input to <code>GaussSuppressionFromData</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nUniqueVar</code></td>
<td>
<p>A single variable holding the number of unique contributors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>charVar</code></td>
<td>
<p>Variable with contributor codes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeCodes</code></td>
<td>
<p>Vector, list or data frame of codes considered non-singletons.
Single element lists and single column data frames behave just like vectors.
In other cases, <code>charVar</code>-names must be used.
With empty <code>charVar</code> a vector of row indices is assumed and conversion to integer is performed.
See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integerSingleton</code></td>
<td>
<p>Integer output when <code>TRUE</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>ModelMatrix generated by parent function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>primary</code></td>
<td>
<p>Vector (integer or logical) specifying primary suppressed cells.
It will be ensured that any non-suppressed inner cell is not considered a singleton.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whenPrimaryMatters</code></td>
<td>
<p>Function to be called when <code>primary</code> caused non-singleton. Supply <code>NULL</code> to do nothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whenNoVar</code></td>
<td>
<p>When <code>TRUE</code>, and without <code>nUniqueVar</code> and <code>freqVar</code> in input,
all cells will be marked as singletons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>specialMultiple</code></td>
<td>
<p>When <code>TRUE</code>, and when <code style="white-space: pre;">⁠integerSingleton &amp;⁠</code> <code>length(charVar) &gt; 1</code> <code style="white-space: pre;">⁠&amp; length(nUniqueVar)⁠</code>,
a special method is used.
By re-coding to single <code>charVar</code> and by re-calculating <code>nUnique</code>.
To be unique (<code>nUnique=1</code>), uniqueness is only required for a single <code>charvar</code>.
Otherwise, the <code>charvar</code> combination must be unique.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowGroupsPackage</code></td>
<td>
<p>Parameter <code>pkg</code> to <code>RowGroups</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Unused parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numVar</code></td>
<td>
<p>vector containing numeric values in the data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dominanceVar</code></td>
<td>
<p>When specified, <code>dominanceVar</code> is used in place of <code>numVar</code>.
Specifying <code>dominanceVar</code> is beneficial for avoiding warnings when there
are multiple <code>numVar</code> variables. Typically, <code>dominanceVar</code> will be one
of the variables already included in <code>numVar</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function marks input cells as singletons according to ones in
<code>data[[nUniqueVar]]</code>, if available, and otherwise according to <code>data[[freqVar]]</code>.
The output vector can be logical or integer. When, integer, singletons are given as positive values.
Their unique values represent the unique values/combinations of <code>data[[charVar]]</code>.
</p>


<h3>Value</h3>

<p>logical or integer vector
</p>


<h3>Note</h3>

<p><code>SingletonUniqueContributor0</code> is a special version that produces singleton as
a two-element list.
See <code>GaussSuppression</code> and <code>SuppressDominantCells</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">S &lt;- function(data, ...) {
  cbind(data, singleton = SingletonUniqueContributor(data, ...))
}
d2 &lt;- SSBtoolsData("d2")
d &lt;- d2[d2$freq &lt; 5, ]
d$nUnique &lt;- round((5 - d$freq)/3)
d$freq &lt;- round(d$freq/2)
d[7:8, 2:4] &lt;- NA
rownames(d) &lt;- NULL

S(d, freqVar = "freq", integerSingleton = FALSE)
S(d, freqVar = "freq", nUniqueVar = "nUnique", integerSingleton = TRUE, charVar = "main_income")
S(d, nUniqueVar = "nUnique", integerSingleton = TRUE, charVar = c("main_income", "k_group"))
S(d, freqVar = "freq", nUniqueVar = "nUnique", integerSingleton = FALSE, 
  charVar = "main_income", removeCodes = "other")
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = c("other", "400"))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = data.frame(anyname = c("other", "400")))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = list(main_income = c("other", "pensions"), k_group = "300"))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = data.frame(main_income = "other", k_group = "400"))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, removeCodes = 1:5)

x &lt;- SSBtools::ModelMatrix(d, hierarchies = list(region = "Total"))
which(colSums(x) == 1)
which(rowSums(x[, colSums(x) == 1]) &gt; 0)
# columns 2, 3, 4, 5, 7 correspond to inner cells: rows 3, 4, 5, 6, 8 
# with 2:4 not primary rows 3:5 are forced non-singleton
S(d, freqVar = "freq", nUniqueVar = "nUnique", integerSingleton = FALSE, x = x, primary = 5:8)

</code></pre>


</div>