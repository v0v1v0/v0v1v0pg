<div class="container">

<table style="width: 100%;"><tr>
<td>dplyr-ggvis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dplyr verbs for ggvis.</h2>

<h3>Description</h3>

<p>Applying a dplyr verb to a ggvis object creates a reactive transformation:
whenever the underlying data changes the transformation will be recomputed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ggvis'
groups(x)

## S3 method for class 'ggvis'
group_by(.data, ..., .add = FALSE)

## S3 method for class 'ggvis'
ungroup(x, ...)

## S3 method for class 'ggvis'
summarise(.data, ...)

## S3 method for class 'ggvis'
mutate(.data, ...)

## S3 method for class 'ggvis'
arrange(.data, ...)

## S3 method for class 'ggvis'
select(.data, ...)

filter.ggvis(.data, ...)

## S3 method for class 'ggvis'
distinct(.data, ...)

## S3 method for class 'ggvis'
slice(.data, ...)

## S3 method for class 'ggvis'
rename(.data, ...)

## S3 method for class 'ggvis'
transmute(.data, ...)

## S3 method for class 'reactive'
groups(x)

## S3 method for class 'reactive'
ungroup(x, ...)

## S3 method for class 'reactive'
group_by(.data, ..., add = FALSE)

## S3 method for class 'reactive'
summarise(.data, ...)

## S3 method for class 'reactive'
mutate(.data, ...)

## S3 method for class 'reactive'
arrange(.data, ...)

## S3 method for class 'reactive'
select(.data, ...)

filter.reactive(.data, ...)

## S3 method for class 'reactive'
distinct(.data, ...)

## S3 method for class 'reactive'
slice(.data, ...)

## S3 method for class 'reactive'
rename(.data, ...)

## S3 method for class 'reactive'
transmute(.data, ...)
</code></pre>


<h3>Non-standard evaluation</h3>

<p>Both dplyr and shiny do non-standard evaluation, so to help each package
figure out when it should evaluate its code, reactive components in
these functions must be wrapped in <code>eval()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)
base &lt;- mtcars %&gt;% ggvis(~mpg, ~cyl) %&gt;% layer_points()
base %&gt;% group_by(cyl) %&gt;% summarise(mpg = mean(mpg)) %&gt;%
  layer_points(fill := "red", size := 100)

base %&gt;% filter(mpg &gt; 25) %&gt;% layer_points(fill := "red")

base %&gt;% mutate(cyl = jitter(cyl)) %&gt;% layer_points(fill := "red")

## Not run: 
# Dynamically restrict range using filter
mtcars %&gt;% ggvis(~disp, ~mpg) %&gt;%
   filter(cyl &gt; eval(input_slider(0, 10))) %&gt;%
   layer_points()

# Dynamically compute box-cox transformation with mutate
bc &lt;- function(x, lambda) {
  if (abs(lambda) &lt; 1e-6) log(x) else (x ^ lambda - 1) / lambda
}
bc_slider &lt;- input_slider(-2, 2, 1, step = 0.1)
mtcars %&gt;%
 ggvis(~disp, ~mpg) %&gt;%
 mutate(disp = bc(disp, eval(bc_slider))) %&gt;%
 layer_points()

## End(Not run)
</code></pre>


</div>