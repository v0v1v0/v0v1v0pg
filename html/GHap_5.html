<div class="container">

<table style="width: 100%;"><tr>
<td>ghap.ancsvm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
SVM-based predictions of haplotype ancestry
</h2>

<h3>Description</h3>

<p>This function uses Support Vector Machines (SVM) to predict ancestry of haplotype alleles in test samples.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> ghap.ancsvm(object, blocks, test = NULL, train = NULL,
             cost = 1, gamma = NULL, tune = FALSE,
             only.active.samples = TRUE, only.active.markers = TRUE,
             ncores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>A GHap.phase object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>

<p>A data frame containing block boundaries, such as supplied by the <code>ghap.blockgen</code> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>

<p>Character vector of individuals to test.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train</code></td>
<td>

<p>Character vector of individuals to use as reference samples.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>

<p>A numeric value specifying the C constant of the regularization term in the Lagrange formulation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>A numeric value specifying the gamma parameter of the RBF kernel (default = 1/blocksize).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune</code></td>
<td>

<p>A logical value specfying if a grid search is to be performed for parameters (default = FALSE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.active.samples</code></td>
<td>

<p>A logical value specifying whether only active samples should be included in predictions (default = TRUE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.active.markers</code></td>
<td>

<p>A logical value specifying whether only active markers should be used for predictions (default = TRUE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>

<p>A numeric value specifying the number of cores to be used in parallel computing (default = 1).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A logical value specfying whether log messages should be printed (default = TRUE).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function predicts haplotype allele ancestry using Support Vector Machines (SVM) together with a Gaussian Radial Basis Function (RBF) kernel. The user is required to specify the C constant of the regularization term in the Lagrange formulation (default cost = 1) and the gamma parameter (default gamma = 1/blocksize) of the RBF kernel. <br></p>


<h3>Value</h3>

<p>If ran with tune = FALSE, the function returns a dataframe with the following columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>BLOCK</code></td>
<td>

<p>Block alias.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CHR</code></td>
<td>

<p>Chromosome name.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BP1</code></td>
<td>

<p>Block start position.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BP2</code></td>
<td>

<p>Block end position.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>POP</code></td>
<td>

<p>Original population label.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ID</code></td>
<td>

<p>Individual name.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HAP1</code></td>
<td>

<p>Predicted ancestry of haplotype 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HAP2</code></td>
<td>

<p>Predicted ancestry of haplotype 2.
</p>
</td>
</tr>
</table>
<p>If tune = TRUE, the function returns a dataframe with the following columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>

<p>The candidate value of the C constant.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>The canidate value of the gamma parameter.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accuracy</code></td>
<td>

<p>The percentage of correctly assigned ancestries.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yuri Tani Utsunomiya &lt;ytutsunomiya@gmail.com&gt;
</p>


<h3>References</h3>

<p>R. J. Haasl  et al. Genetic ancestry inference using support vector machines, and the active emergence of a unique American population. Eur J Hum Genet. 2013. 21(5):554-62.
</p>
<p>D. Meyer et al. e1071: Misc Functions of the Department of Statistics, Probability Theory Group (e1071). TU Wien. 2019 R Package Version 1.7-0.1. http://cran.r-project.org/web/packages/e1071/index.html.
</p>


<h3>See Also</h3>

<p><code>svm</code>, <code>ghap.ancsmooth</code>, <code>ghap.ancplot</code>, <code>ghap.ancmark</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# #### DO NOT RUN IF NOT NECESSARY ###
# 
# # Copy phase data in the current working directory
# exfiles &lt;- ghap.makefile(dataset = "example",
#                          format = "phase",
#                          verbose = TRUE)
# file.copy(from = exfiles, to = "./")
# 
# # Load phase data
# 
# phase &lt;- ghap.loadphase("example")
# 
# ### RUN ###
# 
# # Calculate marker density
# mrkdist &lt;- diff(phase$bp)
# mrkdist &lt;- mrkdist[which(mrkdist &gt; 0)]
# density &lt;- mean(mrkdist)
# 
# # Generate blocks for admixture events up to g = 10 generations in the past
# # Assuming mean block size in Morgans of 1/(2*g)
# # Approximating 1 Morgan ~ 100 Mbp
# g &lt;- 10
# window &lt;- (100e+6)/(2*g)
# window &lt;- ceiling(window/density)
# step &lt;- ceiling(window/4)
# blocks &lt;- ghap.blockgen(phase, windowsize = window,
#                         slide = step, unit = "marker")
# 
# # Tune supervised analysis
# train &lt;- unique(phase$id[which(phase$pop != "Cross")])
# ranblocks &lt;- sample(x = 1:nrow(blocks), size = 5, replace = FALSE)
# tunesvm &lt;- ghap.ancsvm(object = phase, blocks = blocks[ranblocks,],
#                        train = train, gamma = 1/window*c(0.1,1,10),
#                        tune = TRUE)
# 
# # Supervised analysis with default parameters
# hapadmix &lt;- ghap.ancsvm(object = phase, blocks = blocks,
#                         train = train)
# anctracks &lt;- ghap.ancsmooth(object = phase, admix = hapadmix)
# ghap.ancplot(ancsmooth = anctracks)

</code></pre>


</div>