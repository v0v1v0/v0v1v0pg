<div class="container">

<table style="width: 100%;"><tr>
<td>central_region</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Central region / Global envelope</h2>

<h3>Description</h3>

<p>Provides central regions or global envelopes or confidence bands
</p>


<h3>Usage</h3>

<pre><code class="language-R">central_region(
  curve_sets,
  type = "erl",
  coverage = 0.5,
  alternative = c("two.sided", "less", "greater"),
  probs = c(0.25, 0.75),
  quantile.type = 7,
  central = "median",
  nstep = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>curve_sets</code></td>
<td>
<p>A <code>curve_set</code> object or a list of <code>curve_set</code> objects.
Also <code>envelope</code> objects of <span class="pkg">spatstat</span> and <code>fdata</code> of <span class="pkg">fda.usc</span>
are accepted instead of curve_set objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of the global envelope with current options for 'rank', 'erl', 'cont', 'area',
'qdir', 'st' and 'unscaled'. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coverage</code></td>
<td>
<p>A number between 0 and 1. The 100*coverage% central region will be calculated.
A vector of values can also be provided, leading to the corresponding number of central regions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: "two.sided" (default), "less" or "greater".
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantile.type</code></td>
<td>
<p>As type argument of <code>quantile</code>, how to
calculate quantiles for 'q' or 'qdir'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>central</code></td>
<td>
<p>Either "mean" or "median". If the curve sets do not contain the component
<code>theo</code> for the theoretical central function, then the central function (used for plotting only)
is calculated either as the mean or median of functions provided in the curve sets.
For 'qdir', 'st' and 'unscaled' only the mean is allowed as an option, due to their definition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstep</code></td>
<td>
<p>1 or 2 for how to contruct a combined global envelope if list of curve sets
is provided. 2 (default) for a two-step combining procedure, 1 for one-step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a <code>curve_set</code> object,
or an <code>envelope</code> object of <span class="pkg">spatstat</span> or <code>fdata</code> object of <span class="pkg">fda.usc</span>,
the function <code>central_region</code> constructs a central region, i.e. a global envelope,
from the given set of functions (or vectors).
</p>
<p>Generally an envelope is a band bounded by the vectors (or functions)
<code class="reqn">T_{low}</code> and <code class="reqn">T_{hi}</code>.
A <code class="reqn">100(1-\alpha)</code>% or 100*coverage% global envelope is a set
<code class="reqn">(T_{low}, T_{hi})</code> of envelope vectors
such that the probability that <code class="reqn">T_i</code> falls outside this envelope
in any of the d points of the vector <code class="reqn">T_i</code> is less or equal to <code class="reqn">\alpha</code>.
The global envelopes can be constructed based on different measures
that order the functions from the most extreme one to the least extreme one.
We use such orderings of the functions for which we are able to construct global envelopes
with intrinsic graphical interpretation.
</p>
<p>The type of the global envelope can be chosen with the argument <code>type</code> and
the options are given in the following.
Further information about the measures, on which the global envelopes are based,
can be found in Myllymäki and Mrkvička (2020, Section 2.).
</p>

<ul>
<li> <p><code>'rank'</code>: The global rank envelope
proposed by Myllymäki et al. (2017) based on the extreme rank defined as the minimum of pointwise
ranks.
</p>
</li>
<li> <p><code>'erl'</code>: The global rank envelope based on the extreme rank
length (Myllymäki et al.,2017, Mrkvička et al., 2018).
This envelope is constructed as the convex hull of the functions which have extreme rank
length measure that is larger or equal to the critical <code class="reqn">\alpha</code> level of the
extreme rank length measure.
</p>
</li>
<li> <p><code>'cont'</code>: The global rank envelope based on the continuous rank
(Hahn, 2015; Mrkvička et al., 2019) based on minimum of continuous pointwise ranks.
It is contructed as the convex hull in a similar way as the <code>'erl'</code> envelope.
</p>
</li>
<li> <p><code>'area'</code>: The global rank envelope based on the area rank (Mrkvička et al., 2019)
which is based on area between continuous pointwise ranks and minimum pointwise ranks
for those argument (r) values for which pointwise ranks achieve the minimum
(it is a combination of erl and cont).
It is contructed as the convex hull in a similar way as the <code>'erl'</code> and <code>'area'</code> envelopes.
</p>
</li>
<li> <p><code>'qdir'</code>: The directional quantile envelope based on
the directional quantile maximum absolute deviation (MAD) test (Myllymäki et al., 2017, 2015),
which takes into account the unequal variances of the test function T(r) for
different distances r and is also protected against asymmetry of distribution of T(r).
</p>
</li>
<li> <p><code>'st'</code>: The studentised envelope based on the studentised MAD
measure (Myllymäki et al., 2017, 2015),
which takes into account the unequal variances of the test function T(r) for different distances r.
</p>
</li>
<li> <p><code>'unscaled'</code>: The unscaled envelope (Ripley, 1981),
which leads to envelopes with constant width. It corresponds to the classical
maximum deviation test without scaling. This test suffers from unequal variance
of T(r) over the distances r and from the asymmetry of distribution of T(r).
We recommend to use the other alternatives instead. This unscaled global envelope is
provided for reference.
</p>
</li>
</ul>
<p>The values of the chosen measure M are determined for each curve in the <code>curve_set</code>, and
based on the chosen measure, the central region, i.e. the global envelope, is constructed
for the given curves.
</p>
<p>If a list of (suitable) objects are provided in the argument <code>curve_sets</code>,
then by default (<code>nstep = 2</code>) the two-step combining procedure is used to
construct the combined global envelope as described in Myllymäki and Mrkvička (2020, Section 2.2.).
If <code>nstep = 1</code> and the lengths of the multivariate vectors in each component
of the list are equal, then the one-step combining procedure is used where the
functions are concatenated together into a one long vector (see again Myllymäki and Mrkvička, 2020, Section 2.2.).
</p>


<h3>Value</h3>

<p>Either an object of class <code>global_envelope</code> and or an <code>combined_global_envelope</code> object.
The former class is obtained when a set of curves is provided, while the latter in the case
that <code>curve_sets</code> is a list of objects. The print and plot function are defined for the
returned objects (see examples).
</p>
<p>The <code>global_envelope</code> object is essentially a data frame containing columns
</p>

<ul>
<li>
<p> r = the vector of values of the argument r at which the test was made
</p>
</li>
<li>
<p> lo = the lower envelope based on the simulated functions;
in case of a vector of coverage values, several 'lo' exist with names paste0("lo.", 100*coverage)
</p>
</li>
<li>
<p> hi = the upper envelope based on the simulated functions;
in case of a vector of coverage values, several 'lo' exist with names paste0("hi.", 100*coverage)
</p>
</li>
<li>
<p> central = If the <code>curve_set</code> (or <code>envelope</code> object) contains a theoretical curve,
then this function is used as the central curve and returned in this component.
Otherwise, the central curve is the mean or median (according to the argument <code>central</code>)
of the test functions T_i(r), i=2, ..., s+1. Used for visualization only.
</p>
</li>
</ul>
<p>and potentially additionally
</p>

<ul><li>
<p> obs = the data function, if there is only one data function in the given <code>curve_sets</code>.
Otherwise not existing.
</p>
</li></ul>
<p>(Most often <code>central_region</code> is directly applied to functional data where all curves are observed.)
Additionally, the returned object has some attributes, where
</p>

<ul>
<li>
<p> M = A vector of the values of the chosen measure for all the function.
If there is only one observed function, then M[1] gives the value of the measure for this.
</p>
</li>
<li>
<p> M_alpha = The critical value of M corresponding to the 100(1-alpha)% global envelope
(see Myllymäki and Mrkvička, 2020, Definition 1.1. IGI).
</p>
</li>
</ul>
<p>Further the object has some attributes for printing and plotting purposes, where
<code>alternative</code>, <code>type</code>, <code>ties</code>, <code>alpha</code> correspond to those in the function call
and <code>method</code> gives a name for the method.
Attributes of an object <code>res</code> can be obtained using the function
<code>attr</code>, e.g. <code>attr(res, "M")</code> for the values of the ordering measure.
</p>
<p>If the given set of curves had the class <code>envelope</code> of <span class="pkg">spatstat</span>, then the returned
<code>global_envelope</code> object has also the class <code>fv</code> of spatstat, whereby one can utilize
also the plotting functions of <span class="pkg">spatstat</span>, see example in <code>plot.global_envelope</code>.
However, the <code>envelope</code> objects are most often used with <code>global_envelope_test</code>
and not with <code>central_region</code>.
For an <code>fv</code> object, also some further attributes exists as required by <code>fv</code> of <span class="pkg">spatstat</span>.
</p>
<p>The <code>combined_global_envelope</code> is a list of <code>global_envelope</code> objects, where
the components correspond to the components of <code>curve_sets</code>.
The <code>combined_global_envelope</code> object constructed with <code>nstep = 2</code> contains,
in addition to some conventional ones (<code>method</code>, <code>alternative</code>, <code>type</code>, <code>alpha</code>,
<code>M</code>, <code>M_alpha</code>, see above), the second level envelope information as the attributes
</p>

<ul>
<li>
<p> level2_ge = The second level envelope on which the envelope construction is based
</p>
</li>
<li>
<p> level2_curve_set = The second level <code>curve_set</code> from which <code>level2_ge</code> is constructed
</p>
</li>
</ul>
<p>In the case that the given curve sets are two-dimensional, i.e., their arguments values are two-dimensional,
then the returned objects have in addition to the class <code>global_envelope</code> or <code>combined_global_envelope</code>,
the class <code>global_envelope2d</code> or <code>combined_global_envelope2d</code>, respectively. This class is assigned
for plotting purposes: For the 2d envelopes, also the default plots are 2d.
Otherwise the 1d and 2d objects are similar.
</p>


<h3>References</h3>

<p>Mrkvička, T., Myllymäki, M., Jilek, M. and Hahn, U. (2020) A one-way ANOVA test for functional data with graphical interpretation. Kybernetika 56(3), 432-458. doi: 10.14736/kyb-2020-3-0432
</p>
<p>Mrkvička, T., Myllymäki, M., Kuronen, M. and Narisetty, N. N. (2022) New methods for multiple testing in permutation inference for the general linear model. Statistics in Medicine 41(2), 276-297. doi: 10.1002/sim.9236
</p>
<p>Myllymäki, M., Grabarnik, P., Seijo, H. and Stoyan. D. (2015). Deviation test construction and power comparison for marked spatial point patterns. Spatial Statistics 11, 19-34. doi: 10.1016/j.spasta.2014.11.004
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology) 79, 381-404. doi: 10.1111/rssb.12172
</p>
<p>Myllymäki, M. and Mrkvička, T. (2020). GET: Global envelopes in R. arXiv:1911.06583 [stat.ME]. https://doi.org/10.48550/arXiv.1911.06583
</p>
<p>Ripley, B.D. (1981). Spatial statistics. Wiley, New Jersey.
</p>


<h3>See Also</h3>

<p><code>forder</code>, <code>global_envelope_test</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## A central region of a set of functions
#----------------------------------------
if(requireNamespace("fda", quietly=TRUE)) {
  cset &lt;- curve_set(r=as.numeric(row.names(fda::growth$hgtf)),
                    obs=fda::growth$hgtf)
  plot(cset) + ggplot2::ylab("height")
  cr &lt;- central_region(cset, coverage=0.50, type="erl")
  plot(cr)
}

## Confidence bands for linear or polynomial regression
#------------------------------------------------------
# Simulate regression data according to the cubic model
# f(x) = 0.8x - 1.8x^2 + 1.05x^3 for x in [0,1]
par &lt;- c(0,0.8,-1.8,1.05) # Parameters of the true polynomial model
res &lt;- 100 # Resolution
x &lt;- seq(0, 1, by=1/res); x2=x^2; x3=x^3;
f &lt;- par[1] + par[2]*x + par[3]*x^2 + par[4]*x^3 # The true function
d &lt;- f + rnorm(length(x), 0, 0.04) # Data
# Plot the true function and data
plot(f, type="l", ylim=range(d))
points(d)

# Estimate polynomial regression model
reg &lt;- lm(d ~ x + x2 + x3)
ftheta &lt;- reg$fitted.values
resid0 &lt;- reg$residuals
s0 &lt;- sd(resid0)

# Bootstrap regression
B &lt;- 2000 # Number of bootstrap samples

ftheta1 &lt;- array(0, c(B,length(x)))
s1 &lt;- array(0,B)
for(i in 1:B) {
  u &lt;- sample(resid0, size=length(resid0), replace=TRUE)
  reg1 &lt;- lm((ftheta+u) ~ x + x2 + x3)
  ftheta1[i,] &lt;- reg1$fitted.values
  s1[i] &lt;- sd(reg1$residuals)
}

# Centering and scaling
meanftheta &lt;- apply(ftheta1, 2, mean)
m &lt;- array(0, c(B,length(x)))
for(i in 1:B) { m[i,] &lt;- (ftheta1[i,]-meanftheta)/s1[i] }

# Central region computation
boot.cset &lt;- curve_set(r=1:length(x), obs=ftheta+s0*t(m))
cr &lt;- central_region(boot.cset, coverage=c(0.50, 0.80, 0.95), type="erl")

# Plotting the result
plot(cr) + ggplot2::labs(x=expression(italic(x)), y=expression(italic(f(x)))) +
  ggplot2::geom_point(data=data.frame(id=1:length(d), points=d),
                      ggplot2::aes(x=id, y=points)) + # data points
  ggplot2::geom_line(data=data.frame(id=1:length(d), points=f),
                     ggplot2::aes(x=id, y=points)) # true function
</code></pre>


</div>