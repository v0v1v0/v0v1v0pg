<div class="container">

<table style="width: 100%;"><tr>
<td>gamBiCopFit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum penalized likelihood estimation of a Generalized Additive model
for the copula parameter or Kendall's tau.</h2>

<h3>Description</h3>

<p>This function estimates the parameter(s) of a Generalized Additive model
(gam) for the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the <code>mgcv</code> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gamBiCopFit(
  data,
  formula = ~1,
  family = 1,
  tau = TRUE,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A list, data frame or matrix containing the model responses,
(u1,u2) in [0,1]x[0,1], and covariates required by the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A gam formula (see <code>gam</code>,
<code>formula.gam</code> and <code>gam.models</code>
from <code>mgcv</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A copula family: <code>1</code> Gaussian,
<code>2</code> Student t,
<code>5</code> Frank,
<code>301</code> Double Clayton type I (standard and rotated 90 degrees),
<code>302</code> Double Clayton type II (standard and rotated 270 degrees),
<code>303</code> Double Clayton type III (survival and rotated 90 degrees),
<code>304</code> Double Clayton type IV (survival and rotated 270 degrees),
<code>401</code> Double Gumbel type I (standard and rotated 90 degrees),
<code>402</code> Double Gumbel type II (standard and rotated 270 degrees),
<code>403</code> Double Gumbel type III (survival and rotated 90 degrees),
<code>404</code> Double Gumbel type IV (survival and rotated 270 degrees).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p><code>FALSE</code> (default) for a calibration function specified for
the Copula parameter or <code>TRUE</code> for a calibration function specified
for Kendall's tau.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>'NR'</code> for Newton-Raphson
and  <code>'FS'</code> for Fisher-scoring (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> if informations should be printed during the
estimation and <code>FALSE</code> (default) for a silent version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed to <code>gam</code>
from <code>mgcv</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>gamBiCopFit</code> returns a list consisting of
</p>
<table>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>S4 <code>gamBiCop-class</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>'FS'</code> for Fisher-scoring (default) and
<code>'NR'</code> for Newton-Raphson.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.rel</code></td>
<td>
<p>relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iters</code></td>
<td>
<p>maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>the estimation procedure's trace.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p><code>0</code> if the algorithm converged and <code>1</code> otherwise.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>gamBiCop</code> and <code>gamBiCopSimulate</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(copula)
require(mgcv)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 5e2
rho &lt;- 0.5
fam &lt;- 1


## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## Display the calibration surface
par(mfrow = c(1, 3), pty = "s", mar = c(1, 1, 4, 1))
u &lt;- seq(0, 1, length.out = 100)
sel &lt;- matrix(c(1, 1, 2, 2, 3, 3), ncol = 2)
jet.colors &lt;- colorRamp(c(
  "#00007F", "blue", "#007FFF", "cyan", "#7FFF7F",
  "yellow", "#FF7F00", "red", "#7F0000"
))
jet &lt;- function(x) rgb(jet.colors(exp(x / 3) / (1 + exp(x / 3))),
    maxColorValue = 255
  )
for (k in 1:3) {
  tmp &lt;- outer(u, u, function(x, y)
    eta0 + calib.surf[[sel[k, 1]]](x) + calib.surf[[sel[k, 2]]](y))
  persp(u, u, tmp,
    border = NA, theta = 60, phi = 30, zlab = "",
    col = matrix(jet(tmp), nrow = 100),
    xlab = paste("X", sel[k, 1], sep = ""),
    ylab = paste("X", sel[k, 2], sep = ""),
    main = paste("eta0+f", sel[k, 1],
      "(X", sel[k, 1], ") +f", sel[k, 2],
      "(X", sel[k, 2], ")",
      sep = ""
    )
  )
}

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Display the data
dev.off()
plot(data[, "u1"], data[, "u2"], xlab = "U1", ylab = "U2")

## Model fit with a basis size (arguably) too small
## and unpenalized cubic spines
pen &lt;- FALSE
basis0 &lt;- c(3, 4, 4)
formula &lt;- ~ s(x1, k = basis0[1], bs = "cr", fx = !pen) +
  s(x2, k = basis0[2], bs = "cr", fx = !pen) +
  s(x3, k = basis0[3], bs = "cr", fx = !pen)
system.time(fit0 &lt;- gamBiCopFit(data, formula, fam))

## Model fit with a better basis size and penalized cubic splines (via min GCV)
pen &lt;- TRUE
basis1 &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis1[1], bs = "cr", fx = !pen) +
  s(x2, k = basis1[2], bs = "cr", fx = !pen) +
  s(x3, k = basis1[3], bs = "cr", fx = !pen)
system.time(fit1 &lt;- gamBiCopFit(data, formula, fam))

## Extract the gamBiCop objects and show various methods
(res &lt;- sapply(list(fit0, fit1), function(fit) {
  fit$res
}))
metds &lt;- list("logLik" = logLik, "AIC" = AIC, "BIC" = BIC, "EDF" = EDF)
lapply(res, function(x) sapply(metds, function(f) f(x)))


## Comparison between fitted, true smooth and spline approximation for each
## true smooth function for the two basis sizes
fitted &lt;- lapply(res, function(x) gamBiCopPredict(x, data.frame(x1 = u, x2 = u, x3 = u),
    type = "terms"
  )$calib)
true &lt;- vector("list", 3)
for (i in 1:3) {
  y &lt;- eta0 + calib.surf[[i]](u)
  true[[i]]$true &lt;- y - eta0
  temp &lt;- gam(y ~ s(u, k = basis0[i], bs = "cr", fx = TRUE))
  true[[i]]$approx &lt;- predict.gam(temp, type = "terms")
  temp &lt;- gam(y ~ s(u, k = basis1[i], bs = "cr", fx = FALSE))
  true[[i]]$approx2 &lt;- predict.gam(temp, type = "terms")
}

## Display results
par(mfrow = c(1, 3), pty = "s")
yy &lt;- range(true, fitted)
yy[1] &lt;- yy[1] * 1.5
for (k in 1:3) {
  plot(u, true[[k]]$true,
    type = "l", ylim = yy,
    xlab = paste("Covariate", k), ylab = paste("Smooth", k)
  )
  lines(u, true[[k]]$approx, col = "red", lty = 2)
  lines(u, fitted[[1]][, k], col = "red")
  lines(u, fitted[[2]][, k], col = "green")
  lines(u, true[[k]]$approx2, col = "green", lty = 2)
  legend("bottomleft",
    cex = 0.6, lty = c(1, 1, 2, 1, 2),
    c("True", "Fitted", "Appox 1", "Fitted 2", "Approx 2"),
    col = c("black", "red", "red", "green", "green")
  )
}
</code></pre>


</div>