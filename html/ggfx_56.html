<div class="container">

<table style="width: 100%;"><tr>
<td>with_blend</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Blend a layer with a reference</h2>

<h3>Description</h3>

<p>This filter blends the layer with a reference according to one of many rules
as laid out in the <em>Details</em> section.
</p>


<h3>Usage</h3>

<pre><code class="language-R">with_blend(
  x,
  bg_layer,
  blend_type = "over",
  flip_order = FALSE,
  alpha = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bg_layer</code></td>
<td>
<p>The background layer to use. Can either be a string
identifying a registered filter, or a raster object. The map will be resized
to match the dimensions of x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blend_type</code></td>
<td>
<p>The type of blending to perform. See <em>Details</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip_order</code></td>
<td>
<p>Should the order of the background and the overlay be
flipped so that <code>bg_layer</code> is treated as being on top and <code>x</code> being below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>For non-Duff-Porter blends the alpha channel may become modified.
This argument can be used to set the resulting alpha channel to that of the
source (<code>"src"</code>) or destination (<code>"dst"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed on to methods. See
the documentation of supported object for a description of
object specific arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two images can be blended in a variety of ways as described below. In the
following <em>source</em> will refer to the top-most image, and <em>destination</em>  to
the bottom-most image. Note that which is which can be controlled with the
<code>flip_order</code> argument.
</p>


<h4>Duff-Porter alpha blend modes</h4>

<p>This is a set of well-defined blend types for composing two images, taking
their opacity into account:
</p>

<ul>
<li> <p><code>"source"</code>: Completely disregards the destination, leaving only the source
</p>
</li>
<li> <p><code>"destination"</code>: Completely disregards the source, leaving only the
destination
</p>
</li>
<li> <p><code>"clear"</code>: Disregards both destination and source
</p>
</li>
<li> <p><code>"xor"</code>: Composes source on top of destination, setting shared areas to
transparent
</p>
</li>
<li> <p><code>"over"</code>: Composes source on top of destination
</p>
</li>
<li> <p><code>"in"</code>: Shows source, but only where the destination is opaque
</p>
</li>
<li> <p><code>"out"</code>: Shows source but only where the destination is transparent
</p>
</li>
<li> <p><code>"atop"</code>: Composes source on top of destination, keeping the transparency
of destination
</p>
</li>
<li> <p><code>"copy"</code>: Like source, but will only affect the area occupied by the source
image
</p>
</li>
</ul>
<h4>Mathmathical blend modes</h4>

<p>These blend modes perform often complex channel operations based on the
different channel values in the source and destination:
</p>

<ul>
<li> <p><code>"multiply"</code>: Multiplies the channel values of source and destination
together (after scaling them to 0-1) to obtain new channel values
</p>
</li>
<li> <p><code>"screen"</code>: As multiply except that the channels are scaled to 1-0 before
multiplication, and the result is reversed again before being used
</p>
</li>
<li> <p><code>"bumpmap"</code>: Like multiple, except source is converted to greyscale first
</p>
</li>
<li> <p><code>"divide"</code>: Divide the channel values in source by the channel values in
destination
</p>
</li>
<li> <p><code>"plus"</code>: Add the channel values together <em>including the alpha channel</em>
</p>
</li>
<li> <p><code>"minus"</code>: Subtracts the destination channels from the source channels
</p>
</li>
<li> <p><code>"modulus_plus"</code>: As plus, but overflow will wrap around instead of being
capped
</p>
</li>
<li> <p><code>"modulus_minus"</code>: As minus but overflow (underflow) will wrap around
instead of being capped
</p>
</li>
<li> <p><code>"difference"</code>: Takes the absolute difference in channel values between
source and destination
</p>
</li>
<li> <p><code>"exclusion"</code>: <code>source + destination - 2*source*destination</code>. A sort of
averaged difference
</p>
</li>
<li> <p><code>"lighten"</code>: Will pick the lightest pixel at each pixel
</p>
</li>
<li> <p><code>"darken"</code>: Will pick the darkest pixel at each pixel
</p>
</li>
<li> <p><code>"lighten_intensity"</code>: Will pick the most intense colour at each pixel
</p>
</li>
<li> <p><code>"darken_intensity"</code>: Will pick the least intense colour at each pixel
</p>
</li>
</ul>
<h4>Lighting blend modes</h4>

<p>These blend modes are designed to provide different lighting effects:
</p>

<ul>
<li> <p><code>"overlay"</code>: Simultaneously multiplies and screens at the same time based
on the colour values of the destination. Will colorize midtones in the
destination with the source
</p>
</li>
<li> <p><code>"hard_light"</code>: The inverse of overlay (i.e. the source acts as the
destination and vice versa)
</p>
</li>
<li> <p><code>"soft_light"</code>: Like overlay but will extent the range of colorization past
the midtones
</p>
</li>
<li> <p><code>"pegtop_light"</code>: Like soft-light, but without any discontinuity in the
blend
</p>
</li>
<li> <p><code>"linear_light"</code>: Combines dodging and burning so that the destination will
be dodged (lightened) when the source is light and burned (darkened) when
the source is dark
</p>
</li>
<li> <p><code>"vivid_light"</code>: A refinement of linear-light that better avoids shading
intense colours
</p>
</li>
<li> <p><code>"pin_light"</code>: Preserves midtones of the destination and only shades
lighter and darker parts, resulting in harsh, contrasty lightning.
</p>
</li>
<li> <p><code>"linear_dodge"</code>: Lighten the destination if the source is light
</p>
</li>
<li> <p><code>"linear_burn"</code>: Darked the destination if the source is dark
</p>
</li>
<li> <p><code>"color_dodge"</code>: Like linear-dodge, but preserves blacks in the destination
image
</p>
</li>
<li> <p><code>"color_burn"</code>: Like linear-burn but preserve whites in the destination
image
</p>
</li>
</ul>
<h4>Channel copying blends</h4>

<p>These blend modes copies a single channel from the source to the destination
</p>

<ul>
<li> <p><code>"copy_opacity"</code>: Will set the opacity of destination to the grayscale
version of source. To copy the opacity of source into destination use
<code>blend_type = "in"</code> with <code>flip_order = TRUE</code>.
</p>
</li>
<li> <p><code>"copy_red"</code>: Copies the red channel in source into the red channel in
destination
</p>
</li>
<li> <p><code>"copy_green"</code>: Copies the green channel in source into the green channel in
destination
</p>
</li>
<li> <p><code>"copy_blue"</code>: Copies the blue channel in source into the blue channel in
destination
</p>
</li>
<li> <p><code>"hue"</code>: Replaces the hue of the destination with the hue of the source
</p>
</li>
<li> <p><code>"saturate"</code>: Replaces the saturation of the destination with the
saturation of the source
</p>
</li>
<li> <p><code>"luminize"</code>: Replaces the luminance of the destination with the luminance
of the source
</p>
</li>
<li> <p><code>"colorize"</code>: Combines hue and saturate
</p>
</li>
</ul>
<h4>Special blends</h4>


<ul><li> <p><code>"unique"</code>: Only keep pixels in the source that differ from the
destination.
</p>
</li></ul>
<p>The above is obviously a very quick overview. More information can be found
in <a href="https://legacy.imagemagick.org/Usage/compose/">https://legacy.imagemagick.org/Usage/compose/</a>
</p>



<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other blend filters: 
<code>with_blend_custom()</code>,
<code>with_interpolate()</code>,
<code>with_mask()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ggplot2)
ggplot() +
  as_reference(
    geom_text(aes(0.5, 0.5, label = 'Blend Modes!'), size = 10, fontface = 'bold'),
    id = "text"
  ) +
  with_blend(
    geom_polygon(aes(c(0, 1, 1), c(0, 0, 1)), colour = NA, fill = 'magenta'),
    bg_layer = "text",
    blend_type = 'xor'
  )

</code></pre>


</div>