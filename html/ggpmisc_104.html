<div class="container">

<table style="width: 100%;"><tr>
<td>stat_ma_line</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicted line from major axis linear fit</h2>

<h3>Description</h3>

<p>Predicted values and a confidence band are computed and, by default, plotted.
<code>stat_ma_line()</code> behaves similarly to <code>stat_smooth</code>
except for fitting the model with <code>lmodel2::lmodel2()</code> with <code>"MA"</code>
as default for <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_ma_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = "lmodel2:MA",
  method.args = list(),
  n.min = 2L,
  formula = NULL,
  range.y = NULL,
  range.x = NULL,
  se = TRUE,
  fm.values = FALSE,
  n = 80,
  nperm = 99,
  fullrange = FALSE,
  level = 0.95,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function or character If character, "MA", "SMA" , "RMA" or
"OLS", alternatively "lmodel2" or the name of a model fit function are
accepted, possibly followed by the fit function's <code>method</code> argument
separated by a colon (e.g. <code>"lmodel2:MA"</code>). If a function different to
<code>lmodel2()</code>, it must accept arguments named <code>formula</code>,
<code>data</code>, <code>range.y</code>, <code>range.x</code> and <code>nperm</code> and return a
model fit object of class <code>lmodel2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range.y, range.x</code></td>
<td>
<p>character Pass "relative" or "interval" if method
"RMA" is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>logical Return confidence interval around smooth? ('TRUE' by
default, see 'level' to control.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fm.values</code></td>
<td>
<p>logical Add R2, p-value and n as columns to returned data?
('FALSE' by default.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperm</code></td>
<td>
<p>integer Number of permutation used to estimate significance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fullrange</code></td>
<td>
<p>Should the fit span the full range of the plot, or just
the data?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Level of confidence interval to use (only 0.95 currently).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either "x" or "y" controlling the default for
<code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This statistic fits major axis (<code>"MA"</code>) and other model II
regressions with function <code>lmodel2</code>. Model II
regression is called for when both <code>x</code> and <code>y</code> are subject to
random variation and the intention is not to predict <code>y</code> from <code>x</code>
by means of the model but rather to study the relationship between two
independent variables. A frequent case in biology are allometric
relationships among body parts.
</p>
<p>As the fitted line is the same whether <code>x</code> or <code>y</code> is on the rhs
of the model equation, <code>orientation</code> even if accepted does not have an
effect on the fitted line. In contrast, <code>geom_smooth</code> treats
each axis differently and can thus have two orientations. The orientation
is easy to deduce from the argument passed to <code>formula</code>. Thus,
<code>stat_ma_line()</code> will by default guess which orientation the layer
should have. If no argument is passed to <code>formula</code>, the orientation
can be specified directly passing an argument to the <code>orientation</code>
parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives
the axis that is on the rhs of the model equation, <code>"x"</code> being the
default orientation. Package 'ggpmisc' does not define new geometries
matching the new statistics as they are not needed and conceptually
transformations of <code>data</code> are expressed as statistics.
</p>
<p>The minimum number of observations with distinct values can be set through
parameter <code>n.min</code>. The default <code>n.min = 2L</code> is the smallest
possible value. However, model fits with very few observations are of
little interest and using a larger number for <code>n.min</code> than the default
is wise.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values and their confidence limits. Optionally
it will also include additional values related to the model fit.
</p>


<h3>Computed variables</h3>

<p>'stat_ma_line()' provides the following
variables, some of which depend on the orientation: </p>
 <dl>
<dt>y *or*
x</dt>
<dd>
<p>predicted value</p>
</dd> <dt>ymin *or* xmin</dt>
<dd>
<p>lower pointwise confidence
interval around the mean</p>
</dd> <dt>ymax *or* xmax</dt>
<dd>
<p>upper pointwise confidence
interval around the mean</p>
</dd> <dt>se</dt>
<dd>
<p>standard error</p>
</dd> </dl>
<p>If <code>fm.values = TRUE</code> is passed then columns based on the summary of
the model fit are added, with the same value in each row within a group.
This is wasteful and disabled by default, but provides a simple and robust
approach to achieve effects like colouring or hiding of the model fit line
based on P-values, r-squared or the number of observations.
</p>


<h3>Aesthetics</h3>

<p><code>stat_ma_line</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code>. Both must be mapped to
<code>numeric</code> variables. In addition, the aesthetics understood by the
geom (<code>"geom_smooth"</code> is the default) are understood and grouping
respected.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for major axis regression: 
<code>stat_ma_eq()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate artificial data
set.seed(98723)
my.data &lt;- data.frame(x = rnorm(100) + (0:99) / 10 - 5,
                      y = rnorm(100) + (0:99) / 10 - 5,
                      group = c("A", "B"))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "SMA")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "RMA",
               range.y = "interval", range.x = "interval")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "OLS")

# plot line to the ends of range of data (the default)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(fullrange = FALSE) +
  expand_limits(x = c(-10, 10), y = c(-10, 10))

# plot line to the limits of the scales
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(fullrange = TRUE) +
  expand_limits(x = c(-10, 10), y = c(-10, 10))

# plot line to the limits of the scales
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(orientation = "y", fullrange = TRUE) +
  expand_limits(x = c(-10, 10), y = c(-10, 10))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(formula = x ~ y)

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_ma_line()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line() +
  facet_wrap(~group)

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    stat_ma_line(geom = "debug")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    stat_ma_line(geom = "debug", fm.values = TRUE)

</code></pre>


</div>