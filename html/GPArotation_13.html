<div class="container">

<table style="width: 100%;"><tr>
<td>eiv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Errors-in-Variables Rotation</h2>

<h3>Description</h3>

<p>Rotate to errors-in-variables representation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">    eiv(L, identity=seq(NCOL(L)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a factor loading matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>identity</code></td>
<td>
<p>indicates rows which should be identity matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments discarded.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function rotates to an errors-in-variables representation. The
optimization is not iterative and does not use the GPA algorithm.  
The function can be used directly or the
function name can be passed to factor analysis functions like <code>factanal</code>.
</p>
<p>The loadings matrix is rotated so the <code class="reqn">k</code> rows indicated by <code>identity</code> 
form an identity matrix, and the remaining <code class="reqn">M-k</code> rows are free parameters.
<code class="reqn">\Phi</code> is also free. The default makes the first <code class="reqn">k</code> rows 
the identity. If inverting the matrix
of the rows indicated by <code>identity</code> fails, the rotation will fail and the
user needs to supply a different choice of rows.
</p>
<p>Not all authors consider this representation to be a rotation. 
Viewed as a rotation method, it is oblique, with an
explicit solution: given an initial loadings matrix <code class="reqn">L</code> partitioned as
<code class="reqn">L = (L_1^T, L_2^T)^T</code>, then (for the default 
<code>identity</code>) the new loadings matrix is 
<code class="reqn">(I,  (L_2 L_1^{-1})^T)^T</code> 
and <code class="reqn">\Phi = L_1 L_1^T</code>, where <code class="reqn">I</code> is the <code class="reqn">k</code> 
by <code class="reqn">k</code> identity matrix. It is
assumed that <code class="reqn">\Phi = I</code> for the initial loadings matrix.
</p>
<p>One use of this parameterization is
for obtaining good starting values (so it looks a little strange
to rotate towards this solution afterwards). It has a few other purposes: 
(1) It can be useful for comparison with
published results in this parameterization; 
(2) The
S.E.s are more straightfoward to compute, because it is the solution 
to an unconstrained
optimization (though not necessarily computed as such); 
(3) One
may have an idea about which reference variables load on only one
factor, but not impose restrictive constraints on the other loadings,
so, in a nonrestrictive
way, it has similarities to CFA; 
(4) For some purposes, only the subspace spanned by the factors
is important, not the specific parameterization within this subspace;
(5) The back-predicted indicators (explained portion of the indicators) 
do not depend
on the rotation method. Combined with the greater ease to obtain
correct standard errors of this method, this allows easier and more
accurate prediction-standard errors.  
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>factanal</code>) with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>The new loadings matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th</code></td>
<td>
<p>The rotation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function ("eiv").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orthogonal</code></td>
<td>
<p>For consistency with other rotation results. Always FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>For consistency with other rotation results. Always TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>The covariance matrix of the rotated factors.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Erik Meijer and Paul Gilbert.</p>


<h3>References</h3>

<p>Gösta Hägglund. (1982). "Factor Analysis by
Instrumental Variables Methods." <em>Psychometrika</em>, 47, 209–222.
</p>
<p>Sock-Cheng Lewin-Koh and Yasuo Amemiya. (2003). "Heteroscedastic factor
analysis." <em>Biometrika</em>, 90, 85–97.
</p>
<p>Tom Wansbeek and Erik Meijer (2000) <em>Measurement Error and 
Latent Variables in Econometrics</em>, Amsterdam: North-Holland.
</p>


<h3>See Also</h3>

<p><code>echelon</code>, 
<code>rotations</code>, 
<code>GPForth</code>, 
<code>GPFoblq</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 2, covmat=NetherlandsTV, rotation="none")

  fa.eiv &lt;- eiv(fa.unrotated$loadings)
 
  fa.eiv2 &lt;- factanal(factors = 2, covmat=NetherlandsTV, rotation="eiv")
  
  cbind(loadings(fa.unrotated), loadings(fa.eiv), loadings(fa.eiv2))

  fa.eiv3 &lt;- eiv(fa.unrotated$loadings, identity=6:7)
  cbind(loadings(fa.unrotated), loadings(fa.eiv), loadings(fa.eiv3))

  </code></pre>


</div>