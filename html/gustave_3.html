<div class="container">

<table style="width: 100%;"><tr>
<td>define_variance_wrapper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Define a variance estimation wrapper</h2>

<h3>Description</h3>

<p>Given a variance estimation <em>function</em> (specific to a 
survey), <code>define_variance_wrapper</code> defines a variance estimation 
<em>wrapper</em> easier to use (e.g. automatic domain estimation, 
linearization).
</p>


<h3>Usage</h3>

<pre><code class="language-R">define_variance_wrapper(
  variance_function,
  reference_id,
  reference_weight,
  default_id = NULL,
  technical_data = NULL,
  technical_param = NULL,
  objects_to_include = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>variance_function</code></td>
<td>
<p>An R function. It is the methodological workhorse of 
the variance estimation: from a set of arguments including the variables 
of interest (see below), it should return a vector of estimated variances.
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_id</code></td>
<td>
<p>A vector containing the ids of all the responding units
of the survey. It can also be an unevaluated expression (enclosed in 
<code>quote()</code>) to be evaluated within the execution environment of the wrapper.
It is compared with <code>default$id</code> (see below) to check whether 
some observations are missing in the survey file. The matrix of variables 
of interest passed on to <code>variance_function</code> has <code>reference_id</code> 
as rownames and is ordered according to its values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_weight</code></td>
<td>
<p>A vector containing the reference weight of the survey. 
It can also be an unevaluated expression (enclosed in <code>quote()</code>) to 
be evaluated within the execution environment of the wrapper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default_id</code></td>
<td>
<p>A character vector of length 1, the name of the default 
identifying variable in the survey file. It can also be an unevaluated 
expression (enclosed in <code>quote()</code>) to be evaluated within the survey file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>technical_data</code></td>
<td>
<p>A named list of technical data needed to perform 
the variance estimation (e.g. sampling strata, first- or second-order 
probabilities of inclusion, estimated response probabilities, calibration 
variables). Its names should match the names of the corresponding arguments 
in <code>variance_function</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>technical_param</code></td>
<td>
<p>A named list of technical parameters used to control 
some aspect of the variance estimation process (e.g. alternative methodology).
Its names should match the names of the corresponding arguments in <code>variance_function</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objects_to_include</code></td>
<td>
<p>(Advanced use) A character vector indicating the name of 
additional R objects to include within the variance wrapper.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Defining variance estimation wrappers is the <strong>key feature</strong> of
the <code>gustave</code> package. It is the workhorse of the ready-to-use 
<code>qvar</code> function and should be used directly to handle more complex
cases (e.g. surveys with several stages or balanced sampling).
</p>
<p>Analytical variance estimation is often difficult to carry out by 
non-specialists owing to the complexity of the underlying sampling 
and estimation methodology. This complexity yields complex <em>variance 
estimation functions</em> which are most often only used by the sampling expert 
who actually wrote them. A <em>variance estimation wrapper</em> is an 
intermediate function that is "wrapped around" the (complex) variance 
estimation function in order to provide the non-specialist with 
user-friendly features (see examples): </p>

<ul>
<li>
<p> calculation of complex statistics (see 
<code>standard statistic wrappers</code>)
</p>
</li>
<li>
<p> domain estimation 
</p>
</li>
<li>
<p> handy evaluation and factor discretization
</p>
</li>
</ul>
<p><code>define_variance_wrapper</code> allows the sampling expert to define a 
variance estimation wrapper around a given variance estimation function and
set its default parameters. The produced variance estimation wrapper is 
standalone in the sense that it contains all technical data necessary
to carry out the estimation (see <code>technical_data</code>).
</p>
<p>The arguments of the <code>variance_function</code> fall into three types: </p>

<ul>
<li>
<p> the data argument (mandatory, only one allowed): the numerical matrix of 
variables of interest to apply the variance estimation formula on
</p>
</li>
<li>
<p> technical data arguments (optional, one or more allowed): technical 
and methodological information used by the variance estimation function
(e.g. sampling strata, first- or second-order probabilities of inclusion, 
estimated response probabilities, calibration variables)
</p>
</li>
<li>
<p> technical parameters (optional, one or more allowed): non-data arguments 
to be used to control some aspect of the variance estimation (e.g. alternative
methodology)</p>
</li>
</ul>
<p><code>technical_data</code> and <code>technical_param</code> are used to determine
which arguments of <code>variance_function</code> relate to technical information, 
the only remaining argument is considered as the data argument.
</p>


<h3>Value</h3>

<p>An R function that makes the estimation of variance based on the
provided variance function easier. Its parameters are: </p>
 <ul>
<li>
<p><code>data</code>: one or more calls to a statistic wrapper (e.g. <code>total()</code>,
<code>mean()</code>, <code>ratio()</code>). See examples and
<code>standard statistic wrappers</code>) and
<code>standard statistic wrappers</code>)
</p>
</li>
<li> <p><code>where</code>: a logical vector indicating a domain on which the
variance estimation is to be performed </p>
</li>
<li> <p><code>by</code>: q qualitative
variable whose levels are used to define domains on which the variance
estimation is performed </p>
</li>
<li> <p><code>alpha</code>: a numeric vector of length 1
indicating the threshold for confidence interval derivation (<code>0.05</code> by
default) </p>
</li>
<li> <p><code>display</code>: a logical verctor of length 1 indicating
whether the result of the estimation should be displayed or not </p>
</li>
<li>
<p><code>id</code>: a character vector of size 1 containing the name of the
identifying variable in the survey file. Its default value depends on the
value of <code>default_id</code> in <code>define_variance_wrapper</code> </p>
</li>
<li>
<p><code>envir</code>: an environment containing a binding to <code>data</code></p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>References</h3>

<p>Rao, J.N.K (1975), "Unbiased variance estimation for multistage designs",
<em>Sankhya</em>, C nÂ°37
</p>


<h3>See Also</h3>

<p><code>qvar</code>, <code>standard statistic wrappers</code>, <code>varDT</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Example from the Labour force survey (LFS)

# The (simulated) Labour force survey (LFS) has the following characteristics:
# - first sampling stage: balanced sampling of 4 areas (each corresponding to 
#   about 120 dwellings) on first-order probability of inclusion (proportional to 
#   the number of dwellings in the area) and total annual income in the area.
# - second sampling stage: in each sampled area, simple random sampling of 20 
#   dwellings
# - neither non-response nor calibration

# As this is a multi-stage sampling design with balanced sampling at the first
# stage, the qvar function does not apply. A variance wrapper can nonetheless
# be defined using the core define_variance_wrapper function.

# Step 1 : Definition of the variance function and the corresponding technical data

# In this context, the variance estimation function specific to the LFS 
# survey can be defined as follows:

var_lfs &lt;- function(y, ind, dwel, area){
  
  variance &lt;- list()
  
  # Variance associated with the sampling of the dwellings
  y &lt;- sum_by(y, ind$id_dwel)
  variance[["dwel"]] &lt;- var_srs(
    y = y, pik = dwel$pik_dwel, strata = dwel$id_area, 
    w = (1 / dwel$pik_area^2 - dwel$q_area)
  )
  
  # Variance associated with the sampling of the areas
  y &lt;- sum_by(y = y, by = dwel$id_area, w = 1 / dwel$pik_dwel) 
  variance[["area"]] &lt;- varDT(y = y, precalc = area)
  
  Reduce(`+`, variance)
  
}

# where y is the matrix of variables of interest and ind, dwel and area the technical data:

technical_data_lfs &lt;- list()

# Technical data at the area level
# The varDT function allows for the pre-calculation of 
# most of the methodological quantities needed.
technical_data_lfs$area &lt;- varDT(
  y = NULL, 
  pik = lfs_samp_area$pik_area, 
  x = as.matrix(lfs_samp_area[c("pik_area", "income")]),
  id = lfs_samp_area$id_area
)

# Technical data at the dwelling level
# In order to implement Rao (1975) formula for two-stage samples,
# we associate each dwelling with the diagonal term corresponding 
# to its area in the first-stage variance estimator: 
lfs_samp_dwel$q_area &lt;- with(technical_data_lfs$area, setNames(diago, id))[lfs_samp_dwel$id_area]
technical_data_lfs$dwel &lt;- lfs_samp_dwel[c("id_dwel", "pik_dwel", "id_area", "pik_area", "q_area")]

# Technical data at the individual level
technical_data_lfs$ind &lt;- lfs_samp_ind[c("id_ind", "id_dwel", "sampling_weight")]

# Test of the variance function var_lfs
y &lt;- matrix(as.numeric(lfs_samp_ind$unemp), ncol = 1, dimnames = list(lfs_samp_ind$id_ind))
with(technical_data_lfs, var_lfs(y = y, ind = ind, dwel = dwel, area = area))


# Step 2 : Definition of the variance wrapper

# Call of define_variance_wrapper
precision_lfs &lt;- define_variance_wrapper(
  variance_function = var_lfs,
  technical_data = technical_data_lfs, 
  reference_id = technical_data_lfs$ind$id_ind,
  reference_weight = technical_data_lfs$ind$sampling_weight,
  default_id = "id_ind"
)

# Test
precision_lfs(lfs_samp_ind, unemp)

# The variance wrapper precision_lfs has the same features
# as variance wrappers produced by the qvar function (see
# qvar examples for more details).

</code></pre>


</div>