<div class="container">

<table style="width: 100%;"><tr>
<td>get_h_hp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generator of h and hp (derivative of h) functions.</h2>

<h3>Description</h3>

<p>Generator of <code>h</code> and <code>hp</code> (derivative of <code class="reqn">h</code>) functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_h_hp(mode, para = NULL, para2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>A string, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para</code></td>
<td>
<p>May be optional. A number, the first parameter. Default to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>para2</code></td>
<td>
<p>May be optional. A number, the second parameter. If <code>mode</code> is one of the adaptive mode below, this specifies the percentile (see details). Default to <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>mode</code> parameter can be chosen from the options listed below along with the corresponding definitions of <code>h</code> under appropriate choices of <code>para</code> and <code>para2</code> parameters. Unless otherwise noted, <code>para</code> and <code>para2</code>, must both be strictly positive if provided, and are set to 1 if not provided. Functions <code>h</code> and <code>hp</code> should only be applied to non-negative values <code>x</code> and this is not enforced or checked by the functions.
Internally calls <code>get_h_hp_vector</code>.
</p>

<dl>
<dt><code>asinh</code></dt>
<dd>
<p>An asinh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\mathrm{asinh}(\mathrm{para}\cdot\boldsymbol{x})=\log\left(\mathrm{para}\cdot\boldsymbol{x}+\sqrt{(\mathrm{para}\cdot\boldsymbol{x})^2+1}\right)</code>. Unbounded and takes one parameter. Equivalent to <code>min_asinh(x, para, Inf)</code>.</p>
</dd>
<dt><code>cosh</code></dt>
<dd>
<p>A shifted cosh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\cosh(\mathrm{para}\cdot\boldsymbol{x})-1</code>. Unbounded and takes one parameter. Equivalent to <code>min_cosh(x, para, Inf)</code>.</p>
</dd>
<dt><code>exp</code></dt>
<dd>
<p>A shifted exponential function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\exp(\mathrm{para}\cdot\boldsymbol{x})-1</code>. Unbounded and takes one parameter. Equivalent to <code>min_exp(x, para, Inf)</code>.</p>
</dd>
<dt><code>identity</code></dt>
<dd>
<p>The identity function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{x}</code>. Unbounded and does not take any parameter. Equivalent to <code>pow(x, 1)</code> or <code>min_pow(x, 1, Inf)</code>.</p>
</dd>
<dt><code>log_pow</code></dt>
<dd>
<p>A power function on a log scale <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\log(1+\boldsymbol{x})^{\mathrm{para}}</code>. Unbounded and takes one parameter. Equivalent to <code>min_log_pow(x, para, Inf)</code>.</p>
</dd>
<dt><code>mcp</code></dt>
<dd>
<p>Treating <code class="reqn">\lambda</code>=para, <code class="reqn">\gamma</code>=para2, the step-wise MCP function applied element-wise: <code class="reqn">\lambda x-x^2/(2\gamma)</code> if <code class="reqn">x\leq\lambda\gamma</code>, or <code class="reqn">\gamma\lambda^2/2</code> otherwise. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_asinh</code></dt>
<dd>
<p>A truncated asinh function applied element-wise: <code class="reqn">\min(\mathrm{asinh}(\mathrm{para}\cdot\boldsymbol{x}),\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_asinh_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_asinh</code>.</p>
</dd>
<dt><code>min_cosh</code></dt>
<dd>
<p>A truncated shifted cosh function applied element-wise: <code class="reqn">\min(\cosh(\mathrm{para}\cdot\boldsymbol{x})-1,\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_cosh_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_cosh</code>.</p>
</dd>
<dt><code>min_exp</code></dt>
<dd>
<p>A truncated shifted exponential function applied element-wise: <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\min(\exp(\mathrm{para}\cdot\boldsymbol{x})-1,\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_exp_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_exp</code>.</p>
</dd>
<dt><code>min_log_pow</code></dt>
<dd>
<p>A truncated power on a log scale applied element-wise: <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\min(\log(1+\boldsymbol{x}),\mathrm{para}_2)^{\mathrm{para}}</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_log_pow_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_log_pow</code>.</p>
</dd>
<dt><code>min_pow</code></dt>
<dd>
<p>A truncated power function applied element-wise: <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\min(\boldsymbol{x},\mathrm{para}_2)^{\mathrm{para}}</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_pow_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_pow</code>.</p>
</dd>
<dt><code>min_sinh</code></dt>
<dd>
<p>A truncated sinh function applied element-wise: <code class="reqn">\min(\sinh(\mathrm{para}\cdot\boldsymbol{x}),\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_sinh_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_sinh</code>.</p>
</dd>
<dt><code>min_softplus</code></dt>
<dd>
<p>A truncated shifted softplus function applied element-wise: <code class="reqn">\min(\log(1+\exp(\mathrm{para}\cdot\boldsymbol{x}))-\log(2),\mathrm{para}_2)</code>. Bounded and takes two parameters.</p>
</dd>
<dt><code>min_softplus_ada</code></dt>
<dd>
<p>Adaptive version of <code>min_softplus</code>.</p>
</dd>
<dt><code>pow</code></dt>
<dd>
<p>A power function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\boldsymbol{x}^{\mathrm{para}}</code>. Unbounded and takes two parameter. Equivalent to <code>min_pow(x, para, Inf)</code>.</p>
</dd>
<dt><code>scad</code></dt>
<dd>
<p>Treating <code class="reqn">\lambda</code>=para, <code class="reqn">\gamma</code>=para2, the step-wise SCAD function applied element-wise: <code class="reqn">\lambda x</code> if <code class="reqn">x\leq\lambda</code>, or <code class="reqn">(2\gamma\lambda x-x^2-\lambda^2)/(2(\gamma-1))</code> if <code class="reqn">\lambda&lt;x&lt;\gamma\lambda</code>, or <code class="reqn">\lambda^2(\gamma+1)/2</code> otherwise. Bounded and takes two parameters, where <code>para2</code> must be larger than 1, and will be set to 2 by default if not provided.</p>
</dd>
<dt><code>sinh</code></dt>
<dd>
<p>A sinh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\sinh(\mathrm{para}\cdot\boldsymbol{x})</code>. Unbounded and takes one parameter. Equivalent to <code>min_sinh(x, para, Inf)</code>.</p>
</dd>
<dt><code>softplus</code></dt>
<dd>
<p>A shifted softplus function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\log(1+\exp(\mathrm{para}\cdot\boldsymbol{x}))-\log(2)</code>. Unbounded and takes one parameter. Equivalent to <code>min_softplus(x, para, Inf)</code>.</p>
</dd>
<dt><code>tanh</code></dt>
<dd>
<p>A tanh function <code class="reqn">\boldsymbol{h}(\boldsymbol{x})=\tanh(\mathrm{para}\cdot\boldsymbol{x})</code>. Bounded and takes one parameter.</p>
</dd>
<dt><code>truncated_sin</code></dt>
<dd>
<p>A truncated sin function applied element-wise: <code class="reqn">\sin(\mathrm{para}\cdot x)</code> if <code class="reqn">\mathrm{para}\cdot x\leq\pi/2</code>, or 1 otherwise. Bounded and takes one parameter.</p>
</dd>
<dt><code>truncated_tan</code></dt>
<dd>
<p>A truncated tan function applied element-wise: <code class="reqn">\tan(\mathrm{para}\cdot x)</code> if <code class="reqn">\mathrm{para}\cdot x\leq\pi/4</code>, or 1 otherwise. Bounded and takes one parameter.</p>
</dd>
</dl>
<p>For the adaptive modes (names ending with <code>"_ada"</code>), <code>h</code> and <code>hp</code> are first applied to <code>x</code> without truncation. Then inside each column, values that are larger than the <code>para2</code>-th quantile will be truncated. The quantile is calculated using finite values only, and if no finite values exist the quantile is set to 1.
For example, if <code>mode == "min_pow_ada"</code>, <code>para == 2</code>, <code>para2 == 0.4</code>, the <code>j</code>-th column of the returned <code>hx</code> will be <code>pmin(x[,j]^2, stats::quantile(x[,j]^2, 0.4))</code>, and the <code>j</code>-th column of <code>hpx</code> will be <code>2*x[,j]*(x[,j] &lt;= stats::quantile(x[,j]^2, 0.4))</code>.
</p>


<h3>Value</h3>

<p>A function that returns a list containing <code>hx=h(x)</code> (element-wise) and <code>hpx=hp(x)</code> (element-wise derivative of <code class="reqn">h</code>) when applied to a vector (for mode names not ending with <code>"_ada"</code> only) or a matrix <code>x</code>, with both of the results having the same shape as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">get_h_hp("mcp", 2, 4)(0:10)
get_h_hp("min_log_pow", 1, log(1+3))(matrix(0:11, nrow=3))
get_h_hp("min_pow", 1.5, 3)(seq(0, 5, by=0.5))
get_h_hp("min_softplus")(matrix(seq(0, 2, by=0.1), nrow=7))

get_h_hp("min_log_pow_ada", 1, 0.4)(matrix(0:49, nrow=10))
get_h_hp("min_pow_ada", 2, 0.3)(matrix(0:49, nrow=10))
get_h_hp("min_softplus_ada", 2, 0.6)(matrix(seq(0, 0.49, by=0.01), nrow=10))
</code></pre>


</div>