<div class="container">

<table style="width: 100%;"><tr>
<td>forward_sgwt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Forward Spectral Graph Wavelet Transform</h2>

<h3>Description</h3>

<p><code>forward_sgwt</code> computes the forward Spectral Graph Wavelet Transform (SGWT) for a given graph signal <code class="reqn">f</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">forward_sgwt(
  f,
  evalues,
  evectors,
  b = 2,
  filter_func = zetav,
  filter_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Numeric vector representing the graph signal to analyze.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalues</code></td>
<td>
<p>Numeric vector of eigenvalues of the Laplacian matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evectors</code></td>
<td>
<p>Matrix of eigenvectors of the Laplacian matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Numeric scalar that controls the number of scales in the SGWT. It must be greater than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter_func</code></td>
<td>
<p>Function used to compute the filter values. By default, it uses the <code>zetav</code> function but other frame filters can be pass.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter_params</code></td>
<td>
<p>List of additional parameters required by <code>filter_func</code>. Default is an empty list.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The transform is constructed based on the frame defined by the <code>tight_frame</code> function, without the need for its explicit calculation. Other filters can be passed as parameters. The SGWT provides a multi-scale analysis of graph signals.
</p>
<p>Given a graph signal <code class="reqn">f</code> of length <code class="reqn">N</code>, <code>forward_sgwt</code> computes the wavelet coefficients using SGWT.
</p>
<p>The eigenvalues and eigenvectors of the graph Laplacian, are denoted as <code class="reqn">\Lambda</code> and <code class="reqn">U</code> respectively. The parameter <code class="reqn">b</code> controls the number of scales, and <code class="reqn">\lambda_{\text{max}}</code> is the largest eigenvalue.
</p>
<p>For each scale <code class="reqn">j = 0, \ldots, J</code>, where
</p>
<p style="text-align: center;"><code class="reqn">J = \left\lfloor \frac{\log(\lambda_{\text{max}})}{\log(b)} \right\rfloor + 2</code>
</p>
<p> the wavelet coefficients are computed as:
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{w}_j = U \left( g_j \odot (U^T f) \right)
</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">g_j(\lambda) = \sqrt{\psi_j(\lambda)}</code>
</p>
<p> and <code class="reqn">\odot</code> denotes element-wise multiplication.
</p>
<p>The final result is a concatenated vector of these coefficients for all scales.
</p>


<h3>Value</h3>

<p><code>wc</code> A concatenated vector of wavelet coefficients.
</p>


<h3>Note</h3>

<p><code>forward_sgwt</code> can be adapted for other filters by passing a different filter function to the <code>filter_func</code> parameter.
</p>
<p>The computation of <code class="reqn">k_{\text{max}}</code> using <code class="reqn">\lambda_{\text{max}}</code> and <code class="reqn">b</code> applies primarily to the default <code>zetav</code> filter. It can be overridden by providing it in the <code>filter_params</code> list for other filters.
</p>


<h3>References</h3>

<p>GÃ¶bel, F., Blanchard, G., von Luxburg, U. (2018). Construction of tight frames on graphs and application to denoising. In Handbook of Big Data Analytics (pp. 503-522). Springer, Cham.
</p>
<p>Hammond, D. K., Vandergheynst, P., &amp; Gribonval, R. (2011). Wavelets on graphs via spectral graph theory. Applied and Computational Harmonic Analysis, 30(2), 129-150.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>


<h3>See Also</h3>

<p><code>inverse_sgwt</code>, <code>tight_frame</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Extract the adjacency matrix from the grid1 and compute the Laplacian
L &lt;- laplacian_mat(grid1$sA)

# Compute the spectral decomposition of L
decomp &lt;- eigensort(L)

# Create a sample graph signal
f &lt;- rnorm(nrow(L))

# Compute the forward Spectral Graph Wavelet Transform
wc &lt;- forward_sgwt(f, decomp$evalues, decomp$evectors)

## End(Not run)

</code></pre>


</div>