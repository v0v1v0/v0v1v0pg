<div class="container">

<table style="width: 100%;"><tr>
<td>ssa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Invoking the stochastic simulation algorithm</h2>

<h3>Description</h3>

<p>Main interface function to the implemented <abbr><span class="acronym">SSA</span></abbr> methods. Runs a
single realization of a predefined system.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssa(
                   x0,            # initial state vector
                    a,            # propensity vector
                   nu,            # state-change matrix
                parms = NULL,     # model parameters
                   tf,            # final time
               method = ssa.d(),  # SSA method
              simName = "",
                  tau = 0.3,      # deprecated
                    f = 10,       # deprecated
              epsilon = 0.03,     # deprecated
                   nc = 10,       # deprecated
                  hor = NA_real_, # deprecated
                  dtf = 10,       # deprecated
                   nd = 100,      # deprecated
  ignoreNegativeState = TRUE,
      consoleInterval = 0,
       censusInterval = 0,
              verbose = FALSE,
          maxWallTime = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>numerical vector of initial states where the component elements
must be named using the same notation as the corresponding state variable in
the propensity vector, <code>a</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>character vector of propensity functions where state variables
correspond to the names of the elements in <code>x0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>numerical matrix of change if the number of individuals in each
state (rows) caused by a single reaction of any given type (columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms</code></td>
<td>
<p>named vector of model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tf</code></td>
<td>
<p>final time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>an SSA method,
the valid options are:
</p>

<ul>
<li> <p><code>ssa.d()</code> — Direct method (default method),
</p>
</li>
<li> <p><code>ssa.etl()</code> - Explicit tau-leap,
</p>
</li>
<li> <p><code>ssa.btl()</code> — Binomial tau-leap, or
</p>
</li>
<li> <p><code>ssa.otl()</code> — Optimized tau-leap.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simName</code></td>
<td>
<p>optional text string providing an arbitrary name/label for
the simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.etl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.btl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.otl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.otl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hor</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.otl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtf</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.otl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nd</code></td>
<td>
<p>[DEPRECATED], see <code>ssa.otl()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreNegativeState</code></td>
<td>
<p>boolean object indicating if negative state
values should be ignored (this can occur in the <code>etl</code> method).
If <code>ignoreNegativeState=TRUE</code> the simulation finishes gracefully when
encountering a negative population size (i.e. does not throw an error).
If <code>ignoreNegativeState=FALSE</code> the simulation stops with an error
message when encountering a negative population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>consoleInterval</code></td>
<td>
<p>(approximate) interval at which <code>ssa</code> produces
simulation status output on the console (assumes <code>verbose=TRUE</code>).
If <code>consoleInterval=0</code> console output is generated each time step (or
tau-leap). If <code>consoleInterval=Inf</code> no console output is generated.
Note, <code>verbose=FALSE</code> disables all console output. <strong>Console
output drastically slows down simulations.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censusInterval</code></td>
<td>
<p>(approximate) interval between recording the state of the system.
If <code>censusInterval=0</code> <code class="reqn">(t,x)</code> is recorded at each time step (or
tau-leap). If <code>censusInterval=Inf</code> only <code class="reqn">(t_0,x_0)</code>
and <code class="reqn">(t_f,x_t)</code> is recorded. Note, the size of the time
step (or tau-leaps) ultimately limits the interval between subsequent
recordings of the system state since the state of the system cannot be
recorded at a finer time interval the size of the time steps (or tau-leaps).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>boolean object indicating if the status of the simulation
simulation should be displayed on the console. If <code>verbose=TRUE</code>
the elapsed wall time and <code class="reqn">(t,x)</code> is displayed on the console every
<code>consoleInterval</code> time step and a brief summary is displayed at
the end of the simulation. If <code>verbose=FALSE</code> the simulation runs
<em>entirely</em> silent (overriding <code>consoleInterval</code>).
<strong>Verbose runs drastically slows down simulations.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxWallTime</code></td>
<td>
<p>maximum wall time duration (in seconds) that the
simulation is allowed to run for before terminated. This option is
useful, in particular, for systems that can end up growing uncontrolably.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Although <code>ssa</code> can be invoked by only specifying the system
arguments (initial state vector <code>x0</code>, propensity vector <code>a</code>,
state-change matrix <code>nu</code>), the final time (<code>tf</code>), and the
<abbr><span class="acronym">SSA</span></abbr> method to use, substantial improvements in speed and accuracy
can be obtained by adjusting the additional (and optional) <code>ssa</code>
arguments. By default <code>ssa</code> (tries to) use conservative default values
for the these arguments, prioritizing computational accuracy over
computational speed. These default values are, however, <strong>not</strong> fool
proof for the approximate methods, and occasionally one will have to hand
tweak them in order for a stochastic model to run appropriately.
</p>


<h3>Value</h3>

<p>Returns a list object with the following elements,
</p>

<ul>
<li> <p><code>data</code>: a numerical matrix object of the simulation time series where the first column is the time vector and subsequent columns are the state frequencies.
</p>
</li>
<li> <p><code>stats</code>: sub-list object with elements containing various simulation statistics. The of the sub-list are:
</p>
</li>
<li> <p><code>stats$startWallTime</code>: start wall clock time (YYYY-mm-dd HH:MM:SS).
</p>
</li>
<li> <p><code>stats$endWallTime</code>: end wall clock time (YYYY-mm-dd HH:MM:SS).
</p>
</li>
<li> <p><code>stats$elapsedWallTime</code>: elapsed wall time in seconds.
</p>
</li>
<li> <p><code>stats$terminationStatus</code>: string vector listing the reason(s) for the
termination of the realization in 'plain words'. The possible termination statuses are:
</p>

<ul>
<li> <p><code>finalTime</code> = if the simulation reached the maximum simulation time <code>tf</code>,
</p>
</li>
<li> <p><code>extinction</code> = if the population size of all states is zero,
</p>
</li>
<li> <p><code>negativeState</code> = if one or several states have a negative population size (can occur in the ETL method),
</p>
</li>
<li> <p><code>zeroProp</code> = if all the states have a zero propensity function,
</p>
</li>
<li> <p><code>maxWallTime</code> = if the maximum wall time has been reached. Note the termination status may have more than one message.
</p>
</li>
</ul>
</li>
<li>
<p> 'stats$nSteps“ total number of time steps (or tau-leaps) executed.
</p>
</li>
<li> <p><code>stats$meanStepSize</code>: mean step (or tau-leap) size.
</p>
</li>
<li> <p><code>stats$sdStepSize</code>: one standard deviation of the step (or tau-leap) size.
</p>
</li>
<li> <p><code>stats$SuspendedTauLeaps</code>: number of steps performed using the Direct method due to <code>OTL</code> suspension (only applicable for the <code>OTL</code> method).
</p>
</li>
<li> <p><code>arg$...</code>: sub-list with elements containing all the arguments and their values used to invoke <code>ssa</code> (see Usage and Arguments list above).
</p>
</li>
</ul>
<h3>Preparing a run</h3>

<p>In order to invoke <abbr><span class="acronym">SSA</span></abbr> the stochastic
model needs at least four components, the initial state vector (<code>x0</code>),
state-change matrix (<code>nu</code>), propensity vector (<code>a</code>), and the final
time of the simulation (<code>tf</code>). The initial state vector defines the
population sizes in all the states at <code class="reqn">t=0</code>, e.g. for a system with two
species <code>X1</code> and <code>X2</code> where both have an initial population size
of 1000 the initial state vector is defined as <code>x0 &lt;- c(X1=1000,X2=1000)</code>. The elements of the vector have to be labelled using
the same notation as the state variables used in the propensity functions.
The state-change matrix defines the change in the number of individuals in
each state (rows) as caused by one reaction of a given type (columns). For
example, the state-change matrix for system with the species <code class="reqn">S_1</code>
and <code class="reqn">S_2</code> with two reactions </p>
<p style="text-align: center;"><code class="reqn">S_1
  \stackrel{c_1}{\longrightarrow} S_2</code>
</p>
 <p style="text-align: center;"><code class="reqn">S_2
  \stackrel{c_2}{\longrightarrow} 0</code>
</p>

<p>is defined as <code>nu &lt;- matrix(c(-1,0,+1,-1),nrow=2,byrow=TRUE)</code> where
<code class="reqn">c_1</code> and <code class="reqn">c_2</code> are the per capita reaction probabilities.
The propensity vector, <code>a</code>, defines the probabilities that a particular
reaction will occur over the next infinitesimal time interval <code class="reqn">\left[
  t,t+dt \right]</code>. For example, in the previous example the
propensity vector is defined as <code>a &lt;- c("c1*X1","c2*X2")</code>. The
propensity vector consists of character elements of each reaction's
propensity function where each state variable requires the corresponding
named element label in the initial state vector (<code>x0</code>).
</p>


<h3>Example</h3>

<p>Irreversible isomerization:
Perhaps the simplest model that can be formulated using the <abbr><span class="acronym">SSA</span></abbr>
is the irreversible isomerization (or radioactive decay) model. This model
is often used as a first pedagogic example to illustrate the <abbr><span class="acronym">SSA</span></abbr>
(see e.g. Gillespie 1977). The deterministic formulation of this model is
</p>
<p style="text-align: center;"><code class="reqn">\frac{dX}{dt}=-cX</code>
</p>

<p>where the single reaction channel is
</p>
<p style="text-align: center;"><code class="reqn">S \stackrel{c}{\longrightarrow} 0</code>
</p>

<p>By setting <code class="reqn">X_0=1000</code> and <code class="reqn">c=0.5</code> it is now simple to define this model
and run it for 10 time steps using the Direct method,
</p>
<pre>
  out &lt;- ssa(x0=c(X=1000),a=c("c*X"),nu=matrix(-1),parms=c(c=0.5),tf=10)
</pre>
<p>The resulting time series can then be displayed by,
</p>
<pre>
  ssa.plot(out)
</pre>


<h3>Note</h3>

<p>Selecting the appropriate <abbr><span class="acronym">SSA</span></abbr> method is a trade-off between
computational speed, accuracy of the results, and which <abbr><span class="acronym">SSA</span></abbr>
actually works for a given scenario. This depends on the characteristics of
the defined system (e.g. number of reaction channels, number of species, and
the absolute and relative magnitude of the propensity functions).
<strong>Not all methods are appropriate for all models.</strong> When selecting a
<abbr><span class="acronym">SSA</span></abbr> method all of these factors have to be taken into
consideration. The various tau-leap methods accept a number of additional
arguments. While the default values of these arguments may work for some
scenarios they may have to be adjusted for others. The default values for
the tau-leap methods are conservative in terms of computational speed and
substantial increase in efficiency may be gained by optimizing their values
for a specific system.
</p>


<h3>See Also</h3>

<p>GillespieSSA-package, <code>ssa.d()</code>, <code>ssa.etl()</code>, <code>ssa.btl()</code>, <code>ssa.otl()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Irreversible isomerization
## Large initial population size (X=1000)
parms &lt;- c(c=0.5)
x0  &lt;- c(X=10000)
a   &lt;- c("c*X")
nu  &lt;- matrix(-1)
out &lt;- ssa(x0,a,nu,parms,tf=10,method=ssa.d(),simName="Irreversible isomerization") # Direct method
plot(out$data[,1],out$data[,2]/10000,col="red",cex=0.5,pch=19)

## Smaller initial population size (X=100)
x0  &lt;- c(X=100)
out &lt;- ssa(x0,a,nu,parms,tf=10,method=ssa.d()) # Direct method
points(out$data[,1],out$data[,2]/100,col="green",cex=0.5,pch=19)

## Small initial population size (X=10)
x0  &lt;- c(X=10)
out &lt;- ssa(x0,a,nu,parms,tf=10,method=ssa.d()) # Direct method
points(out$data[,1],out$data[,2]/10,col="blue",cex=0.5,pch=19)

## Logistic growth
parms &lt;- c(b=2, d=1, K=1000)
x0  &lt;- c(N=500)
a   &lt;- c("b*N", "(d+(b-d)*N/K)*N")
nu  &lt;- matrix(c(+1,-1),ncol=2)
out &lt;- ssa(x0,a,nu,parms,tf=10,method=ssa.d(),maxWallTime=5,simName="Logistic growth")
ssa.plot(out)

## Kermack-McKendrick SIR model
parms &lt;- c(beta=0.001, gamma=0.1)
x0  &lt;- c(S=499,I=1,R=0)
a   &lt;- c("beta*S*I","gamma*I")
nu  &lt;- matrix(c(-1,0,+1,-1,0,+1),nrow=3,byrow=TRUE)
out &lt;- ssa(x0,a,nu,parms,tf=100,method=ssa.d(),simName="SIR model")
ssa.plot(out)

## Lotka predator-prey model
parms &lt;- c(c1=10, c2=.01, c3=10)
x0  &lt;- c(Y1=1000,Y2=1000)
a   &lt;- c("c1*Y1","c2*Y1*Y2","c3*Y2")
nu  &lt;- matrix(c(+1,-1,0,0,+1,-1),nrow=2,byrow=TRUE)
out &lt;- ssa(x0,a,nu,parms,tf=100,method=ssa.etl(),simName="Lotka predator-prey model")
ssa.plot(out)

</code></pre>


</div>