<div class="container">

<table style="width: 100%;"><tr>
<td>randsignal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate Random Signal with Varying Regularity</h2>

<h3>Description</h3>

<p><code>randsignal</code> constructs a random signal with specific regularity properties, utilizing the adjacency matrix <code>A</code> of the graph, a smoothness parameter <code>eta</code>, and an exponent <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">randsignal(eta, k, A, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>Numeric. Smoothness parameter (between 0 and 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Interger. Smoothness parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Adjacency matrix. Must be symmetric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Optional. Largest eigenvalue of <code>A</code> in magnitude (obtained using the <code>eigs</code> function from the <code>RSpectra</code> package if not provided).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method is inspired by the approach described in the first referenced paper.
</p>
<p>The generated signal is formulated as
<code class="reqn">f = A^k x_{\eta} / r^k</code>
where <code class="reqn">x_{\eta}</code> represents Bernoulli random variables, and <code class="reqn">r</code> is the largest eigenvalue of the matrix <code class="reqn">A</code>.
</p>
<p>The power <code class="reqn">k</code> essentially captures the influence of a node's <code class="reqn">k</code>-hop neighborhood in the generated signal, implying that a higher <code class="reqn">k</code> would aggregate more neighborhood information resulting in a smoother signal.
</p>
<p>The normalization by the largest eigenvalue ensures that the signal remains bounded. This signal generation can be related to the Laplacian quadratic form that quantifies the smoothness of signals on graphs. By controlling the parameters <code class="reqn">\eta</code> and <code class="reqn">k</code>, we can modulate the smoothness or regularity of the generated signal.
</p>


<h3>Value</h3>

<p><code>f</code> a numeric vector representing the output signal.
</p>


<h3>Note</h3>

<p>While the <code>randsignal</code> function uses the adjacency matrix to parameterize and generate signals reflecting node-to-node interactions, the smoothness of these signals can subsequently be measured using the <code>smoothmodulus</code> function.
</p>
<p>The generation is carried out in sparse matrices format in order to scale up.
</p>


<h3>References</h3>

<p>Behjat, H., Richter, U., Van De Ville, D., &amp; SÃ¶rnmo, L. (2016). Signal-adapted tight frames on graphs. IEEE Transactions on Signal Processing, 64(22), 6017-6029.
</p>
<p>de Loynes, B., Navarro, F., &amp; Olivier, B. (2021). Data-driven thresholding in denoising with spectral graph wavelet transform. Journal of Computational and Applied Mathematics, 389, 113319.
</p>


<h3>See Also</h3>

<p><code>smoothmodulus</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Generate a signal with smoothness parameters eta = 0.7 and k = 3
f &lt;- randsignal(eta = 0.7, k = 3, A = grid1$sA)

## End(Not run)
</code></pre>


</div>