<div class="container">

<table style="width: 100%;"><tr>
<td>graph-rip</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create RIP ordering of the cliques of  an undirected graph;
create junction tree.</h2>

<h3>Description</h3>

<p>A RIP (running intersection property) ordering of the
cliques is also called a perfect ordering. If the graph is not
chordal, then no such ordering exists.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rip(object, ...)

## Default S3 method:
rip(object, root = NULL, nLevels = NULL, ...)

ripMAT(amat, root = NULL, nLevels = rep(2, ncol(amat)))

junction_tree(object, ...)

## Default S3 method:
junction_tree(object, nLevels = NULL, ...)

junction_treeMAT(amat, nLevels = rep(2, ncol(amat)), ...)

jTree(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An undirected graph represented either as a
<code>graphNEL</code> object, an <code>igraph</code>, a (dense)
<code>matrix</code>, a (sparse) <code>dgCMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments; currently not used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>A vector of variables. The first variable in the
perfect ordering will be the first variable on 'root'. The
ordering of the variables given in 'root' will be followed as
far as possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nLevels</code></td>
<td>
<p>Typically, the number of levels of the variables
(nodes) when these are discrete. Used in determining the
triangulation using a "minimum clique weight heuristic". See
section 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amat</code></td>
<td>
<p>Adjacency matrix</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The RIP ordering of the cliques of a decomposable
(i.e. chordal) graph is obtained by first ordering the
variables linearly with maximum cardinality search (by
<code>mcs</code>). The root argument is transfered to <code>mcs</code> as a
way of controlling which clique will be the first in the RIP
ordering.  The <code>junction_tree()</code> (and
<code>junction_tree()</code>) (for "junction tree") is just a wrapper
for a call of <code>triangulate()</code> followed by a call of
<code>rip()</code>.
</p>


<h3>Value</h3>

<p><code>rip</code> returns a list (an object of class
<code>ripOrder</code>. A print method exists for such objects.)
</p>


<h3>Synonymous functions</h3>

<p>For backward compatibility with downstream packages we have the
following synonymous functions:
</p>

<ul>
<li>
<p> jTree = junction_tree (Used in rags2ridges)
</p>
</li>
<li>
<p> junctionTree = junction_tree
</p>
</li>
</ul>
<h3>Note</h3>

<p>The workhorse is the <code>ripMAT()</code> function. The
<code>nLevels</code> argument to the <code>rip</code> functions has no
meaning.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code>mcs</code>, <code>triangulate</code>,
<code>moralize</code>, <code>ug</code>, <code>dag</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## graphNEL
uG &lt;- ug(~me:ve + me:al + ve:al + al:an + al:st + an:st)
mcs(uG)
rip(uG)
junction_tree(uG)

## Adjacency matrix
uG &lt;- ug(~me:ve:al + al:an:st, result="matrix")
mcs(uG)
rip(uG)
junction_tree(uG)

## Sparse adjacency matrix
uG &lt;- ug(c("me", "ve", "al"), c("al", "an", "st"), result="dgCMatrix")
mcs(uG)
rip(uG)
junction_tree(uG)

## Non--decomposable graph
uG &lt;- ug(~1:2 + 2:3 + 3:4 + 4:5 + 5:1)
mcs(uG)
rip(uG)
junction_tree(uG)


</code></pre>


</div>