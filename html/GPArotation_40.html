<div class="container">

<table style="width: 100%;"><tr>
<td>Random.Start</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a Random Orthogonal Rotation</h2>

<h3>Description</h3>

<p>Random orthogonal rotation to use as Tmat matrix to start GPFRSorth, GPFRSoblq, GPForth, or GPFoblq.
</p>


<h3>Usage</h3>

<pre><code class="language-R">    Random.Start(k)
    </code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>An integer indicating the dimension of the square matrix.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The random start function produces an orthogonal matrix with columns
of length one based on the QR decompostion. This randomization procedures
follows the logic of Stewart(1980) and Mezzari(2007), as of GPArotation version 2024.2-1.
</p>


<h3>Value</h3>

<p>An orthogonal matrix.</p>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert. Additional input from Yves Rosseel.
</p>


<h3>References</h3>

<p>Stewart, G. W. (1980). The Efficient Generation of Random Orthogonal Matrices 
with an Application to Condition Estimators. 
<em>SIAM Journal on Numerical Analysis</em>, 
<b>17</b>(3), 403–409. http://www.jstor.org/stable/2156882
</p>
<p>Mezzadri, F. (2007). How to generate random matrices from the classical
compact groups. <em>Notices of the American Mathematical Society</em>, <b>54</b>(5), 592–604.
https://arxiv.org/abs/math-ph/0609050
</p>


<h3>See Also</h3>

<p><code>GPFRSorth</code>, 
<code>GPFRSoblq</code>,
<code>GPForth</code>, 
<code>GPFoblq</code>,
<code>rotations</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # Generate a random ortogonal matrix of dimension 5 x 5
  Random.Start(5)
  
  # function for generating orthogonal or oblique random matrix
  Random.Start &lt;- function(k = 2L,orthogonal=TRUE){
    mat &lt;- matrix(rnorm(k*k),k)
    if (orthogonal){
      qr.out &lt;- qr(matrix(rnorm(k * k), nrow = k, ncol = k))
      Q &lt;- qr.Q(qr.out)
      R &lt;- qr.R(qr.out)
      R.diag &lt;- diag(R)
      R.diag2 &lt;- R.diag/abs(R.diag)
      ans &lt;- t(t(Q) * R.diag2)
      ans
      }
    else{
	  ans &lt;- mat %*% diag(1/sqrt(diag(crossprod(mat))))
 	  }
    ans
    }
    	
  data("Thurstone", package="GPArotation")
  simplimax(box26,Tmat = Random.Start(3, orthogonal = TRUE))
  simplimax(box26,Tmat = Random.Start(3, orthogonal = FALSE))

  # covariance matrix is Phi = t(Th) %*% Th
  rms &lt;- Random.Start(3, FALSE)
  t(rms) %*% rms # covariance matrix because oblique rms
  rms &lt;- Random.Start(3, TRUE)
  t(rms) %*% rms # identity matrix because orthogonal rms
	
   </code></pre>


</div>