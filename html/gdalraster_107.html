<div class="container">

<table style="width: 100%;"><tr>
<td>RunningStats-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class to calculate mean and variance in one pass</h2>

<h3>Description</h3>

<p><code>RunningStats</code> computes summary statistics on a data stream efficiently.
Mean and variance are calculated with Welford's online algorithm
(<a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a>).
The min, max, sum and count are also tracked. The input data values are not
stored in memory, so this class can be used to compute statistics for very
large data streams.
</p>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to remove <code>NA</code> from the input data or
<code>FALSE</code> to retain <code>NA</code> (defaults to <code>TRUE</code>).</p>
</td>
</tr></table>
<h3>Value</h3>

<p>An object of class <code>RunningStats</code>. A <code>RunningStats</code> object
maintains the current minimum, maximum, mean, variance, sum and count of
values that have been read from the stream. It can be updated repeatedly
with new values (i.e., chunks of data read from the input stream), but its
memory footprint is negligible. Class methods for updating with new values
and retrieving current values of statistics are described in Details.
<code>RunningStats</code> is a C++ class exposed directly to R (via
<code>RCPP_EXPOSED_CLASS</code>). Methods of the class are accessed in R using the <code>$</code>
operator.
</p>


<h3>Usage</h3>

<pre>
## Constructor
rs &lt;- new(RunningStats, na_rm)

## Methods (see Details)
rs$update(newvalues)
rs$get_count()
rs$get_mean()
rs$get_min()
rs$get_max()
rs$get_sum()
rs$get_var()
rs$get_sd()
rs$reset()
</pre>


<h3>Details</h3>

<p><code>new(RunningStats, na_rm)</code>
Constructor. Returns an object of class <code>RunningStats</code>.
</p>
<p><code>$update(newvalues)</code>
Updates the <code>RunningStats</code> object with a numeric vector of <code>newvalues</code>
(i.e., a chunk of values from the data stream). No return value, called
for side effects.
</p>
<p><code>$get_count()</code>
Returns the count of values received from the data stream.
</p>
<p><code>$get_mean()</code>
Returns the mean of values received from the data stream.
</p>
<p><code>$get_min()</code>
Returns the minimum value received from the data stream.
</p>
<p><code>$get_max()</code>
Returns the maximum value received from the data stream.
</p>
<p><code>$get_sum()</code>
Returns the sum of values received from the data stream.
</p>
<p><code>$get_var()</code>
Returns the variance of values from the data stream
(denominator n - 1).
</p>
<p><code>$get_sd()</code>
Returns the standard deviation of values from the data stream
(denominator n - 1).
</p>
<p><code>$reset()</code>
Clears the <code>RunningStats</code> object to its initialized state (count = 0).
No return value, called for side effects.
</p>


<h3>Note</h3>

<p>The intended use is computing summary statistics for specific subsets or
zones of a raster that could be defined in various ways and are generally
not contiguous. The algorithm as implemented here incurs the cost of
floating point division for each new value updated (i.e., per pixel), but is
reasonably efficient for the use case. Note that GDAL internally uses an
optimized version of Welford's algorithm to compute raster statistics as
described in detail by Rouault, 2016
(<a href="https://github.com/OSGeo/gdal/blob/master/gcore/statistics.txt">https://github.com/OSGeo/gdal/blob/master/gcore/statistics.txt</a>).
The class method <code>GDALRaster$getStatistics()</code> is a GDAL API wrapper that
computes statistics for a whole raster band.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(42)

rs &lt;- new(RunningStats, na_rm=TRUE)
chunk &lt;- runif(1000)
rs$update(chunk)
object.size(rs)

rs$get_count()
length(chunk)

rs$get_mean()
mean(chunk)

rs$get_min()
min(chunk)

rs$get_max()
max(chunk)

rs$get_var()
var(chunk)

rs$get_sd()
sd(chunk)


## 10^9 values read in 10,000 chunks
## should take under 1 minute on most PC hardware
for (i in 1:1e4) {
  chunk &lt;- runif(1e5)
  rs$update(chunk)
}
rs$get_count()
rs$get_mean()
rs$get_var()

object.size(rs)

</code></pre>


</div>