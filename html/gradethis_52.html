<div class="container">

<table style="width: 100%;"><tr>
<td>mock_this_exercise</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mock a user submission to an exercise</h2>

<h3>Description</h3>

<p>This function helps you test your <code>grade_this()</code> and <code>grade_this_code()</code>
logic by helping you quickly create the environment that these functions
expect when used to grade a user submission to an exercise in a <span class="pkg">learnr</span>
tutorial.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mock_this_exercise(
  .user_code,
  .solution_code = NULL,
  ...,
  .label = "mock",
  .engine = "r",
  .stage = "check",
  .result = rlang::missing_arg(),
  setup_global = NULL,
  setup_exercise = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.user_code</code></td>
<td>
<p>A single string or expression in braces representing the
user submission to this exercise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.solution_code</code></td>
<td>
<p>An optional single string or expression in braces
representing the solution code to this exercise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.label</code></td>
<td>
<p>The label of the mock exercise, defaults to <code>"mock"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.engine</code></td>
<td>
<p>The engine of the mock exercise. If the engine is not <code>"r"</code>,
then <code>.result</code> must be provided explicitly since <code>mock_this_exercise()</code>
cannot evaluate the <code>.user_code</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.stage</code></td>
<td>
<p>The stage of the exercise evaluation, defaults to <code>"check"</code>.
<span class="pkg">learnr</span> stages are <code>"code_check"</code>, <code>"check"</code> or <code>"error_check"</code>. When
gradethis is used outside of learnr, this variable is typically <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.result</code></td>
<td>
<p>The result of the evaluation of the <code>.user_code</code>. If the
<code>.engine</code> is <code>"r"</code>, the result will be prepared automatically by evaluating
the user code.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setup_global</code></td>
<td>
<p>An optional single string or expression in braces
representing the global <code>setup</code> chunk code.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>setup_exercise</code></td>
<td>
<p>An optional single string or expression in braces
representing the code in the exercise's setup chunk(s).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns the checking environment that is expected by <code>grade_this()</code>
and <code>grade_this_code()</code>. Both of these functions themselves return a
function that gets called on the checking environment. In other words, the
object returned by this function can be passed to the function returned
from either <code>grade_this()</code> or <code>grade_this_code()</code> to test the grading
logic used in either.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># First we'll create a grading function with grade_this(). The user's code
# should return the value 42, and we have some specific messages if they're
# close but miss this target. Otherwise, we'll fall back to the default fail
# message, which will include code feedback.
this_grader &lt;-
  grade_this({
    pass_if_equal(42, "Great Work!")
    fail_if_equal(41, "You were so close!")
    fail_if_equal(43, "Oops, just missed!")
    fail()
  })

# Our first mock submission is almost right...
this_grader(mock_this_exercise(.user_code = 41, .solution_code = 42))

# Our second mock submission is a little too high...
this_grader(mock_this_exercise(.user_code = 43, .solution_code = 42))

# A third submission takes an unusual path, but arrives at the right answer.
# Notice that you can use braces around an expression.
this_grader(
  mock_this_exercise(
    .user_code = {
      x &lt;- 31
      y &lt;- 11
      x + y
    },
    .solution_code = 42
  )
)

# Our final submission changes the prompt slightly. Suppose we have provided
# an `x` object in our global setup with a value of 31. We also have a `y`
# object that we create for the user in the exercise setup chunk. We then ask
# the student to add `x` and `y`. What happens if the student subtracts
# instead? That's what this mock submission tests:
this_grader(
  mock_this_exercise(
    .user_code = x - y,
    .solution_code = x + y,
    setup_global = x &lt;- 31,
    setup_exercise = y &lt;- 11
  )
)
</code></pre>


</div>