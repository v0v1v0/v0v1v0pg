<div class="container">

<table style="width: 100%;"><tr>
<td>order_maxmin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum minimum distance ordering</h2>

<h3>Description</h3>

<p>Return the indices of an approximation to the maximum minimum distance ordering.
A point in the center is chosen first, and then each successive point
is chosen to maximize the minimum distance to previously selected points
</p>


<h3>Usage</h3>

<pre><code class="language-R">order_maxmin(locs, lonlat = FALSE, space_time = FALSE, st_scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T, 
a longitude and latitude (in degrees) giving a point on the sphere, 
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>space_time</code></td>
<td>
<p>TRUE if locations are euclidean space-time locations, 
FALSE otherwise. If set to TRUE, temporal dimension is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st_scale</code></td>
<td>
<p>two-vector giving the amount by which the spatial
and temporal coordinates are scaled. If <code>NULL</code>, the function
uses the locations to automatically select a scaling.
If set to FALSE, temporal dimension treated as another spatial dimension (not recommended).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e. 
the first element of this vector is the index of the first location.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># planar coordinates
nvec &lt;- c(50,50)
locs &lt;- as.matrix( expand.grid( 1:nvec[1]/nvec[1], 1:nvec[2]/nvec[2] ) )
ord &lt;- order_maxmin(locs)
par(mfrow=c(1,3))
plot( locs[ord[1:100],1], locs[ord[1:100],2], xlim = c(0,1), ylim = c(0,1) )
plot( locs[ord[1:300],1], locs[ord[1:300],2], xlim = c(0,1), ylim = c(0,1) )
plot( locs[ord[1:900],1], locs[ord[1:900],2], xlim = c(0,1), ylim = c(0,1) )

# longitude/latitude coordinates (sphere)
latvals &lt;- seq(-80, 80, length.out = 40 )
lonvals &lt;- seq( 0, 360, length.out = 81 )[1:80]
locs &lt;- as.matrix( expand.grid( lonvals, latvals ) )
ord &lt;- order_maxmin(locs, lonlat = TRUE)
par(mfrow=c(1,3))
plot( locs[ord[1:100],1], locs[ord[1:100],2], xlim = c(0,360), ylim = c(-90,90) )
plot( locs[ord[1:300],1], locs[ord[1:300],2], xlim = c(0,360), ylim = c(-90,90) )
plot( locs[ord[1:900],1], locs[ord[1:900],2], xlim = c(0,360), ylim = c(-90,90) )

</code></pre>


</div>