<div class="container">

<table style="width: 100%;"><tr>
<td>price_indexes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Price indexes</h2>

<h3>Description</h3>

<p>Calculate a variety of price indexes using information on prices and
quantities at two points in time.
</p>


<h3>Usage</h3>

<pre><code class="language-R">arithmetic_index(type)

geometric_index(type)

harmonic_index(type)

laspeyres_index(p1, p0, q0, na.rm = FALSE)

paasche_index(p1, p0, q1, na.rm = FALSE)

jevons_index(p1, p0, na.rm = FALSE)

lowe_index(p1, p0, qb, na.rm = FALSE)

young_index(p1, p0, pb, qb, na.rm = FALSE)

fisher_index(p1, p0, q1, q0, na.rm = FALSE)

hlp_index(p1, p0, q1, q0, na.rm = FALSE)

lm_index(elasticity)

cswd_index(p1, p0, na.rm = FALSE)

cswdb_index(p1, p0, q1, q0, na.rm = FALSE)

bw_index(p1, p0, na.rm = FALSE)

stuvel_index(a, b)

arithmetic_agmean_index(elasticity)

geometric_agmean_index(elasticity)

lehr_index(p1, p0, q1, q0, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The name of the index. See details for the possible types of
indexes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>Current-period prices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>Base-period prices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q0</code></td>
<td>
<p>Base-period quantities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing values be removed? By default missing values for
prices or quantities return a missing value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q1</code></td>
<td>
<p>Current-period quantities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qb</code></td>
<td>
<p>Period-b quantities for the Lowe/Young index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pb</code></td>
<td>
<p>Period-b prices for the Lowe/Young index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elasticity</code></td>
<td>
<p>The elasticity of substitution for the Lloyd-Moulton and
AG mean indexes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a, b</code></td>
<td>
<p>Parameters for the generalized Stuvel index.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>arithmetic_index()</code>, <code>geometric_index()</code>, and
<code>harmonic_index()</code> functions return a function to calculate a given
type of arithmetic, geometric (logarithmic), and harmonic index. Together,
these functions produce functions to calculate the following indexes.
</p>

<ul>
<li> <p><strong>Arithmetic indexes</strong>
</p>
</li>
<li>
<p> Carli
</p>
</li>
<li>
<p> Dutot
</p>
</li>
<li>
<p> Laspeyres
</p>
</li>
<li>
<p> Palgrave
</p>
</li>
<li>
<p> Unnamed index (arithmetic mean of Laspeyres and Palgrave)
</p>
</li>
<li>
<p> Drobisch (or Sidgwick, arithmetic mean of Laspeyres and Paasche)
</p>
</li>
<li>
<p> Walsh-I (arithmetic Walsh)
</p>
</li>
<li>
<p> Marshall-Edgeworth
</p>
</li>
<li>
<p> Geary-Khamis
</p>
</li>
<li>
<p> Lowe
</p>
</li>
<li>
<p> Young
</p>
</li>
<li>
<p> Hybrid-CSWD
</p>
</li>
<li> <p><strong>Geometric indexes</strong>
</p>
</li>
<li>
<p> Jevons
</p>
</li>
<li>
<p> Geometric Laspeyres (or Jöhr)
</p>
</li>
<li>
<p> Geometric Paasche
</p>
</li>
<li>
<p> Geometric Young
</p>
</li>
<li>
<p> Törnqvist (or Törnqvist-Theil)
</p>
</li>
<li>
<p> Montgomery-Vartia / Vartia-I
</p>
</li>
<li>
<p> Sato-Vartia / Vartia-II
</p>
</li>
<li>
<p> Walsh-II (geometric Walsh)
</p>
</li>
<li>
<p> Theil
</p>
</li>
<li>
<p> Rao
</p>
</li>
<li> <p><strong>Harmonic indexes</strong>
</p>
</li>
<li>
<p> Coggeshall (equally weighted harmonic index)
</p>
</li>
<li>
<p> Paasche
</p>
</li>
<li>
<p> Harmonic Laspeyres
</p>
</li>
<li>
<p> Harmonic Young
</p>
</li>
</ul>
<p>Along with the <code>lm_index()</code> function to calculate the Lloyd-Moulton
index, these are just convenient wrappers for
<code>generalized_mean()</code> and <code>index_weights()</code>.
</p>
<p>The Laspeyres, Paasche, Jevons, Lowe, and Young indexes are among the most
common price indexes, and so they get their own functions. The
<code>laspeyres_index()</code>, <code>lowe_index()</code>, and <code>young_index()</code>
functions correspond to setting the appropriate <code>type</code> in
<code>arithmetic_index()</code>; <code>paasche_index()</code> and <code>jevons_index()</code>
instead come from the <code>harmonic_index()</code> and <code>geometric_index()</code>
functions.
</p>
<p>In addition to these indexes, there are also functions for calculating a
variety of indexes not based on generalized means. The Fisher index is the
geometric mean of the arithmetic Laspeyres and Paasche indexes; the Harmonic
Laspeyres Paasche (or Harmonic Paasche Laspeyres) index is the harmonic
analog of the Fisher index (8054 on Fisher's list). The
Carruthers-Sellwood-Ward-Dalen and Carruthers-Sellwood-Ward-Dalen-Balk
indexes are sample analogs of the Fisher
index; the Balk-Walsh index is the sample analog of the Walsh index. The AG
mean index is the arithmetic or geometric mean of the geometric and
arithmetic Laspeyres indexes, weighted by the elasticity of substitution.
The <code>stuvel_index()</code> function returns a function to calculate a Stuvel
index of the given parameters. The Lehr index is an alternative to the
Geary-Khamis index, and is the implicit price index for Fisher's index 4153.
</p>


<h3>Value</h3>

<p><code>arithmetic_index()</code>, <code>geometric_index()</code>, <code>harmonic_index()</code>, and
<code>stuvel_index()</code> each return a function to compute the relevant price
indexes; <code>lm_index()</code>, <code>arithmetic_agmean_index()</code>, and
<code>geometric_agmean_index()</code> each return a function to calculate the
relevant index for a given elasticity of substitution. The others return a
numeric value giving the change in price between the base period and current
period.
</p>


<h3>Note</h3>

<p>There are different ways to deal with missing values in a price index,
and care should be taken when relying on these functions to remove missing
values. Setting <code>na.rm = TRUE</code> removes price relatives with missing
information, either because of a missing price or a missing weight, while
using all available non-missing information to make the weights.
</p>
<p>Certain properties of an index-number formula may not work as expected when
removing missing values if there is ambiguity about how to remove missing
values from the weights (as in, e.g., a Törnqvist or Sato-Vartia index). The
<code>balanced()</code> operator may be helpful, as it balances the removal of missing
values across prices and quantities prior to making the weights.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Fisher, I. (1922). <em>The Making of Index Numbers</em>. Houghton Mifflin
Company.
</p>
<p>IMF, ILO, Eurostat, UNECE, OECD, and World Bank. (2020).
<em>Consumer Price Index Manual: Concepts and Methods</em>.
International Monetary Fund.
</p>
<p>von der Lippe, P. (2007). <em>Index Theory and Price Statistics</em>. Peter Lang.
</p>
<p>von der Lippe, P. (2015). Generalized Statistical Means and New Price Index
Formulas, Notes on some unexplored index formulas, their interpretations and
generalizations. Munich Personal RePEc Archive paper no. 64952.
</p>
<p>Selvanathan, E. A. and Rao, D. S. P. (1994).
<em>Index Numbers: A Stochastic Approach</em>. MacMillan.
</p>


<h3>See Also</h3>

<p><code>generalized_mean()</code> for the generalized mean that powers
most of these functions.
</p>
<p><code>contributions()</code> for calculating percent-change contributions.
</p>
<p><code>quantity_index()</code> to remap the arguments in these functions for a
quantity index.
</p>
<p><code>price6()</code> for an example of how to use these functions with more
than two time periods.
</p>
<p>The <span class="pkg">piar</span> package has more functionality working with price indexes for
multiple groups of products over many time periods.
</p>
<p>Other price index functions: 
<code>geks()</code>,
<code>index_weights()</code>,
<code>splice_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">p0 &lt;- price6[[2]]
p1 &lt;- price6[[3]]
q0 &lt;- quantity6[[2]]
q1 &lt;- quantity6[[3]]
pb &lt;- price6[[1]]
qb &lt;- quantity6[[1]]

#---- Calculating price indexes ----

# Most indexes can be calculated by combining the appropriate weights
# with the correct type of mean

geometric_index("Laspeyres")(p1, p0, q0)
geometric_mean(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Arithmetic Laspeyres index

laspeyres_index(p1, p0, q0)
arithmetic_mean(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Harmonic calculation for the arithmetic Laspeyres

harmonic_mean(p1 / p0, index_weights("HybridLaspeyres")(p1, q0))

# Same as transmuting the weights

all.equal(
  scale_weights(index_weights("HybridLaspeyres")(p1, q0)),
  transmute_weights(1, -1)(p1 / p0, index_weights("Laspeyres")(p0, q0))
)

# This strategy can be used to make more exotic indexes, like the
# quadratic-mean index (von der Lippe, 2007, p. 61)

generalized_mean(2)(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Or the exponential mean index (p. 62)

log(arithmetic_mean(exp(p1 / p0), index_weights("Laspeyres")(p0, q0)))

# Or the arithmetic hybrid index (von der Lippe, 2015, p. 5)

arithmetic_mean(p1 / p0, index_weights("HybridLaspeyres")(p1, q0))
contraharmonic_mean(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Unlike its arithmetic counterpart, the geometric Laspeyres can
# increase when base-period prices increase if some of these prices
# are small

gl &lt;- geometric_index("Laspeyres")
p0_small &lt;- replace(p0, 1, p0[1] / 5)
p0_dx &lt;- replace(p0_small, 1, p0_small[1] + 0.01)
gl(p1, p0_small, q0) &lt; gl(p1, p0_dx, q0)

#---- Price updating the weights in a price index ----

# Chain an index by price updating the weights

p2 &lt;- price6[[4]]
laspeyres_index(p2, p0, q0)

I1 &lt;- laspeyres_index(p1, p0, q0)
w_pu &lt;- update_weights(p1 / p0, index_weights("Laspeyres")(p0, q0))
I2 &lt;- arithmetic_mean(p2 / p1, w_pu)
I1 * I2

# Works for other types of indexes, too

harmonic_index("Laspeyres")(p2, p0, q0)

I1 &lt;- harmonic_index("Laspeyres")(p1, p0, q0)
w_pu &lt;- factor_weights(-1)(p1 / p0, index_weights("Laspeyres")(p0, q0))
I2 &lt;- harmonic_mean(p2 / p1, w_pu)
I1 * I2

#---- Percent-change contributions ----

# Percent-change contributions for the Tornqvist index

w &lt;- index_weights("Tornqvist")(p1, p0, q1, q0)
(con &lt;- geometric_contributions(p1 / p0, w))

all.equal(sum(con), geometric_index("Tornqvist")(p1, p0, q1, q0) - 1)

#---- Missing values ----

# NAs get special treatment

p_na &lt;- replace(p0, 6, NA)

# Drops the last price relative

laspeyres_index(p1, p_na, q0, na.rm = TRUE)

# Only drops the last period-0 price

sum(p1 * q0, na.rm = TRUE) / sum(p_na * q0, na.rm = TRUE)

#---- von Bortkiewicz decomposition ----

paasche_index(p1, p0, q1) / laspeyres_index(p1, p0, q0) - 1

wl &lt;- scale_weights(index_weights("Laspeyres")(p0, q0))
pl &lt;- laspeyres_index(p1, p0, q0)
ql &lt;- quantity_index(laspeyres_index)(q1, q0, p0)

sum(wl * (p1 / p0 / pl - 1) * (q1 / q0 / ql - 1))

# Similar decomposition for geometric Laspeyres/Paasche

wp &lt;- scale_weights(index_weights("Paasche")(p1, q1))
gl &lt;- geometric_index("Laspeyres")(p1, p0, q0)
gp &lt;- geometric_index("Paasche")(p1, p0, q1)

log(gp / gl)

sum(scale_weights(wl) * (wp / wl - 1) * log(p1 / p0 / gl))

#---- Consistency in aggregation ----

p0a &lt;- p0[1:3]
p0b &lt;- p0[4:6]
p1a &lt;- p1[1:3]
p1b &lt;- p1[4:6]
q0a &lt;- q0[1:3]
q0b &lt;- q0[4:6]
q1a &lt;- q1[1:3]
q1b &lt;- q1[4:6]

# Indexes based on the generalized mean with value share weights are
# consistent in aggregation

lm_index(0.75)(p1, p0, q0)

w &lt;- index_weights("LloydMoulton")(p0, q0)
Ia &lt;- generalized_mean(0.25)(p1a / p0a, w[1:3])
Ib &lt;- generalized_mean(0.25)(p1b / p0b, w[4:6])
generalized_mean(0.25)(c(Ia, Ib), c(sum(w[1:3]), sum(w[4:6])))

# Agrees with group-wise indexes

all.equal(lm_index(0.75)(p1a, p0a, q0a), Ia)
all.equal(lm_index(0.75)(p1b, p0b, q0b), Ib)

# Care is needed with more complex weights, e.g., Drobisch, as this
# doesn't fit Balk's (2008) definition (p. 113) of a generalized-mean
# index (it's the arithmetic mean of a Laspeyres and Paasche index)

arithmetic_index("Drobisch")(p1, p0, q1, q0)

w &lt;- index_weights("Drobisch")(p1, p0, q1, q0)
Ia &lt;- arithmetic_mean(p1a / p0a, w[1:3])
Ib &lt;- arithmetic_mean(p1b / p0b, w[4:6])
arithmetic_mean(c(Ia, Ib), c(sum(w[1:3]), sum(w[4:6])))

# Does not agree with group-wise indexes

all.equal(arithmetic_index("Drobisch")(p1a, p0a, q1a, q0a), Ia)
all.equal(arithmetic_index("Drobisch")(p1b, p0b, q1b, q0b), Ib)

</code></pre>


</div>