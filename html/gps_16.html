<div class="container">

<table style="width: 100%;"><tr>
<td>penutils</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Utility functions for working with wiggliness penalties
</h2>

<h3>Description</h3>

<p>Evaluate <code class="reqn">\|\bm{D\beta}\|^2</code> without using <code class="reqn">\bm{D}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">DiffCoef(b, xt, d, m)

btSb(b, xt, d, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a vector of B-spline coefficients (<code>length(b) == length(xt) - d</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xt</code></td>
<td>
<p>full knot sequence for ordinary B-splines (<code>length(xt) &gt;= 2 * d</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>B-spline order (<code class="reqn">d \ge 2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>penalty order (<code class="reqn">1 \le m \le d - 1</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Implicit Evaluation of the Penalty</h4>

<p>Sometimes we want to evaluate the penalty <code class="reqn">\|\bm{D\beta}\|^2</code> for some <code class="reqn">\bm{\beta}</code>. The obvious way is to do the matrix-vector multiplication <code class="reqn">\bm{D\beta}</code> then compute its <code class="reqn">L_2</code> norm, however, implicit evaluation without using <code class="reqn">\bm{D}</code> is possible. For general P-splines, we can calculate <code class="reqn">\bm{D}_{\textrm{gps}}\bm{\beta}</code> by taking order-<code class="reqn">m</code> general differences between elements of <code class="reqn">\bm{\beta}</code>, and function <code>DiffCoef</code> does this. For O-splines, the evaluation can be more refined. Denote domain knots by <code class="reqn">s_0,\ s_1,\ s_2,\ \ldots,\ s_k,\ s_{k + 1}</code>, where <code class="reqn">(s_j)_1^k</code> are interior knots and <code class="reqn">s_0 = a</code>, <code class="reqn">s_{k + 1} = b</code> are domain endpoints. The derivative penalty adds up local wiggliness measure on each interval: <code class="reqn">\int_a^b f^{(m)}(x)^2\mathrm{d}x = \sum_{j = 0}^k\int_{s_j}^{s_{j + 1}} f^{(m)}(x)^2\mathrm{d}x</code>. Function <code>btSb</code> calculates each integral in the summation and returns those additive components in a vector.
</p>



<h3>Value</h3>

<p><code>DiffCoef</code> (for general P-splines only) returns <code class="reqn">\bm{D}_{\textrm{gps}}\bm{\beta}</code> as a vector.
</p>
<p><code>btSb</code> (for O-splines only) returns a vector with element <code class="reqn">\int_{s_j}^{s_{j + 1}} f^{(m)}(x)^2\mathrm{d}x</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(Matrix)
require(gps)

## 11 domain knots at equal quantiles of Beta(3, 3) distribution
xd &lt;- qbeta(seq.int(0, 1, by = 0.1), 3, 3)
## full knots (with clamped boundary knots) for constructing cubic B-splines
xt &lt;- c(0, 0, 0, xd, 1, 1, 1)

## compute 2nd order D matrix for O-splines
D.os &lt;- SparseD(xt, d = 4, m = 2, gps = FALSE)
D2.os &lt;- D.os$order.2

## get 2nd order D matrix for general P-splines
## we can of course compute it with D.gps &lt;- SparseD(xt, d = 4, m = 2, gps = TRUE)
## but it is readily stored in the "sandwich" attribute of 'D.os'
D.gps &lt;- attr(D.os, "sandwich")$D
D2.gps &lt;- D.gps$order.2

## random B-spline coefficients
b &lt;- rnorm(ncol(D2.gps))

## two ways to evaluate a difference penalty
diff.b1 &lt;- DiffCoef(b, xt, d = 4, m = 2)  ## implicit
diff.b2 &lt;- as.numeric(D2.gps %*% b)       ## explicit
range(diff.b1 - diff.b2) / max(abs(diff.b1))

## several ways to evaluate a derivative penalty
sum(btSb(b, xt, d = 4, m = 2))  ## recommended
sum(as.numeric(D2.os %*% b) ^ 2)
S2.os &lt;- crossprod(D2.os); sum(b * as.numeric(S2.os %*% b))
</code></pre>


</div>