<div class="container">

<table style="width: 100%;"><tr>
<td>stat_peaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local maxima (peaks) or minima (valleys)</h2>

<h3>Description</h3>

<p><code>stat_peaks</code> finds at which x positions local y maxima are located and
<code>stat_valleys</code> finds at which x positions local y minima are located.
Both stats return a subset of <code>data</code> with rows matching for peaks or
valleys with formatted character labels added. The formatting is determined
by a format string compatible with <code>sprintf()</code> or <code>strftime()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_peaks(
  mapping = NULL,
  data = NULL,
  geom = "point",
  span = 5,
  ignore_threshold = 0,
  strict = FALSE,
  label.fmt = NULL,
  x.label.fmt = NULL,
  y.label.fmt = NULL,
  orientation = "x",
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_valleys(
  mapping = NULL,
  data = NULL,
  geom = "point",
  span = 5,
  ignore_threshold = 0,
  strict = FALSE,
  label.fmt = NULL,
  x.label.fmt = NULL,
  y.label.fmt = NULL,
  orientation = "x",
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>span</code></td>
<td>
<p>a peak is defined as an element in a sequence which is greater
than all other elements within a window of width span centered at that
element. The default value is 5, meaning that a peak is bigger than two
consecutive neighbors on each side. A <code>NULL</code> value for <code>span</code>
is taken as a span covering the whole of the data range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_threshold</code></td>
<td>
<p>numeric value between 0.0 and 1.0 indicating the size
threshold below which peaks will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>logical flag: if TRUE, an element must be strictly greater than
all other values in its window to be considered a peak. Default: FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
values into character strings by means of function <code>sprintf</code>
or <code>strptime</code>, its use is deprecated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $x$-values into character strings by means of function
<code>sprintf</code> or <code>strftime</code>. The default argument
varies depending on the scale in use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $y$-values into character strings by means of function
<code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either "x" or "y".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points
on this layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These stats use <code>geom_point</code> by default as it is the geom most
likely to work well in almost any situation without need of tweaking. The
default aesthetics set by these stats allow their direct use with
<code>geom_text</code>, <code>geom_label</code>, <code>geom_line</code>, <code>geom_rug</code>,
<code>geom_hline</code> and <code>geom_vline</code>. The formatting of the labels
returned can be controlled by the user.
</p>
<p>The default for parameter <code>strict</code> is <code>TRUE</code> in functions
<code>splus2R::peaks()</code> and <code>find_peaks()</code>, while the default is <code>FALSE</code>
in <code>stat_peaks()</code> and in <code>stat_valleys()</code>.
</p>


<h3>Returned and computed variables</h3>


<dl>
<dt>x</dt>
<dd>
<p>x-value at the peak (or valley) as numeric</p>
</dd>
<dt>y</dt>
<dd>
<p>y-value at the peak (or valley) as numeric</p>
</dd>
<dt>x.label</dt>
<dd>
<p>x-value at the peak (or valley) as character</p>
</dd>
<dt>y.label</dt>
<dd>
<p>y-value at the peak (or valley) as character</p>
</dd>
</dl>
<h3>Warning!</h3>

<p>The current version of these statistics do not support
passing <code>nudge_x</code> or <code>nurge_y</code> named parameters to the geometry.
Use 'position' and one of the position functions such as
<code>position_nudge_keep</code> instead.
</p>


<h3>Note</h3>

<p>These statistics check the scale of the <code>x</code> aesthetic and if it is
Date or Datetime they correctly generate the labels by transforming the
numeric <code>x</code> values to Date or POSIXct objects, respectively. In which
case the <code>x.label.fmt</code> must follow the syntax supported by
<code>strftime()</code> rather than by <code>sprintf()</code>. Overlap of labels with
points can avoided by use of one of the nudge positions, possibly together
with geometry <code>geom_text_s</code> from package
<code>ggpp</code>, or with <code>geom_text_repel</code> or
<code>geom_label_repel</code> from package
<code>ggrepel</code>. To discard overlapping labels use
<code>check_overlap = TRUE</code> as argument to <code>geom_text</code> or
<code>geom_text_s</code>. By default the labels are character values suitable to
be plotted as is, but with a suitable format passed as argument to
<code>label.fmt</code> labels suitable for parsing by the geoms (e.g. into
expressions containing Greek letters, super- or subscripts, maths symbols
or maths constructs) can be also easily obtained.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># lynx is a time.series object
lynx_num.df &lt;-
  try_tibble(lynx,
             col.names = c("year", "lynx"),
             as.numeric = TRUE) # years -&gt; as numeric

ggplot(lynx_num.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_valleys(colour = "blue")

ggplot(lynx_num.df, aes(lynx, year)) +
  geom_line(orientation = "y") +
  stat_peaks(colour = "red", orientation = "y") +
  stat_valleys(colour = "blue", orientation = "y")

ggplot(lynx_num.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red", geom = "rug")

ggplot(lynx_num.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red", geom = "text", hjust = -0.1, angle = 33)

ggplot(lynx_num.df, aes(lynx, year)) +
  geom_line(orientation = "y") +
  stat_peaks(colour = "red", orientation = "y") +
  stat_peaks(colour = "red", orientation = "y",
             geom = "text", hjust = -0.1)

lynx_datetime.df &lt;-
   try_tibble(lynx,
              col.names = c("year", "lynx")) # years -&gt; POSIXct

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_valleys(colour = "blue")

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red",
             geom = "text",
             hjust = -0.1,
             x.label.fmt = "%Y",
             angle = 33)

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red",
             geom = "text_s",
             position = position_nudge_keep(x = 0, y = 200),
             hjust = -0.1,
             x.label.fmt = "%Y",
             angle = 90) +
  expand_limits(y = 8000)

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red",
             geom = "text_s",
             position = position_nudge_to(y = 7600),
             arrow = arrow(length = grid::unit(1.5, "mm")),
             point.padding = 0.7,
             x.label.fmt = "%Y",
             angle = 90) +
  expand_limits(y = 9000)

</code></pre>


</div>