<div class="container">

<table style="width: 100%;"><tr>
<td>GM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multithreaded Gaussian mixture trainer
</h2>

<h3>Description</h3>

<p>The traditional training algorithm via maximum likelihood for parameterizing weighted data with a mixture of Gaussian PDFs. Bounds on covariance matrix eigen ratios and mixture weights are optional.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GM(
  X,
  Xw = rep(1, ncol(X)),
  alpha = numeric(0),
  mu = matrix(ncol = 0, nrow = 0),
  sigma = matrix(ncol = 0, nrow = 0),
  G = 5L,
  convergenceEPS = 1e-05,
  convergenceTail = 10,
  alphaEPS = 0,
  eigenRatioLim = Inf,
  embedNoise = 1e-6,
  maxIter = 1000L,
  maxCore = 7L,
  tlimit = 3600,
  verbose = TRUE,
  updateAlpha = TRUE,
  updateMean = TRUE,
  updateSigma = TRUE,
  checkInitialization = FALSE,
  KmeansFirst = TRUE,
  KmeansPPfirst = FALSE,
  KmeansRandomSeed = NULL,
  friendlyOutput = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>A <code>d x N</code> numeric matrix where <code>N</code> is the number of observations — each column is an observation, and <code>d</code> is the dimensionality. Column-observation representation promotes cache locality.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xw</code></td>
<td>

<p>A numeric vector of size <code>N</code>. <code>Xw[i]</code> is the weight on observation <code>X[, i]</code>. Users should normalize <code>Xw</code> such that the elements sum up to <code>N</code>. Default uniform weights for all observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>A numeric vector of size <code>K</code>, the number of Gaussian kernels in the mixture model. <code>alpha</code> are the initial mixture weights and should sum up to 1. Default empty.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>A <code>d x K</code> numeric matrix. <code>mu[, i]</code> is the initial mean for the <code>i</code>th Gaussian kernel. Default empty.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Either a list of <code>d x d</code> matrices, or a <code>d^2 x K</code> numeric matrix. For the latter, each column represents a flattened <code>d x d</code> initial covariance matrix of the <code>i</code>th Gaussian kernel. In R, <code>as.numeric(aMatrix)</code> gives the flattened version of <code>aMatrix</code>. Covariance matrix of each Gaussian kernel MUST be positive-definite. Default empty.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>

<p>An integer. If at least one of the parameters <code>alpha</code>, <code>mu</code>, <code>sigma</code> are empty, the program will initialize <code>G</code> Gaussian kernels via K-means++ deterministic initialization. See <code>KMppIni()</code>. Otherwise <code>G</code> is ignored. Default 5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergenceEPS</code></td>
<td>

<p>A numeric value. If the average change of all parameters in the mixture model is below <code>convergenceEPS</code> relative to those in the pervious iteration, the program ends. Checking convergence this way is faster than recomputing the log-likelihood every iteration. Default 1e-5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergenceTail</code></td>
<td>

<p>If every one of the last <code>convergenceTail</code> iteration produces less than a relative increase of <code>convergenceEPS</code> in log-likelihood, stop.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaEPS</code></td>
<td>

<p>A numeric value. During training, if any Gaussian kernel's weight is no greater than <code>alphaEPS</code>, the kernel is deleted. Default 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigenRatioLim</code></td>
<td>

<p>A numeric value. During training, if any Gaussian kernel's max:min eigen value ratio exceeds <code>eigenRatioLim</code>, the kernel is treated as degenerate and deleted. Thresholding eigen ratios is in the interest of minimizing the effect of degenerate kernels in an early stage. Default <code>Inf</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>embedNoise</code></td>
<td>

<p>A small constant added to the diagonal entries of all covariance matrices. This may prevent covariance matrices collapsing prematurely. A suggested value is 1e-6. Covariance degeneration is detected during Cholesky decomposition, and will lead the trainer to remove the corresponding mixture component. For high-dimensional problem, setting <code>embedNoise</code> to nonzero may pose the illusion of massive log-likelihood, all because one or more mixture components are so close to singular, which makes the densities around them extremely high.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>

<p>An integer, the maximal number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxCore</code></td>
<td>

<p>An integer. The maximal number of threads to invoke. Should be no more than the total number of logical processors on machine. Default 7.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tlimit</code></td>
<td>

<p>A numeric value. The program exits with the current model in <code>tlimit</code> seconds.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A boolean value. <code>TRUE</code> prints progress.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateAlpha</code></td>
<td>

<p>A boolean value or boolean vector. If a boolean value, <code>TRUE</code> implies weights on all mixture components are subject to update, otherwise they should stay unchanged during training. If a boolean vector, its size should equal the number of mixture components. <code>updateAlpha[i] == TRUE</code> implies the weight on the <code>i</code>th component is subject to update. Regardless of <code>updateAlpha</code>, the output will have normalized mixture weights.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateMean</code></td>
<td>

<p>A boolean value or a boolean vector. If a boolean value, <code>TRUE</code> implies means of all mixture components are subject to update, otherwise they should stay unchanged during training. If a boolean vector, its size should equal the number of mixture components. <code>updateMean[i] == TRUE</code> implies the mean of the <code>i</code>th component is subject to update.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>updateSigma</code></td>
<td>

<p>A boolean value or a boolean vector. If a boolean value, <code>TRUE</code> implies covariances of all mixture components are subject to update, otherwise they should stay unchanged during training. If a boolean vector, its size should equal the number of mixture components. <code>updateSigma[i] == TRUE</code> implies the covariance of the <code>i</code>th component is subject to update.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkInitialization</code></td>
<td>

<p>Check if any of the input covariance matrices are singular.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>KmeansFirst</code></td>
<td>

<p>A boolean value. Run K-means clustering for finding means.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>KmeansPPfirst</code></td>
<td>

<p>A boolean value. Run stochastic K-means++ for K-means initialization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>KmeansRandomSeed</code></td>
<td>

<p>An integer or <code>NULL</code>, the random seed for K-means++.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>friendlyOutput</code></td>
<td>

<p><code>TRUE</code> returns covariance matrices in a list rather than a single matrix of columns of flattened covariance matrices.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An in-place Cholesky decomposition of covariance matrix is implemented for space and speed efficiency. Only the upper triangle of the Cholesky decomposition is memorized for each Gaussian kernel, and it is then applied to a forward substitution routine for fast Mahalanobis distances computation. Each of the three main steps in an iteration — Gaussian density computation, parameter inference, parameter update — is multithreaded and hand-scheduled using Intel TBB. Extensive efforts have been made over cache-friendliness and extra multithreading overheads such as memory allocation.
</p>
<p>If <code>eigenRatioLim</code> is finite, eigen decomposition employs routines in <code>RcppArmadillo</code>.
</p>


<h3>Value</h3>

<p>A list of size 5:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>alpha </code></td>
<td>
<p>a numeric vector of size <code>K</code>. The mixture weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu </code></td>
<td>
<p>a <code>d x K</code> numeric matrix. Each column is the mean of a Gaussian kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma </code></td>
<td>
<p>a <code>d^2 x K</code> numeric matrix. Each column is the flattened covariance matrix of a Gaussian kernel. Do <code>matrix(sigma[, i], nrow = d)</code> to recover the covariance matrix of the <code>i</code>th kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted </code></td>
<td>
<p>a numeric vector of size <code>N</code>. <code>fitted[i]</code> is the probability density of the <code>i</code>th observation given by the mixture model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterMember </code></td>
<td>
<p>a list of <code>K</code> integer vectors, the hard clustering inferred from the mixture model. Each integer vector contains the indexes of observations in <code>X</code>.</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>For one-dimensional data, <code>X</code> should still follow the data structure requirements: a matrix where each column is an observation.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># =============================================================================
# Examples below use 1 thread to pass CRAN check. Speed advantage of multiple
# threads will be more pronounced for larger data.
# =============================================================================


# =============================================================================
# Parameterize the iris data. Let the function initialize Gaussian kernels.
# =============================================================================
X = t(iris[1:4])
# CRAN check only allows 2 threads at most. Increase `maxCore` for
# acceleration.
gmmRst = GMKMcharlie::GM(X, G = 4L, maxCore = 1L, friendlyOutput = FALSE)
str(gmmRst)




# =============================================================================
# Parameterize the iris data given Gaussian kernels.
# =============================================================================
G = 3L
d = nrow(X) # Dimensionality.
alpha = rep(1, G) / G
mu = X[, sample(ncol(X), G)] # Sample observations as initial means.
# Take the average variance and create initial covariance matrices.
meanVarOfEachDim = sum(diag(var(t(X)))) / d
covar = diag(meanVarOfEachDim / G, d)
covars = matrix(rep(as.numeric(covar), G), nrow = d * d)


# Models are sensitive to initialization.
gmmRst2 = GMKMcharlie::GM(
  X, alpha = alpha, mu = mu, sigma = covars, maxCore = 1L,
  friendlyOutput = FALSE)
str(gmmRst2)




# =============================================================================
# For fun, fit Rosenbrock function with a Gaussian mixture.
# =============================================================================
set.seed(123)
rosenbrock &lt;- function(x, y) {(1 - x) ^ 2 + 100 * (y - x ^ 2) ^ 2}
N = 2000L
x = runif(N, -2, 2)
y = runif(N, -1, 3)
z = rosenbrock(x, y)


X = rbind(x, y)
Xw = z * (N / sum(z)) # Weights on observations should sum up to N.
gmmFit = GMKMcharlie::GM(X, Xw = Xw, G = 5L, maxCore = 1L, verbose = FALSE,
  friendlyOutput = FALSE)


oldpar = par()$mfrow
par(mfrow = c(1, 2))
plot3D::points3D(x, y, z, pch = 20)
plot3D::points3D(x, y, gmmFit$fitted, pch = 20)
par(mfrow = oldpar)




# =============================================================================
# For fun, fit a 3D spiral distribution.
# =============================================================================
N = 2000
t = runif(N) ^ 2 * 15
x = cos(t) + rnorm(N) * 0.1
y = sin(t) + rnorm(N) * 0.1
z = t + rnorm(N) * 0.1


X = rbind(x, y, z)
d = 3L
G = 10L
gmmFit = GMKMcharlie::GM(X, G = G, maxCore = 1L, verbose = FALSE,
  KmeansFirst = TRUE, KmeansPPfirst = TRUE, KmeansRandomSeed = 42,
  friendlyOutput = TRUE)
# Sample N points from the Gaussian mixture.
ns = as.integer(round(N * gmmFit$alpha))
sampledPoints = list()
for(i in 1:G)
{
  sampledPoints[[i]] = MASS::mvrnorm(
    ns[i], mu = gmmFit$mu[, i], Sigma = matrix(gmmFit$sigma[[i]], nrow = d))
}
sampledPoints =
  matrix(unlist(lapply(sampledPoints, function(x) t(x))), nrow = d)


# Plot the original data and the samples from the mixture model.
oldpar = par()$mfrow
par(mfrow = c(1, 2))
plot3D::points3D(x, y, z, pch = 20)
plot3D::points3D(x = sampledPoints[1, ],
                 y = sampledPoints[2, ],
                 z = sampledPoints[3, ], pch = 20)
par(mfrow = oldpar)




# =============================================================================
# For fun, fit a 3D spiral distribution. Fix parameters at random.
# =============================================================================
N = 2000
t = runif(N) ^ 2 * 15
x = cos(t) + rnorm(N) * 0.1
y = sin(t) + rnorm(N) * 0.1
z = t + rnorm(N) * 0.1


X = rbind(x, y, z); dimnames(X) = NULL
d = 3L
G = 10L
mu = X[, sample(ncol(X), G)]
s = matrix(rep(as.numeric(cov(t(X))), G), ncol = G)
alpha = rep(1 / G, G)
updateAlpha = sample(c(TRUE, FALSE), G, replace = TRUE)
updateMean = sample(c(TRUE, FALSE), G, replace = TRUE)
updateSigma = sample(c(TRUE, FALSE), G, replace = TRUE)
gmmFit = GMKMcharlie::GM(X, alpha = alpha, mu = mu, sigma = s, G = G,
                         maxCore = 2, verbose = FALSE,
                         updateAlpha = updateAlpha,
                         updateMean = updateMean,
                         updateSigma = updateSigma,
                         convergenceEPS = 1e-5, alphaEPS = 1e-8,
                         friendlyOutput = TRUE)
</code></pre>


</div>