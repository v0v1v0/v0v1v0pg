<div class="container">

<table style="width: 100%;"><tr>
<td>breakpoints.glogisfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Segmented Fitting of the Generalized Logistic Distribution</h2>

<h3>Description</h3>

<p>Fitting univariate generalized logisitc distributions (Type I: skew-logistic with
location, scale, and shape parameters) to segments of time series data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'glogisfit'
breakpoints(obj, h = 0.15, breaks = NULL, ic = "LWZ",
  hpc = "none", ...)

## S3 method for class 'breakpoints.glogisfit'
refit(object, ...)

## S3 method for class 'breakpoints.glogisfit'
coef(object, log = TRUE, ...)

## S3 method for class 'breakpoints.glogisfit'
fitted(object, type = c("mean", "variance", "skewness"), ...)

## S3 method for class 'breakpoints.glogisfit'
confint(object, parm = NULL, level = 0.95, breaks = NULL, 
  meat. = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>an object of class <code>glogisfit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>numeric. Minimal segment size either given as fraction relative to the
sample size or as an integer giving the minimal number of observations
in each segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>integer specifying the maximal number of breaks to be calculated.
By default the maximal number allowed by <code>h</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic</code></td>
<td>
<p>character specifying the default information criterion that should
be employed for selecting the number of breakpoints. Default is <code>"LWZ"</code>
(Liu-Wu-Zidek criterion, a modified BIC). Instead the classic <code>"BIC"</code>
can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hpc</code></td>
<td>
<p>a character specifying the high performance computing support.
Default is <code>"none"</code>, can be set to <code>"foreach"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>breakpoints.glogisfit</code> as returned by
the <code>breakpoints</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical option in <code>coef</code> method indicating whether scale and
shape parameters should be reported in logs (default) or the original
levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character specifying which moments of the segmented fitted distribution
should be extracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>integer. Either <code>parm</code> or <code>breaks</code> may be set, see below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>numeric. The confidence level to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meat.</code></td>
<td>
<p>function. A function for extracting the meat of a sandwich estimator
from a fitted object. By default, the inverse of <code>bread</code>
is used, i.e., a correctly specified model is assumed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To test whether sequences (typically time series) of observations follow the same
generalized logistic distribution, the stability of the parameters can be tested.
If there is evidence for parameter instability, breakpoints can be estimated to
find segments with stable parameters.
</p>
<p>The methods from the <span class="pkg">strucchange</span> and <span class="pkg">fxregime</span> packages are leveraged.
For testing, the generalized M-fluctuation tests from <span class="pkg">strucchange</span> can directly
be employed using <code>gefp</code>. For breakpoint estimation,
the methods documented here provide a user interface to some internal functionality
from the <span class="pkg">fxregime</span> packages. They employ the (unexported) workhorse function
<code>gbreakpoints</code> which is modeled after <code>breakpoints</code> 
from the <span class="pkg">strucchange</span> package but employing user-defined estimation methods.
</p>
<p>Optional support for high performance computing is available in the <code>breakpoints</code>
method based on the <span class="pkg">foreach</span> package for the dynamic programming algorithm.
If <code>hpc = "foreach"</code> is to be used, a parallel backend should be registered
before. See <code>breakpoints</code> for more information.
</p>


<h3>Value</h3>

<p><code>breakpoints.glogisfit</code> returns an object of class <code>"breakpoints.glogisfit"</code> that
inherits from <code>"gbreakpointsfull"</code>.
</p>


<h3>References</h3>

<p>Windberger T, Zeileis A (2014). Structural Breaks in Inflation Dynamics within the
European Monetary Union. <em>Eastern European Economics</em>, <b>52</b>(3), 66–88.
</p>
<p>Zeileis A, Shah A, Patnaik I (2010). Testing, Monitoring, and Dating Structural
Changes in Exchange Rate Regimes. <em>Computational Statistics and Data Analysis</em>,
<b>54</b>(6), 1696–1706. doi: <a href="https://doi.org/10.1016/j.csda.2009.12.005">10.1016/j.csda.2009.12.005</a>.
</p>


<h3>See Also</h3>

<p><code>glogisfit</code>, <code>fxregimes</code>, <code>breakpoints</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## artifical data with one structural change
set.seed(1071)
x &lt;- c(rglogis(50, -1, scale = 0.5, shape = 3), rglogis(50, 1, scale = 0.5, shape = 1))
x &lt;- zoo(x, yearmon(seq(2000, by = 1/12, length = 100)))

## full sample estimation
gf &lt;- glogisfit(x)

if(require("strucchange")) {

## structural change testing
gf_scus &lt;- gefp(gf, fit = NULL)
plot(gf_scus, aggregate = FALSE)
plot(gf_scus, functional = meanL2BB)
sctest(gf_scus)
sctest(gf_scus, functional = meanL2BB)


## breakpoint estimation
gf_bp &lt;- breakpoints(gf)
plot(gf_bp)
summary(gf_bp)
breakdates(gf_bp)
coef(gf_bp)
confint(gf_bp)

## fitted model
plot(x)
lines(gf_bp)
lines(fitted(gf_bp, type = "mean"), col = 4)
lines(confint(gf_bp))

}
</code></pre>


</div>