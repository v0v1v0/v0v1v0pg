<div class="container">

<table style="width: 100%;"><tr>
<td>getopt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>C-like getopt behavior</h2>

<h3>Description</h3>

<p><code>getopt</code> is primarily intended to be used with <code>Rscript</code>.  It
facilitates writing <code style="white-space: pre;">⁠#!⁠</code> shebang scripts that accept short and long
flags/options.  It can also be used from <code>R</code> directly, but is probably less
useful in this context.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getopt(
  spec = NULL,
  opt = NULL,
  command = get_Rscript_filename(),
  usage = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>The getopt specification, or spec of what options are considered
valid.  The specification must be either a 4-5 column matrix, or a
character vector coercible into a 4 column matrix using
<code>matrix(x,ncol=4,byrow=TRUE)</code> command.  The matrix/vector
contains:
</p>
<p>Column 1: the <em>long flag</em> name.  A multi-character string.
</p>
<p>Column 2: <em>short flag</em> alias of Column 1.  A single-character
string.
</p>
<p>Column 3: <em>Argument</em> mask of the <em>flag</em>.  An integer.
Possible values: 0=no argument, 1=required argument, 2=optional argument.
</p>
<p>Column 4: Data type to which the <em>flag</em>'s argument shall be cast using
<code>storage.mode()</code>.  A multi-character string.  This only considered
for same-row Column 3 values of 1,2.  Possible values: logical,
integer, double, complex, character.
If numeric is encountered then it will be converted to double.
</p>
<p>Column 5 (optional): A brief description of the purpose of the option.
</p>
<p>The terms <em>option</em>, <em>flag</em>, <em>long flag</em>, <em>short flag</em>,
and <em>argument</em> have very specific meanings in the context of this
document.  Read the “Description” section for definitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt</code></td>
<td>
<p>This defaults to the return value of <code>commandArgs(TRUE)</code> unless
<code>argv</code> is in the global environment in which case it uses that instead
(this is for compatibility with <code>littler</code>).
</p>
<p>If R was invoked directly via the <code>R</code> command, this corresponds to all
arguments passed to R after the <code>--args</code> flag.
</p>
<p>If R was invoked via the <code>Rscript</code> command, this corresponds to all
arguments after the name of the R script file.
</p>
<p>Read about <code>commandArgs()</code> and Rscript to learn more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>command</code></td>
<td>
<p>The string to use in the usage message as the name of the
script.  See argument <em>usage</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>usage</code></td>
<td>
<p>If <code>TRUE</code>, argument <code>opt</code> will be ignored and a usage
statement (character string) will be generated and returned from <code>spec</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>This is used internally to debug the <code>getopt()</code> function itself.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>getopt()</code> returns a list data structure containing names of the
flags that were present in the character vector passed in under
the <code>opt</code> argument.  Each value of the list is coerced to the
data type specified according to the value of the <code>spec</code> argument.  See
below for details.
</p>
<p>Notes on naming convention:
</p>

<ol>
<li>
<p> An <em>option</em> is one of the shell-split input strings.
</p>
</li>
<li>
<p> A <em>flag</em> is a type of <em>option</em>.  a <em>flag</em> can be defined as
having no <em>argument</em> (defined below), a required <em>argument</em>, or an
optional <em>argument</em>.
</p>
</li>
<li>
<p> An <em>argument</em> is a type of <em>option</em>, and is the value associated
with a flag.
</p>
</li>
<li>
<p> A <em>long flag</em> is a type of <em>flag</em>, and begins with the string
<code style="white-space: pre;">⁠--⁠</code>.  If the <em>long flag</em> has an associated <em>argument</em>, it may be
delimited from the <em>long flag</em> by either a trailing <code>=</code>, or may be
the subsequent <em>option</em>.
</p>
</li>
<li>
<p> A <em>short flag</em> is a type of <em>flag</em>, and begins with the string
<code>-</code>.  If a <em>short flag</em> has an associated <em>argument</em>, it is the
subsequent <em>option</em>.  <em>short flags</em> may be bundled together,
sharing a single leading <code>-</code>, but only the final <em>short flag</em> is able
to have a corresponding <em>argument</em>.
</p>
</li>
</ol>
<p>Many users wonder whether they should use the <code>getopt</code> package, <code>optparse</code> package,
or <code>argparse</code> package.
Here is some of the major differences:
</p>
<p>Features available in <code>getopt</code> unavailable in <code>optparse</code>
</p>

<ol><li>
<p> As well as allowing one to specify options that take either
no argument or a required argument like <code>optparse</code>,
<code>getopt</code> also allows one to specify option with an optional argument.
</p>
</li></ol>
<p>Some features implemented in <code>optparse</code> package unavailable in <code>getopt</code>
</p>

<ol>
<li>
<p> Limited support for capturing positional arguments after the optional arguments
when <code>positional_arguments</code> set to <code>TRUE</code> in <code>optparse::parse_args()</code>
</p>
</li>
<li>
<p> Automatic generation of an help option and printing of help text when encounters an <code>-h</code>
</p>
</li>
<li>
<p> Option to specify default arguments for options as well the
variable name to store option values
</p>
</li>
</ol>
<p>There is also new package <code>argparse</code> introduced in 2012 which contains
all the features of both getopt and optparse but which has a dependency on
Python 2.7 or 3.2+.
</p>
<p>Some Features unlikely to be implemented in <code>getopt</code>:
</p>

<ol>
<li>
<p> Support for multiple, identical flags, e.g. for <code style="white-space: pre;">⁠-m 3 -v 5 -v⁠</code>, the
trailing <code>-v</code> overrides the preceding <code style="white-space: pre;">⁠-v 5⁠</code>, result is <code>v=TRUE</code> (or equivalent
typecast).
</p>
</li>
<li>
<p> Support for multi-valued flags, e.g. <code style="white-space: pre;">⁠--libpath=/usr/local/lib --libpath=/tmp/foo⁠</code>.
</p>
</li>
<li>
<p> Support for lists, e.g. <code style="white-space: pre;">⁠--define os=linux --define os=redhat⁠</code> would
set <code>result$os$linux=TRUE</code> and <code>result$os$redhat=TRUE</code>.
</p>
</li>
<li>
<p> Support for incremental, argument-less flags, e.g. <code style="white-space: pre;">⁠/path/to/script -vvv⁠</code> should set <code>v=3</code>.
</p>
</li>
<li>
<p> Support partial-but-unique string match on options, e.g. <code>--verb</code> and
<code>--verbose</code> both match long flag <code>--verbose</code>.
</p>
</li>
<li>
<p> No support for mixing in positional arguments or extra arguments that
don't match any options.  For example, you can't do <code style="white-space: pre;">⁠my.R --arg1 1 foo bar baz⁠</code> and recover <code>foo</code>, <code>bar</code>, <code>baz</code> as a list.  Likewise for <code style="white-space: pre;">⁠my.R foo --arg1 1 bar baz⁠</code>.
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Allen Day
</p>


<h3>Examples</h3>

<pre><code class="language-R">#!/path/to/Rscript
library('getopt')
# get options, using the spec as defined by the enclosed list.
# we read the options from the default: commandArgs(TRUE).
spec = matrix(c(
  'verbose', 'v', 2, "integer",
  'help'   , 'h', 0, "logical",
  'count'  , 'c', 1, "integer",
  'mean'   , 'm', 1, "double",
  'sd'     , 's', 1, "double"
), byrow=TRUE, ncol=4)
opt = getopt(spec)

# if help was asked for print a friendly message
# and exit with a non-zero error code
if (!is.null(opt$help)) {
  cat(getopt(spec, usage = TRUE))
  q(status = 1)
}

# set some reasonable defaults for the options that are needed,
# but were not specified.
if (is.null(opt$mean)) opt$mean &lt;- 0
if (is.null(opt$sd)) opt$sd &lt;- 1
if (is.null(opt$count)) opt$count &lt;- 10
if (is.null(opt$verbose)) opt$verbose &lt;- FALSE

# print some progress messages to stderr, if requested.
if (opt$verbose) write("writing...", stderr())

# do some operation based on user input.
cat(rnorm(opt$count, mean = opt$mean, sd = opt$sd), sep = "\n")

# signal success and exit.
# q(status=0)
</code></pre>


</div>