<div class="container">

<table style="width: 100%;"><tr>
<td>sftrans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transform filter band edges</h2>

<h3>Description</h3>

<p>Transform band edges of a generic lowpass filter to a filter with different
band edges and to other filter types (high pass, band pass, or band stop).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sftrans(Sz, ...)

## S3 method for class 'Zpg'
sftrans(Sz, w, stop = FALSE, ...)

## S3 method for class 'Arma'
sftrans(Sz, w, stop = FALSE, ...)

## Default S3 method:
sftrans(Sz, Sp, Sg, w, stop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sz</code></td>
<td>
<p>In the generic case, a model to be transformed. In the default case,
a vector containing the zeros in a pole-zero-gain model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to the generic function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>critical frequencies of the target filter specified in radians.
<code>w</code> must be a scalar for low-pass and high-pass filters, and <code>w</code>
must be a two-element vector c(low, high) specifying the lower and upper
bands in radians.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop</code></td>
<td>
<p>FALSE for a low-pass or band-pass filter, TRUE for a high-pass or
band-stop filter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sp</code></td>
<td>
<p>a vector containing the poles in a pole-zero-gain model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sg</code></td>
<td>
<p>a vector containing the gain in a pole-zero-gain model.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a low pass filter represented by poles and zeros in the splane, you can
convert it to a low pass, high pass, band pass or band stop by transforming
each of the poles and zeros individually. The following summarizes the
transformations:

</p>
<pre>

  Transform         Zero at x                  Pole at x
  ----------------  -------------------------  --------------------------
  Low-Pass          zero: Fc x/C               pole: Fc x/C
  S -&gt; C S/Fc       gain: C/Fc                 gain: Fc/C
  ----------------  -------------------------  --------------------------
  High Pass         zero: Fc C/x               pole: Fc C/x
  S -&gt; C Fc/S       pole: 0                    zero: 0
                    gain: -x                   gain: -1/x
  ----------------  -------------------------  --------------------------
  Band Pass         zero: b +- sqrt(b^2-FhFl)  pole: b +- sqrt(b^2-FhFl)
         S^2+FhFl   pole: 0                    zero: 0
  S -&gt; C --------   gain: C/(Fh-Fl)            gain: (Fh-Fl)/C
         S(Fh-Fl)   b=x/C (Fh-Fl)/2            b=x/C (Fh-Fl)/2
  ----------------  -------------------------  --------------------------
  Band Stop         zero: b +- sqrt(b^2-FhFl)  pole: b +- sqrt(b^2-FhFl)
         S(Fh-Fl)   pole: +-sqrt(-FhFl)        zero: +-sqrt(-FhFl)
  S -&gt; C --------   gain: -x                   gain: -1/x
         S^2+FhFl   b=C/x (Fh-Fl)/2            b=C/x (Fh-Fl)/2
  ----------------  -------------------------  --------------------------
  Bilinear          zero: (2+xT)/(2-xT)        pole: (2+xT)/(2-xT)
       2 z-1        pole: -1                   zero: -1
  S -&gt; -----        gain: (2-xT)/T             gain: (2-xT)/T
       T z+1
  ----------------  -------------------------  --------------------------
</pre>
<p>where C is the cutoff frequency of the initial lowpass filter, F_c is the
edge of the target low/high pass filter and [F_l,F_h] are the edges of the
target band pass/stop filter. With abundant tedious algebra, you can derive
the above formulae yourself by substituting the transform for S into
<code class="reqn">H(S)=S-x</code> for a zero at x or <code class="reqn">H(S)=1/(S-x)</code> for a pole at x, and
converting the result into the form:
</p>
<p style="text-align: center;"><code class="reqn">g prod(S-Xi) / prod(S-Xj)</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel. This is
significant for High Pass, Band Pass and Band Stop filters which create
numerous extra poles and zeros, most of which cancel. Those which do not
cancel have a fill-in effect, extending the shorter of the sets to have the
same number of as the longer of the sets of poles and zeros (or at least
split the difference in the case of the band pass filter). There may be other
opportunistic cancellations, but it does not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in an
unstable filter. Because of cancellation, this will only happen if the number
of poles is smaller than the number of zeros and the filter is high pass or
band pass. The analytic design methods all yield more poles than zeros, so
this will not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for sftrans.Zpg, an object of class "Zpg",
containing the list elements:
</p>

<dl>
<dt>z</dt>
<dd>
<p>complex vector of the zeros of the transformed model</p>
</dd>
<dt>p</dt>
<dd>
<p>complex vector of the poles of the transformed model</p>
</dd>
<dt>g</dt>
<dd>
<p>gain of the transformed model</p>
</dd>
</dl>
<p>For sftrans.Arma, an object of class "Arma", containing the list elements:
</p>

<dl>
<dt>b</dt>
<dd>
<p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt>
<dd>
<p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>.<br>
Conversion to R by Tom Short,<br>
adapted by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>Proakis &amp; Manolakis (1992). <em>Digital Signal Processing</em>. New
York: Macmillan Publishing Company.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 6th order Bessel bandpass
zpg &lt;- besselap(6)
bp &lt;- sftrans(zpg, c(2, 3), stop = TRUE)
freqs(bp, seq(0, 4, length.out = 128))
bp &lt;- sftrans(zpg, c(0.1,0.3), stop = FALSE)
freqs(bp, seq(0, 4, length.out = 128))

</code></pre>


</div>