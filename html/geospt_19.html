<div class="container">

<table style="width: 100%;"><tr>
<td>network.design</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generating <code>AKSE</code> associated with a conditioned network design
</h2>

<h3>Description</h3>

<p>Generates a sampling network for a given sampling distance or type (configuration), and calculates the average kriging standard error (<code>AKSE</code>) associated with the spatial configuration for a given predefined variogram
</p>


<h3>Usage</h3>

<pre><code class="language-R">network.design(formula, vgm.model, xmin, xmax, ymin, ymax, npoint.x, npoint.y,
npoints, boundary=NULL, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name z, for ordinary and simple kriging use the formula <code>z~1</code>; for simple kriging also define beta (see below); for universal kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>, use the formula <code>z~x+y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vgm.model</code></td>
<td>
<p>variogram model of dependent variable (or its residuals), defined by a call to vgm or fit.variogram</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoint.x</code></td>
<td>
<p>number of points to generate on the <code>x</code>-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoint.y</code></td>
<td>
<p>number of points to generate on the <code>y</code>-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoints</code></td>
<td>
<p>(approximate) sample size inside (shapefile) border</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmin</code></td>
<td>
<p>minimum <code>x</code>-coordinate of the study area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ymin</code></td>
<td>
<p>minimum <code>y</code>-coordinate of the study area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmax</code></td>
<td>
<p>maximum <code>x</code>-coordinate of the study area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ymax</code></td>
<td>
<p>maximum <code>y</code>-coordinate of the study area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>SpatialPolygons or SpatialPolygonsDataFrame object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character; "random" for completely spatial random; "regular" for regular (systematically aligned) sampling; "stratified" for stratified random (one single random location in each "cell"); "nonaligned" for nonaligned systematic sampling (nx random y coordinates, ny random x coordinates); "hexagonal" for sampling on a hexagonal lattice; "clustered" for clustered sampling; "Fibonacci" for Fibonacci sampling on the sphere (see references). By default type ="regular".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments will be passed of the <code>krige</code> and <code>spsample</code> functions.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>returns the <code>AKSE</code> value associated with the spatial distribution of points and the kriging method used.
</p>


<h3>References</h3>

<p>Fibonacci sampling: Alvaro Gonzalez, 2010. <em>Measurement of Areas on a Sphere Using Fibonacci and Latitude-Longitude Lattices</em>. Mathematical Geosciences 42(1), p. 49-64
</p>


<h3>See Also</h3>

<p><code>krige</code>,  <code>krige.cv</code>, <code>spsample</code>, <code>point.in.polygon</code>, <code>sample</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
### regular grid 10x10
vgmok &lt;- vgm(112.33, "Sph", 4.3441,0)
vgmsk &lt;- vgm(74.703, "Sph", 3.573,0)
vgmuk &lt;- vgm(53.064, "Sph", 2.8858,0)
vgmuk2 &lt;- vgm(19.201, "Sph", 1.5823,0)
# network: ordinary kriging (without boundary)
net1.ok &lt;- network.design(z~1,vgmok, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=10,
    npoint.y=10, nmax=6)
net2.ok &lt;- network.design(z~1,vgmok, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=20,
    npoint.y=20, nmax=6)
# it's worth noting that the variograms are different in each kriging

# network: simple kriging (without boundary)

net1.sk &lt;- network.design(z~1,vgmsk, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=10,
    npoint.y=10, nmax=6, beta=2)
net2.sk &lt;- network.design(z~1,vgmsk, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=20,
    npoint.y=20, nmax=6, beta=2)
# network: universal kriging, second order trend (without boundary)
net1.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2),vgmuk, xmin=0,xmax=10, ymin=0,
    ymax=10, npoint.x=10, npoint.y=10, nmax=8)
net2.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2),vgmuk2, xmin=0,xmax=10, ymin=0,
    ymax=10, npoint.x=20, npoint.y=20, nmax=8)


# Creating the grid with the prediction and plotting points
library(geoR)
data(ca20)
Sr1 &lt;- Polygon(ca20$borders)
Srs1 = Polygons(list(Sr1), "s1")
Polygon = SpatialPolygons(list(Srs1))
vgmok.ca &lt;- vgm(112.33, "Sph", 244.9,0)
vgmsk.ca &lt;- vgm(100, "Sph", 150.2,0)
vgmuk.ca &lt;- vgm(85.57, "Sph", 110.5,0)
vgmuk2.ca &lt;- vgm(62.14, "Sph", 89.7,0)

# network: ordinary kriging (with boundary)
netb1.ok&lt;- network.design(z~1, vgmok.ca, npoints=50, boundary=Polygon, nmax=6)
netb2.ok&lt;- network.design(z~1, vgmok.ca, npoints=100, boundary=Polygon, nmax=6)
# network: simple kriging (with boundary)
netb1.sk &lt;- network.design(z~1, vgmsk.ca, npoints=50, boundary=Polygon, nmax=6, beta=2)
netb2.sk &lt;- network.design(z~1, vgmsk.ca, npoints=100, boundary=Polygon, nmax=6, beta=2)
# network: universal kriging, second order trend (with boundary)
netb1.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2), vgmuk.ca, npoints=50,
    boundary=Polygon, nmax=8)
netb2.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2), vgmuk2.ca, npoints=100,
    boundary=Polygon, nmax=8)

## End(Not run)
</code></pre>


</div>