<div class="container">

<table style="width: 100%;"><tr>
<td>GeneralizedHyperbolicDistribution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Hyperbolic Distribution</h2>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and random number
generation for the generalized hyperbolic distribution, with
parameters <code class="reqn">\alpha</code> (tail), <code class="reqn">\beta</code> (skewness),
<code class="reqn">\delta</code> (peakness), <code class="reqn">\mu</code> (location) and
<code class="reqn">\lambda</code> (shape).
</p>


<h3>Usage</h3>

<pre><code class="language-R">dghyp(x, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda))
pghyp(q, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda),
      lower.tail = TRUE, subdivisions = 100,
      intTol = .Machine$double.eps^0.25, valueOnly = TRUE, ...)
qghyp(p, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda),
      lower.tail = TRUE, method = c("spline","integrate"),
      nInterpol = 501, uniTol = .Machine$double.eps^0.25,
      subdivisions = 100, intTol = uniTol, ...)
rghyp(n, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
      param = c(mu, delta, alpha, beta, lambda))
ddghyp(x, mu = 0, delta = 1, alpha = 1, beta = 0, lambda = 1,
       param = c(mu, delta, alpha, beta, lambda))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,q</code></td>
<td>
<p>Vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of random variates to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Location parameter <code class="reqn">\mu</code>, default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Scale parameter <code class="reqn">\delta</code>, default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Tail parameter <code class="reqn">\alpha</code>, default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Skewness parameter <code class="reqn">\beta</code>, default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Shape parameter <code class="reqn">\lambda</code>, default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>Specifying the parameters as a vector of the form<br><code>c(mu,delta,alpha,beta,lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>Logical. If <code>TRUE</code>, probabilities are
<code class="reqn">P(X\leq x)</code>, otherwise they are <code class="reqn">P(X&gt;x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subdivisions</code></td>
<td>
<p>The maximum number of subdivisions used to
integrate the density and determine the accuracy of the distribution
function calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intTol</code></td>
<td>
<p>Value of <code>rel.tol</code> and hence <code>abs.tol</code> in
calls to <code>integrate</code>. See <code>integrate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valueOnly</code></td>
<td>
<p>Logical. If <code>valueOnly = TRUE</code> calls to
<code>pghyp</code> only return the value obtained for the integral.
If <code>valueOnly = FALSE</code> an estimate of the
accuracy of the numerical integration is also returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nInterpol</code></td>
<td>
<p>Number of points used in <code>qghyp</code> for cubic
spline interpolation of the distribution function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uniTol</code></td>
<td>
<p>Value of <code>tol</code> in
calls to <code>uniroot</code>. See <code>uniroot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Passes additional arguments to <code>integrate</code> in
<code>pghyp</code> and <code>qghyp</code>, and to <code>uniroot</code> in
<code>qghyp</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Users may either specify the values of the parameters individually or
as a vector. If both forms are specified, then the values specified by
the vector <code>param</code> will overwrite the other ones. In addition the
parameter values are examined by calling the function
<code>ghypCheckPars</code> to see if they are valid.
</p>
<p>The density function is
</p>
<p style="text-align: center;"><code class="reqn">f(x)=c(\lambda,\alpha,\beta,\delta)\times%
    \frac{K_{\lambda-1/2}(\alpha\sqrt{\delta^2+(x-\mu)^2})}%
    {(\frac{\sqrt{\delta^2+(x-\mu)^2}}{\alpha})^{1/2-\lambda}}%
    e^{\beta(x-\mu)}</code>
</p>

<p>where <code class="reqn">K_\nu()</code> is the modified Bessel function of the
third kind with order <code class="reqn">\nu</code>, and
</p>
<p style="text-align: center;"><code class="reqn">c(\lambda,\alpha,\beta,\delta)=%
    \frac{(\frac{\sqrt{\alpha^2-\beta^2}}{\delta})^\lambda}%
    {\sqrt{2\pi}K_\lambda(\delta\sqrt{\alpha^2-\beta^2})}</code>
</p>

<p>Use <code>ghypChangePars</code> to convert from the
<code class="reqn">(\rho, \zeta)</code>,
<code class="reqn">(\xi, \chi)</code>,
<code class="reqn">(\bar\alpha, \bar\beta)</code>, or
<code class="reqn">(\pi, \zeta)</code> parameterizations
to the <code class="reqn">(\alpha, \beta)</code> parameterization used
above.
</p>
<p><code>pghyp</code> uses the function <code>integrate</code> to
numerically integrate the density function. The integration is from
<code>-Inf</code> to <code>x</code> if <code>x</code> is to the left of the mode, and
from <code>x</code> to <code>Inf</code> if <code>x</code> is to the right of the
mode. The probability calculated this way is subtracted from 1 if
required. Integration in this manner appears to make calculation of
the quantile function more stable in extreme cases.
</p>
<p>Calculation of quantiles using <code>qghyp</code> permits the use of two
different methods. Both methods use <code>uniroot</code> to find the value
of <code class="reqn">x</code> for which a given <code class="reqn">q</code> is equal <code class="reqn">F(x)</code> where <code class="reqn">F</code>
denotes the cumulative distribution function. The difference is in how
the numerical approximation to <code class="reqn">F</code> is obtained. The obvious
and more accurate method is to calculate the value of <code class="reqn">F(x)</code>
whenever it is required using a call to <code>pghyp</code>. This is what
is done if the method is specified as <code>"integrate"</code>. It is clear
that the time required for this approach is roughly linear in the
number of quantiles being calculated. A Q-Q plot of a large data set
will clearly take some time. The alternative (and default) method is
that for the major part of the distribution a spline approximation to
<code class="reqn">F(x)</code> is calculated and quantiles found using <code>uniroot</code> with
this approximation. For extreme values (for which the tail probability
is less than <code class="reqn">10^{-7}</code>), the integration method is still
used even when the method specifed is <code>"spline"</code>.
</p>
<p>If accurate probabilities or quantiles are required, tolerances
(<code>intTol</code> and <code>uniTol</code>) should be set to small values, say
<code class="reqn">10^{-10}</code> or <code class="reqn">10^{-12}</code> with <code>method
  = "integrate"</code>. Generally then accuracy might be expected to be at
least <code class="reqn">10^{-9}</code>. If the default values of the functions
are used, accuracy can only be expected to be around
<code class="reqn">10^{-4}</code>. Note that on 32-bit systems
<code>.Machine$double.eps^0.25 = 0.0001220703</code> is a typical value.
</p>


<h3>Value</h3>

<p><code>dghyp</code> gives the density function, <code>pghyp</code> gives the
distribution function, <code>qghyp</code> gives the quantile function and
<code>rghyp</code> generates random variates.
</p>
<p>An estimate of the accuracy of the approximation to the distribution
function can be found by setting <code>valueOnly = FALSE</code> in the call to
<code>pghyp</code> which returns a list with components <code>value</code> and
<code>error</code>.
</p>
<p><code>ddghyp</code> gives the derivative of <code>dghyp</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O., and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S., and Read, C. B., Vol. 3,
pp. 700–707.-New York: Wiley.
</p>
<p>Bibby, B. M., and Sörenson,M. (2003).
Hyperbolic processes in finance.
In <em>Handbook of Heavy Tailed Distributions in Finance</em>,ed.,
Rachev, S. T. pp. 212–248. Elsevier Science B.~V.
</p>
<p>Dagpunar, J.S. (1989).
An easily implemented generalised inverse Gaussian generator
<em>Commun. Statist.-Simula.</em>, <b>18</b>, 703–710.
</p>
<p>Prause, K. (1999) <em>The generalized hyperbolic models: Estimation,
financial derivatives and risk measurement.</em> PhD Thesis, Mathematics
Faculty, University of Freiburg.
</p>


<h3>See Also</h3>

<p><code>dhyperb</code> for the hyperbolic distribution,
<code>dgig</code> for the generalized inverse Gaussian distribution,
<code>safeIntegrate</code>,
<code>integrate</code> for its shortfalls, also
<code>splinefun</code>, <code>uniroot</code> and
<code>ghypChangePars</code> for changing parameters to the
<code class="reqn">(\alpha,\beta)</code> parameterization.
</p>


<h3>Examples</h3>

<pre><code class="language-R">param &lt;- c(0, 1, 3, 1, 1/2)
ghypRange &lt;- ghypCalcRange(param = param, tol = 10^(-3))
par(mfrow = c(1, 2))

### curves of density and distribution
curve(dghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
title("Density of the \n Generalized  Hyperbolic Distribution")
curve(pghyp(x, param = param), ghypRange[1], ghypRange[2], n = 500)
title("Distribution Function of the \n Generalized Hyperbolic Distribution")

### curves of density and log density
par(mfrow = c(1, 2))
data &lt;- rghyp(1000, param = param)
curve(dghyp(x, param = param), range(data)[1], range(data)[2],
      n = 1000, col = 2)
hist(data, freq = FALSE, add = TRUE)
title("Density and Histogram of the\n Generalized Hyperbolic Distribution")
DistributionUtils::logHist(data,
    main = "Log-Density and Log-Histogram of\n the Generalized Hyperbolic Distribution")
curve(log(dghyp(x, param = param)),
      range(data)[1], range(data)[2],
      n = 500, add = TRUE, col = 2)

### plots of density and derivative
par(mfrow = c(2, 1))
curve(dghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
title("Density of the\n Generalized  Hyperbolic Distribution")
curve(ddghyp(x, param = param), ghypRange[1], ghypRange[2], n = 1000)
title("Derivative of the Density of the\n Generalized Hyperbolic Distribution")
</code></pre>


</div>