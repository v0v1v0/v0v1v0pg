<div class="container">

<table style="width: 100%;"><tr>
<td>foreccomb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Format Raw Data for Forecast Combination</h2>

<h3>Description</h3>

<p>Structures cross-sectional input data (individual model forecasts) for forecast combination. Stores data as S3 class
<code>foreccomb</code> that serves as input to the forecast combination techniques. Handles missing value imputation (optional) and resolves
problems due to perfect collinearity.
</p>


<h3>Usage</h3>

<pre><code class="language-R">foreccomb(observed_vector, prediction_matrix, newobs = NULL,
  newpreds = NULL, byrow = FALSE, na.impute = TRUE, criterion = "RMSE")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>observed_vector</code></td>
<td>
<p>A vector or univariate time series; contains ‘actual values’ for training set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction_matrix</code></td>
<td>
<p>A matrix or multivariate time series; contains individual model forecasts for training set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newobs</code></td>
<td>
<p>A vector or univariate time series; contains ‘actual values’ if a test set is used (optional).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newpreds</code></td>
<td>
<p>A matrix or multivariate time series; contains individual model forecasts if a test set is used (optional). Does not
require specification of <code>newobs</code> – in the case in which a forecaster only wants to train the forecast combination method
with a training set and apply it to future individual model forecasts, only <code>newpreds</code> is required, not <code>newobs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byrow</code></td>
<td>
<p>logical. The default (<code>FALSE</code>) assumes that each column of the forecast matrices (<code>prediction_matrix</code> and – if
specified – <code>newpreds</code>) contains forecasts from one forecast model; if each row of the matrices contains forecasts from
one forecast model, set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.impute</code></td>
<td>
<p>logical. The default (<code>TRUE</code>) behavior is to impute missing values via the cross-validated spline approach of
the <code>mtsdi</code> package. If set to <code>FALSE</code>, forecasts with missing values will be removed. Missing values in the observed data are never
imputed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>One of <code>"RMSE"</code> (default), <code>"MAE"</code>, or <code>"MAPE"</code>. Is only used if <code>prediction_matrix</code> is not full rank: The algorithm
checks which models are causing perfect collinearity and the one with the worst individual accuracy (according to the chosen
criterion) is removed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function imports the column names of the prediction matrix (if <code>byrow = FALSE</code>, otherwise the row names) as model names;
if no column names are specified, generic model names are created.
</p>
<p>The missing value imputation algorithm is a modified version of the EM algorithm for imputation that is applicable to time series
data - accounting for correlation between the forecasting models and time structure of the series itself. A smooth spline is
fitted to each of the time series at each iteration. The degrees of freedom of each spline are chosen by cross-validation.
</p>
<p>Forecast combination relies on the lack of perfect collinearity. The test for this condition checks if <code>prediction_matrix</code> is full
rank. In the presence of perfect collinearity, the iterative algorithm identifies the subset of forecasting models that are causing
linear dependence and removes the one among them that has the lowest accuracy (according to a selected criterion, default is RMSE).
This procedure is repeated until the revised prediction matrix is full rank.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb</code>.
</p>


<h3>Author(s)</h3>

<p>Christoph E. Weiss, Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Junger, W. L., Ponce de Leon, A., and Santos, N. (2003). Missing Data Imputation in Multivariate Time Series
via EM Algorithm. <em>Cadernos do IME</em>, <b>15</b>, 8–21.
</p>
<p>Dempster, A., Laird, N., and Rubin D. (1977). Maximum Likelihood from Incomplete Data via the EM Algorithm.
<em>Journal of the Royal Statistical Society, Series B</em>, <b>39(1)</b>, 1–38.
</p>


<h3>See Also</h3>

<p><code>mnimput</code>,
<code>rankMatrix</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

## Example with a training set only:
foreccomb(train_o, train_p)

## Example with a training set and future individual forecasts:
foreccomb(train_o, train_p, newpreds=test_p)

## Example with a training set and a full test set:
foreccomb(train_o, train_p, test_o, test_p)

## Example with forecast models being stored in rows:
preds_row &lt;- matrix(rnorm(1000, 1), 10, 100)
train_p_row &lt;- preds_row[,1:80]
foreccomb(train_o, train_p_row, byrow = TRUE)

## Example with NA imputation:
train_p_na &lt;- train_p
train_p_na[2,3] &lt;- NA
foreccomb(train_o, train_p_na, na.impute = TRUE)

## Example with perfect collinearity:
train_p[,2] &lt;- 0.8*train_p[,1] + 0.4*train_p[,8]
foreccomb(train_o, train_p, criterion="RMSE")

</code></pre>


</div>