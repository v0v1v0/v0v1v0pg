<div class="container">

<table style="width: 100%;"><tr>
<td>ssden</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating Probability Density Using Smoothing Splines</h2>

<h3>Description</h3>

<p>Estimate probability densities using smoothing spline ANOVA models.
The symbolic model specification via <code>formula</code> follows the same
rules as in <code>lm</code>, but with the response missing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssden(formula, type=NULL, data=list(), alpha=1.4, weights=NULL,
      subset, na.action=na.omit, id.basis=NULL, nbasis=NULL, seed=NULL,
      domain=as.list(NULL), quad=NULL, qdsz.depth=NULL, bias=NULL,
      prec=1e-7, maxiter=30, skip.iter=FALSE)

ssden1(formula, type=NULL, data=list(), alpha=1.4, weights=NULL,
       subset, na.action=na.omit, id.basis=NULL, nbasis=NULL, seed=NULL,
       domain=as.list(NULL), quad=NULL, prec=1e-7, maxiter=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code>mkterm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional vector of bin-counts for histogram data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.basis</code></td>
<td>
<p>Index of observations to be used as "knots."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p>Number of "knots" to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed to be used for the random generation of "knots."
Ignored when <code>id.basis</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>Data frame specifying marginal support of density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quad</code></td>
<td>
<p>Quadrature for calculating integral.  Mandatory if
variables other than factors or numerical vectors are involved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qdsz.depth</code></td>
<td>
<p>Depth to be used in <code>smolyak.quad</code> for
the generation of quadrature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias</code></td>
<td>
<p>Input for sampling bias.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code>ssanova</code> for
notes on skipping theta iteration.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model specification via <code>formula</code> is for the log density.
For example, <code>~x1*x2</code> prescribes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	log f(x1,x2) = g_{1}(x1) + g_{2}(x2) + g_{12}(x1,x2) + C
    </code>
</p>

<p>with the terms denoted by <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>; the constant is determined by the fact that a
density integrates to one.
</p>
<p>The selective term elimination may characterize (conditional)
independence structures between variables.  For example,
<code>~x1*x2+x1*x3</code> yields the conditional independence of x2 and x3
given x1.
</p>
<p>Parallel to those in a <code>ssanova</code> object, the model terms
are sums of unpenalized and penalized terms.  Attached to every
penalized term there is a smoothing parameter, and the model
complexity is largely determined by the number of smoothing
parameters.
</p>
<p>The selection of smoothing parameters is through a cross-validation
mechanism described in the references, with a parameter
<code>alpha</code>; <code>alpha=1</code> is "unbiased" for the minimization of
Kullback-Leibler loss but may yield severe undersmoothing, whereas
larger <code>alpha</code> yields smoother estimates.
</p>
<p>A subset of the observations are selected as "knots."  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
"knots" <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>ssden</code> returns a list object of class <code>"ssden"</code>.
<code>ssden1</code> returns a list object of class
<code>c("ssden1","ssden")</code>.
</p>
<p><code>dssden</code> and <code>cdssden</code> can be used to
evaluate the estimated joint density and conditional density;
<code>pssden</code>, <code>qssden</code>, <code>cpssden</code>,
and <code>cqssden</code> can be used to evaluate (conditional) cdf
and quantiles.
</p>
<p>The method <code>project.ssden</code> can be used to calculate the
Kullback-Leibler projection of <code>"ssden"</code> objects for model
selection; <code>project.ssden1</code> can be used to calculate the
square error projection of <code>"ssden1"</code> objects.
</p>


<h3>Note</h3>

<p>In <code>ssden</code>, default quadrature will be constructed for
numerical vectors on a hyper cube, then outer product with factor
levels will be taken if factors are involved.  The sides of the
hyper cube are specified by <code>domain</code>; for <code>domain$x</code>
missing, the default is
<code>c(min(x),max(x))+c(-1,1)*(max(x)-mimn(x))*.05</code>.  In 1-D, the
quadrature is the 200-point Gauss-Legendre formula returned from
<code>gauss.quad</code>.  In multi-D, delayed Smolyak cubatures
from <code>smolyak.quad</code> are used on cubes with the marginals
properly transformed; see Gu and Wang (2003) for the marginal
transformations.
</p>
<p>For reasonable execution time in higher dimensions, set
<code>skip.iter=TRUE</code> in call to <code>ssden</code>.
</p>
<p>If you get an error message from <code>ssden</code> stating <code>"Newton
    iteration diverges"</code>, try to use a larger <code>qdsz.depth</code> which
will execute slower, or switch to <code>ssden1</code>.  The default values
of <code>qdsz.depth</code> for dimensions 4, 5, 6+ are 12, 11, 10.
</p>
<p><code>ssden1</code> does not involve multi-D quadrature but does not
perform as well as <code>ssden</code>.  It can be used in very high
dimensions where <code>ssden</code> is infeasible.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p>Chong Gu, <a href="mailto:chong@stat.purdue.edu">chong@stat.purdue.edu</a></p>


<h3>References</h3>

<p>Gu, C. and Wang, J. (2003), Penalized likelihood density
estimation: Direct cross-validation and scalable approximation.
<em>Statistica Sinica</em>, <b>13</b>, 811–826.
</p>
<p>Gu, C., Jeon, Y., and Lin, Y. (2013), Nonparametric density
estimation in high dimensions.  <em>Statistica Sinica</em>,
<b>23</b>, 1131–1153.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 1-D estimate: Buffalo snowfall
data(buffalo)
buff.fit &lt;- ssden(~buffalo,domain=data.frame(buffalo=c(0,150)))
plot(xx&lt;-seq(0,150,len=101),dssden(buff.fit,xx),type="l")
plot(xx,pssden(buff.fit,xx),type="l")
plot(qq&lt;-seq(0,1,len=51),qssden(buff.fit,qq),type="l")
## Clean up
## Not run: rm(buffalo,buff.fit,xx,qq)
dev.off()
## End(Not run)

## 2-D with triangular domain: AIDS incubation
data(aids)
## rectangular quadrature
quad.pt &lt;- expand.grid(incu=((1:40)-.5)/40*100,infe=((1:40)-.5)/40*100)
quad.pt &lt;- quad.pt[quad.pt$incu&lt;=quad.pt$infe,]
quad.wt &lt;- rep(1,nrow(quad.pt))
quad.wt[quad.pt$incu==quad.pt$infe] &lt;- .5
quad.wt &lt;- quad.wt/sum(quad.wt)*5e3
## additive model (pre-truncation independence)
aids.fit &lt;- ssden(~incu+infe,data=aids,subset=age&gt;=60,
                  domain=data.frame(incu=c(0,100),infe=c(0,100)),
                  quad=list(pt=quad.pt,wt=quad.wt))
## conditional (marginal) density of infe
jk &lt;- cdssden(aids.fit,xx&lt;-seq(0,100,len=51),data.frame(incu=50))
plot(xx,jk$pdf,type="l")
## conditional (marginal) quantiles of infe (TIME-CONSUMING)
## Not run: 
cqssden(aids.fit,c(.05,.25,.5,.75,.95),data.frame(incu=50))

## End(Not run)
## Clean up
## Not run: rm(aids,quad.pt,quad.wt,aids.fit,jk,xx)
dev.off()
## End(Not run)

## One factor plus one vector
data(gastric)
gastric$trt
fit &lt;- ssden(~futime*trt,data=gastric)
## conditional density
cdssden(fit,c("1","2"),cond=data.frame(futime=150))
## conditional quantiles
cqssden(fit,c(.05,.25,.5,.75,.95),data.frame(trt=as.factor("1")))
## Clean up
## Not run: rm(gastric,fit)

## Sampling bias
## (X,T) is truncated to T&lt;X&lt;1 for T~U(0,1), so X is length-biased
rbias &lt;- function(n) {
  t &lt;- runif(n)
  x &lt;- rnorm(n,.5,.15)
  ok &lt;- (x&gt;t)&amp;(x&lt;1)
  while(m&lt;-sum(!ok)) {
    t[!ok] &lt;- runif(m)
    x[!ok] &lt;- rnorm(m,.5,.15)
    ok &lt;- (x&gt;t)&amp;(x&lt;1)
  }
  cbind(x,t)
}
xt &lt;- rbias(100)
x &lt;- xt[,1]; t &lt;- xt[,2]
## length-biased
bias1 &lt;- list(t=1,wt=1,fun=function(t,x){x[,]})
fit1 &lt;- ssden(~x,domain=list(x=c(0,1)),bias=bias1)
plot(xx&lt;-seq(0,1,len=101),dssden(fit1,xx),type="l")
## truncated
bias2 &lt;- list(t=t,wt=rep(1/100,100),fun=function(t,x){x[,]&gt;t})
fit2 &lt;- ssden(~x,domain=list(x=c(0,1)),bias=bias2)
plot(xx,dssden(fit2,xx),type="l")
## Clean up
## Not run: rm(rbias,xt,x,t,bias1,fit1,bias2,fit2)
</code></pre>


</div>