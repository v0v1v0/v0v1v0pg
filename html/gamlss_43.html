<div class="container">

<table style="width: 100%;"><tr>
<td>find.hyper</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A function to select values of hyper-parameters in a GAMLSS model </h2>

<h3>Description</h3>

<p>This function selects the values of hyper parameters and/or non-linear parameters in a GAMLSS model. It uses the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>optim</code> 
which then minimises the generalised Akaike information criterion (GAIC) with a user defined penalty. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">find.hyper(model = NULL, parameters = NULL, other = NULL, k = 2,
        steps = c(0.1), lower = -Inf, upper = Inf, method = "L-BFGS-B",
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>this is a GAMLSS model in <code>quote()</code>. e.g. <br><code>quate(gamlss(y~cs(x,df=p[1]),sigma.fo=~cs(x,df=p[2]),data=abdom))</code> 
where p[1] and p[2] denote the parameters to be estimated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>the starting values in the search of the optimum hyper-parameters and/or non-linear parameters e.g. <code>parameters=c(3,3)</code>  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>other</code></td>
<td>
<p>this is used to optimise other non-parameters, for example a transformation of the explanatory variable of the kind <code class="reqn">x^{p[3]}</code>,
<code>others=quote(nx&lt;-x^p[3])</code> where <code>nx</code> is now in the model formula </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>specifies the penalty in the GAIC, (the default is 2) e.g. <code>k=3</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>the steps taken in the optimisation procedure [see the <code>ndeps</code> option in <code>optim()</code>], by default is set to 0.1 for all hyper parameters and non-linear parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>the lower permissible level of the parameters  i.e. <code>lower=c(1,1)</code> this does not apply if a method other than the default method "L-BFGS-B" is used </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>the upper permissible level of the parameters  i.e. <code>upper=c(30,10)</code>, this is not apply if a method other than the default method "L-BFGS-B" is used </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method used in <code>optim()</code> to numerically minimise the GAIC over the hyper-parameters and/or non-linear parameters.  By default this is "L-BFGS-B" to allow box-restriction on the parameters </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for extra arguments to be passed to the <code>R</code> function <code>optim()</code> used in the optimisation</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This historically was an experimental function which worked well for the search of the optimum degrees of freedom and non-linear parameters  (e.g. power parameter <code class="reqn">\lambda</code> used to transform <code>x</code> to <code class="reqn">x^\lambda</code>). 
With the introduction of the P-Spline smoothing function <code>pb()</code> the function <code>find.hyper()</code> became almost redundant.  <code>find.hyper()</code> takes lot longer than <code>pb()</code> to find automatically the hyper parameters while both method produce similar results. See below the examples for a small demonstration. 
</p>


<h3>Value</h3>

<p>The function turns the same output as the function <code>optim()</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>the optimum hyper-parameter values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>the minimised value of the GAIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>A two-element integer vector giving the number of calls to ‘fn’ and ‘gr’ respectively </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>An integer code. ‘0’ indicates successful convergence. see the function <code>optim()</code> for other errors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A character string giving any additional information returned by the optimiser, or ‘NULL’</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>It may be slow to find the optimum</p>


<h3>Author(s)</h3>

<p> Mikis Stasinopoulos </p>


<h3>References</h3>

 
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code>gamlss</code>, <code>plot.gamlss</code>, <code>optim</code>  </p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(abdom)
# Example estimating the smoothing parameters for mu and 
# the transformation parameters for x
# declare the model
mod1&lt;-quote(gamlss(y~cs(nx,df=p[1]),family=BCT,data=abdom,
                        control=gamlss.control(trace=FALSE)))
# since we want also to find the transformation for x 
# we use the "other"" option
op &lt;- find.hyper(model=mod1, other=quote(nx&lt;-x^p[2]), parameters=c(3,0.5), 
            lower=c(1,0.001), steps=c(0.1,0.001))
op
# the optimum parameters found are 
# p = (p[1],p[2]) = (3.113218 0.001000) = (df for mu, lambda)
# so it needs df = 3 on top of the constant and linear 
# in  the cubic spline model for mu since p[1] is approximately  3
#  and log transformation for x since p[2] is approximately  0 
# here is an example with no data declaration in define the model
# we have to attach the data
attach(abdom)
mod2 &lt;- quote(gamlss(y~cs(nx,df=p[1]),family=BCT,
                control=gamlss.control(trace=FALSE)))
op2&lt;-find.hyper(model=mod2, other=quote(nx&lt;-x^p[2]), parameters=c(3,0.5), 
                lower=c(1,0.001), steps=c(0.1,0.001))
op2
detach(abdom)
#--------------------------------------------------------------
# showing different ways of estimating the smoothing parameter
# get the df using local ML (PQL) 
m0 &lt;- gamlss(y~pb(x), data=abdom)
# get the df using local GAIC 
m1&lt;-gamlss(y~pb(x, method="GAIC", k=2), data=abdom)
# fiiting cubic splines with fixed df's at 3
m2&lt;-gamlss(y~cs(x, df=3), data=abdom)
# fitting cubic splines using find hyper (global GAIC)
mod1 &lt;- quote(gamlss(y~cs(x, df=p[1]),family=BCT,data=abdom,control=gamlss.control(trace=FALSE)))
op &lt;- find.hyper(model=mod1, parameters=c(3), lower=c(1,0.001), steps=c(0.1,0.001))
# now fit final model
m3 &lt;- gamlss(y~cs(x, df=op$par), data=abdom)
# effetive degrees of fredom for the 4 models
edf(m0);edf(m1); m2$mu.df; m3$mu.df
# deviances for the four models
deviance(m0); deviance(m1); deviance(m2); deviance(m3)
# their GAIC
GAIC(m0,m1,m2,m3)
# plotting  the models
plot(y~x, data=abdom, type="n")
lines(fitted(m3)~abdom$x, col="red")
lines(fitted(m1)~abdom$x, col="green")
lines(fitted(m0)~abdom$x, col="blue")
# almost identical

## End(Not run) 
</code></pre>


</div>