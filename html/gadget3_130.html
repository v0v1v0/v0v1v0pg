<div class="container">

<table style="width: 100%;"><tr>
<td>step</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>G3 stock_* transformation functions</h2>

<h3>Description</h3>

<p>Additional meta-functions to help manage writing stock-handling actions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">g3_step(step_f, recursing = FALSE, orig_env = environment(step_f))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>step_f</code></td>
<td>
<p>Input formula containing references to functions below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursing</code></td>
<td>
<p>Only use default value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orig_env</code></td>
<td>
<p>Only use default value</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All action producing functions will run their output through <code>g3_step</code>.
This means that the functions described here will be available in any gadget3
code.
</p>
<p>They handle translation of stock instance naming, so code can refer to e.g.
<code>stock__num</code> without having to translate naming to the final stock name,
and iterating over stock dimensions.
</p>


<h3>Value</h3>



<h4>g3_step</h4>

<p>A formula object with references to above functions replaced.
</p>



<h3>debug_label</h3>

<p>Add a comment to the code to act as a label for that step, when producing an
outline of the model. There shouldn't be more than one <code>debug_label</code>
call in a step.
</p>
<p>Models compiled with <code>trace = TRUE</code> will print the resultant string to stdout.
</p>


<h4>Arguments</h4>

<p>Any number of character strings, or g3_stock variables. The latter
will be replaced with the final name.
</p>



<h3>debug_trace</h3>

<p>Identical to debug_label, but not considered a "label", just a code
comment, so any number of calls can be added.
</p>


<h3>stock_assert</h3>

<p><code>stock_assert(expression, message, message/stock-var, ...)</code>
</p>
<p>Assert that <var>expression</var> is true, if not abort with a message.
</p>


<h3>stock_reshape</h3>

<p><code>stock_reshape(dest_stock, expression)</code>
</p>
<p>Output <var>expression</var> with it's length structure reshaped to match
<var>dest_stock</var>. The source stock is considered to be the first one
found in <var>expression</var>
</p>
<p>How this is achieved depends on the difference. If the source and
destination match then this is a no-op. Otherwise a transformation
matrix is generated and included into the model.
</p>


<h3>stock_ss</h3>

<p><code>stock_ss(stock_var, [ dimname = override, dimname = override, ... ][, vec = (dimname|full|single) ])</code>
</p>
<p>Subsets <var>stock_var</var> for the current iteration of stock_iterate().
</p>
<p>The <var>vec</var> parameter decides the start value for all dimensions
If <code>full</code>, no other dimensions are set.
If set to a dimname, all dimensions after that dimension are set (i.e. a dimname-vector will be returned)
If <code>single</code>, all dimensions are set (i.e. a single value wil be returned).
The default is <code>length</code> if a length dimension is present (i.e. a length vector will be returned), otherwise <code>single</code>.
</p>
<p>If <var>dimname</var>s are supplied, then the code supplied will override the above.
This code can include <code>default</code>, which will be substituted for the default subset,
or <code>missing</code> to represent an empty position in the subset.
</p>


<h3>stock_ssinv</h3>

<p><code>stock_ssinv(stock_var, [ dimname, dimname, ... ])</code>
</p>
<p>like stock_ss(), but subset only the mentioned <var>dimname</var>s.
</p>


<h3>stock_switch</h3>

<p><code>stock_switch(stock, stock_name1 = expr, stock_name2 = expr, ... [ default ])</code>
</p>
<p>Switch based on name of <var>stock</var>, returning the relevant <var>expr</var> or
<var>default</var>. If no default supplied, then an unknown stock is an error.
</p>
<p><var>expr</var> is implicitly wrapped with <code>stock_with(stock, ...)</code>,
so any references to the stock variable will work. If only default is provided,
then this is identical to calling <code>stock_with</code>.
</p>


<h3>stock_with</h3>

<p><code>stock_with(stock, expr)</code>
</p>
<p>Replaced with <var>expr</var> but with all stock variables of <var>stock</var> renamed
with their final name. This is generally needed when not iterating over a
stock, but e.g. zeroing or summing the whole thing.
</p>


<h3>stock_iterate</h3>

<p><code>stock_iterate(stock, expr)</code>
</p>
<p>Wrap <var>expr</var> with the code to iterate over vector dimensions in
<var>stock</var>, accessed using <code>stock_ss(stock)</code>.
</p>
<p>Which dimensions are iterated over is decided based on the call to
<code>stock_ss(stock)</code>. By default, stock_ss leaves length blank so will
iterate over a length vector for each dimension.
</p>
<p>You can iterate over each value individually with the following:
<code>stock_iterate(stock, stock_ss(stock, length = default) )</code>
</p>
<p>Current values for each dimension will be available as variables,
e.g. <code>area</code>, <code>age</code>, and can be used in formulae.
</p>


<h3>stock_intersect</h3>

<p><code>stock_intersect(stock, expr)</code>
</p>
<p>Wrap <var>expr</var> with the code to intersect all dimensions with
the dimensions of an outer stock_iterate().
</p>


<h3>stock_interact</h3>

<p><code>stock_interact(stock, expr, prefix = prefix)</code>
</p>
<p>Wrap <var>expr</var> with the code to interact with the dimensions of an outer
stock_iterate(). Interact means to intersect over area, but try the
combinatoral explosion of all other dimensions, i.e. what would make most
sense when 2 stocks interact in a predator-prey relationship.
</p>
<p>Additional variables will be prefixed with <var>prefix</var>.
</p>


<h3>stock_prepend</h3>

<p><code>stock_prepend(stock, param_call, name_part = NULL)</code>
</p>
<p>Converts a g3_param or g3_param_table call, prefixing the
parameter name with the stock name, and renaming any references to stock variables.
If <var>name_part</var> given, will only add given part(s) of the stock name.
</p>
<p>Returns <var>param_call</var> with the additions made.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### debug_label
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10)
prey_stock &lt;- g3_stock('herring', 1:3) %&gt;% g3s_age(1,3)
g3_step(~debug_trace("Zero ", stock, "-", prey_stock, " biomass-consuming counter"))

### stock_assert
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10)
g3_step(~stock_assert(stock_with(stock, all(is.finite(stock__num))), stock, "__num became NaN/Inf"))

### stock_reshape
s &lt;- g3_stock('s', seq(3, 21, 3))
s__num &lt;- g3_stock_instance(s, 100)
agg &lt;- g3_stock('agg', c(3, 10, 21), open_ended = FALSE)
g3_eval(~stock_iterate(s, stock_reshape(agg, stock_ss(s__num))))

### stock_ss
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10) %&gt;% g3s_livesonareas(1)
stock__num &lt;- g3_stock_instance(stock)
g3_step(~stock_iterate(stock, { x &lt;- x + stock_ss(stock__num) }))
g3_step(~stock_ss(stock__num, area = 5))
# Lengthgroups for age_idx + 1
g3_step(~stock_ss(stock__num, age = default + 1))
# Vector for the entirety of the "next" area
g3_step(~stock_ss(stock__num, area = default + 1, vec = area))
g3_step(~stock_ss(stock__num, area = , age = j))

### stock_ssinv
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10) %&gt;% g3s_livesonareas(1)
g3_step(~g3_step(~stock_ssinv(stock, 'age')))
g3_step(~g3_step(~stock_ssinv(stock, 'area')))

### stock_switch
stock &lt;- g3_stock('halibut', 1:10) ; fleet_stock &lt;- g3_fleet('igfs')
g3_step(~stock_switch(stock, halibut = 2, herring = 3, -1))
g3_step(~stock_switch(fleet_stock, halibut = 2, herring = 3, -1))
g3_step(~stock_switch(stock, halibut = stock__midlen, -1))

### stock_with
stock &lt;- g3_stock('halibut', 1:10)
g3_step(~stock_with(stock, sum(stock__num)))

### stock_iterate
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10)
g3_step(~stock_iterate(stock, x &lt;- x + stock_ss(stock__num)))

### stock_intersect
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10)
prey_stock &lt;- g3_stock('herring', 1:3) %&gt;% g3s_age(1,3)
g3_step(~stock_iterate(stock, stock_intersect(prey_stock, {
  x &lt;- x + stock_ss(stock__num) + stock_ss(prey_stock__num)
})))

### stock_interact
stock &lt;- g3_stock('halibut', 1:10) %&gt;% g3s_age(1,10)
prey_stock &lt;- g3_stock('herring', 1:3) %&gt;% g3s_age(1,3)
g3_step(~stock_iterate(stock, stock_interact(prey_stock, {
  x &lt;- x + stock_ss(stock__num) + stock_ss(prey_stock__num)
}, prefix = "prey" )))
</code></pre>


</div>