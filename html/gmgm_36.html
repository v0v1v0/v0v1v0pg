<div class="container">

<table style="width: 100%;"><tr>
<td>param_learn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Learn the parameters of a Gaussian mixture graphical model</h2>

<h3>Description</h3>

<p>This function learns the parameters of a Gaussian mixture graphical model.
Using the local decomposability of the log-likelihood, this task consists in
learning each local conditional model independently with the EM algorithm
(Koller and Friedman, 2009).
</p>


<h3>Usage</h3>

<pre><code class="language-R">param_learn(
  gmgm,
  data,
  nodes = structure(gmgm)$nodes,
  col_seq = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gmgm</code></td>
<td>
<p>An initial object of class <code>gmbn</code> or <code>gmdbn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the data used for learning. Its columns
must explicitly be named after the nodes of <code>gmgm</code> and must not contain
missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>A character vector containing the nodes whose local conditional
models are learned (by default all the nodes of <code>gmgm</code>). If <code>gmgm</code>
is a <code>gmdbn</code> object, the same nodes are learned for each of its
<code>gmbn</code> elements. This constraint can be overcome by passing a list of
character vectors named after some of these elements (<code>b_1</code>, ...) and
containing learned nodes specific to them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_seq</code></td>
<td>
<p>A character vector containing the column names of <code>data</code>
that describe the observation sequence. If <code>NULL</code> (the default), all the
observations belong to a single sequence. If <code>gmgm</code> is a temporal
<code>gmbn</code> or <code>gmdbn</code> object, the observations of a same sequence must
be ordered such that the <code class="reqn">t</code>th one is related to time slice <code class="reqn">t</code>
(note that the sequences can have different lengths). If <code>gmgm</code> is a
non-temporal <code>gmbn</code> object, this argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value indicating whether learned nodes in progress
are displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to function <code>em</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>gmgm</code></td>
<td>
<p>The final <code>gmbn</code> or <code>gmdbn</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evol_loglik</code></td>
<td>
<p>A list with elements:
</p>

<dl>
<dt><code>global</code></dt>
<dd>
<p>A numeric vector containing the global log-likelihood
before and after learning.</p>
</dd>
<dt><code>local</code></dt>
<dd>
<p>For a <code>gmbn</code> object, a numeric matrix containing the
local conditional log-likelihoods before and after learning. For a
<code>gmdbn</code> object, a list of numeric matrices containing these values for
each <code>gmbn</code> element.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>References</h3>

<p>Koller, D. and Friedman, N. (2009). <em>Probabilistic Graphical Models:
Principles and Techniques</em>. The MIT Press.
</p>


<h3>See Also</h3>

<p><code>param_em</code>, <code>struct_em</code>,
<code>struct_learn</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(data_body)
gmbn_1 &lt;- gmbn(
  AGE = split_comp(add_var(NULL, data_body[, "AGE"]), n_sub = 3),
  FAT = split_comp(add_var(NULL,
                           data_body[, c("FAT", "GENDER", "HEIGHT", "WEIGHT")]),
                   n_sub = 2),
  GENDER = split_comp(add_var(NULL, data_body[, "GENDER"]), n_sub = 2),
  GLYCO = split_comp(add_var(NULL, data_body[, c("GLYCO", "AGE", "WAIST")]),
                     n_sub = 2),
  HEIGHT = split_comp(add_var(NULL, data_body[, c("HEIGHT", "GENDER")])),
  WAIST = split_comp(add_var(NULL,
                             data_body[, c("WAIST", "AGE", "FAT", "HEIGHT",
                                           "WEIGHT")]),
                     n_sub = 3),
  WEIGHT = split_comp(add_var(NULL, data_body[, c("WEIGHT", "HEIGHT")]),
                      n_sub = 2)
)
res_learn_1 &lt;- param_learn(gmbn_1, data_body, verbose = TRUE)

library(dplyr)
data(data_air)
data &lt;- data_air %&gt;%
  group_by(DATE) %&gt;%
  mutate(NO2.1 = lag(NO2), O3.1 = lag(O3), TEMP.1 = lag(TEMP),
         WIND.1 = lag(WIND)) %&gt;%
  ungroup()
gmdbn_1 &lt;- gmdbn(
  b_2 = gmbn(
    NO2 = split_comp(add_var(NULL, data[, c("NO2", "NO2.1", "WIND")]),
                     n_sub = 3),
    O3 = split_comp(add_var(NULL,
                            data[, c("O3", "NO2", "NO2.1", "O3.1", "TEMP",
                                     "TEMP.1")]),
                    n_sub = 3),
    TEMP = split_comp(add_var(NULL, data[, c("TEMP", "TEMP.1")]), n_sub = 3),
    WIND = split_comp(add_var(NULL, data[, c("WIND", "WIND.1")]), n_sub = 3)
  ),
  b_13 = gmbn(
    NO2 = split_comp(add_var(NULL, data[, c("NO2", "NO2.1", "WIND")]),
                     n_sub = 3),
    O3 = split_comp(add_var(NULL,
                            data[, c("O3", "O3.1", "TEMP", "TEMP.1", "WIND")]),
                    n_sub = 3),
    TEMP = split_comp(add_var(NULL, data[, c("TEMP", "TEMP.1")]), n_sub = 3),
    WIND = split_comp(add_var(NULL, data[, c("WIND", "WIND.1")]), n_sub = 3)
  )
)
res_learn_2 &lt;- param_learn(gmdbn_1, data_air, col_seq = "DATE", verbose = TRUE)

</code></pre>


</div>