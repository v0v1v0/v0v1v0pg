<div class="container">

<table style="width: 100%;"><tr>
<td>SFCMeans</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SFCMeans</h2>

<h3>Description</h3>

<p>spatial version of the c-mean algorithm (SFCMeans, FCM_S1)
</p>


<h3>Usage</h3>

<pre><code class="language-R">SFCMeans(
  data,
  nblistw = NULL,
  k,
  m,
  alpha,
  lag_method = "mean",
  window = NULL,
  noise_cluster = FALSE,
  delta = NULL,
  maxiter = 500,
  tol = 0.01,
  standardize = TRUE,
  robust = FALSE,
  verbose = TRUE,
  init = "random",
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A dataframe with only numerical variables. Can also be a list of
rasters (produced by the package raster). In that case, each raster is
considered as a variable and each pixel is an observation. Pixels with NA
values are not used during the classification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nblistw</code></td>
<td>
<p>A list.w object describing the neighbours typically produced
by the spdep package. Required if data is a dataframe, see the parameter window
if you use a list of rasters as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>An integer describing the number of cluster to find</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A float for the fuzziness degree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A float representing the weight of the space in the analysis (0
is a typical fuzzy-c-mean algorithm, 1 is balanced between the two
dimensions, 2 is twice the weight for space)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag_method</code></td>
<td>
<p>A string indicating if a classical lag must be used
("mean") or if a weighted median must be used ("median"). When working with rasters, a function
can be given (or a string which will be parsed). It will be applied to all the pixels values
in the matrix designated by the parameter window and weighted according to the values of this matrix.
Typically, to obtain an average of the pixels in a 3x3 matrix one could use the function sum (or "sum")
and set the window as: window &lt;- matrix(1/9,nrow = 3, ncol = 3). There is one special case when working 
with rasters: one can specify "nl" (standing for non-local) which calculated a lagged version of the 
input rasters, using the inverse of the euclidean distance as spatial weights (see the section Advanced 
examples in the vignette introduction for more details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>If data is a list of rasters, then a window must be specified instead of
a list.w object. It will be used to calculate a focal function on each raster. The
window must be a square numeric matrix with odd dimensions (such 3x3). The values in
the matrix indicate the weight to give to each pixel and the centre of the matrix is
the centre of the focal function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_cluster</code></td>
<td>
<p>A boolean indicatong if a noise cluster must be added to the solution (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>A float giving the distance of the noise cluster to each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>An integer for the maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance criterion used in the evaluateMatrices function for
convergence assessment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>A boolean to specify if the variables must be centred and
reduced (default = True)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>A boolean indicating if the "robust" version of the algorithm must be used (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A boolean to specify if the progress should be printed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A string indicating how the initial centres must be selected. "random"
indicates that random observations are used as centres. "kpp" use a distance-based method
resulting in more dispersed centres at the beginning. Both of them are heuristic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An integer used for random number generation. It ensures that the
starting centres will be the same if the same value is selected.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The implementation is based on the following article : <a href="https://doi.org/10.1016/j.patcog.2006.07.011">doi:10.1016/j.patcog.2006.07.011</a>.<br></p>
<p>the membership matrix (u) is calculated as follow <br></p>
<p style="text-align: center;"><code class="reqn">u_{ik} = \frac{(||x_{k} - v{_i}||^2 + \alpha||\bar{x_{k}} - v{_i}||^2)^{(-1/(m-1))}}{\sum_{j=1}^c(||x_{k} - v{_j}||^2 + \alpha||\bar{x_{k}} - v{_j}||^2)^{(-1/(m-1))}}</code>
</p>

<p>the centers of the groups are updated with the following formula
</p>
<p style="text-align: center;"><code class="reqn">v_{i} = \frac{\sum_{k=1}^N u_{ik}^m(x_{k} + \alpha\bar{x_{k}})}{(1 + \alpha)\sum_{k=1}^N u_{ik}^m}</code>
</p>

<p>with
</p>

<ul>
<li>
<p> vi the center of the group vi
</p>
</li>
<li>
<p> xk the data point k
</p>
</li>
<li>
<p> xk_bar the spatially lagged data point k
</p>
</li>
</ul>
<h3>Value</h3>

<p>An S3 object of class FCMres with the following slots
</p>

<ul>
<li>
<p> Centers: a dataframe describing the final centers of the groups
</p>
</li>
<li>
<p> Belongings: the final membership matrix
</p>
</li>
<li>
<p> Groups: a vector with the names of the most likely group for each observation
</p>
</li>
<li>
<p> Data: the dataset used to perform the clustering (might be standardized)
</p>
</li>
<li>
<p> isRaster: TRUE if rasters were used as input data, FALSE otherwise
</p>
</li>
<li>
<p> k: the number of groups
</p>
</li>
<li>
<p> m: the fuzyness degree
</p>
</li>
<li>
<p> alpha: the spatial weighting parameter (if SFCM or SGFCM)
</p>
</li>
<li>
<p> beta: beta parameter for generalized version of FCM (GFCM or SGFCM)
</p>
</li>
<li>
<p> algo: the name of the algorithm used
</p>
</li>
<li>
<p> rasters: a list of rasters with membership values and the most likely group (if rasters were used)
</p>
</li>
<li>
<p> missing: a boolean vector indicating raster cell with data (TRUE) and with NA (FALSE) (if rasters were used)
</p>
</li>
<li>
<p> maxiter: the maximum number of iterations used
</p>
</li>
<li>
<p> tol: the convergence criterio
</p>
</li>
<li>
<p> lag_method: the lag function used (if SFCM or SGFCM)
</p>
</li>
<li>
<p> nblistw: the neighbours list used (if vector data were used for SFCM or SGFCM)
</p>
</li>
<li>
<p> window: the window used (if raster data were used for SFCM or SGFCM)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">data(LyonIris)
AnalysisFields &lt;-c("Lden","NO2","PM25","VegHautPrt","Pct0_14","Pct_65","Pct_Img",
"TxChom1564","Pct_brevet","NivVieMed")
dataset &lt;- sf::st_drop_geometry(LyonIris[AnalysisFields])
queen &lt;- spdep::poly2nb(LyonIris,queen=TRUE)
Wqueen &lt;- spdep::nb2listw(queen,style="W")
result &lt;- SFCMeans(dataset, Wqueen,k = 5, m = 1.5, alpha = 1.5, standardize = TRUE)
</code></pre>


</div>