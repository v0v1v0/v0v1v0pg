<div class="container">

<table style="width: 100%;"><tr>
<td>GraphqlClient</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GraphqlClient</h2>

<h3>Description</h3>

<p>R6 class for constructing GraphQL queries
</p>


<h3>Value</h3>

<p>a 'GraphqlClient' class (R6 class)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>url</code></dt>
<dd>
<p>(character) list of fragments</p>
</dd>
<dt><code>headers</code></dt>
<dd>
<p>list of named headers</p>
</dd>
<dt><code>schema</code></dt>
<dd>
<p>holds schema</p>
</dd>
<dt><code>result</code></dt>
<dd>
<p>holds result from http request</p>
</dd>
<dt><code>fragments</code></dt>
<dd>
<p>(list) list of fragments</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>GraphqlClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>GraphqlClient$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ping"><code>GraphqlClient$ping()</code></a>
</p>
</li>
<li> <p><a href="#method-load_schema"><code>GraphqlClient$load_schema()</code></a>
</p>
</li>
<li> <p><a href="#method-dump_schema"><code>GraphqlClient$dump_schema()</code></a>
</p>
</li>
<li> <p><a href="#method-schema2json"><code>GraphqlClient$schema2json()</code></a>
</p>
</li>
<li> <p><a href="#method-fragment"><code>GraphqlClient$fragment()</code></a>
</p>
</li>
<li> <p><a href="#method-exec"><code>GraphqlClient$exec()</code></a>
</p>
</li>
<li> <p><a href="#method-prep_query"><code>GraphqlClient$prep_query()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-new"></a>


<h4>Method <code>new()</code>
</h4>

<p>Create a new 'GraphqlClient' object
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$new(url, headers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt>
<dd>
<p>(character) URL for the GraphQL schema</p>
</dd>
<dt><code>headers</code></dt>
<dd>
<p>Any acceptable headers, a named list. See examples</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new 'GraphqlClient' object
</p>


<hr>
<a id="method-print"></a>


<h4>Method <code>print()</code>
</h4>

<p>print method for the 'GraphqlClient' class
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>self</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>ignored</p>
</dd>
</dl>
</div>


<hr>
<a id="method-ping"></a>


<h4>Method <code>ping()</code>
</h4>

<p>ping the GraphQL server
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$ping(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>curl options passed on to [crul::verb-HEAD]</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>'TRUE' if successful response, 'FALSE' otherwise
</p>


<hr>
<a id="method-load_schema"></a>


<h4>Method <code>load_schema()</code>
</h4>

<p>load schema, from URL or local file
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$load_schema(schema_url = NULL, schema_file = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>schema_url</code></dt>
<dd>
<p>(character) url for a schema file</p>
</dd>
<dt><code>schema_file</code></dt>
<dd>
<p>(character) path to a schema file</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>curl options passed on to [crul::verb-GET]</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>nothing, loads schema into '$schema' slot
</p>


<hr>
<a id="method-dump_schema"></a>


<h4>Method <code>dump_schema()</code>
</h4>

<p>dump schema to a local file
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$dump_schema(file)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt>
<dd>
<p>(character) path to a file</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>nothing, writes schema to 'file'
</p>


<hr>
<a id="method-schema2json"></a>


<h4>Method <code>schema2json()</code>
</h4>

<p>convert schema to JSON
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$schema2json(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>options passed on to [jsonlite::toJSON()]</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>json
</p>


<hr>
<a id="method-fragment"></a>


<h4>Method <code>fragment()</code>
</h4>

<p>load schema, from URL or local file
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$fragment(name, x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>(character) fragment name</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>(character) the fragment</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>nothing returned; sets fragments internally
</p>


<hr>
<a id="method-exec"></a>


<h4>Method <code>exec()</code>
</h4>

<p>execute the query
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$exec(query, variables, encoding = "UTF-8", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt>
<dd>
<p>(character) a query, of class 'query' or 'fragment'</p>
</dd>
<dt><code>variables</code></dt>
<dd>
<p>(list) named list with query variables values</p>
</dd>
<dt><code>encoding</code></dt>
<dd>
<p>(character) encoding to use to parse the response. passed
on to [crul::HttpResponse] '$parse()' method. default: "UTF-8"</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>curl options passed on to [crul::verb-POST]</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>character string of response, if successful
</p>


<hr>
<a id="method-prep_query"></a>


<h4>Method <code>prep_query()</code>
</h4>

<p>not used right now
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$prep_query(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt>
<dd>
<p>(character) a query, of class 'query' or 'fragment'</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">x &lt;- GraphqlClient$new()
x

## Not run: 
# make a client
token &lt;- Sys.getenv("GITHUB_GRAPHQL_TOKEN")
cli &lt;- GraphqlClient$new(
  url = "https://api.github.com/graphql",
  headers = list(Authorization = paste0("Bearer ", token))
)

# if the GraphQL server has a schema, you can load it
cli$load_schema()

# dump schema to local file
f &lt;- tempfile(fileext = ".json")
cli$dump_schema(file = f)
readLines(f)
jsonlite::fromJSON(readLines(f))

# after dumping to file, you can later read schema from file for faster loading
rm(cli)
cli &lt;- GraphqlClient$new(
  url = "https://api.github.com/graphql",
  headers = list(Authorization = paste0("Bearer ", token))
)
cli$load_schema(schema_file = f)

# variables
cli$url
cli$schema
cli$schema$data
cli$schema$data$`__schema`
cli$schema$data$`__schema`$queryType
cli$schema$data$`__schema`$mutationType
cli$schema$data$`__schema`$subscriptionType
head(cli$schema$data$`__schema`$types)
cli$schema$data$`__schema`$directives


# methods
## ping - hopefully you get TRUE
cli$ping()

## dump schema
cli$schema2json()


## define query
### creat a query class first
qry &lt;- Query$new()
## another
qry$query('repos', '{
  viewer {
    repositories(last: 10, isFork: false, privacy: PUBLIC) {
      edges {
        node {
          isPrivate
          id
          name
        }
      }
    }
  }
}')
qry
qry$queries
qry$queries$repos
### execute the query
cli$exec(qry$queries$repos)


# query with a fragment
### define query without fragment, but referring to it
qry &lt;- Query$new()
qry$query('queryfrag', '{
  ropensci: repositoryOwner(login:"ropensci") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
  ropenscilabs: repositoryOwner(login:"ropenscilabs") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
}')

### define a fragment
frag &lt;- Fragment$new()
frag$fragment('Watchers', '
  fragment on Repository {
    watchers(first: 3) {
      edges {
        node {
          name
       }
    }
  }
}')
frag$fragments
frag$fragments$Watchers

### add the fragment to the query 'queryfrag'
qry$add_fragment('queryfrag', frag$fragments$Watchers)
qry
qry$queries$queryfrag

### execute query: we'll hook together the query and your fragment internally
cli$exec(qry$queries$queryfrag)

## End(Not run)
</code></pre>


</div>