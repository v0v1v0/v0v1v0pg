<div class="container">

<table style="width: 100%;"><tr>
<td>fda.usc_efic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auxiliary functions for the <span class="pkg">goffda</span> package</h2>

<h3>Description</h3>

<p>Auxiliary functions required for the methods
implemented in the <span class="pkg">goffda</span> package, as enhancements of the auxiliary
functions <code>fdata.cen</code> and
<code>func.mean</code> from the
<code>fda.usc-package</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fdata_cen(X_fdata, mean_X = func_mean(X_fdata))

func_mean(X_fdata)

inprod_fdata(X_fdata1, X_fdata2 = NULL, int_rule = "trapezoid",
  as_matrix = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X_fdata</code></td>
<td>
<p>sample of functional data as an
<code>fdata</code> object of length <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_X</code></td>
<td>
<p>functional mean of <code>X_fdata</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_fdata1, X_fdata2</code></td>
<td>
<p>samples of functional
data as <code>fdata</code> objects of lengths <code class="reqn">n_1</code>
and <code class="reqn">n_2</code>, respectively. Sample sizes can be different.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_matrix</code></td>
<td>
<p>flag to indicate if <code>inprod_fdata</code> returns a matrix
or the vector of its lower triangular part in column-major order.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>whether to show or not information about the
<code>inprod_fdata</code> procedure.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p><code>func_mean</code>: computes the functional mean of
<code>X_fdata</code>.
</p>
</li>
<li>
<p><code>fdata_cen</code>: centers the
functional data <code>X_fdata</code>.
</p>
</li>
<li>
<p><code>inprod_fdata(X_fdata1)</code>:  computes as a row vector the
elements of the lower triangular part of the inner products matrix
(<code>X_fdata</code> vs <code>X_fdata</code>). If <code>as_matrix = TRUE</code>, the
matrix of inner products is given.
</p>
</li>
<li>
<p><code>inprod_fdata(X_fdata1, X_fdata2)</code>: computes the matrix of
inner products (<code>as_matrix = TRUE</code> is forced) between <code>X_fdata1</code>
and <code>X_fdata2</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Code iterated by Eduardo García-Portugués, Gonzalo Álvarez-Pérez,
and Javier Álvarez-Liébana from the <code>fda.usc-package</code>
originals.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## fdata_cen() vs fda.usc::fdata_cen()

data(phoneme, package = "fda.usc")
mlearn &lt;- phoneme$learn[1:10, ]
plot(fda.usc::fdata.cen(mlearn)$Xcen)
plot(fdata_cen(mlearn))

## inprod_fdata() vs fda.usc::inprod.fdata()

# inprod_fdata between mlearn and mlearn: as a row vector

A &lt;- fda.usc::inprod.fdata(fdata1 = mlearn)
A[upper.tri(A, diag = TRUE)]
inprod_fdata(X_fdata1 = mlearn, int_rule = "trapezoid", as_matrix = FALSE)

# inprod_fdata between mlearn and mlearn: as a matrix

A &lt;- fda.usc::inprod.fdata(fdata1 = mlearn)
A
inprod_fdata(X_fdata1 = mlearn, int_rule = "trapezoid", as_matrix = TRUE)

# inprod_fdata between mlearn and mlearn2: as a matrix

mlearn2 &lt;- phoneme$learn[11:30, ]
A &lt;- fda.usc::inprod.fdata(fdata1 = mlearn, fdata2 = mlearn2)
A
B &lt;- inprod_fdata(X_fdata1 = mlearn, X_fdata2 = mlearn2,
int_rule = "trapezoid", as_matrix = TRUE)
B

## Efficiency comparisons

microbenchmark::microbenchmark(fda.usc::fdata.cen(mlearn), fdata_cen(mlearn),
                               times = 1e3, control = list(warmup = 20))

microbenchmark::microbenchmark(fda.usc::inprod.fdata(fdata1 = mlearn),
                               inprod_fdata(X_fdata1 = mlearn,
                               as_matrix = FALSE), times = 1e3,
                               control = list(warmup = 20))

</code></pre>


</div>