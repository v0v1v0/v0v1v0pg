<div class="container">

<table style="width: 100%;"><tr>
<td>gena.mating</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mating</h2>

<h3>Description</h3>

<p>Mating (selection) method (algorithm) to be used in the
genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gena.mating(
  population,
  fitness,
  parents.n,
  method = "rank",
  par = NULL,
  self = FALSE,
  iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>population</code></td>
<td>
<p>numeric matrix which rows are chromosomes i.e. vectors of 
parameters values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitness</code></td>
<td>
<p>numeric vector which <code>i</code>-th element is the value of 
<code>fn</code> at point <code>population[i, ]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parents.n</code></td>
<td>
<p>even positive integer representing the number of parents.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>mating method to be used for selection of parents.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>additional parameters to be passed depending on the <code>method</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self</code></td>
<td>
<p>logical; if <code>TRUE</code> then chromosome may mate itself. 
Otherwise mating is allowed only between different chromosomes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>iteration number of the genetic algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Denote <code>population</code> by <code class="reqn">C</code> which <code>i</code>-th row 
<code>population[i, ]</code> is a chromosome <code class="reqn">c_{i}</code> i.e. the vector of 
parameter values of the function being optimized <code class="reqn">f(.)</code> that is
provided via <code>fn</code> argument of <code>gena</code>.
The elements of chromosome <code class="reqn">c_{ij}</code> are genes representing parameters 
values. Argument <code>fitness</code> is a vector of function values at
corresponding chromosomes i.e. <code>fitness[i]</code> corresponds to
<code class="reqn">f_{i}=f(c_{i})</code>. Total number of chromosomes in population
<code class="reqn">n_{population}</code> equals to <code>nrow(population)</code>.
</p>
<p>Mating algorithm determines selection of chromosomes that will become parents. 
During mating each iteration one of chromosomes become a parent until
there are <code class="reqn">n_{parents}</code> (i.e. <code>parents.n</code>) parents selected.
Each chromosome may become a parent multiple times or not become a 
parent at all.
</p>
<p>Denote by <code class="reqn">c^{s}_{i}</code> the <code class="reqn">i</code>-th of selected parents. Parents
<code class="reqn">c^{s}_{i}</code> and <code class="reqn">c^{s}_{i + 1}</code> form a pair that will further
produce a child (offspring), where <code class="reqn">i</code> is odd.
If <code>self = FALSE</code> then for each pair of parents 
<code class="reqn">(c_{i}^s, c_{i+1}^s)</code> it is insured that 
<code class="reqn">c^{s}_{i} \ne c^{s}_{i + 1}</code> except the case when there are several 
identical chromosomes in population. However <code>self</code> is ignored 
if <code>method</code> is <code>"tournament"</code>, so in this case self-mating
is always possible.
</p>
<p>Denote by <code class="reqn">p_{i}</code> the probability of a chromosome to become a parent.
Remind that each chromosome may become a parent multiple times.
Probability <code class="reqn">p_{i}\left(f_{i}\right)</code> is a function 
of fitness <code class="reqn">f_{i}</code>. Usually this function is non-decreasing so 
more fitted chromosomes have higher probability of becoming a parent. 
There is also an intermediate value <code class="reqn">w_{i}</code> called weight such that:
</p>
<p style="text-align: center;"><code class="reqn">p_{i}=\frac{w_{i}}{\sum\limits_{j=1}^{n_{population}}w_{j}}</code>
</p>

<p>Therefore all weights <code class="reqn">w_{i}</code> are proportional to corresponding 
probabilities <code class="reqn">p_{i}</code> by the same factor (sum of weights).
</p>
<p>Argument <code>method</code> determines particular mating algorithm to be applied.
Denote by <code class="reqn">\tau</code> the vector of parameters used by the algorithm.
Note that <code class="reqn">\tau</code> corresponds to <code>par</code>. The algorithm determines
a particular form of the <code class="reqn">w_{i}\left(f_{i}\right)</code> function which 
in turn determines <code class="reqn">p_{i}\left(f_{i}\right)</code>.
</p>
<p>If <code>method = "constant"</code> then all weights and probabilities are equal:
</p>
<p style="text-align: center;"><code class="reqn">w_{i}=1 =&gt; p_{i}=\frac{1}{n_{population}}</code>
</p>

<p>If <code>method = "rank"</code> then each chromosome receives a rank <code class="reqn">r_{i}</code> 
based on the fitness <code class="reqn">f_{i}</code> value. So if <code>j</code>-th chromosome is the
fittest one and <code>k</code>-th chromosome has the lowest fitness value then
<code class="reqn">r_{j}=n_{population}</code> and  <code class="reqn">r_{k}=1</code>. The relationship
between weight <code class="reqn">w_{i}</code> and rank <code class="reqn">r_{i}</code> is as follows:
</p>
<p style="text-align: center;"><code class="reqn">w_{i}=\left(\frac{r_{i}}{n_{population}}\right)^{\tau_{1}}</code>
</p>

<p>The greater value of <code class="reqn">\tau_{1}</code> the greater portion of probability will
be delivered to more fitted chromosomes. 
Default value is <code class="reqn">\tau_{1} = 0.5</code> so <code>par = 0.5</code>.
</p>
<p>If <code>method = "fitness"</code> then weights are calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">w_{i}=\left(f_{i} - 
                  \min\left(f_{1},...,f_{n_{population}}\right) + 
                  \tau_{1}\right)^{\tau_{2}}</code>
</p>

<p>By default <code class="reqn">\tau_{1}=10</code> and <code class="reqn">\tau_{2}=0.5</code> i.e. 
<code>par = c(10, 0.5)</code>. There is a restriction <code class="reqn">\tau_{1}\geq0</code>
insuring that expression in brackets is non-negative.
</p>
<p>If <code>method = "tournament"</code> then  <code class="reqn">\tau_{1}</code> (i.e. <code>par</code>) 
chromosomes will be randomly selected with equal probabilities and without 
replacement. Then the chromosome with the highest fitness 
(among these selected chromosomes) value will become a parent.
It is possible to provide representation of this algorithm via 
probabilities <code class="reqn">p_{i}</code> but the formulas are numerically unstable.
By default <code>par = min(5, ceiling(parents.n * 0.1))</code>.
</p>
<p>Validation and default values assignment for <code>par</code> is performed inside
<code>gena</code> function not in <code>gena.mating</code>.
It allows to perform validation a single time instead of repeating it
each iteration of genetic algorithm.
</p>
<p>For more information on mating (selection) algorithms
please see Shukla et. al. (2015).
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>

<ul>
<li> <p><code>parents</code> - matrix which rows are parents. The number of
rows of this matrix equals to <code>parents.n</code> while the number of columns
is <code>ncol(population)</code>.
</p>
</li>
<li> <p><code>fitness</code> - vector which i-th element is the fitness of the
i-th parent.
</p>
</li>
<li> <p><code>ind</code> - vector which i-th element is the index of i-th
parent in population so <code>$parents[i, ]</code> equals to 
<code>population[ind[i], ]</code>.
</p>
</li>
</ul>
<h3>References</h3>

<p>A. Shukla, H. Pandey, D. Mehrotra (2015). 
Comparative review of selection techniques in genetic algorithm.
<em>2015 International Conference on Futuristic Trends on Computational 
Analysis and Knowledge Management (ABLAZE)</em>, 515-519,
&lt;doi:10.1109/ABLAZE.2015.7154916&gt;.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Consider the following fitness function
fn &lt;- function(x)
{
  val &lt;- x[1] * x[2] - x[1] ^ 2 - x[2] ^ 2
}

# Randomly initialize the population
set.seed(123)
pop.nulation &lt;- 10
population &lt;- gena.population(pop.n = pop.nulation,
                              lower = c(-5, -5), 
                              upper = c(5, 5))

# Calculate fitness of each chromosome
fitness &lt;- rep(NA, pop.nulation)
for(i in 1:pop.nulation)
{
  fitness[i] &lt;- fn(population[i, ])
}

# Perform mating to select parents
parents &lt;- gena.mating(population = population,
                       fitness = fitness,
                       parents.n = pop.nulation,
                       method = "rank",
                       par = 0.8)
print(parents)

</code></pre>


</div>