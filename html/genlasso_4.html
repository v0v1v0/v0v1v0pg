<div class="container">

<table style="width: 100%;"><tr>
<td>fusedlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute the fused lasso solution path for a general graph, or a 1d
or 2d grid</h2>

<h3>Description</h3>

<p>These functions produce the solution path for a general fused lasso
problem. The <code>fusedlasso</code> function takes either a penalty matrix
or a graph object from the <code>igraph</code> package. The
<code>fusedlasso1d</code> and <code>fusedlasso2d</code> functions are convenience
functions that construct the penalty matrix over a 1d or 2d grid.</p>


<h3>Usage</h3>

<pre><code class="language-R">fusedlasso(y, X, D, graph, gamma = 0, approx = FALSE, maxsteps = 2000,
           minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-4, 
	   verbose = FALSE)
fusedlasso1d(y, pos, X, gamma = 0, approx = FALSE, maxsteps = 2000,
             minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-4, 
	     verbose = FALSE)
fusedlasso2d(y, X, dim1, dim2, gamma = 0, approx = FALSE, maxsteps = 2000,
	     minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-4, 
	     verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>a numeric response vector. Alternatively, for <code>fusedlasso2d</code>
with no matrix <code>X</code> passed, <code>y</code> can be a matrix
(its dimensions corresponding to the underlying 2d grid). Note that
when <code>y</code> is given as a vector in <code>fusedlasso2d</code>, with no
<code>X</code> passed, it should be in column major order.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>

<p>only for <code>fusedlasso1d</code>, these are the optional positions of
the positions in the 1d grid. If missing, the 1d grid is assumed to
have unit spacing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>an optional matrix of predictor variables, with observations along
the rows, and variables along the columns. If the passed <code>X</code> 
has more columns than rows, then a warning is given, and a small ridge
penalty is added to the generalized lasso criterion before the path
is computed. If <code>X</code> has less columns than rows, then its rank is
not checked for efficiency, and (unlike the <code>genasso</code> function) a 
ridge penalty is not automatically added if it is rank deficient. 
Therefore, a tall, rank deficient <code>X</code> may cause errors. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>

<p>only for <code>fusedlasso</code>, this is the penalty matrix, i.e., the
oriented incidence matrix over the underlying graph (the orientation
of each edge being arbitrary). Only one of <code>D</code> or <code>graph</code>
needs to be specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>

<p>only for <code>fusedlasso</code>, this is the underlying graph as an
<code>igraph</code> object from the <code>igraph</code> package. Only one of
<code>D</code> or <code>graph</code> needs to be specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim1</code></td>
<td>

<p>only for <code>fusedlasso2d</code>, this is the number of rows in the
underlying 2d grid. If missing and <code>y</code> is given as a matrix, it
is assumed to be the number of rows of <code>y</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim2</code></td>
<td>

<p>only for <code>fusedlasso2d</code>, this is the number of columns in the
underlying 2d grid. If missing and <code>y</code> is given as a matrix, it
is assumed to be the number of columns of <code>y</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>a numeric variable greater than or equal to 0, indicating the ratio
of the two tuning parameters, one for the fusion penalty, and the
other for the pure <code class="reqn">\ell_1</code> penalty. Default is 0. See
"Details" for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx</code></td>
<td>

<p>a logical variable indicating if the approximate solution path
should be used (with no dual coordinates leaving the boundary).
Default is <code>FALSE</code>. Note
that for the 1d fused lasso, with identity predicor matrix,
this approximate path is the same as the exact solution path.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxsteps</code></td>
<td>

<p>an integer specifying the maximum number of steps for the algorithm
to take before termination. Default is 2000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minlam</code></td>
<td>

<p>a numeric variable indicating the value of lambda at which the path
should terminate. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtol</code></td>
<td>

<p>a numeric variable giving the tolerance for determining the rank of
a matrix: if a diagonal value in the R factor of a QR decomposition
is less than R, in absolute value, then it is considered zero. Hence
making rtol larger means being less stringent with determination of
matrix rank. In general, do not change this unless you know what you
are getting into! Default is 1e-7.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>btol</code></td>
<td>

<p>a numeric variable giving the tolerance for accepting "late" hitting
and leaving times: future hitting times and leaving times should always 
be less than the current knot in the path, but sometimes for numerical
reasons they are larger; any computed hitting or leaving time larger 
than the current knot + btol is thrown away. Hence making btol larger
means being less stringent withthe determination of hitting and leaving 
times. Again, in general, do not change this unless you know what you 
are getting into! Default is 1e-7.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>a numeric variable indicating the multiplier for the ridge penalty,
in the case that <code>X</code> is wide (more columns than rows). If numeric
problems occur, make <code>eps</code> larger. Default is 1e-4. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>a logical variable indicating if progress should be reported after
each knot in the path.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The fused lasso estimate minimizes the criterion
</p>
<p style="text-align: center;"><code class="reqn">
    1/2 \sum_{i=1}^n (y_i - x_i^T \beta_i)^2 + \lambda \sum_{(i,j) \in E}
    |\beta_i - \beta_j| + \gamma \cdot \lambda \sum_{i=1}^p |\beta_i|,
  </code>
</p>

<p>where <code class="reqn">x_i</code> is the ith row of the predictor matrix and <code class="reqn">E</code> is
the edge set of the underlying graph. The solution <code class="reqn">\hat{\beta}</code> is
computed as a function of the regularization parameter <code class="reqn">\lambda</code>,
for a fixed value of <code class="reqn">\gamma</code>. The default is to set
<code class="reqn">\gamma=0</code>, which corresponds to pure fusion of the coefficient
vector <code class="reqn">\beta</code>. A choice <code class="reqn">\gamma&gt;0</code> introduces both sparsity
and fusion in the coefficient vector, with a higher value placing more
priority on sparsity.
</p>
<p>If the predictor matrix is the identity, and the primal solution path
<code class="reqn">\beta</code> is desired at several levels of the ratio parameter
<code class="reqn">\gamma</code>, it is much more efficient to compute the solution path
once with <code class="reqn">\gamma=0</code>, and then use soft-thresholding via the
<code>softthresh</code> function.
</p>
<p>Finally, for the image denoising problem, i.e., the fused lasso over a 2d
grid with identity predictor matrix, it is easy to specify a huge graph
with a seemingly small amount of data. For instance, running the 2d
fused lasso (with identity predictor matrix) on an image at standard
1080p HD resolution yields a graph with over 2 million
edges. Moreover, in image denoising problems—somewhat unlike most
other applications of the fused lasso (and generalized lasso)—a
solution is often desired near the dense end of the path
(<code class="reqn">\lambda=0</code>) as opposed to the regularized end
(<code class="reqn">\lambda=\infty</code>). The dual path algorithm implemented by the
<code>fusedlasso2d</code> function begins at the fully regularized end
and works its way down to the dense end. For a problem with many
edges (dual variables), if a solution at the dense is desired, then it
must usually pass through a huge number knots in the path. Hence it is
not advisable to run <code>fusedlasso2d</code> on image denoising problems of
large scale, as the dual solution path is computationally
infeasible. It should be noted that a faster algorithm for the 2d
fused lasso solution path (when the predictor matrix is the identity),
which begins at the dense end of the path, is available in the
<code>flsa</code> package.
</p>


<h3>Value</h3>

<p>The function returns an object of class "fusedlasso", and subclass
"genlasso". This is a list with at least following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>values of lambda at which the solution path changes slope,
i.e., kinks or knots.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>

<p>a matrix of primal coefficients, each column corresponding to a knot
in the solution path.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>

<p>a matrix of fitted values, each column corresponding to a knot in
the solution path.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>

<p>a matrix of dual coefficients, each column corresponding to a knot
in the solution path.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hit</code></td>
<td>

<p>a vector of logical values indicating if a new variable in the dual
solution hit the box contraint boundary. A value of <code>FALSE</code>
indicates a variable leaving the boundary.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>

<p>a vector giving an unbiased estimate of the degrees of freedom of
the fit at each knot in the solution path.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>the observed response vector. Useful for plotting and other
methods.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>completepath</code></td>
<td>

<p>a logical variable indicating whether the complete path was
computed (terminating the path early with the <code>maxsteps</code> or
<code>minlam</code> options results in a value of <code>FALSE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bls</code></td>
<td>

<p>the least squares solution, i.e., the solution at lambda = 0. This
can be <code>NULL</code> when <code>completepath</code> is <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>the value of the lambda ratio.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Taylor B. Arnold and Ryan J. Tibshirani
</p>


<h3>References</h3>

<p>Tibshirani, R. J. and Taylor, J. (2011), "The solution path of the
generalized lasso", Annals of Statistics 39 (3) 1335–1371.
</p>
<p>Arnold, T. B. and Tibshirani, R. J. (2014), "Efficient implementations
of the generalized lasso dual path algorithm", arXiv: 1405.3222.
</p>
<p>Tibshirani, R., Saunders, M., Rosset, S., Zhu, J. and Knight,
K. (2005), "Sparsity and smoothness via the fused lasso", Journal of
the Royal Statistics Society: Series B 67(1), 91–108.
</p>


<h3>See Also</h3>

<p><code>softthresh</code>, <code>genlasso</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Fused lasso on a custom graph
set.seed(0)
edges = c(1,2,1,3,1,5,2,4,2,5,3,6,3,7,3,8,6,7,6,8)
gr = graph(edges=edges,directed=FALSE)
plot(gr)
y = c(1,1,0,1,1,0,0,0) + rnorm(8,0.1)

# Can either pass the graph object directly, or
# first construct the penalty matrix, and then
# pass this
a1 = fusedlasso(y,graph=gr)
D = getDgSparse(gr)
a2 = fusedlasso(y,D=D)

plot(a1,numbers=TRUE)


# The 2d fused lasso with a predictor matrix X
set.seed(0)
dim1 = dim2 = 16
p = dim1*dim2
n = 300
X = matrix(rnorm(n*p),nrow=n)
beta0 = matrix(0,dim1,dim2)
beta0[(row(beta0)-dim1/2)^2 + (col(beta0)-dim2/2)^2 &lt;=
(min(dim1,dim2)/3)^2] = 1
y = X %*% as.numeric(beta0) + rnorm(n)

# Takes about 30 seconds for the full solution path
out = fusedlasso2d(y,X,dim1=dim1,dim2=dim2)

# Grab the solution at 8 values of lambda over the path
a = coef(out,nlam=8)

# Plot these against the true coefficients
oldpar &lt;- par(no.readonly = TRUE)
on.exit(par(oldpar))
par(mar=c(1,1,2,1),mfrow=c(3,3))

cols = terrain.colors(30)
zlim = range(c(range(beta0),range(a$beta)))
image(beta0,col=cols,zlim=zlim,axes=FALSE)

for (i in 1:8) {
  image(matrix(a$beta[,i],nrow=dim1),col=cols,zlim=zlim,
  axes=FALSE)
  mtext(bquote(lambda==.(sprintf("%.3f",a$lambda[i]))))
}

</code></pre>


</div>