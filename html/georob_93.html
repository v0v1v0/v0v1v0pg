<div class="container">

<table style="width: 100%;"><tr>
<td>predict.georob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict Method for Robustly Fitted Spatial Linear Models</h2>

<h3>Description</h3>

<p>Robust and customary external drift Kriging prediction
based on a spatial linear models fitted by <code>georob</code>. The
<code>predict</code> method for the class <code>georob</code> computes fitted values, point
and block Kriging predictions as
well as model terms for display by <code>termplot</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'georob'
predict(object, newdata, type =  c("signal", "response", "trend", "terms"),
    terms = NULL, se.fit = TRUE, signif = 0.95, locations,
    variogram.model = NULL, param = NULL, aniso = NULL, variogram.object = NULL,
    control = control.predict.georob(), verbose = 0, ...)

control.predict.georob(full.covmat = FALSE, extended.output = FALSE,
    mmax = 10000, ncores = pcmp[["max.ncores"]], pwidth = NULL, pheight = NULL,
    napp = 1, pcmp = control.pcmp())

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>"georob"</code> (mandatory argument),
see <code>georobObject</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame,
<code>SpatialPointsDataFrame</code>,
<code>SpatialPixelsDataFrame</code>,
<code>SpatialGridDataFrame</code>,
<code>SpatialPolygonsDataFrame</code> or an (optional) object of class
<code>SpatialPoints</code>,
<code>SpatialPixels</code> or
<code>SpatialGrid</code>,
in which to look for variables
with which to compute fitted values or Kriging predictions, see <em>Details</em>.<br> If
<code>newdata</code> is a <code>SpatialPolygonsDataFrame</code> then
block Kriging predictions are computed, otherwise point Kriging
predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character keyword defining what target quantity should be
predicted (computed).  Possible values are
</p>

<ul>
<li> <p><code>"signal"</code>: the “signal”
<code class="reqn">Z(\boldsymbol{s}) =
      \boldsymbol{x}(\boldsymbol{s})^\mathrm{T}
      \boldsymbol{\beta} +
      B(\boldsymbol{s})</code> of
the process (default),
</p>
</li>
<li> <p><code>"response"</code>: the observations
<code class="reqn">Y(\boldsymbol{s}) =
      Z(\boldsymbol{s}) +
      \varepsilon(\boldsymbol{s}),</code>
</p>
</li>
<li> <p><code>"trend"</code>: the external drift
<code class="reqn">\boldsymbol{x}(\boldsymbol{s})^\mathrm{T}
      \boldsymbol{\beta},</code>
</p>
</li>
<li> <p><code>"terms"</code>: the model terms.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>If <code>type = "terms"</code>, which terms (default is all terms).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>a logical scalar, only used if <code>type</code> is equal to
<code>"terms"</code>, see <code>predict.lm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signif</code></td>
<td>
<p>a positive numeric scalar equal to the tolerance or confidence level
for computing respective intervals.  If <code>NULL</code> no intervals are
computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locations</code></td>
<td>
<p>an optional one-sided formula specifying what variables
of <code>newdata</code> are the coordinates of the prediction points<br>
(default: <code>object[["locations.objects"]][["locations"]]</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variogram.model</code></td>
<td>
<p>an optional character keyword defining the
variogram model to be used for Kriging, see <code>georob</code> and
<em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>an optional named numeric vector with values of the
variogram parameters used for Kriging, see <code>georob</code> and
<em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aniso</code></td>
<td>
<p>an optional named numeric vector with values of anisotropy
parameters of a variogram used for Kriging, see <code>georob</code> and
<em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variogram.object</code></td>
<td>
<p>an optional list that defines a possibly nested
variogram model used for Kriging, see <code>georob</code> and
<em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list with the components <code>full.covmat</code>,
<code>extended.output</code>, <code>mmax</code>, <code>ncores</code>, <code>pwidth</code>,
<code>pheight</code>, <code>napp</code> and <code>pcmp</code> or a function such as
<code>control.predict.georob</code> that generates such a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.covmat</code></td>
<td>
<p>a logical scalar controlling whether the full
covariance matrix of the prediction errors is returned (<code>TRUE</code>) or
only the vector with its diagonal elements (<code>FALSE</code>, default), see
<em>Value</em> for an explanation of the effect of <code>full.covmat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extended.output</code></td>
<td>
<p>a logical scalar controlling whether the covariance
matrices of the Kriging predictions and of the data should be computed, see
<em>Details</em> (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mmax</code></td>
<td>
<p>a positive integer equal to the maximum number (default
<code>10000</code>) of prediction items, computed in a sub-task in parallelized
computations, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer controlling how many cores are used for
parallelized computations, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pwidth, pheight, napp</code></td>
<td>
<p>numeric scalars, used to tune numeric
integration of semi-variances for block Kriging, see
<code>preCKrige</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcmp</code></td>
<td>
<p>a list of arguments passed to <code>pmm</code> and other
functions that carry out parallelized computations or a function such as
<code>control.pcmp</code> that generates such a list (see
<code>control.pcmp</code> for allowed arguments).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console.<br><code>verbose = 0</code> (default) largely suppresses
such messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>control.predict.georob</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>newdata</code> is an object of class <code>SpatialPoints</code>,
<code>SpatialPixels</code> or <code>SpatialGrid</code> then the drift model may only
use the coordinates as covariates (universal Kriging).  Furthermore the
names used for the coordinates in <code>newdata</code> must be the same as in
<code>data</code> when creating <code>object</code> (argument <code>locations</code> of
<code>predict.georob</code> should not be used).  Note that the result returned
by <code>predict.georob</code> is then an object of class
<code>SpatialPointsDataFrame</code>, <code>SpatialPixelsDataFrame</code> or
<code>SpatialGridDataFrame</code>.
</p>
<p>The <code>predict</code> method for class <code>georob</code> uses the packages
<span class="pkg">parallel</span> and <span class="pkg">snowfall</span> for parallelized
computation of Kriging predictions.  If there are <code class="reqn">m</code> items to
predict, the task is split into <code>ceiling(m/mmax)</code> sub-tasks that are
then distributed to <code>ncores</code> CPUs.  Evidently, <code>ncores = 1</code>
suppresses parallel execution.  By default, the function uses all
available CPUs as returned by <code>detectCores</code>.  <br>
Note that if <code>full.covmat</code> is <code>TRUE</code> <code>mmax</code> must exceed
<code class="reqn">m</code> (and parallel execution is not possible).
</p>
<p>The argument <code>extended.output = TRUE</code> is used to compute all
quantities required for (approximately) unbiased back-transformation of
Kriging predictions of log-transformed data to the original scale of the
measurements by <code>lgnpp</code>.  In more detail, the following items
are computed:
</p>

<ul>
<li> <p><code>trend</code>: the fitted values,
<code class="reqn">\boldsymbol{x}(\boldsymbol{s})\mathrm{^T}\widehat{\boldsymbol{\beta}}</code>,
</p>
</li>
<li> <p><code>var.pred</code>: the variances of the Kriging predictions,
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[\widehat{Y}(\boldsymbol{s})]</code> or
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s})]</code>,
</p>
</li>
<li> <p><code>cov.pred.target</code>: the covariances between the predictions and the
prediction targets,<br><code class="reqn">\mathrm{Cov}_{\hat{\theta}}[\widehat{Y}(\boldsymbol{s}),Y(\boldsymbol{s})]</code> or
<code class="reqn">\mathrm{Cov}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s}),Z(\boldsymbol{s})]</code>,
</p>
</li>
<li> <p><code>var.target</code>: the variances of the prediction targets
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[Y(\boldsymbol{s})]</code> or
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[Z(\boldsymbol{s})]</code>.
</p>
</li>
</ul>
<p>Note that the component <code>var.pred</code> is also  present if
<code>type</code> is equal to <code>"trend"</code>, irrespective of the choice for <code>extended.output</code>.
This component contains then the variances of the fitted values.
</p>


<h3>Value</h3>

<p>The method <code>predict.georob</code> returns, depending on its arguments, the
following objects:
</p>
<p>If <code>type</code> is equal to <code>"terms"</code> then a vector, a matrix, or a
list with prediction results along with bounds and standard errors, see
<code>predict.lm</code>.  Otherwise, the structure and contents
of the output generated by <code>predict.georob</code> are determined by the
class of <code>newdata</code> and the logical flags <code>full.covmat</code> and
<code>extended.output</code>:
</p>
<p>If <code>full.covmat</code> is <code>FALSE</code> then the result is an object of a "similar"
class as <code>newdata</code> (data frame,
<code>SpatialPointsDataFrame</code>,
<code>SpatialPixelsDataFrame</code>
<code>SpatialGridDataFrame</code>, <br><code>SpatialPolygonsDataFrame</code>).
</p>
<p>The data frame or the
<code>data</code> slot of the <code>Spatial...DataFrame</code> objects
have the following components:
</p>

<ul>
<li>
<p> the coordinates of the prediction points (only present if
<code>newdata</code> is a data frame).
</p>
</li>
<li> <p><code>pred</code>: the Kriging predictions (or fitted values).
</p>
</li>
<li> <p><code>se</code>: the root mean squared prediction errors (Kriging
standard errors).
</p>
</li>
<li> <p><code>lower</code>, <code>upper</code>: the limits of tolerance/confidence
intervals,
</p>
</li>
<li> <p><code>trend</code>, <code>var.pred</code>, <code>cov.pred.target</code>,
<code>var.target</code>: only present if <code>extended.output</code> is <code>TRUE</code>,
see <em>Details</em>.
</p>
</li>
</ul>
<p>If <code>full.covmat</code> is <code>TRUE</code> then <code>predict.georob</code> returns a list
with the following components:
</p>

<ul>
<li> <p><code>pred</code>: a data frame or a <code>Spatial...DataFrame</code> object
as described above for<br><code>full.covmat = FALSE</code>.
</p>
</li>
<li> <p><code>mse.pred</code>: the full covariance matrix of the prediction errors,
<code class="reqn">Y(\boldsymbol{s})-\widehat{Y}(\boldsymbol{s})</code> or
<code class="reqn">Z(\boldsymbol{s})-\widehat{Z}(\boldsymbol{s})</code>
see <em>Details</em>.
</p>
</li>
<li> <p><code>var.pred</code>: the full covariance matrix of the
Kriging predictions, see <em>Details</em>.
</p>
</li>
<li> <p><code>cov.pred.target</code>: the full covariance matrix of the
predictions and the prediction targets, see <em>Details</em>.
</p>
</li>
<li> <p><code>var.target</code>: the full covariance matrix of the
prediction targets, see <em>Details</em>.
</p>
</li>
</ul>
<p>The function <code>control.predict.georob</code> returns a list with control
parameters to steer <code>predict.georob</code>, see arguments of the
function above for its components.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Nussbaum, M., Papritz, A., Baltensweiler, A. and Walthert, L. (2014)
Estimating soil organic carbon stocks of Swiss forest soils by robust
external-drift kriging.  <em>Geoscientific Model Development</em>,
<b>7</b>, 1197–1210.  <a href="https://doi.org/10.5194/gmd-7-1197-2014">doi:10.5194/gmd-7-1197-2014</a>.
</p>
<p>Künsch, H. R., Papritz, A., Schwierz, C. and Stahel, W. A. (2011) Robust
estimation of the external drift and the variogram of spatial data.
Proceedings of the ISI 58th World Statistics Congress of the International
Statistical Institute.
<a href="https://doi.org/10.3929/ethz-a-009900710">doi:10.3929/ethz-a-009900710</a>
</p>


<h3>See Also</h3>

<p><code>georobPackage</code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code>georob</code> for (robust) fitting of spatial linear models;
</p>
<p><code>georobObject</code> for a description of the class <code>georob</code>;
</p>
<p><code>profilelogLik</code> for computing profiles of Gaussian likelihoods;
</p>
<p><code>plot.georob</code> for display of RE(ML) variogram estimates;
</p>
<p><code>control.georob</code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code>georobModelBuilding</code> for stepwise building models of class <code>georob</code>;
</p>
<p><code>cv.georob</code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code>georobMethods</code> for further methods for the class <code>georob</code>;
</p>


<p><code>lgnpp</code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code>georobSimulation</code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code>sample.variogram</code> and <code>fit.variogram.model</code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(meuse)

data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
meuse.grid.pixdf &lt;- meuse.grid
gridded(meuse.grid.pixdf) &lt;- TRUE

data(meuse.blocks, package = "constrainedKriging")

r.logzn.rob &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp", param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1., control = control.georob(cov.bhat = TRUE, full.cov.bhat = TRUE))

## point predictions of log(Zn)
r.pred.points.1 &lt;- predict(r.logzn.rob, newdata = meuse.grid.pixdf,
    control = control.predict.georob(extended.output = TRUE))
str(r.pred.points.1, max = 3)

## back-transformation of point predictions
r.backtf.pred.points &lt;- lgnpp(r.pred.points.1)
str(r.backtf.pred.points, max = 3)

spplot(r.backtf.pred.points, zcol = "lgn.pred", main = "Zn content")

## predicting mean Zn content for whole area
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  ## recompute point predictions with argument full.covmat = TRUE
  r.pred.points.2 &lt;- predict(r.logzn.rob, newdata = meuse.grid.pixdf,
      control = control.predict.georob(extended.output = TRUE, full.covmat = TRUE))
  str(r.pred.points.2, max = 3)
  r.block &lt;- lgnpp(r.pred.points.2, is.block = TRUE, all.pred = r.backtf.pred.points@data)
  r.block
}

## block predictions of log(Zn)
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.pred.block &lt;- predict(r.logzn.rob, newdata = meuse.blocks,
      control = control.predict.georob(extended.output = TRUE,
          pwidth = 75, pheight = 75, mmax = 50))
  r.backtf.pred.block &lt;- lgnpp(r.pred.block, newdata = meuse.grid)

  spplot(r.backtf.pred.block, zcol = "lgn.pred", main = "block means Zn content")
}
</code></pre>


</div>