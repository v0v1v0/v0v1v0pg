<div class="container">

<table style="width: 100%;"><tr>
<td>filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter a signal</h2>

<h3>Description</h3>

<p>Apply a 1-D digital filter compatible with 'Matlab' and 'Octave'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">filter(filt, ...)

## Default S3 method:
filter(filt, a, x, zi = NULL, ...)

## S3 method for class 'Arma'
filter(filt, x, ...)

## S3 method for class 'Ma'
filter(filt, x, ...)

## S3 method for class 'Sos'
filter(filt, x, ...)

## S3 method for class 'Zpg'
filter(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>filt</code></td>
<td>
<p>For the default case, the moving-average coefficients of an ARMA
filter (normally called <code>b</code>), specified as a numeric or complex
vector. Generically, <code>filt</code> specifies an arbitrary filter operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter,
specified as a numeric or complex vector. If <code>a[1]</code> is not equal to 1,
then filter normalizes the filter coefficients by <code>a[1]</code>. Therefore,
<code>a[1]</code> must be nonzero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the input signal to be filtered, specified as a numeric or complex
vector or matrix. If <code>x</code> is a matrix, each column is filtered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zi</code></td>
<td>
<p>If <code>zi</code> is provided, it is taken as the initial state of the
system and the final state is returned as zf. The state vector is a vector
or a matrix (depending on <code>x</code>) whose length or number of rows is equal
to the length of the longest coefficient vector <code>b</code> or <code>a</code> minus
one. If <code>zi</code> is not supplied (NULL), the initial state vector is set
to all zeros. Alternatively, <code>zi</code> may be the character string
<code>"zf"</code>, which specifies to return the final state vector even though
the initial state vector is set to all zeros. Default: NULL.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The filter is a direct form II transposed implementation of the standard
linear time-invariant difference equation:

</p>
<pre>
  N                  M
 SUM a(k+1)y(n-k) + SUM b(k+1)x(n-k) = 0;   1 &lt;= n &lt;= length(x)
 k=0                k=0
</pre>
<p>where <code>N = length(a) - 1</code> and <code>M = length(b) - 1</code>.
</p>
<p>The initial and final conditions for filter delays can be used to filter data
in sections, especially if memory limitations are a consideration. See the
examples.
</p>


<h3>Value</h3>

<p>The filtered signal, of the same dimensions as the input signal. In
case the <code>zi</code> input argument was specified, a list with two elements
is returned containing the variables <code>y</code>, which represents the output
signal, and <code>zf</code>, which contains the final state vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code>filter_zi</code>, <code>sosfilt</code> (preferred because it
avoids numerical problems).
</p>


<h3>Examples</h3>

<pre><code class="language-R">bf &lt;- butter(3, 0.1)                                 # 10 Hz low-pass filter
t &lt;- seq(0, 1, len = 100)                            # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- filter(bf, x)                                   # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")

## specify initial conditions
## from Python scipy.signal.lfilter() documentation
t &lt;- seq(-1, 1, length.out =  201)
x &lt;- (sin(2 * pi * 0.75 * t * (1 - t) + 2.1)
      + 0.1 * sin(2 * pi * 1.25 * t + 1)
      + 0.18 * cos(2 * pi * 3.85 * t))
h &lt;- butter(3, 0.05)
lab &lt;- max(length(h$b), length(h$a)) - 1
zi &lt;- filtic(h$b, h$a, rep(1, lab), rep(1, lab))
z1 &lt;- filter(h, x)
z2 &lt;- filter(h, x, zi * x[1])
plot(t, x, type = "l")
lines(t, z1, col = "red")
lines(t, z2$y, col = "green")
legend("bottomright", legend = c("Original signal",
        "Filtered without initial conditions",
        "Filtered with initial conditions"),
       lty = 1, col = c("black", "red", "green"))

</code></pre>


</div>