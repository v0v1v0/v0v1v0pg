<div class="container">

<table style="width: 100%;"><tr>
<td>stat_quant_eq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Equation, rho, AIC and BIC from quantile regression</h2>

<h3>Description</h3>

<p><code>stat_quant_eq</code> fits a polynomial model by quantile regression and
generates several labels including the equation, rho, 'AIC' and 'BIC'.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_quant_eq(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  ...,
  formula = NULL,
  quantiles = c(0.25, 0.5, 0.75),
  method = "rq:br",
  method.args = list(),
  n.min = 3L,
  eq.with.lhs = TRUE,
  eq.x.rhs = NULL,
  coef.digits = 3,
  coef.keep.zeros = TRUE,
  decreasing = getOption("ggpmisc.decreasing.poly.eq", FALSE),
  rho.digits = 4,
  label.x = "left",
  label.y = "top",
  hstep = 0,
  vstep = NULL,
  output.type = NULL,
  na.rm = FALSE,
  orientation = NA,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object. Using aesthetic names instead of
original variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>numeric vector Values in 0..1 indicating the quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function or character If character, "rq" or the name of a model
fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>). If a
function different to <code>rq()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, <code>tau</code> and <code>method</code>
and return a model fit object of class <code>rq</code> or <code>rqs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>named list with additional arguments passed to <code>rq()</code>
or to a function passed as argument to <code>method</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.min</code></td>
<td>
<p>integer Minimum number of observations needed for fiting a
the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.with.lhs</code></td>
<td>
<p>If <code>character</code> the string is pasted to the front of
the equation label before parsing or a <code>logical</code> (see note).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.x.rhs</code></td>
<td>
<p><code>character</code> this string will be used as replacement for
<code>"x"</code> in the model equation when generating the label before parsing
it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.digits, rho.digits</code></td>
<td>
<p>integer Number of significant digits to use for
the fitted coefficients and rho in labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.keep.zeros</code></td>
<td>
<p>logical Keep or drop trailing zeros when formatting
the fitted coefficients and F-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>logical It specifies the order of the terms in the
returned character string; in increasing (default) or decreasing powers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.x, label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 "normalized parent
coordinates" (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hstep, vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.type</code></td>
<td>
<p>character One of <code>"expression"</code>, <code>"LaTeX"</code>,
<code>"text"</code>, <code>"markdown"</code> or <code>"numeric"</code>. In most cases,
instead of using this statistics to obtain numeric values, it is better to
use <code>stat_fit_tidy()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either <code>"x"</code> or <code>"y"</code> controlling the
default for <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This statistic interprets the argument passed to <code>formula</code> differently
than <code>stat_quantile</code> accepting <code>y</code> as well as
<code>x</code> as explanatory variable, matching <code>stat_quant_line()</code>.
</p>
<p>When two variables are subject to mutual constrains, it is useful to consider
both of them as explanatory and interpret the relationship based on them. So,
from version 0.4.1 'ggpmisc' makes it possible to easily implement the
approach described by Cardoso (2019) under the name of "Double quantile
regression".
</p>
<p>This stat can be used to automatically annotate a plot with rho or
the fitted model equation. The model fitting is done using package
'quantreg', please, consult its documentation for the
details. It supports only linear models fitted with function <code>rq()</code>,
passing <code>method = "br"</code> to it, should work well with up to several
thousand observations. The rho, AIC, BIC and n annotations can be used with
any linear model formula. The fitted equation label is correctly generated
for polynomials or quasi-polynomials through the origin. Model formulas can
use <code>poly()</code> or be defined algebraically with terms of powers of
increasing magnitude with no missing intermediate terms, except possibly
for the intercept indicated by <code>"- 1"</code> or <code>"-1"</code> or <code>"+ 0"</code>
in the formula. The validity of the <code>formula</code> is not checked in the
current implementation. The default aesthetics sets rho as label for the
annotation.  This stat generates labels as R expressions by default but
LaTeX (use TikZ device), markdown (use package 'ggtext') and plain text are
also supported, as well as numeric values for user-generated text labels.
The value of <code>parse</code> is set automatically based on <code>output-type</code>,
but if you assemble labels that need parsing from <code>numeric</code> output,
the default needs to be overridden. This stat only generates annotation
labels, the predicted values/line need to be added to the plot as a
separate layer using <code>stat_quant_line</code>,
<code>stat_quant_band</code> or <code>stat_quantile</code>, so
to make sure that the same model formula is used in all steps it is best to
save the formula as an object and supply this object as argument to the
different statistics.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. <code>stat_quant_eq()</code> mimics how <code>stat_smooth()</code>
works, except that only polynomials can be fitted. In other words, it
respects the grammar of graphics. This helps ensure that the model is
fitted to the same data as plotted in other layers.
</p>
<p>Function <code>rq</code> does not support singular fits, in
contrast to <code>lm</code>.
</p>
<p>The minimum number of observations with distinct values in the explanatory
variable can be set through parameter <code>n.min</code>. The default <code>n.min
  = 3L</code> is the smallest usable value. However, model fits with very few
observations are of little interest and using larger values of <code>n.min</code>
than the default is usually wise.
</p>


<h3>Value</h3>

<p>A data frame, with one row per quantile and columns as described
under <strong>Computed variables</strong>. In cases when the number of observations
is less than <code>n.min</code> a data frame with no rows or columns is returned
rendered as an empty/invisible plot layer.
</p>


<h3>User-defined methods</h3>

<p>User-defined functions can be passed as
argument to <code>method</code>. The requirements are 1) that the signature is
similar to that of functions from package 'quantreg' and 2) that the value
returned by the function is an object belonging to class <code>"rq"</code>, class
<code>"rqs"</code>, or an atomic <code>NA</code> value.
</p>
<p>The <code>formula</code> and <code>tau</code> used to build the equation and quantile
labels aer extracted from the returned <code>"rq"</code> or <code>"rqs"</code> object
and can safely differ from the argument passed to parameter <code>formula</code>
in the call to <code>stat_poly_eq()</code>. Thus, user-defined methods can
implement both model selection or conditional skipping of labelling.
</p>


<h3>Warning!</h3>

<p>For the formatted equations to be valid, the fitted model
must be a polynomial, with or without intercept. If defined using
<code>poly()</code> the argument <code>raw = TRUE</code> must be passed. If defined
manually as powers of <code>x</code>, <strong>the terms must be in order of
increasing powers, with no missing intermediate power term.</strong> Please, see
examples below. A check on the model is used to validate that it is a
polynomial, in most cases a warning is issued. Failing to comply with this
requirement results in the return of <code>NA</code> as the formatted equation.
</p>


<h3>Aesthetics</h3>

<p><code>stat_quant_eq()</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code> of <code>rq()</code>. All three must be mapped to
<code>numeric</code> variables. In addition, the aesthetics understood by the
geom used (<code>"text"</code> by default) are understood and grouping respected.
</p>
<p><em>If the model formula includes a transformation of <code>x</code>, a
matching argument should be passed to parameter <code>eq.x.rhs</code>
as its default value <code>"x"</code> will not reflect the applied
transformation. In plots, transformation should never be applied to the
left hand side of the model formula, but instead in the mapping of the
variable within <code>aes</code>, as otherwise plotted observations and fitted
curve will not match. In this case it may be necessary to also pass
a matching argument to parameter <code>eq.with.lhs</code>.</em>
</p>


<h3>Computed variables</h3>

<p>If output.type different from <code>"numeric"</code> the returned tibble contains
columns below in addition to a modified version of the original <code>group</code>:
</p>

<dl>
<dt>x,npcx</dt>
<dd>
<p>x position</p>
</dd>
<dt>y,npcy</dt>
<dd>
<p>y position</p>
</dd>
<dt>eq.label</dt>
<dd>
<p>equation for the fitted polynomial as a character string to be parsed</p>
</dd>
<dt>r.label, and one of cor.label, rho.label, or tau.label</dt>
<dd>
<p><code class="reqn">rho</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>AIC.label</dt>
<dd>
<p>AIC for the fitted model.</p>
</dd>
<dt>n.label</dt>
<dd>
<p>Number of observations used in the fit.</p>
</dd>
<dt>method.label</dt>
<dd>
<p>Set according <code>method</code> used.</p>
</dd>
<dt>rq.method</dt>
<dd>
<p>character, method used.</p>
</dd>
<dt>rho, n</dt>
<dd>
<p>numeric values extracted or computed from fit object.</p>
</dd>
<dt>hjust, vjust</dt>
<dd>
<p>Set to "inward" to override the default of the "text" geom.</p>
</dd>
<dt>quantile</dt>
<dd>
<p>Numeric value of the quantile used for the fit</p>
</dd>
<dt>quantile.f</dt>
<dd>
<p>Factor with a level for each quantile</p>
</dd>
</dl>
<p>If output.type is <code>"numeric"</code> the returned tibble contains columns
in addition to a modified version of the original <code>group</code>:
</p>

<dl>
<dt>x,npcx</dt>
<dd>
<p>x position</p>
</dd>
<dt>y,npcy</dt>
<dd>
<p>y position</p>
</dd>
<dt>coef.ls</dt>
<dd>
<p>list containing the "coefficients" matrix from the summary of the fit object</p>
</dd>
<dt>rho, AIC, n</dt>
<dd>
<p>numeric values extracted or computed from fit object</p>
</dd>
<dt>rq.method</dt>
<dd>
<p>character, method used.</p>
</dd>
<dt>hjust, vjust</dt>
<dd>
<p>Set to "inward" to override the default of the "text" geom.</p>
</dd>
<dt>quantile</dt>
<dd>
<p>Indicating the quantile  used for the fit</p>
</dd>
<dt>quantile.f</dt>
<dd>
<p>Factor with a level for each quantile</p>
</dd>
<dt>b_0.constant</dt>
<dd>
<p>TRUE is polynomial is forced through the origin</p>
</dd>
<dt>b_i</dt>
<dd>
<p>One or columns with the coefficient estimates</p>
</dd>
</dl>
<p>To explore the computed values returned for a given input we suggest the use
of <code>geom_debug</code> as shown in the example below.
</p>


<h3>Note</h3>

<p>For backward compatibility a logical is accepted as argument for
<code>eq.with.lhs</code>. If <code>TRUE</code>, the default is used, either
<code>"x"</code> or <code>"y"</code>, depending on the argument passed to <code>formula</code>.
However, <code>"x"</code> or <code>"y"</code> can be substituted by providing a
suitable replacement character string through <code>eq.x.rhs</code>.
Parameter <code>orientation</code> is redundant as it only affects the default
for <code>formula</code> but is included for consistency with
<code>ggplot2::stat_smooth()</code>.
</p>
<p>R option <code>OutDec</code> is obeyed based on its value at the time the plot
is rendered, i.e., displayed or printed. Set <code>options(OutDec = ",")</code>
for languages like Spanish or French.
</p>
<p>Support for the <code>angle</code> aesthetic is not automatic and requires
that the user passes as argument suitable numeric values to override the
defaults for label positions.
</p>


<h3>References</h3>

<p>Written as an answer to question 65695409 by Mark Neal at
Stackoverflow.
</p>


<h3>See Also</h3>

<p>The quantile fit is done with function <code>rq</code>,
please consult its documentation. This <code>stat_quant_eq</code> statistic can
return ready formatted labels depending on the argument passed to
<code>output.type</code>. This is possible because only polynomial models are
supported. For other types of models, statistics
<code>stat_fit_glance</code>,  <code>stat_fit_tidy</code> and
<code>stat_fit_glance</code> should be used instead and the code for
construction of character strings from numeric values and their mapping to
aesthetic <code>label</code> needs to be explicitly supplied in the call.
</p>
<p>Other ggplot statistics for quantile regression: 
<code>stat_quant_band()</code>,
<code>stat_quant_line()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate artificial data
set.seed(4321)
x &lt;- 1:100
y &lt;- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
y &lt;- y / max(y)
my.data &lt;- data.frame(x = x, y = y,
                      group = c("A", "B"),
                      y2 = y * c(1, 2) + max(y) * c(0, 0.1),
                      w = sqrt(x))

# using defaults
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line() +
  stat_quant_eq()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line() +
  stat_quant_eq(mapping = use_label("eq"))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line() +
  stat_quant_eq(mapping = use_label("eq"), decreasing = TRUE)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line() +
  stat_quant_eq(mapping = use_label("eq", "method"))

# same formula as default
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = y ~ x) +
  stat_quant_eq(formula = y ~ x)

# explicit formula "x explained by y"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = x ~ y) +
  stat_quant_eq(formula = x ~ y)

# using color
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(mapping = aes(color = after_stat(quantile.f))) +
  stat_quant_eq(mapping = aes(color = after_stat(quantile.f))) +
  labs(color = "Quantiles")

# location and colour
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(mapping = aes(color = after_stat(quantile.f))) +
  stat_quant_eq(mapping = aes(color = after_stat(quantile.f)),
                label.y = "bottom", label.x = "right") +
  labs(color = "Quantiles")

# give a name to a formula
formula &lt;- y ~ poly(x, 3, raw = TRUE)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula)

# angle
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula, angle = 90, hstep = 0.04, vstep = 0,
                label.y = 0.02, hjust = 0) +
  expand_limits(x = -15) # make space for equations

# user set quantiles
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, quantiles = 0.5) +
  stat_quant_eq(formula = formula, quantiles = 0.5)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_band(formula = formula,
                  quantiles = c(0.1, 0.5, 0.9)) +
  stat_quant_eq(formula = formula, parse = TRUE,
                quantiles = c(0.1, 0.5, 0.9))

# grouping
ggplot(my.data, aes(x, y2, color = group)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula)

ggplot(my.data, aes(x, y2, color = group)) +
  geom_point() +
  stat_quant_band(formula = formula, linewidth = 0.75) +
  stat_quant_eq(formula = formula) +
  theme_bw()

# labelling equations
ggplot(my.data, aes(x, y2,  shape = group, linetype = group,
       grp.label = group)) +
  geom_point() +
  stat_quant_band(formula = formula, color = "black", linewidth = 0.75) +
  stat_quant_eq(mapping = use_label("grp", "eq", sep = "*\": \"*"),
                formula = formula) +
  expand_limits(y = 3) +
  theme_classic()

# modifying the explanatory variable within the model formula
# modifying the response variable within aes()
formula.trans &lt;- y ~ I(x^2)
ggplot(my.data, aes(x, y + 1)) +
  geom_point() +
  stat_quant_line(formula = formula.trans) +
  stat_quant_eq(mapping = use_label("eq"),
               formula = formula.trans,
               eq.x.rhs = "~x^2",
               eq.with.lhs = "y + 1~~`=`~~")

# using weights
ggplot(my.data, aes(x, y, weight = w)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula)

# no weights, quantile set to upper boundary
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, quantiles = 0.95) +
  stat_quant_eq(formula = formula, quantiles = 0.95)

# manually assemble and map a specific label using paste() and aes()
ggplot(my.data, aes(x, y2, color = group, grp.label = group)) +
  geom_point() +
  stat_quant_line(method = "rq", formula = formula,
                  quantiles = c(0.05, 0.5, 0.95),
                  linewidth = 0.5) +
  stat_quant_eq(mapping = aes(label = paste(after_stat(grp.label), "*\": \"*",
                                            after_stat(eq.label), sep = "")),
                quantiles = c(0.05, 0.5, 0.95),
                formula = formula, size = 3)

# manually assemble and map a specific label using sprintf() and aes()
ggplot(my.data, aes(x, y2, color = group, grp.label = group)) +
  geom_point() +
  stat_quant_band(method = "rq", formula = formula,
                  quantiles = c(0.05, 0.5, 0.95)) +
  stat_quant_eq(mapping = aes(label = sprintf("%s*\": \"*%s",
                                              after_stat(grp.label),
                                              after_stat(eq.label))),
                quantiles = c(0.05, 0.5, 0.95),
                formula = formula, size = 3)

# geom = "text"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, quantiles = 0.5) +
  stat_quant_eq(label.x = "left", label.y = "top",
                formula = formula,
                quantiles = 0.5)

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics using after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, geom = "debug")

## Not run: 
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(mapping = aes(label = after_stat(eq.label)),
                  formula = formula, geom = "debug",
                  output.type = "markdown")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, geom = "debug", output.type = "text")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, geom = "debug", output.type = "numeric")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, quantiles = c(0.25, 0.5, 0.75),
                  geom = "debug", output.type = "text")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, quantiles = c(0.25, 0.5, 0.75),
                  geom = "debug", output.type = "numeric")

## End(Not run)

</code></pre>


</div>