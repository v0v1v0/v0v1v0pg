<div class="container">

<table style="width: 100%;"><tr>
<td>filtfilt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Zero-phase digital filtering</h2>

<h3>Description</h3>

<p>Forward and reverse filter the signal.
</p>


<h3>Usage</h3>

<pre><code class="language-R">filtfilt(filt, ...)

## Default S3 method:
filtfilt(filt, a, x, ...)

## S3 method for class 'Arma'
filtfilt(filt, x, ...)

## S3 method for class 'Ma'
filtfilt(filt, x, ...)

## S3 method for class 'Sos'
filtfilt(filt, x, ...)

## S3 method for class 'Zpg'
filtfilt(filt, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>filt</code></td>
<td>
<p>For the default case, the moving-average coefficients of an ARMA
filter (normally called <code>b</code>). Generically, <code>filt</code> specifies an
arbitrary filter operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>the autoregressive (recursive) coefficients of an ARMA filter,
specified as a vector. If <code>a[1]</code> is not equal to 1, then filter
normalizes the filter coefficients by <code>a[1]</code>. Therefore, <code>a[1]</code>
must be nonzero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the input signal to be filtered. If <code>x</code> is a matrix, all
colums are filtered.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Forward and reverse filtering the signal corrects for phase distortion
introduced by a one-pass filter, though it does square the magnitude response
in the process. That’s the theory at least. In practice the phase correction
is not perfect, and magnitude response is distorted, particularly in the stop
band.
</p>
<p>Before filtering the input signal is extended with a reflected part of both
ends of the signal. The length of this extension is 3 times the filter order.
The Gustafsson [1] method is then used to specify the initial conditions used
to further handle the edges of the signal.
</p>


<h3>Value</h3>

<p>The filtered signal, normally of the same length of the input signal
<code>x</code>, returned as a vector or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle, <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br> Francesco Potortì,
<a href="mailto:pot@gnu.org">pot@gnu.org</a>,<br> Luca Citi, <a href="mailto:lciti@essex.ac.uk">lciti@essex.ac.uk</a>.<br>
Conversion to R and adapted by Geert van Boxtel
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Gustafsson, F. (1996). Determining the initial states in
forward-backward filtering. IEEE Transactions on Signal Processing, 44(4),
988 - 992.
</p>


<h3>See Also</h3>

<p><code>filter</code>, <code>filter_zi</code>, <code>Arma</code>,
<code>Sos</code>, <code>Zpg</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">bf &lt;- butter(3, 0.1)                                 # 10 Hz low-pass filter
t &lt;- seq(0, 1, len = 100)                            # 1 second sample
x &lt;- sin(2* pi * t * 2.3) + 0.25 * rnorm(length(t))  # 2.3 Hz sinusoid+noise
z &lt;- filter(bf, x)                                   # apply filter
plot(t, x, type = "l")
lines(t, z, col = "red")
zz &lt;- filtfilt(bf, x)
lines(t, zz, col="blue")
legend("bottomleft", legend = c("original", "filter", "filtfilt"), lty = 1,
 col = c("black", "red", "blue"))

</code></pre>


</div>