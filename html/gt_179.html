<div class="container">

<table style="width: 100%;"><tr>
<td>summary_rows</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add group-wise summary rows using aggregation functions</h2>

<h3>Description</h3>

<p>Add summary rows to one or more row groups by using the table data and any
suitable aggregation functions. Multiple summary rows can be added for
selected groups via expressions given to <code>fns</code>. You can selectively format
the values in the resulting summary cells by use of formatting expressions in
<code>fmt</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">summary_rows(
  data,
  groups = everything(),
  columns = everything(),
  fns = NULL,
  fmt = NULL,
  side = c("bottom", "top"),
  missing_text = "---",
  formatter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><em>The gt table data object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;gt_tbl&gt;⁠</code> // <strong>required</strong>
</p>
<p>This is the <strong>gt</strong> table object that is commonly created through use of the
<code>gt()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p><em>Specification of row group IDs</em>
</p>
<p><code style="white-space: pre;">⁠&lt;row-group-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>The row groups to which targeting operations are constrained. Can either be
a series of row group ID values provided in <code>c()</code> or a select helper
function (e.g. <code>starts_with()</code>, <code>ends_with()</code>, <code>contains()</code>, <code>matches()</code>,
<code>num_range()</code>, and <code>everything()</code>). By default this is set to
<code>everything()</code>, which means that all available groups will obtain summary
rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>The columns for which the summaries should be calculated. Can either
be a series of column names provided in <code>c()</code>, a vector of column indices,
or a select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fns</code></td>
<td>
<p><em>Aggregation Expressions</em>
</p>
<p><code style="white-space: pre;">⁠&lt;expression|list of expressions&gt;⁠</code>
</p>
<p>Functions used for aggregations. This can include base functions like
<code>mean</code>, <code>min</code>, <code>max</code>, <code>median</code>, <code>sd</code>, or <code>sum</code> or any other user-defined
aggregation function. Multiple functions, each of which would generate a
different row, are to be supplied within a <code>list()</code>. We can specify the
functions by use of function names in quotes (e.g., <code>"sum"</code>), as bare
functions (e.g., <code>sum</code>), or in formula form (e.g., <code>minimum ~ min(.)</code>)
where the LHS could be used to supply the summary row label and ID values.
More information on this can be found in the
<em>Aggregation expressions for <code>fns</code></em> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fmt</code></td>
<td>
<p><em>Formatting expressions</em>
</p>
<p><code style="white-space: pre;">⁠&lt;expression|list of expressions&gt;⁠</code>
</p>
<p>Formatting expressions in formula form. The RHS of <code>~</code> should contain a
formatting call (e.g., <code style="white-space: pre;">⁠~ fmt_number(., decimals = 3, use_seps = FALSE⁠</code>).
Optionally, the LHS could contain a group-targeting expression (e.g.,
<code>"group_a" ~ fmt_number(.)</code>). More information on this can be found in the
<em>Formatting expressions for <code>fmt</code></em> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>
<p><em>Side used for placement of summary rows</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[bottom|top]⁠</code> // <em>default:</em> <code>"bottom"</code>
</p>
<p>Should the summary rows be placed at the <code>"bottom"</code> (the default) or the
<code>"top"</code> of the row group?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_text</code></td>
<td>
<p><em>Replacement text for <code>NA</code> values</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>"---"</code>
</p>
<p>The text to be used in place of <code>NA</code> values in summary cells with no data
outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formatter</code></td>
<td>
<p><em>Deprecated Formatting function</em>
</p>
<p><code style="white-space: pre;">⁠&lt;expression&gt;⁠</code>
</p>
<p>Deprecated, please use <code>fmt</code> instead. This was previously used as a way to
input a formatting function name, which could be any of the <code style="white-space: pre;">⁠fmt_*()⁠</code>
functions available in the package (e.g., <code>fmt_number()</code>, <code>fmt_percent()</code>,
etc.), or a custom function using <code>fmt()</code>. The options of a formatter can
be accessed through <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><em>Deprecated Formatting arguments</em>
</p>
<p><code style="white-space: pre;">⁠&lt;Named arguments&gt;⁠</code>
</p>
<p>Deprecated (along with <code>formatter</code>) but otherwise used for argument values
for a formatting function supplied in <code>formatter</code>. For example, if using
<code>formatter = fmt_number</code>, options such as <code>decimals = 1</code>, <code>use_seps = FALSE</code>, and the like can be used here.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>gt_tbl</code>.
</p>


<h3>Using <code>columns</code> to target column data for aggregation</h3>

<p>Targeting of column data for which aggregates should be generated is done
through the <code>columns</code> argument. We can declare column names in <code>c()</code> (with
bare column names or names in quotes) or we can use
<strong>tidyselect</strong>-style expressions. This can be as basic as supplying a select
helper like <code>starts_with()</code>, or, providing a more complex incantation like
</p>
<p><code>where(~ is.numeric(.x) &amp; max(.x, na.rm = TRUE) &gt; 1E6)</code>
</p>
<p>which targets numeric columns that have a maximum value greater than
1,000,000 (excluding any <code>NA</code>s from consideration).
</p>
<p>By default all columns are selected (with the <code>everything()</code> default). This
default may be not what's needed unless all columns can undergo useful
aggregation by expressions supplied in <code>fns</code>.
</p>


<h3>Aggregation expressions for <code>fns</code>
</h3>

<p>There are a number of ways to express how an aggregation should work for
each summary row. In addition to that, we have the ability to pass important
information such as the summary row ID value and its label (the former
necessary for targeting within <code>tab_style()</code> or <code>tab_footnote()</code> and the
latter used for display in the rendered table). Here are a number of
instructive examples for how to supply such expressions.
</p>


<h4>Double-sided formula with everything supplied</h4>

<p>We can be explicit and provide a double-sided formula (in the form
<code style="white-space: pre;">⁠&lt;LHS&gt; ~ &lt;RHS&gt;⁠</code>) that expresses everything about a summary row. That is, it
has an aggregation expression (where <code>.</code> represents the data in the
focused column). Here's an example:
</p>
<p><code>list(id = "minimum", label = "min") ~ min(., na.rm = TRUE)</code>
</p>
<p>The left side (the list) contains named elements that identify the <code>id</code> and
<code>label</code> for the summary row. The right side has an expression for obtaining
a minimum value (dropping <code>NA</code> values in the calculation).
</p>
<p>The <code>list()</code> can be replaced with <code>c()</code> but the advantage of a list is
allowing the use of the <code>md()</code> and <code>html()</code> helper functions. The above
example can be written as:
</p>
<p><code>list(id = "minimum", label = md("**Minimum**")) ~ min(., na.rm = TRUE)</code>
</p>
<p>and we can have that label value interpreted as Markdown text.
</p>



<h4>Function names in quotes</h4>

<p>With <code>fns = "min"</code> we get the equivalent of the fuller expression:
</p>
<p><code>list(id = "min", label = "min") ~ min(., na.rm = TRUE)</code>
</p>
<p>For sake of convenience, common aggregation functions with the <code>na.rm</code>
argument will be rewritten with the <code>na.rm = TRUE</code> option. These functions
are: <code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"sd"</code>, and <code>"sum"</code>.
</p>
<p>Should you need to specify multiple aggregation functions in this way (giving
you multiple summary rows), use <code>c()</code> or <code>list()</code>.
</p>



<h4>RHS formula expressions</h4>

<p>With <code>fns = ~ min(.)</code> or <code>fns = list(~ min(.))</code>, <strong>gt</strong> will use the function
name as the <code>id</code> and <code>label</code>. The expansion of this shorthand to full form
looks like this:
</p>
<p><code>list(id = "min", label = "min") ~ min(.)</code>
</p>
<p>The RHS expression is kept as written and the name portion is both the <code>id</code>
and the <code>label</code>.
</p>



<h4>Named vector or list with RHS formula expression</h4>

<p>Using <code>fns = c(minimum = ~ min(.))</code> or <code>fns = list(minimum = ~ min(.))</code>
expands to this:
</p>
<p><code>list(id = "minimum", label = "minimum") ~ min(.)</code>
</p>



<h4>Unnamed vector or list with RHS formula expression</h4>

<p>With <code>fns = c("minimum", "min") ~ min(.)</code> or
<code>fns = list("minimum", "min") ~ min(.)</code> the LHS contains the <code>label</code> and <code>id</code>
values and, importantly, the order is <code>label</code> first and <code>id</code> second. This can
be rewritten as:
</p>
<p><code>list(id = "min", label = "minimum") ~ min(.)</code>
</p>
<p>If the vector or list is partially named, <strong>gt</strong> has enough to go on to
disambiguate the unnamed element. So with
<code>fns = c("minimum", label = "min") ~ min(.)</code>, <code>"min"</code> is indeed the <code>label</code>
and <code>"minimum"</code> is taken as the <code>id</code> value.
</p>



<h4>A fully named list with three specific elements</h4>

<p>We can avoid using a formula if we are satisfied with the default options of
a function (except some of those functions with the <code>na.rm</code> options, see
above). Instead, a list with the named elements <code>id</code>, <code>label</code>, and <code>fn</code> could
be used. It can look like this:
</p>
<p><code>fns = list(id = "mean_id", label = "average", fn = "mean")</code>
</p>
<p>which translates to
</p>
<p><code>list(id = "mean_id", label = "average") ~ mean(., na.rm = TRUE)</code>
</p>



<h3>Formatting expressions for <code>fmt</code>
</h3>

<p>Given that we are generating new data in a table, we might also want to
take the opportunity to format those new values right away. We can do this
in the <code>fmt</code> argument, either with a single expression or a number of them
in a list.
</p>


<h4>Formatting cells across all groups</h4>

<p>We can supply a one-sided (RHS only) or two-sided expression (targeting
groups) to <code>fmt</code>, and, several can be provided in a list. The RHS will always
contain an expression that uses a formatting function (e.g., <code>fmt_number()</code>,
<code>fmt_currency()</code>, etc.) and it must contain an initial <code>.</code> that stands for
the data object. If performing numeric formatting on all columns in the new
summary rows, it might look something like this:
</p>
<p><code>fmt = ~ fmt_number(., decimals = 1, use_seps = FALSE)</code>
</p>
<p>We can use the <code>columns</code> and <code>rows</code> arguments that are available in every
formatting function. This allows us to format only a subset of columns or
rows. Summary rows can be targeted by using their ID values and these are
settable within expressions given to <code>fns</code> (see the <em>Aggregation expressions
for <code>fns</code></em> section for details on this). Here's an example with hypothetical
column and row names:
</p>
<p><code>fmt = ~ fmt_number(., columns = num, rows = "mean", decimals = 3)</code>
</p>



<h4>Formatting cells in specific groups</h4>

<p>A two-sided expression is needed for targeting the formatting directives to
specific summary row groups. In this format, the LHS should contain an
expression that resolves to a set of available groups. We can use a single
row group name in quotes, several of those in a vector, or a select helper
expression like <code>starts_with()</code> or <code>matches()</code>.
</p>
<p>In a situation where summary rows were generated across the row groups named
<code>"group_1"</code>, <code>"group_2"</code>, and <code>"group_3"</code>, we could format all summary cells
in <code>"group_2"</code> with the following:
</p>
<p><code>fmt = "group_2" ~ fmt_number(., decimals = 1, use_seps = FALSE)</code>
</p>
<p>If you wanted to target the latter two groups, this can be done:
</p>
<p><code>fmt = matches("2|3") ~ fmt_number(., decimals = 1, use_seps = FALSE)</code>
</p>
<p>Should you need to target a single cell, the LHS expression for group
targeting could be paired with single values for <code>columns</code> and <code>rows</code> on the
RHS formatting expression. Like this:
</p>
<p><code>fmt = "group_1" ~ fmt_number(., columns = num, rows = "mean")</code>
</p>



<h3>Extraction of summary rows</h3>

<p>Should we need to obtain the summary data for external purposes,
<code>extract_summary()</code> can be used with a <code>gt_tbl</code> object where summary rows
were added via <code>summary_rows()</code> or <code>grand_summary_rows()</code>.
</p>


<h3>Examples</h3>

<p>Use a modified version of <code>sp500</code> dataset to create a <strong>gt</strong> table with row
groups and row labels. Create the summary rows labeled <code>min</code>, <code>max</code>, and
<code>avg</code> by row group (where each each row group is a week number) with
<code>summary_rows()</code>.
</p>
<div class="sourceCode r"><pre>sp500 |&gt;
  dplyr::filter(date &gt;= "2015-01-05" &amp; date &lt;= "2015-01-16") |&gt;
  dplyr::arrange(date) |&gt;
  dplyr::mutate(week = paste0("W", strftime(date, format = "%V"))) |&gt;
  dplyr::select(-adj_close, -volume) |&gt;
  gt(
    rowname_col = "date",
    groupname_col = "week"
  ) |&gt;
  summary_rows(
    fns = list(
      "min",
      "max",
      list(label = "avg", fn = "mean")
    ),
    fmt = ~ fmt_number(., use_seps = FALSE)
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_summary_rows_1.png" alt="This image of a table was generated from the first code example in the `summary_rows()` help file." style="width:100%;"><p>Using the <code>countrypops</code> dataset, let's process that a bit before giving it
to <strong>gt</strong>. We can create a summary rows with totals that appear at the top of
each row group (with <code>side = "top"</code>). We can define the aggregation with a
list that contains parameters for the summary row label (<code>md("**ALL**")</code>),
the shared ID value of those rows across groups (<code>"totals"</code>), and the
aggregation function (expressed as <code>"sum"</code>, which <strong>gt</strong> recognizes as the
<code>sum()</code> function). To top it all off, we'll add background fills to the
summary rows with <code>tab_style()</code>.
</p>
<div class="sourceCode r"><pre>countrypops |&gt;
  dplyr::filter(
    country_code_2 %in% c("BR", "RU", "IN", "CN", "FR", "DE", "IT", "GB")
  ) |&gt;
  dplyr::filter(year %% 10 == 0) |&gt;
  dplyr::select(country_name, year, population) |&gt;
  tidyr::pivot_wider(names_from = year, values_from = population) |&gt;
  gt(rowname_col = "country_name") |&gt;
  tab_row_group(
    label = md("*BRIC*"),
    rows = c("Brazil", "Russia", "India", "China"),
    id = "bric"
  ) |&gt;
  tab_row_group(
    label = md("*Big Four*"),
    rows = c("France", "Germany", "Italy", "United Kingdom"),
    id = "big4"
  ) |&gt;
  row_group_order(groups = c("bric", "big4")) |&gt;
  tab_stub_indent(rows = everything()) |&gt;
  tab_header(title = "Populations of the BRIC and Big Four Countries") |&gt;
  tab_spanner(columns = everything(), label = "Year") |&gt;
  fmt_number(n_sigfig = 3, suffixing = TRUE) |&gt;
  summary_rows(
    fns =  list(label = md("**ALL**"), id = "totals", fn = "sum"),
    fmt = ~ fmt_number(., n_sigfig = 3, suffixing = TRUE),
    side = "top"
  ) |&gt;
  tab_style(
    locations = cells_summary(),
    style = cell_fill(color = "lightblue" |&gt; adjust_luminance(steps = +1))
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_summary_rows_2.png" alt="This image of a table was generated from the second code example in the `summary_rows()` help file." style="width:100%;"><h3>Function ID</h3>

<p>6-1
</p>


<h3>Function Introduced</h3>

<p><code>v0.2.0.5</code> (March 31, 2020)
</p>


<h3>See Also</h3>

<p>Other row addition/modification functions: 
<code>grand_summary_rows()</code>,
<code>row_group_order()</code>,
<code>rows_add()</code>
</p>


</div>