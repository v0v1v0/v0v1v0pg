<div class="container">

<table style="width: 100%;"><tr>
<td>discretize.jointly</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Discretize Multivariate Continuous Data by a Cluster-Preserving Grid</h2>

<h3>Description</h3>

<p>Discretize multivariate continuous data using a grid that captures the joint distribution via
preserving clusters in the original data
</p>


<h3>Usage</h3>

<pre><code class="language-R">discretize.jointly(
  data,
  k = c(2:10),
  min_level = 1,
  cluster_method = c("Ball+BIC", "kmeans+silhouette", "PAM"),
  grid_method = c("Sort+split", "MultiChannel.WUC"),
  cluster_label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix containing two or more continuous variables.
Columns are variables, rows are observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>either an integer, a vector of integers, or <code>Inf</code>, specifying 
different ways to find clusters in <code>data</code>. The default is a vector 
containing integers from 2 to 10. If 'k' is a single number, <code>data</code> will 
be grouped into into exactly 'k' clusters. If 'k' is an integer vector, an 
optimal 'k' is chosen from among the integers, that maximizes the average 
silhouette width. If 'k' is set to <code>Inf</code>, an optimal k is chosen among
2 to <code>nrow(data)</code>. If <code>cluster_label</code> is specified, <code>k</code> is 
ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_level</code></td>
<td>
<p>integer or vector, signifying the minimum number of levels 
along each dimension. If a vector of size <code>ncol(data)</code>, then each element
will be mapped 1:1 to each dimension in order. If an integer, then all dimensions
will have the same minimum number of levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_method</code></td>
<td>
<p>the clustering method to be used. Ignored if cluster labels 
are given
"kmeans+silhouette" will use k-means to cluster <code>data</code> and the average 
Silhouette score to select the number of clusters k.
"Ball+BIC" will use Mclust (modelNames = "VII") to cluster <code>data</code> and 
BIC score to select the number of cluster k.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_method</code></td>
<td>
<p>the discretization method to be used. 
"Sort+split" will sort the cluster by cluster mean in each dimension and then
split consecutive pairs only if the sum of the error rate of each cluster is
less than or equal to 50
in a certain dimension. The maximum number of lines is the number of 
clusters minus one.
"MultiChannel.WUC" will split each dimension by weighted with-in cluster
sum of squared distances by "Ckmeans.1d.dp::MultiChannel.WUC". Applied in 
each projection on each dimension. The channel of each point is defined by 
its multivariate cluster label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_label</code></td>
<td>
<p>a vector of user-specified cluster labels for each observation
in <code>data</code>. The user is free to choose any clustering.
If unspecified, k-means clustering is used by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function implements algorithms described in (Wang et al. 2020).
</p>


<h3>Value</h3>

<p>A list that contains four items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>a matrix that contains the discretized version of the original <code>data</code>.
Discretized values are one(1)-based.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>a list of vectors containing decision boundaries for each variable/dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clabels</code></td>
<td>
<p>a vector containing cluster labels for each observation in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csimilarity</code></td>
<td>
<p>a similarity score between clusters from joint discretization
<code>D</code> and cluster labels <code>clabels</code>. The score is the adjusted Rand index.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jiandong Wang, Sajal Kumar and Mingzhou Song
</p>


<h3>References</h3>

<p>Wang J, Kumar S, Song M (2020).
“Joint Grid Discretization for Biological Pattern Discovery.”
In <em>Proceedings of the 11th ACM International Conference on Bioinformatics, Computational Biology and Health Informatics</em>.
ISBN 9781450379649, <a href="https://doi.org/10.1145/3388440.3412415">doi:10.1145/3388440.3412415</a>.
</p>


<h3>See Also</h3>

<p>See Ckmeans.1d.dp for discretizing univariate continuous data.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># using a specified k
x = rnorm(100)
y = sin(x)
z = cos(x)
data = cbind(x, y, z)
discretized_data = discretize.jointly(data, k=5)$D

# using a range of k
x = rnorm(100)
y = log1p(abs(x))
z = tan(x)
data = cbind(x, y, z)
discretized_data = discretize.jointly(data, k=c(3:10))$D

# using k = Inf
x = c()
y = c()
mns = seq(0,1200,100)
for(i in 1:12){
  x = c(x,runif(n=20, min=mns[i], max=mns[i]+20))
  y = c(y,runif(n=20, min=mns[i], max=mns[i]+20))
}
data = cbind(x, y)
discretized_data = discretize.jointly(data, k=Inf)$D

# using an alternate clustering method to k-means
library(cluster)
x = rnorm(100)
y = log1p(abs(x))
z = sin(x)
data = cbind(x, y, z)

# pre-cluster the data using partition around medoids (PAM)
cluster_label = pam(x=data, diss = FALSE, metric = "euclidean", k = 5)$clustering
discretized_data = discretize.jointly(data, cluster_label = cluster_label)$D

</code></pre>


</div>