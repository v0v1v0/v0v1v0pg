<div class="container">

<table style="width: 100%;"><tr>
<td>GAfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Genetic algorithm for preliminary estimation of a GMVAR, StMVAR, or G-StMVAR model</h2>

<h3>Description</h3>

<p><code>GAfit</code> estimates the specified GMVAR, StMVAR, or G-StMVAR model using a genetic algorithm.
It's designed to find starting values for gradient based methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GAfit(
  data,
  p,
  M,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  ngen = 200,
  popsize,
  smart_mu = min(100, ceiling(0.5 * ngen)),
  initpop = NULL,
  mu_scale,
  mu_scale2,
  omega_scale,
  W_scale,
  lambda_scale,
  ar_scale = 0.2,
  upper_ar_scale = 1,
  ar_scale2 = 1,
  regime_force_scale = 1,
  red_criteria = c(0.05, 0.01),
  pre_smart_mu_prob = 0,
  to_return = c("alt_ind", "best_ind"),
  minval,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt>
<dd>
<p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt>
<dd>
<p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>is "GMVAR", "StMVAR", or "G-StMVAR" model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li>
</ul>
<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngen</code></td>
<td>
<p>a positive integer specifying the number of generations to be ran through in
the genetic algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popsize</code></td>
<td>
<p>a positive even integer specifying the population size in the genetic algorithm.
Default is <code>10*n_params</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smart_mu</code></td>
<td>
<p>a positive integer specifying the generation after which the random mutations
in the genetic algorithm are "smart". This means that mutating individuals will mostly mutate fairly
close (or partially close) to the best fitting individual (which has the least regimes with time varying
mixing weights practically at zero) so far.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initpop</code></td>
<td>
<p>a list of parameter vectors from which the initial population of the genetic algorithm
will be generated from. The parameter vectors should be...
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt>
<dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li>
<p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li>
</ul>
</dd>
<dt><strong>For constrained models:</strong></dt>
<dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul><li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>
</dd>
<dt><strong>For same_means models:</strong></dt>
<dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li>
<p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li>
</ul>
</dd>
<dt><strong>For structural models:</strong></dt>
<dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul><li>
<p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>
<dl>
<dt><strong>If AR parameters are constrained: </strong></dt>
<dd>
<p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt>
<dd>
<p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt>
<dd>
<p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained:</strong></dt>
<dd>
<p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code>
with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is a <code class="reqn">(d(M-1) x r)</code>
constraint matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>2*sd(data[,i]), i=1,..,d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
structural model is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector partly specifying the scale and variability of the
random covariance matrices in random mutations. The elements of the matrix <code class="reqn">W</code> are drawn independently
from such normal distributions that the expectation of the main <strong>diagonal</strong> elements of the first
regime's error term covariance matrix <code class="reqn">\Omega_1 = WW'</code> is <code>W_scale</code>. The distribution of <code class="reqn">\Omega_1</code>
will be in some sense like a Wishart distribution but with the columns (elements) of <code class="reqn">W</code> obeying the given
constraints. The constraints are accounted for by setting the element to be always zero if it is subject to a zero
constraint and for sign constraints the absolute value or negative the absolute value are taken, and then the
variances of the elements of <code class="reqn">W</code> are adjusted accordingly. This argument is ignored if reduced form model
is considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_scale</code></td>
<td>
<p>a length <code class="reqn">M - 1</code> vector specifying the <strong>standard deviation</strong> of the mean zero normal
distribution from which the eigenvalue <code class="reqn">\lambda_{mi}</code> parameters are drawn from in random mutations.
As the eigenvalues should always be positive, the absolute value is taken. The elements of <code>lambda_scale</code>
should be strictly positive real numbers with the <code class="reqn">m-1</code>th element giving the degrees of freedom for the <code class="reqn">m</code>th
regime. The expected value of the main <strong>diagonal</strong> elements <code class="reqn">ij</code> of the <code class="reqn">m</code>th <code class="reqn">(m&gt;1)</code> error term covariance
matrix will be <code>W_scale[i]*(d - n_i)^(-1)*sum(lambdas*ind_fun)</code> where the <code class="reqn">(d x 1)</code> vector <code>lambdas</code> is
drawn from the absolute value of the t-distribution, <code>n_i</code> is the number of zero constraints in the <code class="reqn">i</code>th
row of <code class="reqn">W</code> and <code>ind_fun</code> is an indicator function that takes the value one iff the <code class="reqn">ij</code>th element of
<code class="reqn">W</code> is not constrained to zero. Basically, larger lambdas (or smaller degrees of freedom) imply larger variance.
</p>
<p>If the lambda parameters are <strong>constrained</strong> with the <code class="reqn">(d(M - 1) x r)</code> constraint matrix <code class="reqn">C_lambda</code>,
then provide a length <code class="reqn">r</code> vector specifying the standard deviation of the (absolute value of the) mean zero
normal distribution each of the <code class="reqn">\gamma</code> parameters are drawn from (the <code class="reqn">\gamma</code> is a <code class="reqn">(r x 1)</code> vector).
The expected value of the main diagonal elements of the covariance matrices then depend on the constraints.
</p>
<p>This argument is ignored if <code class="reqn">M==1</code> or a reduced form model is considered. Default is <code>rep(3, times=M-1)</code>
if lambdas are not constrained and <code>rep(3, times=r)</code> if lambdas are constrained.
</p>
<p>As with omega_scale and W_scale, this argument should be adjusted carefully if specified by hand. <strong>NOTE</strong>
that if lambdas are constrained in some other way than restricting some of them to be identical, this parameter
should be adjusted accordingly in order to the estimation succeed!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar_scale</code></td>
<td>
<p>a positive real number between zero and one, adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration. With large <code>p</code> or <code>d</code>, <code>ar_scale</code> is restricted from above,
see the details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper_ar_scale</code></td>
<td>
<p>the upper bound for <code>ar_scale</code> parameter (see above) in the random mutations. Setting
this too high might lead to failure in proposing new parameters that are well enough inside the parameter space,
and especially with large <code>p</code> one might want to try smaller upper bound (e.g., 0.5). With large <code>p</code> or
<code>d</code>, <code>upper_ar_scale</code> is restricted from above, see the details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong> coefficients
(in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to be very small.
If set smaller than 1, be careful as it might lead to failure in the creation of stationary parameter candidates</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regime_force_scale</code></td>
<td>
<p>a non-negative real number specifying how much should natural selection favor individuals
with less regimes that have almost all mixing weights (practically) at zero. Set to zero for no favoring or large
number for heavy favoring. Without any favoring the genetic algorithm gets more often stuck in an area of the
parameter space where some regimes are wasted, but with too much favouring the best genes might never mix into
the population and the algorithm might converge poorly. Default is <code>1</code> and it gives <code class="reqn">2x</code> larger surviving
probability weights for individuals with no wasted regimes compared to individuals with one wasted regime.
Number <code>2</code> would give <code class="reqn">3x</code> larger probability weights etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>red_criteria</code></td>
<td>
<p>a length 2 numeric vector specifying the criteria that is used to determine whether a regime is
redundant (or "wasted") or not.
Any regime <code>m</code> which satisfies <code>sum(mixingWeights[,m] &gt; red_criteria[1]) &lt; red_criteria[2]*n_obs</code> will
be considered "redundant". One should be careful when adjusting this argument (set <code>c(0, 0)</code> to fully disable
the 'redundant regime' features from the algorithm).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre_smart_mu_prob</code></td>
<td>
<p>A number in <code class="reqn">[0,1]</code> giving a probability of a "smart mutation" occuring randomly in each
iteration before the iteration given by the argument <code>smart_mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to_return</code></td>
<td>
<p>should the genetic algorithm return the best fitting individual which has "positive enough" mixing
weights for as many regimes as possible (<code>"alt_ind"</code>) or the individual which has the highest log-likelihood
in general (<code>"best_ind"</code>) but might have more wasted regimes?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minval</code></td>
<td>
<p>a real number defining the minimum value of the log-likelihood function that will be considered.
Values smaller than this will be treated as they were <code>minval</code> and the corresponding individuals will
never survive. The default is <code>-(10^(ceiling(log10(n_obs)) + d) - 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a single value, interpreted as an integer, or NULL, that sets seed for the random number generator in the beginning of
the function call. If calling <code>GAfit</code> from <code>fitGSMVAR</code>, use the argument <code>seeds</code> instead of passing the argument
<code>seed</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The core of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em>.
It utilizes a slightly modified version of the individually adaptive crossover and mutation rates described
by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed by
<em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>By "redundant" or "wasted" regimes we mean regimes that have the time varying mixing weights practically at
zero for almost all t. A model including redundant regimes would have about the same log-likelihood value without
the redundant regimes and there is no purpose to have redundant regimes in a model.
</p>
<p>Some of the AR coefficients are drawn with the algorithm by Ansley and Kohn (1986). However,
when using large <code>ar_scale</code> with large <code>p</code> or <code>d</code>, numerical inaccuracies caused
by the imprecision of the float-point presentation may result in errors or nonstationary AR-matrices.
Using smaller <code>ar_scale</code> facilitates the usage of larger <code>p</code> or <code>d</code>. Therefore, we bound
<code>upper_ar_scale</code> from above by <code class="reqn">1-pd/150</code> when <code>p*d&gt;40</code> and by <code class="reqn">1</code> otherwise.
</p>


<h3>Value</h3>

<p>Returns the estimated parameter vector which has the form described in <code>initpop</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity. <em>Journal of statistical computation
and simulation</em>, <strong>24</strong>:2,  99-106.
</p>
</li>
<li>
<p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li>
<p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li>
<p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li>
<p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li>
<p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li>
<p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
 # Preliminary estimation of a G-StMVAR(1, 1, 1) model with 50 generations.
 GA_estimates &lt;- GAfit(gdpdef, p=1, M=c(1, 1), model="G-StMVAR",
                       ngen=50, seed=1)
 GA_estimates

</code></pre>


</div>