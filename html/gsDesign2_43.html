<div class="container">

<table style="width: 100%;"><tr>
<td>gs_spending_bound</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Derive spending bound for group sequential boundary</h2>

<h3>Description</h3>

<p>Computes one bound at a time based on spending under given distributional
assumptions. While user specifies <code>gs_spending_bound()</code> for use with other
functions, it is not intended for use on its own.
Most important user specifications are made through a list provided to
functions using <code>gs_spending_bound()</code>.
Function uses numerical integration and Newton-Raphson iteration to derive
an individual bound for a group sequential design that satisfies a
targeted boundary crossing probability. Algorithm is a simple extension of
that in Chapter 19 of Jennison and Turnbull (2000).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gs_spending_bound(
  k = 1,
  par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL,
    max_info = NULL),
  hgm1 = NULL,
  theta = 0.1,
  info = 1:3,
  efficacy = TRUE,
  test_bound = TRUE,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Analysis for which bound is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>A list with the following items:
</p>

<ul>
<li> <p><code>sf</code> (class spending function).
</p>
</li>
<li> <p><code>total_spend</code> (total spend).
</p>
</li>
<li> <p><code>param</code> (any parameters needed by the spending function <code>sf()</code>).
</p>
</li>
<li> <p><code>timing</code> (a vector containing values at which spending function
is to be evaluated or <code>NULL</code> if information-based spending is used).
</p>
</li>
<li> <p><code>max_info</code> (when <code>timing</code> is <code>NULL</code>, this can be input as positive number
to be used with <code>info</code> for information fraction at each analysis).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hgm1</code></td>
<td>
<p>Subdensity grid from <code>h1()</code> (k=2) or <code>hupdate()</code> (k&gt;2)
for analysis k-1; if k=1, this is not used and may be <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Natural parameter used for lower bound only spending;
represents average drift at each time of analysis at least up to analysis k;
upper bound spending is always set under null hypothesis (theta = 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>Statistical information at all analyses, at least up to analysis k.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>efficacy</code></td>
<td>
<p><code>TRUE</code> (default) for efficacy bound, <code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test_bound</code></td>
<td>
<p>A logical vector of the same length as <code>info</code>
should indicate which analyses will have a bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer value controlling grid for numerical integration
as in Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally <code>r</code> will not be changed by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance parameter for convergence (on Z-scale).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a numeric bound (possibly infinite) or, upon failure,
generates an error message.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Author(s)</h3>

<p>Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>


<h3>References</h3>

<p>Jennison C and Turnbull BW (2000),
<em>Group Sequential Methods with Applications to Clinical Trials</em>.
Boca Raton: Chapman and Hall.
</p>


<h3>Examples</h3>

<pre><code class="language-R">gs_power_ahr(
  analysis_time = c(12, 24, 36),
  event = c(30, 40, 50),
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)
</code></pre>


</div>