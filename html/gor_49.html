<div class="container">

<table style="width: 100%;"><tr>
<td>search_tour_genetic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Genetic Algorithm for the TSP</h2>

<h3>Description</h3>

<p>Genetic algorithm for TSP.  In addition to crossover and mutation,
which are described below, the algorithm performs also 2-opt
local search on offsprings and mutants.  In this way, this
algorithm is at least as good as chained 2-opt search.
</p>


<h3>Usage</h3>

<pre><code class="language-R">search_tour_genetic(
  d,
  n,
  Npop = 20,
  Ngen = 50,
  beta = 1,
  elite = 2,
  Pini = NA,
  local = 1,
  verb = TRUE,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>Distance matrix of the TSP instance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of vertices of the TSP complete graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Npop</code></td>
<td>
<p>Population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ngen</code></td>
<td>
<p>Number of generations (iterations of the algorithm).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Control parameter of the crossing and selection
probabilities.  It defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elite</code></td>
<td>
<p>Number of better fitted individuals to pass on to the
next generation.  It defaults to 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pini</code></td>
<td>
<p>Initial population.  If it is NA, a random initial
population of Npop individuals is generated.  Otherwise, it
should be a matrix; each row should be an individual (a
permutation of the 1:n sequence) and then Npop is set to the
number of rows of Pini.  This option allows to chain several
runs of the genetic algorithm, which could be needed in the
hardest cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local</code></td>
<td>
<p>Average fraction of parents + offsprings + mutants
that will be taken as starting tours by the local search
algorithm improve_tour_2opt.  It should be a number between
0 and 1.  It defauls to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>Boolean to activate console echo.  It defaults to
TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>Boolean to activate the recording of the distances of
all tours found by the algorithm.  It defaults to FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The genetic algorithm consists of starting with a tour population,
which can be provided by the user or can be random.  The
initial population can be the output of a previous run of the
genetic algorithm, thus allowing a chained execution.  Then
the routine sequentially perform over the tours of the
population the <strong>crossover</strong>, <strong>mutation</strong>,
<strong>local search</strong> and <strong>selection</strong> operations.
</p>
<p>The <strong>crossover</strong> operation takes two tours and forms two
offsprings trying to exploit the good structure of the
parents; see crossover_tours for more information.
</p>
<p>The <strong>mutation</strong> operation performs a "small" perturbation of
each tour trying to escape from local optima.  It uses a
random 4-exchange, see perturb_tour_4exc and
search_tour_chain2opt for more information.
</p>
<p>The <strong>local search</strong> operation takes the tours found by the
crossover and mutation operations and improves them using the
2-opt local search heuristic, see improve_tour_2opt.  This
makes this algorithm at least as good as chained local search,
see search_tour_chain2opt.
</p>
<p>The <strong>selection</strong> operation is used when selecting pairs of
parents for crossover and when selecting individuals to form
the population for the next generation.  In both cases, it
uses a probability exponential in the distance with rate
parameter "beta", favouring the better fitted to be selected.
Lower values of beta favours the inclusion of tours with worse
fitting function values.  When selecting the next population,
the selection uses <em>elitism</em>, which is to save the best
fitted individuals to the next generation; this is controlled
with parameter "elite".
</p>
<p>The usefulness of the crossover and mutation operations stems from
its abitily to escape from the 2-opt local minima in a way
akin to the perturbation used in chained local search
search_tour_chain2opt.  Of course, more iterations (Ngen)
and larger populations (Npop) might lower the result, but
recall that no random algorithm can guarantee to find the
optimum of a given TSP instance.
</p>
<p>This algorithm calls many times the routines crossover_tours,
improve_tour_2opt and perturb_tour_4exc; therefore, it is
not especially efficient when called on large problems or with
high populations of many generations.  Input parameter "local"
can be used to randomly select which tours will start local
search, thus diminishing the run time of the algorithm.
Please consider chaining the algorithm:  perform short runs,
using the output of a run as the input of the next.
</p>


<h3>Value</h3>

<p>A list with four components: $tour contains a permutation
of the 1:n sequence representing the tour constructed by the
algorithm, $distance contains the value of the distance
covered by the tour, $generation contains the generation is
which the minimum was found and $population contains the final
tour population.  When log=TRUE, the output includes several
lists of distances of tours found by the algorithm, separated
by initial tours, offsprings, mutants, local minima and
selected tours.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>References</h3>

<p>Hromkovic <em>Algorithms for hard problems</em> (2004),
Hartmann, Weigt, <em>Phase transitions in combinatorial
optimization problems</em> (2005).
</p>


<h3>See Also</h3>

<p>crossover_tours performs the crosover of two tours,
gauge_tour transforms a tour into a canonical sequence for
comparison, search_tour_chain2opt performs a chained 2-opt
search, perturb_tour_4exc transforms a tour using a random
4-exchange, improve_tour_2opt improves a tour using the
2-opt algorithm, improve_tour_3opt improves a tour using the
3-opt algorithm, build_tour_nn_best nearest neighbor
heuristic, build_tour_2tree double-tree heuristic,
compute_tour_distance computes tour distances,
compute_distance_matrix computes a distance matrix,
plot_tour plots a tour.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Regular example with obvious solution (minimum distance 32)
m &lt;- 6   # Generate some points in the plane
z &lt;- cbind(c(rep(0,m), rep(2,m), rep(5,m), rep(7,m)), rep(seq(0,m-1),4))
n &lt;- nrow(z)
d &lt;- compute_distance_matrix(z)
bc &lt;- search_tour_genetic(d, n, Npop = 5, Ngen = 3, local = 0.2)
bc     # Distance 32
plot_tour(z,bc)

## Random points
set.seed(1)
n &lt;- 15
z &lt;- cbind(runif(n,min=1,max=10),runif(n,min=1,max=10))
d &lt;- compute_distance_matrix(z)
bg &lt;- search_tour_genetic(d, n, 5, 3, local = 0.25)
bg     # Distance 32.48669
plot_tour(z,bg)

</code></pre>


</div>