<div class="container">

<table style="width: 100%;"><tr>
<td>CS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Continuous Spike</h2>

<h3>Description</h3>

<p>Run a Gibbs sampler for a multivariate Bayesian sparse group selection model with Continuous spike prior for detecting pleiotropic effects on the traits. This function is designed for summary statistics containing estimated regression coefficients and their estimated covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">CS(
  Betah,
  Sigmah,
  kappa0,
  tau20,
  zeta0,
  m,
  K,
  niter = 1000,
  burnin = 500,
  nthin = 2,
  nchains = 2,
  a1 = a1,
  a2 = a2,
  c1 = c1,
  c2 = c2,
  sigma2 = 10^-3,
  snpnames = snpnames,
  genename = genename
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Betah</code></td>
<td>
<p>A list containing m-dimensional vectors of the regression coefficients for K studies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigmah</code></td>
<td>
<p>A list containing the positive definite covariance matrices (m*m-dimensional) which is the estimated covariance matrices of K studies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa0</code></td>
<td>
<p>Initial value for kappa (its dimension is equal to nchains).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau20</code></td>
<td>
<p>Initial value for tau2 (its dimension is equal to nchains).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta0</code></td>
<td>
<p>Initial value for zeta.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of variables in the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Number of traits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Number of iterations for the Gibbs sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Number of burn-in iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthin</code></td>
<td>
<p>The lag of the iterations used for the posterior analysis is defined (or thinning rate).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nchains</code></td>
<td>
<p>Number of Markov chains, when nchains&gt;1, the function calculates the Gelman-Rubin convergence statistic, as modified by Brooks and Gelman (1998).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a1, a2</code></td>
<td>
<p>Hyperparameters of kappa. Default is a1=0.1 and a2=0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c1, c2</code></td>
<td>
<p>Hyperparameters of tau2. Default is c1=0.1 and c2=0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>Variance of spike (multivariate normal distribution with a diagonal covariance matrix with small variance) representing the null effect distribution. Default is 10^-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snpnames</code></td>
<td>
<p>Names of variables for the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genename</code></td>
<td>
<p>Name of group.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let betah_k, k=1,...,K be a m-dimensional vector of the regression coefficients for the kth study and Sigmah_k  be its estimated covariance matrix. The hierarchical set-up of  CS prior, by considering summary statistics (betah_k and Sigmah_k, k=1,...,K) as the input of the method, is given by:
</p>
<p>betah_k ~ (1 - zeta_k) N_m(0,sigma2 I_m) + zeta_k N_m(0,tau2 I_m ),
</p>
<p>zeta_k ~  Ber(kappa),
</p>
<p>kappa ~ Beta(a_1,a_2),
</p>
<p>tau2 ~ inverseGamma (c_1,c_2).
</p>


<h3>Value</h3>


<ul>
<li>
<p> mcmcchain: The list of simulation output for all parameters.
</p>
</li>
<li>
<p> Summary: Summary statistics for regression coefficients in each study.
</p>
</li>
<li>
<p> Criteria: genename, snpnames, PPA, log10BF, lBFDR, theta.
</p>
</li>
<li>
<p> Indicator: A table containing m rows of binary indicators for each study, the number of studies with nonzero signal and having pleiotropic effect by credible interval (CI). The first K columns show nonzero signals, K+1 th column includes the number of studies with nonzero signal and the last column shows an indicator for having pleiotropic effect of each SNP.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Taban Baghfalaki.
</p>


<h3>References</h3>

<p>Baghfalaki, T., Sugier, P. E., Truong, T., Pettitt, A. N., Mengersen, K., &amp; Liquet, B. (2021). Bayesian meta analysis models for cross cancer genomic investigation of pleiotropic effects using group structure. Statistics in Medicine, 40(6), 1498-1518.
</p>


<h3>Examples</h3>

<pre><code class="language-R">############################# Gene DNAJC1 ###############################################
data(DNAJC1)
Breast &lt;- DNAJC1$Breast
Thyroid &lt;- DNAJC1$Thyroid
genename &lt;- "DNAJC1"
snpnames &lt;- Breast$snp
Betah &lt;- list(Breast$beta, Thyroid$beta)
Sigmah &lt;- list(diag(Breast$se^2), diag(Thyroid$se^2))
K &lt;- 2
m &lt;- 14

pvalue &lt;- matrix(0, K, m)
for (k in 1:K) {
  pvalue[k, ] &lt;- 2 * pnorm(-abs(Betah[[k]] / sqrt(diag(Sigmah[[k]]))))
}

zinit &lt;- rep(0, K)
for (j in 1:K) {
  index &lt;- 1:m
  PVALUE &lt;- p.adjust(pvalue[j, ])
  SIGNALS &lt;- index[PVALUE &lt; 0.05]
  modelf1 &lt;- rep(0, m)
  modelf1[SIGNALS] &lt;- 1
  if (max(modelf1) == 1) (zinit[j] &lt;- 1)
}


RES &lt;- CS(Betah, Sigmah,
  kappa0 = 0.5, tau20 = 1, zeta0 = zinit,
  m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 1, a1 = 0.1, a2 = 0.1,
  c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames = snpnames, genename = genename
)
## Not run: 
  print(RES)


  RES1 &lt;- CS(Betah, Sigmah,
    kappa0 = c(0.2, 0.5), tau20 = c(1, 2), zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 2,
    a1 = 0.1, a2 = 0.1, c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames, genename
  )
  print(RES1)
  ################### Simulated summary level data with K=5 ###############################
  data(Simulated_summary)
  genename &lt;- Simulated_summary$genename
  snpnames &lt;- Simulated_summary$snpnames
  Betah &lt;- Simulated_summary$simBeta
  Sigmah &lt;- Simulated_summary$simSIGMA
  K &lt;- 5
  m &lt;- 10

  pvalue &lt;- matrix(0, K, m)
  for (k in 1:K) {
    pvalue[k, ] &lt;- 2 * pnorm(-abs(Betah[[k]] / sqrt(diag(Sigmah[[k]]))))
  }

  zinit &lt;- rep(0, K)
  for (j in 1:K) {
    index &lt;- 1:m
    PVALUE &lt;- p.adjust(pvalue[j, ])
    SIGNALS &lt;- index[PVALUE &lt; 0.05]
    modelf1 &lt;- rep(0, m)
    modelf1[SIGNALS] &lt;- 1
    if (max(modelf1) == 1) (zinit[j] &lt;- 1)
  }


  RES &lt;- CS(Betah, Sigmah,
    kappa0 = 0.5, tau20 = 1, zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 1, a1 = 0.1, a2 = 0.1,
    c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames = snpnames, genename = genename
  )
  print(RES)


  RES1 &lt;- CS(Betah, Sigmah,
    kappa0 = c(0.2, 0.5), tau20 = c(1, 2), zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 2,
    a1 = 0.1, a2 = 0.1, c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames, genename
  )
  print(RES1)
  ################################### Gene PARP2 ##########################################
  library(BhGLM)
  data(PARP2)
  Breast &lt;- PARP2$Breast
  Thyroid &lt;- PARP2$Thyroid
  genename &lt;- "PARP2"
  snpnames &lt;- c("rs3093872", "rs3093921", "rs1713411", "rs3093926", "rs3093930", "rs878156")


  Fit1 &lt;- BhGLM::bglm(y1 ~ ., family = binomial(link = "logit"), data = Breast)
  Betah1 &lt;- Fit1$coefficients[-1]
  Sigmah1 &lt;- cov(coef(arm::sim(Fit1)))[-1, -1]

  Fit2 &lt;- BhGLM::bglm(y2 ~ ., family = binomial(link = "logit"), data = Thyroid)
  Betah2 &lt;- Fit2$coefficients[-1]
  Sigmah2 &lt;- cov(coef(arm::sim(Fit2)))[-1, -1]

  Betah &lt;- list(Betah1, Betah2)
  Sigmah &lt;- list(Sigmah1, Sigmah2)
  K &lt;- 2
  m &lt;- 6

  pvalue &lt;- matrix(0, K, m)
  for (k in 1:K) {
    pvalue[k, ] &lt;- 2 * pnorm(-abs(Betah[[k]] / sqrt(diag(Sigmah[[k]]))))
  }

  zinit &lt;- rep(0, K)
  for (j in 1:K) {
    index &lt;- 1:m
    PVALUE &lt;- p.adjust(pvalue[j, ])
    SIGNALS &lt;- index[PVALUE &lt; 0.05]
    modelf1 &lt;- rep(0, m)
    modelf1[SIGNALS] &lt;- 1
    if (max(modelf1) == 1) (zinit[j] &lt;- 1)
  }


  RES &lt;- CS(Betah, Sigmah,
    kappa0 = 0.5, tau20 = 1, zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 1, a1 = 0.1, a2 = 0.1,
    c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames = snpnames, genename = genename
  )
  print(RES)

  RES1 &lt;- CS(Betah, Sigmah,
    kappa0 = c(0.2, 0.5), tau20 = c(1, 2), zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 2,
    a1 = 0.1, a2 = 0.1, c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames, genename
  )
  print(RES1)
  ########### Simulated individual level data with K=3 and continuous phynotype ###########
  library(BhGLM)
  data(Simulated_individual)
  Study1 &lt;- Simulated_individual$Study1
  Study2 &lt;- Simulated_individual$Study2
  Study3 &lt;- Simulated_individual$Study3
  K &lt;- 3
  m &lt;- 30
  genename &lt;- "Simulated"
  snpnames &lt;- sprintf("SNP%s", seq(1:m))


  Fit1 &lt;- BhGLM::bglm(Y1 ~ ., family = gaussian, data = data.frame(Study1))
  Betah1 &lt;- Fit1$coefficients[-1]
  Sigmah1 &lt;- cov(coef(arm::sim(Fit1)))[-1, -1]

  Fit2 &lt;- BhGLM::bglm(Y2 ~ ., family = gaussian, data = data.frame(Study2))
  Betah2 &lt;- Fit2$coefficients[-1]
  Sigmah2 &lt;- cov(coef(arm::sim(Fit2)))[-1, -1]

  Fit3 &lt;- BhGLM::bglm(Y3 ~ ., family = gaussian, data = data.frame(Study3))
  Betah3 &lt;- Fit3$coefficients[-1]
  Sigmah3 &lt;- cov(coef(arm::sim(Fit3)))[-1, -1]

  Betah &lt;- list(Betah1, Betah2, Betah3)
  Sigmah &lt;- list(Sigmah1, Sigmah2, Sigmah3)


  pvalue &lt;- matrix(0, K, m)
  for (k in 1:K) {
    pvalue[k, ] &lt;- 2 * pnorm(-abs(Betah[[k]] / sqrt(diag(Sigmah[[k]]))))
  }

  zinit &lt;- rep(0, K)
  for (j in 1:K) {
    index &lt;- 1:m
    PVALUE &lt;- p.adjust(pvalue[j, ])
    SIGNALS &lt;- index[PVALUE &lt; 0.05]
    modelf1 &lt;- rep(0, m)
    modelf1[SIGNALS] &lt;- 1
    if (max(modelf1) == 1) (zinit[j] &lt;- 1)
  }

  RES &lt;- CS(Betah, Sigmah,
    kappa0 = 0.5, tau20 = 1, zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 1, a1 = 0.1, a2 = 0.1,
    c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames = snpnames, genename = genename
  )
  print(RES)

  RES1 &lt;- CS(Betah, Sigmah,
    kappa0 = c(0.2, 0.5), tau20 = c(1, 2), zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 2,
    a1 = 0.1, a2 = 0.1, c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames, genename
  )
  print(RES1)

  ########### Simulated individual level data with K=2 and gene expression data ###########
  library(BhGLM)
  data(Simulated_individual_survival)
  Study1 &lt;- Simulated_individual_survival$Study1
  Study2 &lt;- Simulated_individual_survival$Study2
  K &lt;- 2
  m &lt;- 10
  genename &lt;- "Simulated"
  snpnames &lt;- sprintf("G%s", seq(1:m))


  Fit1 &lt;- BhGLM::bcoxph(Study1$T ~ Study1$X)
  Betah1 &lt;- Fit1$coefficients
  Sigmah1 &lt;- Fit1$var


  Fit2 &lt;- BhGLM::bcoxph(Study2$T ~ Study2$X)
  Betah2 &lt;- Fit2$coefficients
  Sigmah2 &lt;- Fit2$var

  Betah &lt;- list(Betah1, Betah2)
  Sigmah &lt;- list(Sigmah1, Sigmah2)

  pvalue &lt;- matrix(0, K, m)
  for (k in 1:K) {
    pvalue[k, ] &lt;- 2 * pnorm(-abs(Betah[[k]] / sqrt(diag(Sigmah[[k]]))))
  }

  zinit &lt;- rep(0, K)
  for (j in 1:K) {
    index &lt;- 1:m
    PVALUE &lt;- p.adjust(pvalue[j, ])
    SIGNALS &lt;- index[PVALUE &lt; 0.05]
    modelf1 &lt;- rep(0, m)
    modelf1[SIGNALS] &lt;- 1
    if (max(modelf1) == 1) (zinit[j] &lt;- 1)
  }


  RES1 &lt;- CS(Betah, Sigmah,
    kappa0 = c(0.2, 0.5), tau20 = c(1, 2), zeta0 = zinit,
    m = m, K = K, niter = 2000, burnin = 1000, nthin = 2, nchains = 2,
    a1 = 0.1, a2 = 0.1, c1 = 0.1, c2 = 0.1, sigma2 = 10^-3, snpnames, genename
  )
  print(RES1)

## End(Not run)
</code></pre>


</div>