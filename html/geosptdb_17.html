<div class="container">

<table style="width: 100%;"><tr>
<td>rbfST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
gaussian, exponential, trigonometric, thin plate spline, inverse multiquadratic, and multiquadratic radial basis function for spatio-temporal prediction
</h2>

<h3>Description</h3>

               
<p>Function for spatio-temporal interpolation from radial basis function (<em>rbfST</em>), where <em>rbfST</em> is in a local neighbourhood.
</p>
<p><em>exponential (EXPON)</em><br></p>
<p style="text-align: center;"><code class="reqn">
\phi(\delta)=e^{-\eta \delta},   \eta&gt;0
</code>
</p>

<p><em>gaussiano (GAU)</em><br></p>
<p style="text-align: center;"><code class="reqn">
\phi(\delta)=e^{-\eta \delta^{2}},    \eta\neq0
</code>
</p>

<p><em>multiquadratic (M)</em><br></p>
<p style="text-align: center;"><code class="reqn">
\phi(\delta)=\sqrt{\eta^2+\delta^2},   \eta\neq0
</code>
</p>

<p><em>inverse multiquadratic (IM)</em><br></p>
<p style="text-align: center;"><code class="reqn">
\phi(\delta)=1/\sqrt{\eta^2+\delta^2},   \eta\neq0
</code>
</p>

<p><em>thin plate spline (TPS)</em><br></p>
<p style="text-align: center;"><code class="reqn">\phi(\delta)=(\eta\cdot\delta)^{2}log(\eta\cdot\delta), if: \delta&gt;0, \eta&gt;0</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi(\delta) = 0, otherwise</code>
</p>

<p><em>completely regularized spline (CRS)</em><br></p>
<p style="text-align: center;"><code class="reqn">\phi(\delta) = \ln(\eta\cdot \delta/2)^{2}+E_{1}(\eta\cdot \delta/2)^{2}+C_{E}, if: \delta&gt;0, \eta&gt;0</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi(\delta) = 0, otherwise</code>
</p>

<p>where <code class="reqn">\ln</code> is natural logarithm, <code class="reqn">E_{1}(x)</code> is the exponential integral function, and <code class="reqn">C_{E}</code> is the Euler constant.
</p>
<p><em>spline with tension (ST)</em>
</p>
<p style="text-align: center;"><code class="reqn">
\phi(\delta)=\ln(\eta\cdot \delta/2)+K_{0}(\eta\cdot \delta)+C_{E}, if: \delta&gt;0
</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi(\delta) = 0, otherwise</code>
</p>

<p>where <code class="reqn">K_{0}(x)</code> is the modified Bessel function and <code class="reqn">C_{E}</code> is the Euler constant.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rbfST(formula, data, eta, rho, newdata, n.neigh, func, progress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables (covariates or principal coordinates); suppose the dependent variable has name <code class="reqn">z_{st}</code> for a <em>rbfST</em> detrended use <code class="reqn">z_{st}</code><code>~1</code>; for a <em>rbfST</em> with trend suppose <code class="reqn">z_{st}</code> is linearly dependent on <code>x</code> and <code>y</code>, use the formula <code class="reqn">z_{st}</code><code>~x+y</code> (linear trend).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>SpatialPointsDataFrame: should contain the spatio-temporal dependent variable, independent variables (statics and/or dynamics), spatial coordinates and the time as an integer or numerical variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>the optimal smoothing parameter, we recommend using the parameter
found by minimizing the root-mean-square prediction errors using cross-validation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>optimal robustness parameter, we recommend using the value obtained by minimizing the root-mean-square prediction errors with cross-validation. <em>eta</em> and <em>rho</em> parameters can be optimized simultaneously, through the <code>bobyqa</code> function from <code>nloptr</code> or  <code>minqa</code> packages</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>data frame or spatial object with prediction/simulation spatio-temporal locations; should contain attribute columns with the independent variables (if present) and (if locations is a formula) the coordinates and time with names, as defined in locations where you want to generate new predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.neigh</code></td>
<td>
<p>number of nearest observations that should be used for a <em>rbfST</em>
prediction, where nearest is defined in terms of the spatio-temporal locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>spatio-temporal radial basis function; model type: "GAU", "EXPON", "TRI", "TPS", "CRS", "ST", "IM" and "M", are currently available</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>

<p>whether a progress bar shall be printed for spatio-temporal radial basis functions; default=TRUE
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>rbf.st function generates individual spatio-temporal predictions from gaussian (GAU), exponential (EXPON), trigonometric (TRI) thin plate spline (TPS), completely regularized spline (CRS), spline with tension (ST), 
inverse multiquadratic (IM), and multiquadratic (M) functions
</p>


<h3>Value</h3>

<p>Attributes columns contain coordinates, time, predictions, and the variance
column contains NA's
</p>


<h3>References</h3>

<p>Melo, C. E. (2012). <em>Analisis geoestadistico espacio tiempo basado en distancias y splines con
aplicaciones</em>. PhD. Thesis. Universitat de Barcelona. 276 p. <a href="http://www.tdx.cat/bitstream/handle/10803/101202/CEMM_TESIS.pdf">[link]</a> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# considering 10 principal coordinates (constructed from a distance-based regression model)
data(croatia.temp)
data(croatiadb)

# prediction case: one point
point &lt;- data.frame(670863,5043464,5,170,200,15.7,3)
names(point) &lt;- c("x","y","t","dem","dsea","twi","est")

croatia.temp[,7] &lt;- as.factor(croatia.temp[,7])
dblm1 &lt;- dblm(data=croatia.temp,y=croatiadb$MTEMP)         
newdata1 &lt;- t(cp.xnews(newdata=point,eigenvalues=dblm1$ev, data=croatia.temp,trend=dblm1$cp))
colnames(newdata1) &lt;- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10")
newdata1 &lt;- data.frame(point[,1:3],newdata1)

data(croatiadb)
coordinates(croatiadb) &lt;- ~x+y
coordinates(newdata1) &lt;- ~x+y
rbfST(MTEMP~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10, data=croatiadb, eta=0.010076, rho=0.00004, 
       newdata=newdata1, n.neigh=60, func="TPS")

# prediction case: a grid of points Croatia (month july)
data(croatia.grid7cp)
coordinates(croatia.grid7cp) &lt;- ~x+y
rbf.t &lt;- rbfST(MTEMP~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10, croatiadb, eta=0.01076, rho=0.00004, 
                newdata=croatia.grid7cp, n.neigh=30, func="TPS")                  
coordinates(rbf.t) &lt;- c("x", "y")
gridded(rbf.t) &lt;- TRUE

# show prediction map
spplot(rbf.t["var1.pred"], cuts=30, col.regions=bpy.colors(40), main = "Earth's average 
       temperature TPS map\n (july month)", key.space=list(space="right", cex=0.8))

## End(Not run)
</code></pre>


</div>