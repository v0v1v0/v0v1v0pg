<div class="container">

<table style="width: 100%;"><tr>
<td>cs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Specify a Smoothing Cubic Spline Fit in a GAMLSS Formula</h2>

<h3>Description</h3>

<p>The functions <code>cs()</code> and <code>scs()</code> are using the cubic smoothing splines function <code>smooth.spline()</code> to do smoothing.  They take a vector and return it with several attributes. 
The vector is used in the construction of the model matrix. The functions do not do the smoothing, but assigns the attributes to the vector to aid gamlss in the smoothing.
The function doing the smoothing is <code>gamlss.cs()</code>.
This function use the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code> which is then used by the backfitting function  <code>additive.fit()</code> which is based on the original GAM implementation described in Chambers and Hastie (1992).
The function <code>gamlss.scs()</code>  differs from the function <code>cs()</code> in that allows cross validation of the smoothing parameters unlike the <code>cs()</code> which fixes the effective degrees of freedom, <code>df</code>.  Note that the recommended smoothing function is now the function <code>pb()</code> which allows the estimation of the smoothing parameters using a local maximum likelihood. The function <code>pb()</code> is based on the penalised beta splines (P-splines) of Eilers and Marx (1996).
</p>
<p>The (experimental) function <code>vc</code> is now defunct. For fitting varying coefficient models, Hastie and Tibshirani (1993) use the function <code>pvc()</code>. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cs(x, df = 3, spar = NULL, c.spar = NULL, control = cs.control(...), ...)
scs(x, df = NULL, spar = NULL, control = cs.control(...), ...)
cs.control(cv = FALSE, all.knots = TRUE, nknots = NULL, keep.data = TRUE,
               df.offset = 0, penalty = 1.4, control.spar = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the univariate predictor, (or expression, that evaluates to a numeric vector). 
For the function <code>vc</code> the x argument is the vector which has its (linear) coefficient change with <code>r</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>the desired equivalent number of degrees of freedom (trace of the smoother matrix minus two for the constant and linear fit). The real smoothing parameter (spar below) is found such that df=tr(S)-2, 
where S is the implicit smoother matrix. Values for df should be greater than 0, with 0 implying a linear fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar</code></td>
<td>
<p> smoothing parameter, typically (but not necessarily) in (0,1].   
The coefficient lambda of the integral of the squared second derivative in the fit (penalised log likelihood)
criterion is a monotone function of ‘spar’, see the details in <code>smooth.spline</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.spar</code></td>
<td>
<p>This is an option to be used when the degrees of freedom of the fitted gamlss object are different from the ones given as input in the option <code>df</code>.  The default values used are the ones given  the  option <code>control.spar</code>    in the R function <code>smooth.spine()</code> and they are <code>c.spar=c(-1.5, 2)</code>. For  very large data sets e.g. 10000 observations, the upper limit may have to increase for example to  <code>c.spar=c(-1.5, 2.5)</code>. Use this option if you have received the warning 'The output df are different from the input, change the control.spar'. <code>c.spar</code> can take both vectors or lists of length 2, for example <code>c.spar=c(-1.5, 2.5)</code> or <code>c.spar=list(-1.5, 2.5)</code> would have the same effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control for the function <code>smooth.spline()</code>, see below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>see the  <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.knots</code></td>
<td>
<p>see the  <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nknots</code></td>
<td>
<p>see the  <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>see the  <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.offset</code></td>
<td>
<p>see the  <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>see the  <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>smooth.spline()</code>, here the default value is 1.4</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.spar</code></td>
<td>
<p>see above <code>c.spar</code> or the equivalent argument in the function <code>smooth.spline</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for extra arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that <code>cs</code> itself does no smoothing; it simply sets things up for the function <code>gamlss()</code> which in turn uses the function 
<code>additive.fit()</code> for backfitting which in turn uses <code>gamlss.cs()</code>
</p>
<p>Note that  <code>cs()</code> and  <code>scs()</code> functions behave differently at their default values that is if df and lambda are not specified.
<code>cs(x)</code> by default will use 3 extra degrees of freedom for smoothing for <code>x</code>.
<code>scs(x)</code> by default will estimate lambda (and the degrees of freedom) automatically using generalised cross validation (GCV).
Note that if GCV is used the convergence of the gamlss model  can be less stable compared to a model where the degrees of freedom are fixed. This will be true for small data sets.         
</p>


<h3>Value</h3>

<p>the vector x is returned, endowed with a number of attributes. The vector itself is used in the construction of the model matrix, 
while the attributes are needed for the backfitting algorithms <code>additive.fit()</code>. 
Since smoothing splines includes linear fits, the linear part will be efficiently computed with the other parametric linear parts of the model. 
</p>


<h3>Warning</h3>

<p>For a user who wishes to compare the <code>gamlss()</code> results with the equivalent <code>gam()</code> 
results in S-plus: make sure when using S-plus that the convergence criteria epsilon and bf.epsilon in <code>control.gam()</code> are decreased sufficiently
to ensure proper convergence in S-plus. 
Also note that the degrees of freedom are defined on top of the linear term in <code>gamlss</code>, but on top of the constant term in S-plus, 
(so use an extra degrees of freedom in S-plus in order to obtain comparable results to those in <code>galmss</code>).
</p>
<p>Change the upper limit of spar if you received the warning 'The output df are different from the input, change the control.spar'.
</p>
<p>For large data sets do not use expressions, e.g. <code>cs(x^0.5)</code> inside the <code>gamlss</code> function command but evaluate the expression, 
e.g. nx=<code class="reqn">x^0.5</code>, first and then use <code>cs(nx)</code>.  
</p>


<h3>Note</h3>

<p>The degrees of freedom df are defined differently from that of the gam() function in S-plus. Here df are the additional degrees of freedom 
excluding the constant and the linear part of x. For example <code>df=4</code> in <code>gamlss()</code> is equivalent to <code>df=5</code> in <code>gam()</code> in S-plus </p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos and Bob Rigby (see also the documentation of the function<code>smooth.spline()</code> for the  original authors of the cubic spline function.)</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in S</em>, Wadsworth &amp; Brooks/Cole.
</p>
<p>Eilers, P. H. C. and Marx, B. D. (1996). Flexible smoothing with B-splines and penalties (with comments and rejoinder). <em>Statist. Sci</em>, <b>11</b>, 89-121.
</p>
<p>Hastie, T. J. and Tibshirani, R. J. (1993), Varying coefficient models (with discussion),J. R. Statist. Soc. B., <b>55</b>,
757-796.
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code>gamlss</code>, <code>gamlss.cs</code>, <code>pb</code>, <code>pvc</code>   </p>


<h3>Examples</h3>

<pre><code class="language-R"># cubic splines example
data(aids)
# fitting a smoothing cubic spline with 7 degrees of freedom
# plus the a quarterly  effect  
aids1&lt;-gamlss(y~cs(x,df=7)+qrt,data=aids,family=PO) # 
aids2&lt;-gamlss(y~scs(x,df=5)+qrt,data=aids,family=PO) # 
aids3&lt;-gamlss(y~scs(x)+qrt,data=aids,family=PO) # using GCV 
with(aids, plot(x,y))
lines(aids$x,fitted(aids1), col="red")
lines(aids$x,fitted(aids3), col="green")
rm(aids1, aids2, aids3)
</code></pre>


</div>