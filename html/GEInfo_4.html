<div class="container">

<table style="width: 100%;"><tr>
<td>cv.GEInfo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for GEInfo</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation for GEInfo approach,
which adaptively accommodates the quality of the prior information and automatically detects the false information.
Tuning parameters are chosen based on a user given criterion.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.GEInfo(
  E,
  G,
  Y,
  family,
  S_G,
  S_GE,
  nfolds = 3,
  xi = 6,
  epsilon = 0,
  max.it = 500,
  thresh = 0.001,
  criterion = "BIC",
  Type_Y = NULL,
  kappa1 = NULL,
  kappa2 = NULL,
  lam1 = NULL,
  lam2 = NULL,
  tau = c(0, 0.25, 0.5, 0.75, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>Observed matrix of E variables, of dimensions n x q.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Observed matrix of G variables, of dimensions n x p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Response variable, of length n. Quantitative for family="gaussian", or family="poisson" (non-negative counts). For family="binomial" should be a factor with two levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Model type: one of ("gaussian", "binomial", "poisson").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S_G</code></td>
<td>
<p>A user supplied vector, denoting the subscript of G variables which have prior information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S_GE</code></td>
<td>
<p>A user supplied matrix, denoting the subscript of GE interactions which have prior information.
The first and second columns of S_GE represent the subscript of G variable and the subscript of E variable, respectively.
For example, S_GE = matrix( c(1, 2), ncol = 2), which indicates that the 1st G variable and the 2nd E variables have an interaction effect on Y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Number of folds. Default is 3.
Although nfolds can be as large as the sample size n (leave-one-out CV), it is not recommended for large datasets. Smallest value allowable is nfolds=3</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>Tuning parameter of MCP penalty. Default is 6.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Tuning parameter of Ridge penalty which shrinks on the coefficients having prior information. Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.it</code></td>
<td>
<p>Maximum number of iterations (total across entire path). Default is 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for group coordinate descent algorithm. The algorithm iterates until the change for each coefficient is less than thresh. Default is 1e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>Criterion used for tuning selection via cross-validation. Currently five options: MSE, AIC, BIC, EBIC, GCV. Default is BIC. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Type_Y</code></td>
<td>
<p>A vector of Type_Y prior information, having the same length with Y. Default is NULL.
For family="gaussian", Type_Y is continuous. For family="binomial", Type_Y is binary.
For family="poisson", Type_Y is count.
If users supply a Type_Y prior information, this function will use it to estimate a GEInfo model. If Type_Y=NULL,
the function will incorporate the prior information included in S_G and S_GE to realize a GEInfo model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa1</code></td>
<td>
<p>A user supplied kappa1 sequence. Default is kappa1=NULL.
Typical usage is to have the program compute its own kappa1 sequence. Supplying a value of kappa1 overrides this. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa2</code></td>
<td>
<p>A user supplied kappa2 sequence. Default is kappa2=NULL.
Typical usage is to have the program compute its own kappa2 sequence. Supplying a value of kappa2 overrides this. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam1</code></td>
<td>
<p>A user supplied lambda1 sequence. Default is lam1=NULL.
Typical usage is to have the program compute its own lambda1 sequence. Supplying a value of lam1 overrides this. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam2</code></td>
<td>
<p>A user supplied lambda2 sequence. Default is lam2=NULL.
Typical usage is to have the program compute its own lambda1 sequence. Supplying a value of lam2 overrides this. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>A user supplied tau sequence ranging from 0 to 1.
Default is tau = c (0, 0.25,0.5,0.75,1). See Details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function contains five tuning parameters, namely kappa1, kappa2, lambda1, lambda2, and tau.
kappa1 and kappa2 are used to estimate model and select variables.
lambda1 and lambda2 are used to calculate the prior-predicted response based on S_G and S_GE.
tau is used for balancing between the observed response Y and the prior-predicted response.
When tau=0 and tau=1, this function realizes cross-validation for GEsgMCP and CGEInfo approaches, respectively.
</p>
<p>In order to select the optimal tuning combination, there are five criteria available, which are MSE, AIC, BIC, GCV, and EBIC. Let L be the loss function of the model,
<code class="reqn">MSE=L</code>, <code class="reqn">AIC=2L+2df</code>, <code class="reqn">BIC=2L+ln(n)df</code>, <code class="reqn">GCV=2L/(1-df/n)^2</code>,
and <code class="reqn">EBIC=2L+ln(n)df + 2df ln(nvar) (1-ln(n)/(2ln(nvar)))</code>.
In most cases, BIC is a good choice. In the case of high dimension, EBIC criterion is recommended first,
which has demonstrated satisfactory performance in high-dimensional studies.
</p>


<h3>Value</h3>

<p>An object of class "GEInfo" is returned, which is a list with the ingredients of the cross-validation fit.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coef.all.tau</code></td>
<td>
<p>A matrix of coefficients, of dimensions (p+1)(q+1) x length(tau).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best.tuning</code></td>
<td>
<p>A list containing the optimal tau, kappa1, and kappa2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Coefficient vector of length q for E variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Coefficient vector of length p for E variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Coefficient matrix of dimensions p*q for G-E interactions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Coefficient vector of length (q+1)p for W (G variables and G-E interactions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>A coefficient vector of length (q+1)(p+1), including the estimates for <code class="reqn">\alpha</code> (intercept), <code class="reqn">a</code> (coefficients for all E variables), and <code class="reqn">b</code> (coefficients for all G variables and G-E interactions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar</code></td>
<td>
<p>Number of non-zero coefficients at the best tunings.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Wang X, Xu Y, and Ma S. (2019). Identifying gene-environment interactions incorporating prior information. Statistics in medicine, 38(9): 1620-1633. doi: <a href="https://doi.org/10.1002/sim.8064">10.1002/sim.8064</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 30; p &lt;- 4; q &lt;- 2
E &lt;- MASS::mvrnorm(n, rep(0,q), diag(q))
G &lt;- MASS::mvrnorm(n, rep(0,p), diag(p))
W &lt;- matW(E, G)
alpha &lt;- 0; a &lt;- seq(0.4, 0.6, length=q);
beta &lt;- c(seq(0.2, 0.5, length=2), rep(0, p-2))
vector.gamma &lt;- c(0.8, 0.9, 0, 0)
gamma &lt;- matrix(c(vector.gamma, rep(0, p*q - length(vector.gamma))), nrow=p, byrow=TRUE)
mat.b.gamma &lt;- cbind(beta, gamma)
b &lt;- as.vector(t(mat.b.gamma))
Y &lt;- alpha + E %*% a + W %*% b + rnorm (n, 0, 0.5)
S_G &lt;- c(1)
S_GE &lt;- cbind(c(1), c(1))
fit4 &lt;- cv.GEInfo(E, G, Y, family='gaussian', S_G=S_G,
 S_GE=S_GE,lam1=0.4,lam2=0.4,kappa1 = 0.4,kappa2=0.4,tau=0.5)
</code></pre>


</div>