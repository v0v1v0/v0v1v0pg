<div class="container">

<table style="width: 100%;"><tr>
<td>grplasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to Fit a Solution of a Group Lasso Problem</h2>

<h3>Description</h3>

<p>Fits the solution of a group lasso problem for a model of type
<code>grpl.model</code>.</p>


<h3>Usage</h3>

<pre><code class="language-R">grplasso(x, ...)

## S3 method for class 'formula'
grplasso(formula, nonpen = ~ 1, data, weights,
         subset, na.action, lambda, coef.init, penscale = sqrt,
         model = LogReg(), center = TRUE, standardize = TRUE,
         control = grpl.control(), contrasts = NULL, ...)

## Default S3 method:
grplasso(x, y, index, weights = rep(1, length(y)), offset = rep(0,
         length(y)), lambda, coef.init = rep(0, ncol(x)),
         penscale = sqrt, model = LogReg(), center = TRUE,
         standardize = TRUE, control = grpl.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>design matrix (including intercept)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p><code>formula</code> of the penalized variables. The response
has to be on the left hand side of <code>~</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonpen</code></td>
<td>
<p><code>formula</code> of the nonpenalized variables. This will
be added to the <code>formula</code> argument above and doesn't need to have the
response on the left hand side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code> containing the variables in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>vector which defines the grouping of the
variables. Components sharing the same
number build a group. Non-penalized coefficients are marked with
<code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>vector of observation weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>vector of offset values; needs to have the same length as the
response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>vector of penalty parameters. Optimization starts with
the first component. See details below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.init</code></td>
<td>
<p>initial vector of parameter estimates corresponding
to the first component in the vector <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penscale</code></td>
<td>
<p>rescaling function to adjust the value of the penalty
parameter to the degrees of freedom of the parameter group. See the
reference below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>an object of class <code>grpl.model</code> implementing
the negative log-likelihood, gradient, hessian etc. See the
documentation of <code>grpl.model</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>logical. If true, the columns of the design matrix will be
centered (except a possible intercept column).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>logical. If true, the design matrix will be
blockwise orthonormalized such that for each block <code class="reqn">X^TX = n 1</code>
(*after* possible centering).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>options for the fitting algorithm, see
<code>grpl.control</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>an optional list. See the 'contrasts.arg' of
'model.matrix.default'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to the functions defined
in <code>model</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When using <code>grplasso.formula</code>, the grouping of the variables is
derived from the type of the variables: The dummy variables of a
factor will be automatically treated as a group. 
</p>
<p>The optimization process starts using the first component of
<code>lambda</code> as penalty parameter <code class="reqn">\lambda</code> and with starting
values defined in <code>coef.init</code> for the parameter vector. Once
fitted, the next component of <code>lambda</code> is considered as penalty
parameter with starting values defined as the (fitted) coefficient
vector based on the previous component of <code>lambda</code>.
</p>


<h3>Value</h3>

<p>A <code>grplasso</code> object is returned, for which <code>coef</code>,
<code>print</code>, <code>plot</code> and <code>predict</code> methods exist.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>coefficients with respect to the <em>original</em> input
variables (even if <code>standardize = TRUE</code> is used for fitting).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>vector of lambda values where coefficients were calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>grouping index vector.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Lukas Meier, <a href="mailto:meier@stat.math.ethz.ch">meier@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Lukas Meier, Sara van de Geer and Peter B\"uhlmann (2008), <em>The
Group Lasso for Logistic Regression</em>, Journal of the Royal
Statistical Society, 70 (1), 53 - 71</p>


<h3>Examples</h3>

<pre><code class="language-R">## Use the Logistic Group Lasso on the splice data set
data(splice)

## Define a list with the contrasts of the factors
contr &lt;- rep(list("contr.sum"), ncol(splice) - 1)
names(contr) &lt;- names(splice)[-1]

## Fit a logistic model 
fit.splice &lt;- grplasso(y ~ ., data = splice, model = LogReg(), lambda = 20,
                       contrasts = contr, center = TRUE, standardize = TRUE)

## Perform the Logistic Group Lasso on a random dataset
set.seed(79)

n &lt;- 50  ## observations
p &lt;- 4   ## variables

## First variable (intercept) not penalized, two groups having 2 degrees
## of freedom each

index &lt;- c(NA, 2, 2, 3, 3)

## Create a random design matrix, including the intercept (first column)
x &lt;- cbind(1, matrix(rnorm(p * n), nrow = n))
colnames(x) &lt;- c("Intercept", paste("X", 1:4, sep = ""))

par &lt;- c(0, 2.1, -1.8, 0, 0)
prob &lt;- 1 / (1 + exp(-x %*% par))
mean(pmin(prob, 1 - prob)) ## Bayes risk
y &lt;- rbinom(n, size = 1, prob = prob) ## binary response vector

## Use a multiplicative grid for the penalty parameter lambda, starting
## at the maximal lambda value
lambda &lt;- lambdamax(x, y = y, index = index, penscale = sqrt,
                    model = LogReg()) * 0.5^(0:5)

## Fit the solution path on the lambda grid
fit &lt;- grplasso(x, y = y, index = index, lambda = lambda, model = LogReg(),
                penscale = sqrt,
                control = grpl.control(update.hess = "lambda", trace = 0))

## Plot coefficient paths
plot(fit)
</code></pre>


</div>