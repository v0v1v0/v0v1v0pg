<div class="container">

<table style="width: 100%;"><tr>
<td>CreateGrammar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Context-free Grammar Object</h2>

<h3>Description</h3>

 
<p>Creates a context-free grammar object. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">  grule(...)

  gsrule(...)

  gvrule(vec)

  CreateGrammar(ruleDef, startSymb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>A series of comma separated strings or expressions, for <code>gsrule</code> and
<code>grule</code> respectively. Expressions can be wrapped in <code>.()</code> to preserve their 
commas or assignment operators.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec</code></td>
<td>

<p>An iterable vector or list.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ruleDef</code></td>
<td>

<p>Grammatical rule definition. Either a list of grammar rule objects (<code>GERule</code>) created using <code>grule</code> and <code>gsrule</code>
with a syntax similar to Backus-Naur form,
or a list of character strings representing symbols and sequences in Backus-Naur form,
or a filename or <code>connection</code> to a .bnf file. 
</p>
<p>See details. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
If not given, the first rule in <code>ruleDef</code> is used.
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>The rule definition is the grammar described in Backus-Naur context-free grammatical format.
The preferred way of defining a grammar is to create a <code>list</code> simulating BNF format,
which collects several named grammar rule objects (<code>GERule</code>).
Each name defines the <em>non-terminal symbol</em>, and each rule 
in the collection determines the <em>production rule</em>, 
i.e., possible <em>sequences</em> that will replace the symbol.
</p>
<p>Defining a grammar rule object (<code>GERule</code>) can take three forms:
</p>
<p>1. The first form uses <code>grule</code> (Grammar Rule), where R expressions are accepted. In the mapping process,
variables are looked up and replaced using the production rules.
</p>
<p>2. The second form uses <code>gsrule</code> (Grammar String Rule) and uses character strings. The input to <code>gsrule</code> are character string values, where any value surrounded by '&lt;' or '&gt;' is considered as <em>non-terminal symbols</em> and
will be replaced using the rule with the same name in the mapping process. Other symbols are considered terminals. This form allows generation of sequences that are not syntactically valid in R (such as <code>`var op var`</code>).
</p>
<p>3. The third form uses <code>gvrule</code> (Grammar Vector Rule), where objects within an iterable (vector or list) containing all of the expressions are used as individual rules. 
</p>
<p>Alternatively, <code>CreateGrammar</code> can read and parse .bnf text files.
</p>


<h3>Value</h3>

<p><code>CreateGrammar</code> returns a <code>grammar</code> object.
</p>
<p><code>grule</code> and <code>gsrule</code> return a <code>GERule</code> object.
</p>


<h3>See Also</h3>

<p><code>c</code>,
<code>GrammarMap</code>,
<code>GrammaticalEvolution</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Define a simple grammar in BNF format
# &lt;expr&gt; ::= &lt;var&gt;&lt;op&gt;&lt;var&gt;
# &lt;op&gt;   ::= + | - | *
# &lt;var&gt;  ::= A | B
ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# print rules
print(ruleDef)

# create and display a vector rule
vectorRule = gvrule(1:5)
print(vectorRule)

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# print grammar object
print(grammarDef)

# Creating the same grammar using R expressions
ruleDef &lt;- list(expr = grule(op(var, var)),
                op   = grule(`+`, `-`, `*`),
                var  = grule(A, B))

grammarDef &lt;- CreateGrammar(ruleDef)

print(grammarDef)

# Two rules with commas and assignments, preserved using .()
ruleDef &lt;- list(expr = grule(data.frame(dat)),
                dat  = grule(.(x = 1, y = 2), .(x = 5, y = 6)))
grammarDef &lt;- CreateGrammar(ruleDef)
print(GrammarMap(c(0), grammarDef))
print(GrammarMap(c(1), grammarDef))
</code></pre>


</div>