<div class="container">

<table style="width: 100%;"><tr>
<td>gt_index</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Return the underlying data, arranged by the internal index</h2>

<h3>Description</h3>

<p>This is a utility function to extract the underlying data from
a <code>gt</code> table. You can use it with a saved <code>gt</code> table, in the pipe (<code style="white-space: pre;">⁠%&gt;%⁠</code>)
or even within most other <code>gt</code> functions (eg <code>tab_style()</code>). It defaults to
returning the column indicated as a vector, so that you can work with the
values. Typically this is used with logical statements to affect one column
based on the values in that specified secondary column.
Alternatively, you can extract the entire ordered data according to the
internal index as a <code>tibble</code>. This allows for even more complex steps
based on multiple indices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gt_index(gt_object, column, as_vector = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gt_object</code></td>
<td>
<p>An existing gt table object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>column</code></td>
<td>
<p>The column name that you intend to extract, accepts tidyeval semantics (ie <code>mpg</code> instead of <code>"mpg"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_vector</code></td>
<td>
<p>A logical indicating whether you'd like just the column indicated as a vector, or the entire dataframe</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector or a <code>tibble</code>
</p>


<h3>Figures</h3>

<p><img src="../help/figures/gt_index_style.png" width="50%" alt="gt_index_style.png"></p>


<h3>Function ID</h3>

<p>2-20
</p>


<h3>See Also</h3>

<p>Other Utilities: 
<code>add_text_img()</code>,
<code>fa_icon_repeat()</code>,
<code>fmt_pad_num()</code>,
<code>fmt_pct_extra()</code>,
<code>fmt_symbol_first()</code>,
<code>generate_df()</code>,
<code>gt_add_divider()</code>,
<code>gt_badge()</code>,
<code>gt_double_table()</code>,
<code>gt_duplicate_column()</code>,
<code>gt_fa_column()</code>,
<code>gt_fa_rank_change()</code>,
<code>gt_fa_rating()</code>,
<code>gt_fa_repeats()</code>,
<code>gt_highlight_cols()</code>,
<code>gt_highlight_rows()</code>,
<code>gt_img_border()</code>,
<code>gt_img_circle()</code>,
<code>gt_img_multi_rows()</code>,
<code>gt_img_rows()</code>,
<code>gt_merge_stack_color()</code>,
<code>gt_merge_stack()</code>,
<code>gt_two_column_layout()</code>,
<code>gtsave_extra()</code>,
<code>img_header()</code>,
<code>pad_fn()</code>,
<code>tab_style_by_grp()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(gt)

# This is a key step, as gt will create the row groups
# based on first observation of the unique row items
# this sampling will return a row-group order for cyl of 6,4,8

set.seed(1234)
sliced_data &lt;- mtcars %&gt;%
  dplyr::group_by(cyl) %&gt;%
  dplyr::slice_head(n = 3) %&gt;%
  dplyr::ungroup() %&gt;%
  # randomize the order
  dplyr::slice_sample(n = 9)

# not in "order" yet
sliced_data$cyl

# But unique order of 6,4,8
unique(sliced_data$cyl)

# creating a standalone basic table
test_tab &lt;- sliced_data %&gt;%
  gt(groupname_col = "cyl")

# can style a specific column based on the contents of another column
tab_out_styled &lt;- test_tab %&gt;%
  tab_style(
    locations = cells_body(mpg, rows = gt_index(., am) == 0),
    style = cell_fill("red")
  )

# OR can extract the underlying data in the "correct order"
# according to the internal gt structure, ie arranged by group
# by cylinder, 6,4,8
gt_index(test_tab, mpg, as_vector = FALSE)

# note that the order of the index data is
# not equivalent to the order of the input data
# however all the of the rows still match
sliced_data
</code></pre>


</div>