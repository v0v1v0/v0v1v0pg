<div class="container">

<table style="width: 100%;"><tr>
<td>geese</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to fit a Generalized Estimating Equation Model</h2>

<h3>Description</h3>

<p>Produces an object of class ‘geese’ which is a Generalized Estimating
Equation fit of the data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geese(
  formula = formula(data),
  sformula = ~1,
  id,
  waves = NULL,
  data = parent.frame(),
  subset = NULL,
  na.action = na.omit,
  contrasts = NULL,
  weights = NULL,
  zcor = NULL,
  corp = NULL,
  control = geese.control(...),
  b = NULL,
  alpha = NULL,
  gm = NULL,
  family = gaussian(),
  mean.link = NULL,
  variance = NULL,
  cor.link = "identity",
  sca.link = "identity",
  link.same = TRUE,
  scale.fix = FALSE,
  scale.value = 1,
  corstr = "independence",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula expression as for <code>glm</code>, of the form
<code>response ~ predictors</code>. See the documentation of lm and
formula for details. As for glm, this specifies the linear
predictor for modeling the mean. A term of the form
<code>offset(expression)</code> is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sformula</code></td>
<td>
<p>a formula expression of the form <code> ~
    predictor</code>, the response being ignored. This specifies the
linear predictor for modeling the dispersion. A term of the
form <code>offset(expression)</code> is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>a vector which identifies the clusters.  The length of
‘id’ should be the same as the number of observations.  Data
are assumed to be sorted so that observations on a cluster are
contiguous rows for all entities in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>waves</code></td>
<td>
<p>an integer vector which identifies components in
clusters. The length of <code>waves</code> should be the same as the
number of observation.  components with the same <code>waves</code>
value will have the same link functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame in which to interpret the
variables occurring in the <code>formula</code>, along with the
<code>id</code> and <code>n</code> variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>expression saying which subset of the rows of the
data should be used in the fit.  This can be a logical vector
(which is replicated to have length equal to the number of
observations), or a numeric vector indicating which observation
numbers are to be included, or a character vector of the row
names to be included.  All observations are included by
default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function to filter missing data.  For <code>gee</code>
only <code>na.omit</code> should be used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>a list giving contrasts for some or all of the
factors appearing in the model formula.  The elements of the
list should have the same name as the variable and should be
either a contrast matrix (specifically, any full-rank matrix
with as many rows as there are levels in the factor), or else a
function to compute such a matrix given the number of levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights to be used in the
fitting process. The length of <code>weights</code> should be the
same as the number of observations. This weights is not (yet)
the weight as in sas proc genmod, and hence is not recommended
to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zcor</code></td>
<td>
<p>a design matrix for correlation parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corp</code></td>
<td>
<p>known parameters such as coordinates used for
correlation coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of iteration and algorithmic constants. See
<code>geese.control</code> for their names and default
values. These can also be set as arguments to <code>geese</code>
itself.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>an initial estimate for the mean parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>an initial estimate for the correlation parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gm</code></td>
<td>
<p>an initial estimate for the scale parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model, as for <code>glm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.link</code></td>
<td>
<p>a character string specifying the link function
for the means. The following are allowed: <code>"identity"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>,
<code>"log"</code>, and <code>"inverse"</code>.  The default value is
determined from family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance</code></td>
<td>
<p>a character string specifying the variance function
in terms of the mean. The following are allowed:
<code>"gaussian"</code>, <code>"binomial"</code>, <code>"poisson"</code>, and
<code>"gamma"</code>. The default value is determined from family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor.link</code></td>
<td>
<p>a character string specifying the link function for
the correlation coefficients. The following are allowed:
<code>"identity"</code>, and <code>"fisherz"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sca.link</code></td>
<td>
<p>a character string specifying the link function for
the scales. The following are allowed: <code>"identity"</code>, and
<code>"log"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link.same</code></td>
<td>
<p>a logical indicating if all the components in a
cluster should use the same link.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.fix</code></td>
<td>
<p>a logical variable; if true, the scale parameter
is fixed at the value of <code>scale.value</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.value</code></td>
<td>
<p>numeric variable giving the value to which the
scale parameter should be fixed; used only if <code>scale.fix
    == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corstr</code></td>
<td>
<p>a character string specifying the correlation
structure.  The following are permitted: <code>"independence"</code>,
<code>"exchangeable"</code>, <code>"ar1"</code>, <code>"unstructured"</code>,
<code>"userdefined"</code>, and <code>"fixed"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>when the correlation structure is <code>fixed</code>, the specification of
<code>Zcor</code> should be a vector of length <code>sum(clusz * (clusz - 1)) /
2.</code>
</p>


<h3>Value</h3>

<p>An object of class <code>"geese"</code> representing the fit.
</p>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>References</h3>

<p>Yan, J. and J.P. Fine (2004) Estimating Equations for
Association Structures.  <em>Statistics in Medicine</em>,
<b>23</b>, 859–880.
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>lm</code>, <code>ordgee</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(seizure)
## Diggle, Liang, and Zeger (1994) pp166-168, compare Table 8.10
seiz.l &lt;- reshape(seizure,
                  varying=list(c("base","y1", "y2", "y3", "y4")),
                  v.names="y", times=0:4, direction="long")
seiz.l &lt;- seiz.l[order(seiz.l$id, seiz.l$time),]
seiz.l$t &lt;- ifelse(seiz.l$time == 0, 8, 2)
seiz.l$x &lt;- ifelse(seiz.l$time == 0, 0, 1)
m1 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data=seiz.l, corstr="exch", family=poisson)
summary(m1)
m2 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data = seiz.l, subset = id!=49,
            corstr = "exch", family=poisson)
summary(m2)
## Using fixed correlation matrix
cor.fixed &lt;- matrix(c(1, 0.5, 0.25, 0.125, 0.125,
                      0.5, 1, 0.25, 0.125, 0.125,
                      0.25, 0.25, 1, 0.5, 0.125,
                      0.125, 0.125, 0.5, 1, 0.125,
                      0.125, 0.125, 0.125, 0.125, 1), 5, 5)
cor.fixed
zcor &lt;- rep(cor.fixed[lower.tri(cor.fixed)], 59)
m3 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data = seiz.l, family = poisson,
            corstr = "fixed", zcor = zcor)
summary(m3)

data(ohio)
fit &lt;- geese(resp ~ age + smoke + age:smoke, id=id, data=ohio,
             family=binomial, corstr="exch", scale.fix=TRUE)
summary(fit)
fit.ar1 &lt;- geese(resp ~ age + smoke + age:smoke, id=id, data=ohio,
                 family=binomial, corstr="ar1", scale.fix=TRUE)
summary(fit.ar1)

###### simulated data
## a function to generate a dataset
gendat &lt;- function() {
  id &lt;- gl(50, 4, 200)
  visit &lt;- rep(1:4, 50)
  x1 &lt;- rbinom(200, 1, 0.6) ## within cluster varying binary covariate
  x2 &lt;- runif(200, 0, 1)   ## within cluster varying continuous covariate
  phi &lt;- 1 + 2 * x1         ## true scale model
  ## the true correlation coefficient rho for an ar(1)
  ## correlation structure is 0.667.
  rhomat &lt;- 0.667 ^ outer(1:4, 1:4, function(x, y) abs(x - y))
  chol.u &lt;- chol(rhomat)
  noise &lt;- as.vector(sapply(1:50, function(x) chol.u %*% rnorm(4)))
  e &lt;- sqrt(phi) * noise
  y &lt;- 1 + 3 * x1 - 2 * x2 + e
  dat &lt;- data.frame(y, id, visit, x1, x2)
  dat
}

dat &lt;- gendat()
fit &lt;- geese(y ~ x1 + x2, id = id, data = dat, sformula = ~ x1,
             corstr = "ar1", jack = TRUE, j1s = TRUE, fij = TRUE)
summary(fit)


#### create user-defined design matrix of unstrctured correlation.
#### in this case, zcor has 4*3/2 = 6 columns, and 50 * 6 = 300 rows
zcor &lt;- genZcor(clusz = rep(4, 50), waves = dat$visit, "unstr")
zfit &lt;- geese(y ~ x1 + x2, id = id, data = dat, sformula = ~ x1,
              corstr = "userdefined", zcor = zcor,
              jack = TRUE, j1s = TRUE, fij = TRUE)
summary(zfit)

#### Now, suppose that we want the correlation of 1-2, 2-3, and 3-4
#### to be the same. Then zcor should have 4 columns.
z2 &lt;- matrix(NA, 300, 4)
z2[,1] &lt;- zcor[,1] + zcor[,4] + zcor[,6]
z2[,2:4] &lt;- zcor[, c(2, 3, 5)]
summary(geese(y ~ x1 + x2, id = id, data = dat, sformula = ~ x1,
              corstr = "userdefined", zcor = z2,
              jack = TRUE, j1s = TRUE, fij = TRUE))

#### Next, we introduce non-constant cluster sizes by
#### randomly selecting 60 percent of the data
good &lt;- sort(sample(1:nrow(dat), .6 * nrow(dat))) 
mdat &lt;- dat[good,]

summary(geese(y ~ x1 + x2, id = id, data = mdat, waves = visit,
              sformula = ~ x1, corstr="ar1",
              jack = TRUE, j1s = TRUE, fij = TRUE))


</code></pre>


</div>