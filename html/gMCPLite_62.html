<div class="container">

<table style="width: 100%;"><tr>
<td>graphTest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple testing using graphs</h2>

<h3>Description</h3>

<p>Implements the graphical test procedure described in Bretz et al. (2009).
Note that the gMCP function in the gMCP package performs the same task.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graphTest(
  pvalues,
  weights = NULL,
  alpha = 0.05,
  G = NULL,
  cr = NULL,
  graph = NULL,
  verbose = FALSE,
  test,
  upscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pvalues</code></td>
<td>
<p>Either a vector or a matrix containing the local p-values for
the hypotheses in the rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Initial weight levels for the test procedure, in case of
multiple graphs this needs to be a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Overall alpha level of the procedure. For entangled graphs
<code>alpha</code> should be a numeric vector of length equal to the number of
graphs, each element specifying the partial alpha for the respective graph.
The overall alpha level equals <code>sum(alpha)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>For simple graphs <code>G</code> should be a numeric matrix determining
the graph underlying the test procedure. Note that the diagonal need to
contain only 0s, while the rows need to sum to 1.  For entangled graphs it
needs to be a list containing the different graph matrices as elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cr</code></td>
<td>
<p>Correlation matrix that should be used for the parametric test.
If <code>cr==NULL</code> the Bonferroni based test procedure is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>As an alternative to the specification via <code>weights</code> and
<code>G</code> one can also hand over a <code>graphMCP</code> object to the code.
<code>graphMCP</code> objects can be created for example with the <code>graphGUI</code>
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If verbose is TRUE, additional information about the
graphical rejection procedure is displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>In the parametric case there is more than one way to handle
subgraphs with less than the full alpha. If the parameter <code>test</code> is
missing, the tests are performed as described by Bretz et al. (2011), i.e.
tests of intersection null hypotheses always exhaust the full alpha level
even if the sum of weights is strictly smaller than one. If
<code>test="simple-parametric"</code> the tests are performed as defined in
Equation (3) of Bretz et al. (2011).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upscale</code></td>
<td>
<p>Logical. If <code>upscale=FALSE</code> then for each intersection
of hypotheses (i.e. each subgraph) a weighted test is performed at the
possibly reduced level alpha of sum(w)*alpha,
where sum(w) is the sum of all node weights in this subset.
If <code>upscale=TRUE</code> all weights are upscaled, so that sum(w)=1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector or a matrix containing the test results for the hypotheses
under consideration. Significant tests are denoted by a 1, non-significant
results by a 0.
</p>


<h3>References</h3>

<p>Bretz, F., Maurer, W., Brannath, W. and Posch, M. (2009) A graphical
approach to sequentially rejective multiple test procedures. Statistics in
Medicine, 28, 586â€“604
</p>
<p>Bretz, F., Maurer, W. and Hommel, G. (2010) Test and power considerations
for multiple endpoint analyses using sequentially rejective graphical
procedures, to appear in Statistics in Medicine
</p>


<h3>Examples</h3>

<pre><code class="language-R">

#### example from Bretz et al. (2010)
weights &lt;- c(1/3, 1/3, 1/3, 0, 0, 0)
graph &lt;- rbind(c(0,       0.5, 0,     0.5, 0,      0),
               c(1/3,     0,   1/3,    0,   1/3,    0),
               c(0,       0.5, 0,     0,   0,      0.5),
               c(0,       1,   0,     0,   0,      0),
               c(0.5,     0,   0.5,   0,   0,      0),
               c(0,       1,   0,     0,   0,      0))
pvals &lt;- c(0.1, 0.008, 0.005, 0.15, 0.04, 0.006)
graphTest(pvals, weights, alpha=0.025, graph)

## observe graphical procedure in detail
graphTest(pvals, weights, alpha=0.025, graph, verbose = TRUE)

## now use many p-values (useful for power simulations)
pvals &lt;- matrix(rbeta(6e4, 1, 30), ncol = 6)
out &lt;- graphTest(pvals, weights, alpha=0.025, graph)
head(out)
# example using multiple graphs (instead of 1)
G1 &lt;- rbind(c(0,0.5,0.5,0,0), c(0,0,1,0,0),
            c(0, 0, 0, 1-0.01, 0.01), c(0, 1, 0, 0, 0),
            c(0, 0, 0, 0, 0))
G2 &lt;- rbind(c(0,0,1,0,0), c(0.5,0,0.5,0,0),
            c(0, 0, 0, 0.01, 1-0.01), c(0, 0, 0, 0, 0),
            c(1, 0, 0, 0, 0))
weights &lt;- rbind(c(1, 0, 0, 0, 0), c(0, 1, 0, 0, 0))
pvals &lt;- c(0.012, 0.025, 0.005, 0.0015, 0.0045)
out &lt;- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2), verbose = TRUE)

## now again with many p-values
pvals &lt;- matrix(rbeta(5e4, 1, 30), ncol = 5)
out &lt;- graphTest(pvals, weights, alpha=c(0.0125, 0.0125), G=list(G1, G2))
head(out)

</code></pre>


</div>