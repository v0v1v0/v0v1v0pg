<div class="container">

<table style="width: 100%;"><tr>
<td>estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Performing statistical inference after calibration</h2>

<h3>Description</h3>

<p><code>estimate</code> performs statistical inference after calibration.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate(formula, data = NULL, calibration, pimat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An object of class "formula" specifying the calibration model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional data frame containing the variables in the model (specified by <code>formula</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calibration</code></td>
<td>
<p>An object of class "calibration", generated by <code>GECalib</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pimat</code></td>
<td>
<p>An optional matrix contatining the joint inclusion probability matrix used for variance estimation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class <code>estimation</code> including the point estimates and its standard error.
</p>


<h3>References</h3>

<p>Kwon, Y., Kim, J., &amp; Qiu, Y. (2024). Debiased calibration estimation using generalized entropy in survey sampling.
Arxiv preprint &lt;https://arxiv.org/abs/2404.01076&gt;
</p>
<p>Deville, J. C., and SÃ¤rndal, C. E. (1992). Calibration estimators in survey sampling.
Journal of the American statistical Association, 87(418), 376-382.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(11)
N = 10000
x = data.frame(x1 = rnorm(N, 2, 1), x2= runif(N, 0, 4))
pi = pt((-x[,1] / 2 - x[,2] / 2), 3);
pi = ifelse(pi &gt;.7, .7, pi)

delta = rbinom(N, 1, pi)
Index_S = (delta == 1)
pi_S = pi[Index_S]; d_S = 1 / pi_S
x_S = x[Index_S,,drop = FALSE]
# pimat = diag(d_S^2 - d_S) / N^2 # 1 / pi_i * (1 - 1 / pi_i)

e = rnorm(N, 0, 1)
y = x[,1] + x[,2] + e;
y_S = y[Index_S] # plot(x_S, y_S)

calibration0 &lt;- GECal::GEcalib(~ 1, dweight = d_S, data = x_S,
                               const = N,
                               entropy = "SL", method = "DS")
GECal::estimate(y_S ~ 1, calibration = calibration0)$estimate # Hajek estimator
# sum(y_S * d_S) * N / sum(d_S)

calibration &lt;- GECal::GEcalib(~ 0, dweight = d_S, data = x_S,
const = numeric(0),
entropy = "SL", method = "DS")
GECal::estimate(y_S ~ 1, calibration = calibration)$estimate # HT estimator

calibration1 &lt;- GECal::GEcalib(~ ., dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x)),
                               entropy = "ET", method = "DS")
GECal::estimate(y_S ~ 1, calibration = calibration1)$estimate

calibration2 &lt;- GECal::GEcalib(~ ., dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x)),
                               entropy = "ET", method = "GEC0")
GECal::estimate(y_S ~ 1, calibration = calibration2)$estimate

calibration3 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x, log(1 / pi))),
                               entropy = "ET", method = "GEC")
GECal::estimate(y_S ~ 1, calibration = calibration3)$estimate

calibration4 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x, NA)),
                               entropy = "ET", method = "GEC")
GECal::estimate(y_S ~ 1, calibration = calibration4)$estimate

calibration5 &lt;- GECal::GEcalib(~ . + g(d_S), dweight = d_S, data = x_S,
                               const = colSums(cbind(1, x, NA)),
                               entropy = "ET", method = "GEC", K_alpha = "log")
GECal::estimate(y_S ~ 1, calibration = calibration5)$estimate

</code></pre>


</div>