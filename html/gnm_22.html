<div class="container">

<table style="width: 100%;"><tr>
<td>gnm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Fitting Generalized Nonlinear Models </h2>

<h3>Description</h3>

<p><code>gnm</code> fits generalised nonlinear models using an
over-parameterized representation. Nonlinear terms are specified by
calls to functions of class <code>"nonlin"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gnm(formula, eliminate = NULL, ofInterest = NULL, constrain = numeric(0),
    constrainTo = numeric(length(constrain)), family = gaussian, 
    data = NULL, subset, weights, na.action,  method = "gnmFit", 
    checkLinear = TRUE, offset, start = NULL, etastart = NULL,
    mustart = NULL, tolerance = 1e-06, iterStart = 2, iterMax = 500,
    trace = FALSE, verbose = TRUE, model = TRUE, x = TRUE,
    termPredictors = FALSE, ridge = 1e-08, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p> a symbolic description of the nonlinear predictor. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eliminate</code></td>
<td>
<p> a factor to be included as the first term in the
model. <code>gnm</code> will exploit the structure of this factor to
improve computational efficiency. See details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ofInterest</code></td>
<td>
<p> optional coefficients of interest, specified by a
regular expression, a numeric vector of indices, a character vector of
names, or "[?]" to select from a Tk dialog. If <code>NULL</code>, it is
assumed that all non-<code>eliminate</code>d coefficients are of interest. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrain</code></td>
<td>
<p> (non-eliminated) coefficients to constrain, specified
by a regular expression, a numeric vector of indices, a logical vector, a
character vector of names, or "[?]" to select from a Tk dialog. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrainTo</code></td>
<td>
<p> a numeric vector of the same length as
<code>constrain</code> specifying the values to constrain to. By default
constrained parameters will be set to zero. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code>family</code> and
<code>wedderburn</code> for possibilities. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>gnm</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting
process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain <code>NA</code>s. If <code>data</code> is a contingency table, the
default is <code>"exclude"</code>. Otherwise the default is first, any
<code>na.action</code> attribute of <code>data</code>; second, any
<code>na.action</code> setting of <code>options</code>, and third,
<code>na.fail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> the method to be used: either <code>"gnmFit"</code> to fit
the model using the default maximum likelihood algorithm,
<code>"coefNames"</code> to return a character vector of names for the
coefficients in the model, <code>"model.matrix"</code> to return the model
matrix, <code>"model.frame"</code> to return the model frame, or the name
of a function providing an alternative fitting algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkLinear</code></td>
<td>
<p> logical: if <code>TRUE</code> <code>glm.fit</code> is used
when the predictor is found to be linear </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p> this can be used to specify an a priori known component to
be added to the predictor during fitting. <code>offset</code> terms
can be included in the formula instead or as well, and if both
are specified their sum is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p> a vector of starting values for the parameters in the
model; if a starting value is <code>NA</code>, the default starting value
will be used. Starting values need not be specified for eliminated
parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p> starting values for the linear predictor. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p> starting values for the vector of means. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterStart</code></td>
<td>
<p> a positive integer specifying the number of start-up iterations
to perform. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main
iterations to perform. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code> and model includes nonlinear
terms, progress indicators are printed as the model is fitted,
including a diagnostic error message if the algorithm fails. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p> logical: if <code>TRUE</code> the model frame is returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> logical: if <code>TRUE</code> the local design matrix from the last
iteration is included as a component of returned model object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>termPredictors</code></td>
<td>
<p> logical: if <code>TRUE</code>, a matrix is returned
with a column for each term in the model, containing the additive
contribution of that term to the predictor. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ridge</code></td>
<td>
<p>numeric, a positive value for the ridge constant to be
used in the fitting algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments passed to fitting function. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Models for <code>gnm</code> are specified by giving a symbolic description
of the nonlinear predictor, of the form <code>response ~ terms</code>. The
<code>response</code> is typically a numeric vector, see later in this
section for alternatives. The usual symbolic language may be used to
specify any linear terms, see <code>formula</code> for details.
</p>
<p>Nonlinear terms may be specified by calls to functions of class
"nonlin". There are several "nonlin" functions in the <code>gnm</code>
package. Some of these specify simple
mathematical functions of predictors: <code>Exp</code>, <code>Mult</code>, and 
<code>Inv</code>. Others specify more specialised nonlinear terms, in
particular <code>MultHomog</code> specifies homogeneous multiplicative
interactions and <code>Dref</code> specifies diagonal reference terms. Users
may also define their own "nonlin" functions, see
<code>nonlin.function</code> for details.
</p>
<p>The <code>eliminate</code> argument may be used to specify a factor that
is to be included as the first term in the model (since an intercept
is then redundant, none is fitted). The structure of the factor is
exploited to improve computational efficiency â€” substantially so if
the <code>eliminate</code>d factor has a large number of levels. Use of
<code>eliminate</code> is designed for factors that are required in the
model but are not of direct interest (e.g., terms needed to fit
multinomial-response models as conditional Poisson models). See
<code>backPain</code> for an example.
</p>
<p>The <code>ofInterest</code> argument may be used to specify coefficients of
interest, the indices of which are returned in the <code>ofInterest</code>
component of the model object. <code>print()</code> displays of the model
object or its components obtained using accessor functions such as
<code>coef()</code> etc, will only show these coefficients. In addition
methods for <code>"gnm"</code> objects which may be applied to a subset of
the parameters are by default applied to the coefficients of interest.
See <code>ofInterest</code> for accessor and replacement functions.
</p>
<p>For contingency tables, the data may be provided as an object of class
<code>"table"</code> from which the frequencies will be extracted to use
as the response. In this case, the response should be specified as
<code>Freq</code> in the model formula. The <code>"predictors"</code>,
<code>"fitted.values"</code>, <code>"residuals"</code>, <code>"prior.weights"</code>,
<code>"weights"</code>, <code>"y"</code> and <code>"offset"</code> components of
the returned <code>gnm</code> fit will be tables with the same format as the
data, completed with <code>NA</code>s where necessary.
</p>
<p>For binomial models, the <code>response</code> may be specified as a factor
in which the first level denotes failure and all other levels denote
success, as a two-column matrix with the columns giving the numbers
of successes and failures, or as a vector of the proportions of
successes.
</p>
<p>The <code>gnm</code> fitting algorithm consists of two stages.  In the start-up
iterations, any nonlinear parameters that are not specified by either the
<code>start</code> argument of <code>gnm</code> or a plug-in function are
updated one parameter at a time, then the linear parameters are
jointly updated before the next iteration. In the main iterations, all
the parameters are jointly updated, until convergence is reached or
the number or iterations reaches <code>iterMax</code>. To solve the
(typically rank-deficient) least squares problem at the heart of the
<code>gnm</code> fitting algorithm,  the design matrix is standardized and
regularized (in the Levenberg-Marquardt sense) prior to solving; the
<code>ridge</code> argument provides a degree of control over the
regularization performed (smaller values may sometimes give faster
convergence but can lead to numerical instability).
</p>
<p>Convergence is judged by comparing the squared components of the score vector
with corresponding elements of the diagonal of the Fisher information
matrix. If, for all components of the score vector, the ratio is less
than <code>tolerance^2</code>, or the corresponding diagonal element of the
Fisher information matrix is less than 1e-20, iterations cease. If the
algorithm has not converged by <code>iterMax</code> iterations,
<code>exitInfo</code> can be used to print information on the
parameters which failed the convergence criteria at the last iteration.
</p>
<p>By default, <code>gnm</code> uses an over-parameterized representation of
the model that is being fitted. Only minimal identifiability constraints
are imposed, so that in general a random parameterization is obtained.
The parameter estimates are ordered so that those for any linear terms
appear first.
</p>
<p><code>getContrasts</code> may be used to obtain estimates of
specified scaled contrasts, if these contrasts are identifiable. For
example, <code>getContrasts</code> may be used to estimate the contrasts
between the first level of a factor and the rest, and obtain standard
errors. 
</p>
<p>If appropriate constraints are known in advance, or have been
determined from a <code>gnm</code> fit, the model may be (re-)fitted using
the <code>constrain</code> argument to specify coefficients which should be
set to values specified by <code>constrainTo</code>. Constraints should only
be specified for non-eliminated parameters. <code>update</code>
provides a convenient way of re-fitting a  <code>gnm</code> model with new
constraints. 
</p>


<h3>Value</h3>

<p>If <code>method = "gnmFit"</code>, <code>gnm</code> returns <code>NULL</code> if the
algorithm has failed and an object of class <code>"gnm"</code> otherwise. A
<code>"gnm"</code> object inherits first from <code>"glm"</code> then <code>"lm"</code>
and is a list containing the following components:     
</p>
<table>
<tr style="vertical-align: top;">
<td><code> call </code></td>
<td>
<p> the matched call. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> formula </code></td>
<td>
<p> the formula supplied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> constrain </code></td>
<td>
<p> a numeric vector specifying any coefficients that
were constrained in the fitting process. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> constrainTo </code></td>
<td>
<p> a numeric vector of the same length as
<code>constrain</code> specifying the values which constrained parameters
were set to. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> family </code></td>
<td>
<p> the <code>family</code> object used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> prior.weights </code></td>
<td>
<p> the case weights initially supplied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> terms </code></td>
<td>
<p> the <code>terms</code> object used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> data </code></td>
<td>
<p> the <code>data</code> argument. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> na.action </code></td>
<td>
<p> the <code>na.action</code> attribute of the model frame </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> xlevels </code></td>
<td>
<p> a record of the levels of the factors used in fitting. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> y </code></td>
<td>
<p> the response used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> offset </code></td>
<td>
<p> the offset vector used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> coefficients </code></td>
<td>
<p> a named vector of non-eliminated coefficients,
with an attribute <code>"eliminated"</code> specifying the eliminated
coefficients if <code>eliminate</code> is non-<code>NULL</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> eliminate </code></td>
<td>
<p> the <code>eliminate</code> argument. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ofInterest </code></td>
<td>
<p> a named numeric vector of indices corresponding
to non-eliminated coefficients, or <code>NULL</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> predictors </code></td>
<td>
<p> the fitted values on the link scale. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> fitted.values </code></td>
<td>
<p> the fitted mean values, obtained by transforming the
predictors by the inverse of the link function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> deviance </code></td>
<td>
<p> up to a constant, minus twice the maximised
log-likelihood. Where sensible, the constant is chosen so
that a saturated model has deviance zero. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> aic </code></td>
<td>
<p> Akaike's <em>An Information Criterion</em>, minus twice the
maximized log-likelihood plus twice the number of parameters (so assuming
that the dispersion is known).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> iter </code></td>
<td>
<p> the number of main iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> conv </code></td>
<td>
<p> logical indicating whether the main iterations
converged, with an attribute for use by <code>exitInfo</code> if
<code>FALSE</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> weights </code></td>
<td>
<p> the <em>working</em> weights, that is, the weights used in
the last iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> residuals </code></td>
<td>
<p> the <em>working</em> residuals, that is, the residuals
from the last iteration. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> df.residual </code></td>
<td>
<p> the residual degrees of freedom. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> rank </code></td>
<td>
<p> the numeric rank of the fitted model. </p>
</td>
</tr>
</table>
<p>The list may also contain the components <code>model</code>, <code>x</code>,
or <code>termPredictors</code> if requested in the arguments to <code>gnm</code>.
</p>
<p>If a table was passed to <code>data</code> and the default for
<code>na.action</code> was not overridden, the list will also contain a
<code>table.attr</code> component, for use by the extractor functions.
</p>
<p>If a binomial <code>gnm</code> model is specified by giving a two-column
response, the weights returned by <code>prior.weights</code> are the total
numbers of cases (factored by the supplied case weights) and the
component <code>y</code> of the result is the proportion of successes.
</p>
<p>The function <code>summary.gnm</code> may be used to obtain and print
a summary of the results, whilst <code>plot.gnm</code> may be used
for model diagnostics.
</p>
<p>The generic functions <code>formula</code>, <code>family</code>, 
<code>terms</code>, <code>coefficients</code>, 
<code>fitted.values</code>, <code>deviance</code>, 
<code>extractAIC</code>, <code>weights</code>, 
<code>residuals</code>, <code>df.residual</code>, 
<code>model.frame</code>, <code>model.matrix</code>, 
<code>vcov</code> and <code>termPredictors</code> maybe used to
extract components from the object returned by <code>gnm</code> or to
construct the relevant objects where necessary. 
</p>
<p>Note that the generic functions <code>weights</code> and
<code>residuals</code> do not act as straight-forward accessor
functions for <code>gnm</code> objects, but return the prior weights and
deviance residuals respectively, as for <code>glm</code> objects.  
</p>


<h3>Note</h3>

<p>Regular expression matching is performed using <code>grep</code> with
default settings.
</p>


<h3>Author(s)</h3>

<p> Heather Turner and David Firth </p>


<h3>References</h3>

<p>Cautres, B, Heath, A F and Firth, D (1998).  Class,
religion and vote in Britain and France.  <em>La Lettre de la Maison
Francaise</em> <b>8</b>.
</p>


<h3>See Also</h3>

<p><code>formula</code> for the symbolic language used to specify
formulae. 
</p>
<p><code>Diag</code> and <code>Symm</code> for specifying special types
of interaction.
</p>
<p><code>Exp</code>, <code>Mult</code>, <code>Inv</code>, <code>MultHomog</code>,
<code>Dref</code> and <code>nonlin.function</code> for incorporating
nonlinear terms in the  <code>formula</code> argument to <code>gnm</code>.
</p>
<p><code>residuals.glm</code> and the generic functions
<code>coef</code>, <code>fitted</code>, etc. for extracting
components from <code>gnm</code> objects.
</p>
<p><code>exitInfo</code> to print more information on last iteration
when <code>gnm</code> has not converged.
</p>
<p><code>getContrasts</code> to estimate (identifiable) scaled contrasts
from a <code>gnm</code> model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">###  Analysis of a 4-way contingency table
set.seed(1)
print(cautres)

##  Fit a "double UNIDIFF" model with the religion-vote and class-vote
##  interactions both modulated by nonnegative election-specific
##  multipliers.
doubleUnidiff &lt;- gnm(Freq ~ election:vote + election:class:religion
                     + Mult(Exp(election), religion:vote) +
                     Mult(Exp(election), class:vote), family = poisson,
                     data = cautres)

##  Examine the multipliers of the class-vote log odds ratios
ofInterest(doubleUnidiff) &lt;- pickCoef(doubleUnidiff, "class:vote[).]")
coef(doubleUnidiff)
## Coefficients of interest:
## Mult(Exp(.), class:vote).election1 
##                        -0.38357138 
## Mult(Exp(.), class:vote).election2 
##                         0.29816599 
## Mult(Exp(.), class:vote).election3 
##                         0.06580307 
## Mult(Exp(.), class:vote).election4 
##                        -0.02174104

##  Re-parameterize by setting first multiplier to zero
getContrasts(doubleUnidiff, ofInterest(doubleUnidiff))
##                                     estimate        SE
## Mult(Exp(.), class:vote).election1 0.0000000 0.0000000
## Mult(Exp(.), class:vote).election2 0.6817374 0.2401644
## Mult(Exp(.), class:vote).election3 0.4493745 0.2473521
## Mult(Exp(.), class:vote).election4 0.3618301 0.2534754
##                                       quasiSE    quasiVar
## Mult(Exp(.), class:vote).election1 0.22854401 0.052232363
## Mult(Exp(.), class:vote).election2 0.07395886 0.005469913
## Mult(Exp(.), class:vote).election3 0.09475938 0.008979340
## Mult(Exp(.), class:vote).election4 0.10934798 0.011956981

##  Same thing but with last multiplier as reference category:
getContrasts(doubleUnidiff, rev(ofInterest(doubleUnidiff)))
##                                       estimate        SE
## Mult(Exp(.), class:vote).election4  0.00000000 0.0000000
## Mult(Exp(.), class:vote).election3  0.08754436 0.1446833
## Mult(Exp(.), class:vote).election2  0.31990727 0.1320022
## Mult(Exp(.), class:vote).election1 -0.36183013 0.2534754
##                                       quasiSE    quasiVar
## Mult(Exp(.), class:vote).election4 0.10934798 0.011956981
## Mult(Exp(.), class:vote).election3 0.09475938 0.008979340
## Mult(Exp(.), class:vote).election2 0.07395886 0.005469913
## Mult(Exp(.), class:vote).election1 0.22854401 0.052232363

##  Re-fit model with first multiplier set to zero
doubleUnidiffConstrained &lt;-
    update(doubleUnidiff, constrain = ofInterest(doubleUnidiff)[1])

##  Examine the multipliers of the class-vote log odds ratios
coef(doubleUnidiffConstrained)[ofInterest(doubleUnidiff)]
##  ...as using 'getContrasts' (to 4 d.p.).
</code></pre>


</div>