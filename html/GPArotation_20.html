<div class="container">

<table style="width: 100%;"><tr>
<td>GPA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rotation Optimization</h2>

<h3>Description</h3>

<p>Gradient projection rotation optimization routine used by various rotation
objective.
</p>


<h3>Usage</h3>

<pre><code class="language-R">    GPFRSorth(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="varimax", methodArgs=NULL, randomStarts=0)
    GPFRSoblq(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="quartimin", methodArgs=NULL, randomStarts=0)

    GPForth(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="varimax", methodArgs=NULL)
    GPFoblq(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, 
       method="quartimin", methodArgs=NULL)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>initial factor loadings matrix for which the rotation 
criterian is to be optimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>convergence is assumed when the norm of the gradient is smaller
than eps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations allowed in the main loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>rotation objective criterian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methodArgs</code></td>
<td>
<p>a list ofmethodArgs arguments passed to the rotation objective</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomStarts</code></td>
<td>
<p>number of random starts (GPFRSorth and GPFRSoblq)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Gradient projection (GP) rotation optimization routines developed by
Jennrich (2001, 2002) and Bernaards and Jennrich (2005).
These functions can be used directly
to rotate a loadings matrix, or indirectly through a rotation
objective passed to a factor estimation routine such as <code>factanal</code>.
A rotation of a matrix <code>A</code> is defined as <code>A %*% solve(t(Th))</code>. 
In case of orthogonal rotation, the factors the rotation matrix
<code>Tmat</code> is orthonormal, and the rotation simplifies 
to <code>A %*% Th</code>. The rotation matrix <code>Th</code> is computed by GP rotation.
</p>
<p>The <code>GPFRsorth</code> and <code>GPFRSoblq</code> functions are the primary functions 
for orthogonal and oblique rotations, respectively. These two functions 
serve as wrapper functions for  <code>GPForth</code> and <code>GPFoblq</code>, with the
added functionality of multiple random starts. 
<code>GPForth</code> is the main GP algorithm for orthogonal rotation.
<code>GPFoblq</code> is the main GP algorithm for oblique rotation.
The <code>GPForth</code> and <code>GPFoblq</code> may be also be called directly. 
</p>
<p>Arguments in the wrapper functions <code>GPFRsorth</code> and <code>GPFRSoblq</code> 
are passed to GP algorithms. Functions require an initial loadings matrix 
<code>A</code> which fixes the equivalence class over which the optimization is done. 
It must be the solution to the orthogonal factor analysis problem as obtained 
from <code>factanal</code> or other factor estimation routines. 
The initial rotation matrix is given by the <code>Tmat</code>. 
By default the GP algorithm use the identity matrix as the initial rotation matrix. 
</p>
<p>For some rotation criteria local minima may exist. To start from random 
initial rotation matrices, the <code>randomStarts</code> argument is available
in <code>GPFRSorth</code> and <code>GPFRSoblq</code>. The returned object includes 
the rotated loadings matrix with the lowest criterion value <code>f</code> 
among attemnpted starts.Technically, this does not have to be the global 
minimum. The <code>randomStarts</code> argument
is not available <code>GPForth</code> and <code>GPFoblq</code>. However, for 
<code>GPForth</code> and <code>GPFoblq</code> a single random
initial rotation matrix may be set by <code>Tmat = Random.Start(ncol(A))</code>.
</p>
<p>The argument <code>method</code> can be used to specify a string indicating
the rotation objective. Oblique rotation defaults to <code>"quartimin"</code> 
and orthogonal rotation defaults to <code>"varimax"</code>. Available rotation objectives
are <code>"oblimin"</code>, <code>"quartimin"</code>, <code>"target"</code>, <code>"pst"</code>,
<code>"oblimax"</code>, <code>"entropy"</code>, <code>"quartimax"</code>, <code>"varimax"</code>, 
<code>"simplimax"</code>, <code>"bentler"</code>, <code>"tandemI"</code>, <code>"tandemII"</code>, 
<code> "geomin"</code>, <code>"cf"</code>, <code>"infomax"</code>, <code>"mccammon"</code>, <code>bifactor</code>,
and <code>"varimin"</code>. The string is prefixed with "vgQ." to give the actual function call. 
See <code>vgQ</code> for details.
</p>
<p>Some rotation criteria (<code>"oblimin"</code>, <code>"target"</code>, <code>"pst"</code>, <code>"simplimax"</code>,
<code>"geomin"</code>, <code>"cf"</code>) require one or more additional arguments. See <code>link{rotations}</code>
for details and default values, if applicable. 
</p>
<p>For examples of the indirect use see <code>rotations</code>. 
</p>
<p>The argument <code>normalize</code> gives an indication of if and how any
normalization should be done before rotation, and then undone after rotation.
If <code>normalize</code> is <code>FALSE</code> (the default) no normalization is done.
If <code>normalize</code> is <code>TRUE</code> then Kaiser normalization is done. (So
squared row entries of normalized <code>A</code> sum to 1.0. This is sometimes called
Horst normalization.)
If <code>normalize</code> is a vector of length equal to the number of indicators (=
number of rows of <code>A</code>) then the colums are divided by <code>normalize</code> 
before rotation and multiplied by <code>normalize</code> after rotation. 
If <code>normalize</code> is a function then it should take <code>A</code> as an argument
and return a vector which is used like the vector above. See Nguyen and Waller (2022)
for detailed investigation of normalization on factor rotations, including 
potential effect on qualitative interpretation of loadings.
</p>


<h3>Value</h3>

<p>A GPArotation object which is a list with elements 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>The rotated loadings, one column for each factor. If randomStarts
were requested then this is the rotated loadings matrix with the 
lowest criterion value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th</code></td>
<td>
<p>The rotation matrix, loadings %*% t(Th) = A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Table</code></td>
<td>
<p>A matrix recording the iterations of the rotation optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>A logical indicating if convergence was obtained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPFRSorth and GPForth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gq</code></td>
<td>
<p>The gradient of the objective function at the rotated loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randStartChar</code></td>
<td>
<p>A vector with characteristics of random starts 
(GPFRSorth and GPFRSoblq only; omitted if randomStarts =&lt; 1).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676–696.
</p>
<p>Jennrich, R.I. (2001). A simple general procedure for orthogonal rotation.
<em>Psychometrika</em>, <b>66</b>, 289–306.
</p>
<p>Jennrich, R.I. (2002). A simple general method for oblique rotation. 
<em>Psychometrika</em>, <b>67</b>, 7–19.
</p>
<p>Nguyen, H.V. and Waller, N.G. (2022). Local minima and factor rotations
in exploratory factor analysis. <em> Psychological Methods</em>. 
Advance online publication. https://doi.org/10.1037/met0000467
</p>


<h3>See Also</h3>

<p><code>Random.Start</code>,
<code>factanal</code>,
<code>oblimin</code>,
<code>quartimin</code>,
<code>targetT</code>,
<code>targetQ</code>,
<code>pstT</code>,
<code>pstQ</code>,
<code>oblimax</code>,
<code>entropy</code>,
<code>quartimax</code>,
<code>Varimax</code>,
<code>varimax</code>,
<code>simplimax</code>,
<code>bentlerT</code>,
<code>bentlerQ</code>,
<code>tandemI</code>,
<code>tandemII</code>,
<code>geominT</code>,
<code>geominQ</code>,
<code>bigeominT</code>,
<code>bigeominQ</code>,
<code>cfT</code>,
<code>cfQ</code>,
<code>equamax</code>,
<code>parsimax</code>,
<code>infomaxT</code>,
<code>infomaxQ</code>,
<code>mccammon</code>,
<code>varimin</code>,
<code>bifactorT</code>,
<code>bifactorQ</code>,
<code>promax</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # see rotations for more examples	
	
  data(Harman, package = "GPArotation")
  GPFRSorth(Harman8, method = "quartimax")
  quartimax(Harman8)
  GPFRSoblq(Harman8, method = "quartimin", normalize = TRUE)
  loadings( quartimin(Harman8, normalize = TRUE) )

  # using random starts
  data("WansbeekMeijer", package = "GPArotation")
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  GPFRSoblq(loadings(fa.unrotated), normalize = TRUE, method = "oblimin", randomStarts = 100)
  oblimin(loadings(fa.unrotated), randomStarts=100)
  data(Thurstone, package = "GPArotation")
  geominQ(box26, normalize = TRUE, randomStarts=100)
  
  # displaying results of factor analysis rotation output
  origdigits &lt;- options("digits")
  Abor.unrotated &lt;- factanal(factors = 2, covmat = ability.cov, rotation = "none")
  Abor &lt;- oblimin(loadings(Abor.unrotated), randomStarts = 20)
  Abor
  print(Abor)
  print(Abor, sortLoadings=FALSE) #this matches the output passed to factanal
  print(Abor, Table=TRUE)
  print(Abor, rotateMat=TRUE)
  print(Abor, digits=2)
  # by default provides the structure matrix for oblique rotation
  summary(Abor)
  summary(Abor, Structure=FALSE)
  options(digits = origdigits$digits)
  
  # GPArotation output does sort loadings, but use print to obtain if needed
  set.seed(334)
  xusl &lt;- quartimin(Harman8, normalize = TRUE, randomStarts=100)
  # loadings without ordering (default)
  loadings(xusl)
  max(abs(print(xusl)$loadings - xusl$loadings)) == 0 # FALSE
  # output sorted loadings via print (not default)
  xsl &lt;- print(xusl)
  max(abs(print(xsl)$loadings - xsl$loadings)) == 0 # TRUE
  
  # Kaiser normalization is used when normalize=TRUE
  factanal(factors = 2, covmat = ability.cov, rotation = "oblimin", 
  			control=list(rotate=list(normalize = TRUE)))
  # Cureton-Mulaik normalization can be done by passing values to the rotation
  # may result in convergence problems
  NormalizingWeightCM &lt;- function (L) {
    Dk &lt;- diag(sqrt(diag(L %*% t(L)))^-1) %*% L
    wghts &lt;- rep(0, nrow(L))
    fpls &lt;- Dk[, 1]
    acosi &lt;- acos(ncol(L)^(-1/2))
    for (i in 1:nrow(L)) {
    	num &lt;- (acosi - acos(abs(fpls[i])))
        dem &lt;- (acosi - (function(a, m) ifelse(abs(a) &lt; (m^(-1/2)), pi/2, 0))(fpls[i], ncol(L)))
        wghts[i] &lt;- cos(num/dem * pi/2)^2 + 0.001
    	}
    Dv &lt;- wghts * sqrt(diag(L %*% t(L)))^-1        
    Dv
  }
  quartimin(Harman8, normalize = NormalizingWeightCM(Harman8), randomStarts=100)
  quartimin(Harman8, normalize = TRUE, randomStarts=100)
	
  </code></pre>


</div>