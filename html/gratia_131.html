<div class="container">

<table style="width: 100%;"><tr>
<td>fitted_samples</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Draw fitted values from the posterior distribution</h2>

<h3>Description</h3>

<p>Expectations (fitted values) of the response drawn from the posterior
distribution of fitted model using a Gaussian approximation to the
posterior or a simple Metropolis Hastings sampler.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitted_samples(model, ...)

## S3 method for class 'gam'
fitted_samples(
  model,
  n = 1,
  data = newdata,
  seed = NULL,
  scale = c("response", "linear_predictor"),
  method = c("gaussian", "mh", "inla", "user"),
  n_cores = 1,
  burnin = 1000,
  thin = 1,
  t_df = 40,
  rw_scale = 0.25,
  freq = FALSE,
  unconditional = FALSE,
  draws = NULL,
  mvn_method = c("mvnfast", "mgcv"),
  ...,
  newdata = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a fitted model of the supported types</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to other methods. For <code>fitted_samples()</code>, these
are passed on to <code>mgcv::predict.gam()</code>. For <code>posterior_samples()</code> these are
passed on to <code>fitted_samples()</code>. For <code>predicted_samples()</code> these are
passed on to the relevant <code>simulate()</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>numeric; the number of posterior samples to return.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame; new observations at which the posterior draws
from the model should be evaluated. If not supplied, the data used to fit
the model will be used for <code>data</code>, if available in <code>model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>numeric; a random seed for the simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>character; what scale should the fitted values be returned on?
<code>"linear predictor"</code> is a synonym for <code>"link"</code> if you prefer that
terminology.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character; which method should be used to draw samples from
the posterior distribution. <code>"gaussian"</code> uses a Gaussian (Laplace)
approximation to the posterior. <code>"mh"</code> uses a Metropolis Hastings sampler
that alternates t proposals with proposals based on a shrunken version of
the posterior covariance matrix. <code>"inla"</code> uses a variant of Integrated
Nested Laplace Approximation due to Wood (2019), (currently not
implemented). <code>"user"</code> allows for user-supplied posterior draws
(currently not implemented).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_cores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code>mvnfast::rmvn()</code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>numeric; number of samples to discard as the burnin draws.
Only used with <code>method = "mh"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>numeric; the number of samples to skip when taking <code>n</code> draws.
Results in <code>thin * n</code> draws from the posterior being taken. Only used with
<code>method = "mh"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_df</code></td>
<td>
<p>numeric; degrees of freedom for t distribution proposals. Only
used with <code>method = "mh"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rw_scale</code></td>
<td>
<p>numeric; Factor by which to scale posterior covariance
matrix when generating random walk proposals. Negative or non finite to
skip the random walk step. Only used with <code>method = "mh"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>logical; <code>TRUE</code> to use the frequentist covariance matrix of
the parameter estimators, <code>FALSE</code> to use the Bayesian posterior
covariance matrix of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unconditional</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>freq == FALSE</code>) then the
Bayesian smoothing parameter uncertainty corrected covariance matrix is
used, if available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draws</code></td>
<td>
<p>matrix; user supplied posterior draws to be used when
<code>method = "user"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mvn_method</code></td>
<td>
<p>character; one of <code>"mvnfast"</code> or <code>"mgcv"</code>. The default is
uses <code>mvnfast::rmvn()</code>, which can be considerably faster at generate large
numbers of MVN random values than <code>mgcv::rmvn()</code>, but which might not work
for some marginal fits, such as those where the covariance matrix is close
to singular.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Deprecated; use <code>n_cores</code> instead. The number of cores for
generating random variables from a multivariate normal distribution.
Passed to <code>mvnfast::rmvn()</code>. Parallelization will take place only if
OpenMP is supported (but appears to work on Windows with current <code>R</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tibble (data frame) with 3 columns containing the posterior
predicted values in long format. The columns are
</p>

<ul>
<li> <p><code>row</code> (integer) the row of <code>data</code> that each posterior draw relates to,
</p>
</li>
<li> <p><code>draw</code> (integer) an index, in range <code>1:n</code>, indicating which draw each row
relates to,
</p>
</li>
<li> <p><code>response</code> (numeric) the predicted response for the indicated row of
<code>data</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p>Models with offset terms supplied via the <code>offset</code> argument to
<code>mgcv::gam()</code> etc. are ignored by <code>mgcv::predict.gam()</code>. As such, this
kind of offset term is also ignored by <code>posterior_samples()</code>. Offset terms
that are included in the model formula supplied to <code>mgcv::gam()</code> etc are
not ignored and the posterior samples produced will reflect those offset
term values. This has the side effect of requiring any new data values
provided to <code>posterior_samples()</code> via the <code>data</code> argument must include the
offset variable.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>References</h3>

<p>Wood, S.N., (2020). Simplified integrated nested Laplace approximation.
<em>Biometrika</em> <strong>107</strong>, 223â€“230. <a href="https://doi.org/10.1093/biomet/asz044">doi:10.1093/biomet/asz044</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">load_mgcv()

dat &lt;- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
m1 &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")

fs &lt;- fitted_samples(m1, n = 5, seed = 42)

fs


# can generate own set of draws and use them
drws &lt;- generate_draws(m1, n = 2, seed = 24)
fs2 &lt;- fitted_samples(m1, method = "user", draws = drws)

fs2


</code></pre>


</div>