<div class="container">

<table style="width: 100%;"><tr>
<td>stat_quadrant_counts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Number of observations in quadrants</h2>

<h3>Description</h3>

<p><code>stat_quadrant_counts()</code> counts the number of observations in each
quadrant of a plot panel. By default it adds a text label to the far corner
of each quadrant. It can also be used to obtain the total number of
observations in each of two pairs of quadrants or in the whole panel.
Grouping is ignored, so en every case a single count is computed for each
quadrant in a plot panel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_quadrant_counts(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  quadrants = NULL,
  pool.along = c("none", "x", "y", "xy"),
  xintercept = 0,
  yintercept = 0,
  label.x = NULL,
  label.y = NULL,
  digits = 2,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code> or <code>aes_</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use on this layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadrants</code></td>
<td>
<p>integer vector indicating which quadrants are of interest,
with a <code>OL</code> indicating the whole plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool.along</code></td>
<td>
<p>character, one of <code>"none"</code>, <code>"x"</code> or <code>"y"</code>,
indicating which quadrants to pool to calculate counts by pair of
quadrants.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xintercept, yintercept</code></td>
<td>
<p>numeric the coordinates of the origin of the
quadrants.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.x, label.y</code></td>
<td>
<p><code>numeric</code> Coordinates (in npc units) to be used
for absolute positioning of the labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>integer Number of digits for fraction and percent labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code> values should be stripped
before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and should not inherit behaviour from the
default plot specification, e.g., <code>borders</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This statistic can be used to automatically count observations in
each of the four quadrants of a plot, and by default add these counts as
text labels. Values exactly equal to <code>xintercept</code> or
<code>yintercept</code> are counted together with those larger than the
intercepts. An argument value of zero, passed to formal parameter
<code>quadrants</code> is interpreted as a request for the count of all
observations in each plot panel.
</p>
<p>The default origin of quadrants is at <code>xintercept = 0</code>,
<code>yintercept = 0</code>. Also by default, counts are computed for all
quadrants within the <em>x</em> and <em>y</em> scale limits, but ignoring any
marginal scale expansion. The default positions of the labels is in the
farthest corner or edge of each quadrant using npc coordinates.
Consequently, when using facets even with free limits for <em>x</em> and
<em>y</em> axes, the location of the labels is consistent across panels. This
is achieved by use of <code>geom = "text_npc"</code> or <code>geom =
  "label_npc"</code>. To pass the positions in native data units, pass <code>geom =
  "text"</code> explicitly as argument.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> the counts of
observations per plot quadrant.
</p>


<h3>Computed variables</h3>

<p>Data frame with one to four rows, one for each
quadrant for which counts are counted in <code>data</code>. </p>

<dl>
<dt>quadrant</dt>
<dd>
<p>integer, one of 0:4</p>
</dd> <dt>x</dt>
<dd>
<p>x value of label position in
data units</p>
</dd> <dt>y</dt>
<dd>
<p>y value of label position in data units</p>
</dd> <dt>npcx</dt>
<dd>
<p>x
value of label position in npc units</p>
</dd> <dt>npcy</dt>
<dd>
<p>y value of label position
in npc units</p>
</dd> <dt>count</dt>
<dd>
<p>number of  observations in the quadrant(s)</p>
</dd>
<dt>total</dt>
<dd>
<p>number of onservations in data</p>
</dd>
<dt>count.label</dt>
<dd>
<p>number of observations as character</p>
</dd>
<dt>pc.label</dt>
<dd>
<p>percent of observations as character</p>
</dd>
<dt>fr.label</dt>
<dd>
<p>fraction of observations as character</p>
</dd> </dl>
<p>.
</p>
<p>As shown in one example below <code>geom_debug</code> can be
used to print the computed values returned by any statistic. The output
shown includes also values mapped to aesthetics, like <code>label</code> in the
example.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code>geom_quadrant_lines()</code>,
<code>stat_panel_counts()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# generate artificial data
set.seed(4321)
x &lt;- -50:50
y &lt;- rnorm(length(x), mean = 0)
my.data &lt;- data.frame(x, y)

# using automatically generated text labels, default origin at (0, 0)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = after_stat(pc.label)))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = after_stat(fr.label)))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = after_stat(dec.label)))

ggplot(my.data, aes(x, y)) +
 geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = sprintf("%i observations", after_stat(count)))) +
  scale_y_continuous(expand = expansion(c(0.05, 0.15))) # reserve space

# user specified origin

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(aes(label = after_stat(pc.label)),
                       colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# more digits in labels

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(aes(label = after_stat(pc.label)), digits = 3,
                       colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(aes(label = after_stat(fr.label)),
                       colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# grouped quadrants

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue",
                      pool.along = "x") +
  stat_quadrant_counts(colour = "blue", label.x = "right",
                       pool.along = "x") +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# whole panel

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quadrant_counts(quadrants = 0, label.x = "left", label.y = "bottom") +
  scale_y_continuous(expand = expansion(mult = c(0.15, 0.05)))

# use a different geometry

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quadrant_counts(geom = "text") # use geom_text()

# Numeric values can be used to build labels with alternative formats
# Here with sprintf(), but paste() and format() also work.

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue") +
  stat_quadrant_counts(aes(label = sprintf("%i of %i genes",
                       after_stat(count), after_stat(total))),
                       colour = "blue") +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# We use geom_debug() to see the computed values

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quadrant_counts(geom = "debug")

  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quadrant_counts(geom = "debug", xintercept = 50)
}

</code></pre>


</div>