<div class="container">

<table style="width: 100%;"><tr>
<td>dgmcm.loglik</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Probability, density, and likelihood functions of the Gaussian mixture
(copula) model</h2>

<h3>Description</h3>

<p>Marginal and simultaneous cumulative distribution, log probability density,
and log-likelihood functions of the Gaussian mixture model (GMM) and
Gaussian mixture copula model (GMCM) and the relevant inverse marginal
quantile functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dgmcm.loglik(theta, u, marginal.loglik = FALSE, ...)

dgmm.loglik(theta, z, marginal.loglik = FALSE)

dgmm.loglik.marginal(theta, x, marginal.loglik = TRUE)

pgmm.marginal(z, theta)

qgmm.marginal(u, theta, res = 1000, spread = 5, rule = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>A list parameters as described in <code>rtheta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>A matrix of (estimates of) realizations from the GMCM where each
row corresponds to an observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marginal.loglik</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the marginal log-likelihood
functions for each multivariate observation (i.e. the log densities) are
returned. In other words, if <code>TRUE</code> the sum of the marginal
likelihoods is not computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>qgmm.marginal</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>A matrix of realizations from the latent process where each row
corresponds to an observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix where each row corresponds to an observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>The resolution at which the inversion of <code>qgmm.marginal</code> is
done. Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spread</code></td>
<td>
<p>The number of marginal standard deviations from the marginal
means the <code>pgmm.marginal</code> is to be evaluated on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>The extrapolation rule used in <code>approxfun</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>qgmm.marginal</code> distributes approximately <code>res</code> points around the
cluster centers according to the mixture proportions in <code>theta$pie</code> and
evaluates <code>pgmm.marginal</code> on these points. An approximate inverse of
<code>pgmm.marginal</code> function is constructed by linear interpolation of the
flipped evaluated coordinates.
</p>


<h3>Value</h3>

<p>The returned value depends on the value of <code>marginal.loglik</code>.
If <code>TRUE</code>, the non-summed marginal likelihood values are returned. If
<code>FALSE</code>, the scalar sum log-likelihood is returned.
</p>
<p><code>dgmcm.loglik</code>: As above, with the GMCM density.
</p>
<p><code>dgmm.loglik</code>: As above, with the GMM density.
</p>
<p><code>dgmm.loglik.marginal</code>: As above, where the j'th element is evaluated
in the j'th marginal GMM density.
</p>
<p><code>pgmm.marginal</code>: A matrix where the (i,j)'th entry is the (i,j)'th
entry of <code>z</code> evaluated in the jth marginal GMM density.
</p>
<p><code>qgmm.marginal</code>: A matrix where the (i,j)'th entry is the (i,j)'th
entry of <code>u</code> evaluated in the inverse jth marginal GMM density.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau &lt;anders.ellern.bilgrau@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
data &lt;- SimulateGMCMData(n = 10)
u &lt;- data$u
z &lt;- data$z
print(theta &lt;- data$theta)

GMCM:::dgmcm.loglik(theta, u, marginal.loglik = FALSE)
GMCM:::dgmcm.loglik(theta, u, marginal.loglik = TRUE)

GMCM:::dgmm.loglik(theta, z, marginal.loglik = FALSE)
GMCM:::dgmm.loglik(theta, z, marginal.loglik = TRUE)

GMCM:::dgmm.loglik.marginal(theta, z, marginal.loglik = FALSE)
GMCM:::dgmm.loglik.marginal(theta, z, marginal.loglik = TRUE)

GMCM:::pgmm.marginal(z, theta)
GMCM:::qgmm.marginal(u, theta)
</code></pre>


</div>