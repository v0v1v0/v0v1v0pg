<div class="container">

<table style="width: 100%;"><tr>
<td>gwpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GWPCA</h2>

<h3>Description</h3>

<p>This function implements basic or robust GWPCA.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gwpca(data, elocat, vars, k = 2, robust = FALSE, scaling=T, kernel = "bisquare",
                  adaptive = FALSE, bw, p = 2, theta = 0, longlat = F, cv = T, scores=F,
                  dMat)
## S3 method for class 'gwpca'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span>, or a sf object defined in package <span class="pkg">sf</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elocat</code></td>
<td>
<p>a two-column numeric array or Spatial*DataFrame object for providing evaluation locations, 
i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame 
as defined in package <span class="pkg">sp</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>a vector of variable names to be evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the number of retained components; k must be less than the number of variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>if TRUE, robust GWPCA will be applied; otherwise basic GWPCA will be applied</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>if TRUE,  the data is scaled to have zero mean and unit variance (standardized); 
otherwise the data is centered but not scaled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by bw.gwpca;fixed (distance) or adaptive bandwidth(number of nearest neighbours)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>If TRUE, cross-validation data will be found that are used to calculate the cross-validation score for the specified bandwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>if scores = TRUE, the scores of the supplied data on the principal components will be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code>gw.dist</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class “gwpca”, returned by the function <code>gwpca</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class “gwpca”:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pca</code></td>
<td>
<p>an object of class inheriting from “princomp”, see princomp. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>the localised loadings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or 
SpatialPolygonsDataFrame object (see package “sp”) or sf object  (see package “sf”) 
integrated with local proportions of variance for each 
principle components, cumulative proportion and winning variable for the 1st principle component in its "data" slot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwpca.scores</code></td>
<td>
<p>the localised scores of the supplied data on the principal components </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>The local amount of variance accounted for by each component</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CV</code></td>
<td>
<p>Vector of cross-validation data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Fotheringham S, Brunsdon, C, and Charlton, M (2002),
Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>
<p>Harris P, Brunsdon C, Charlton M (2011)
Geographically weighted principal components analysis.
International Journal of Geographical Information Science 25:1717-1736
</p>
<p>Harris P, Brunsdon C, Charlton M, Juggins S, Clarke A (2014) Multivariate spatial 
outlier detection using robust geographically weighted methods.  Mathematical 
Geosciences 46(1) 1-31
</p>
<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2014) Geographically 
weighted methods and their use in network re-designs for environmental monitoring. 
Stochastic Environmental Research and Risk Assessment 28: 1869-1887
</p>
<p>Harris P, Clarke A, Juggins S, Brunsdon C, Charlton M (2015) Enhancements to a 
geographically weighted principal components analysis in the context of an 
application to an environmental data set.  Geographical Analysis 47: 146-172
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
if(require("mvoutlier") &amp;&amp; require("RColorBrewer"))
{
  data(bsstop)
  Data.1 &lt;- bsstop[, 1:14]
  colnames(Data.1)
  Data.1.scaled &lt;- scale(as.matrix(Data.1[5:14]))  # standardised data...
  rownames(Data.1.scaled) &lt;- Data.1[, 1]
  #compute principal components:
  pca &lt;- princomp(Data.1.scaled, cor = FALSE, scores = TRUE)  
  # use covariance matrix to match the following...
  pca$loadings
  data(bss.background)
  backdrop &lt;- function() 
   plot(bss.background, asp = 1, type = "l", xaxt = "n", yaxt = "n", 
   xlab = "", ylab = "", bty = "n", col = "grey")
  pc1 &lt;- pca$scores[, 1]
  backdrop()
  points(Data.1$XCOO[pc1 &gt; 0], Data.1$YCOO[pc1 &gt; 0], pch = 16, col = "blue")
  points(Data.1$XCOO[pc1 &lt; 0], Data.1$YCOO[pc1 &lt; 0], pch = 16, col = "red")
  
  #Geographically Weighted PCA and mapping the local loadings
  # Coordinates of the sites
  Coords1 &lt;- as.matrix(cbind(Data.1$XCOO,Data.1$YCOO)) 
  d1s &lt;- SpatialPointsDataFrame(Coords1,as.data.frame(Data.1.scaled))
  pca.gw &lt;- gwpca(d1s,vars=colnames(d1s@data),bw=1000000,k=10)
  local.loadings &lt;- pca.gw$loadings[, , 1]  
  
  # Mapping the winning variable with the highest absolute loading
  # note first component only - would need to explore all components..
  
  lead.item &lt;- colnames(local.loadings)[max.col(abs(local.loadings))]
  df1p = SpatialPointsDataFrame(Coords1, data.frame(lead = lead.item))
  backdrop()
  colour &lt;- brewer.pal(8, "Dark2")[match(df1p$lead, unique(df1p$lead))]
  plot(df1p, pch = 18, col = colour, add = TRUE)
  legend("topleft", as.character(unique(df1p$lead)), pch = 18, col = 
      brewer.pal(8, "Dark2"))
  backdrop()
  
  #Glyph plots give a view of all the local loadings together
  glyph.plot(local.loadings, Coords1, add = TRUE)
  
  #it is not immediately clear how to interpret the glyphs fully, 
  #so inter-actively identify the full loading information using:
  check.components(local.loadings, Coords1)
  
  # GWPCA with an optimal bandwidth
  bw.choice &lt;- bw.gwpca(d1s,vars=colnames(d1s@data),k=2) 
  pca.gw.auto  &lt;- gwpca(d1s,vars=colnames(d1s@data),bw=bw.choice,k=2)
  # note first component only - would need to explore all components..
  local.loadings &lt;- pca.gw.auto$loadings[, , 1]  
  
  lead.item &lt;- colnames(local.loadings)[max.col(abs(local.loadings))]
  df1p = SpatialPointsDataFrame(Coords1, data.frame(lead = lead.item))
  backdrop()
  colour &lt;- brewer.pal(8, "Dark2")[match(df1p$lead, unique(df1p$lead))]
  plot(df1p, pch = 18, col = colour, add = TRUE)
  legend("topleft", as.character(unique(df1p$lead)), pch = 18, 
  col = brewer.pal(8, "Dark2"))
  
  # GWPCPLOT for investigating the raw multivariate data
  gw.pcplot(d1s, vars=colnames(d1s@data),focus=359, bw = bw.choice) 
}

## End(Not run)
</code></pre>


</div>