<div class="container">

<table style="width: 100%;"><tr>
<td>pulstran</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pulse train</h2>

<h3>Description</h3>

<p>Generate a train of pulses based on samples of a continuous function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pulstran(
  t,
  d,
  func,
  fs = 1,
  method = c("linear", "nearest", "cubic", "spline"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>Time values at which <code>func</code> is evaluated, specified as a
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>Offset removed from the values of the array <code>t</code>, specified as a
real vector, matrix, or array. You can apply an optional gain factor to
each delayed evaluation by specifying <code>d</code> as a two-column matrix, with
offset defined in column 1 and associated gain in column 2. If you specify
<code>d</code> as a vector, the values are interpreted as delays only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>Continuous function used to generate a pulse train based on its
samples, specified as 'rectpuls', 'gauspuls', 'tripuls', or a function
handle. If you use <code>func</code> as a function handle, you can pass the
function parameters as follows:<br><code>y &lt;- pulstran(t, d, 'gauspuls',
10e3, bw = 0.5)</code>.<br> This creates a pulse train using a 10 kHz Gaussian
pulse with 50% bandwidth. Alternatively, <code>func</code> can be a prototype
function, specified as a vector. The interval of the function <code>0</code> to
<code>(length(p) - 1) / fs</code>, and its samples are identically zero outside
this interval. By default, linear interpolation is used for generating
delays.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs</code></td>
<td>
<p>Sample rate in Hz, specified as a real scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Interpolation method, specified as one of the following
options:
</p>

<dl>
<dt>"linear" (default)</dt>
<dd>
<p>Linear interpolation. The interpolated value at a
query point is based on linear interpolation of the values at neighboring
grid points in each respective dimension. This is the default interpolation
method.</p>
</dd>
<dt>"nearest"</dt>
<dd>
<p>Nearest neighbor interpolation. The interpolated value at a
query point is the value at the nearest sample grid point.</p>
</dd>
<dt>"cubic"</dt>
<dd>
<p>Shape-preserving piecewise cubic interpolation. The
interpolated value at a query point is based on a shape-preserving
piecewise cubic interpolation of the values at neighboring grid points.</p>
</dd>
<dt>"spline"</dt>
<dd>
<p>Spline interpolation using not-a-knot end conditions. The
interpolated value at a query point is based on a cubic interpolation of
the values at neighboring grid points in each respective dimension.</p>
</dd>
</dl>
<p>Interpolation is performed by the function <code>'interp1'</code> function in the
library <code>'pracma'</code>, and any interpolation method accepted by the
function <code>'interp1'</code> can be specified here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>func</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Generate the signal <code>y &lt;- sum(func(t + d, ...))</code> for each <code>d</code>. If
<code>d</code> is a matrix of two columns, the first column is the delay <code>d</code>
and the second column is the amplitude <code>a</code>, and <code>y &lt;- sum(a *
func(t + d))</code> for each <code>d, a</code>. Clearly, <code>func</code> must be a function
which accepts a vector of times. Any extra arguments needed for the function
must be tagged on the end.
</p>
<p>If instead of a function name you supply a pulse shape sampled at frequency
<code>fs</code> (default 1 Hz), an interpolated version of the pulse is added at
each delay <code>d</code>. The interpolation stays within the the time range of the
delayed pulse. The interpolation method defaults to linear, but it can be any
interpolation method accepted by the function <code>interp1</code>
</p>


<h3>Value</h3>

<p>Pulse train generated by the function, returned as a vector.
</p>


<h3>Author(s)</h3>

<p>Sylvain Pelissier, <a href="mailto:sylvain.pelissier@gmail.com">sylvain.pelissier@gmail.com</a>.<br>
Conversion to R by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## periodic rectangular pulse
t &lt;- seq(0, 60, 1/1e3)
d &lt;- cbind(seq(0, 60, 2), sin(2 * pi * 0.05 * seq(0, 60, 2)))
y &lt;- pulstran(t, d, 'rectpuls')
plot(t, y, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Periodic rectangular pulse")

## assymetric sawtooth waveform
fs &lt;- 1e3
t &lt;- seq(0, 1, 1/fs)
d &lt;- seq(0, 1, 1/3)
x &lt;- tripuls(t, 0.2, -1)
y &lt;- pulstran(t, d, x, fs)
plot(t, y, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Asymmetric sawtooth waveform")

## Periodic Gaussian waveform
fs &lt;- 1e7
tc &lt;- 0.00025
t &lt;- seq(-tc, tc, 1/fs)
x &lt;- gauspuls(t, 10e3, 0.5)
plot(t, x, type="l", xlab = "Time (s)", ylab = "Waveform",
     main = "Gaussian pulse")
ts &lt;- seq(0, 0.025, 1/50e3)
d &lt;- cbind(seq(0, 0.025, 1/1e3), sin(2 * pi * 0.1 * (0:25)))
y &lt;- pulstran(ts, d, x, fs)
plot(ts, y, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Gaussian pulse train")

# Custom pulse trains
fnx &lt;- function(x, fn) sin(2 * pi * fn * x) * exp(-fn * abs(x))
ffs &lt;- 1000
tp &lt;- seq(0, 1, 1/ffs)
pp &lt;- fnx(tp, 30)
plot(tp, pp, type = "l",xlab = 'Time (s)', ylab = 'Waveform',
     main = "Custom pulse")
fs &lt;- 2e3
t &lt;- seq(0, 1.2, 1/fs)
d &lt;- seq(0, 1, 1/3)
dd &lt;- cbind(d, 4^-d)
z &lt;- pulstran(t, dd, pp, ffs)
plot(t, z, type = "l", xlab = "Time (s)", ylab = "Waveform",
     main = "Custom pulse train")

</code></pre>


</div>