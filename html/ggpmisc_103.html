<div class="container">

<table style="width: 100%;"><tr>
<td>stat_ma_eq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Equation, p-value, R^2 of major axis regression</h2>

<h3>Description</h3>

<p><code>stat_ma_eq</code> fits model II regressions. From the fitted model it
generates several labels including the equation, p-value,
coefficient of determination (R^2), and number of observations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_ma_eq(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  ...,
  formula = NULL,
  method = "lmodel2:MA",
  method.args = list(),
  n.min = 2L,
  range.y = NULL,
  range.x = NULL,
  nperm = 99,
  eq.with.lhs = TRUE,
  eq.x.rhs = NULL,
  small.r = getOption("ggpmisc.small.r", default = FALSE),
  small.p = getOption("ggpmisc.small.p", default = FALSE),
  coef.digits = 3,
  coef.keep.zeros = TRUE,
  decreasing = getOption("ggpmisc.decreasing.poly.eq", FALSE),
  rr.digits = 2,
  theta.digits = 2,
  p.digits = max(1, ceiling(log10(nperm))),
  label.x = "left",
  label.y = "top",
  hstep = 0,
  vstep = NULL,
  output.type = NULL,
  na.rm = FALSE,
  orientation = NA,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names. Either <code>y ~ x</code> or <code>x ~ y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function or character If character, "MA", "SMA" , "RMA" or
"OLS", alternatively "lmodel2" or the name of a model fit function are
accepted, possibly followed by the fit function's <code>method</code> argument
separated by a colon (e.g. <code>"lmodel2:MA"</code>). If a function different to
<code>lmodel2()</code>, it must accept arguments named <code>formula</code>,
<code>data</code>, <code>range.y</code>, <code>range.x</code> and <code>nperm</code> and return a
model fit object of class <code>lmodel2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range.y, range.x</code></td>
<td>
<p>character Pass "relative" or "interval" if method
"RMA" is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperm</code></td>
<td>
<p>integer Number of permutation used to estimate significance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.with.lhs</code></td>
<td>
<p>If <code>character</code> the string is pasted to the front of
the equation label before parsing or a <code>logical</code> (see note).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.x.rhs</code></td>
<td>
<p><code>character</code> this string will be used as replacement for
<code>"x"</code> in the model equation when generating the label before parsing
it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small.r, small.p</code></td>
<td>
<p>logical Flags to switch use of lower case r and p for
coefficient of determination and p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.digits</code></td>
<td>
<p>integer Number of significant digits to use for
the fitted coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.keep.zeros</code></td>
<td>
<p>logical Keep or drop trailing zeros when formatting
the fitted coefficients and F-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>logical It specifies the order of the terms in the
returned character string; in increasing (default) or decreasing powers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rr.digits, theta.digits, p.digits</code></td>
<td>
<p>integer Number of digits after the
decimal point to use for R^2, theta and P-value in labels. If <code>Inf</code>,
use exponential notation with three decimal places.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.x, label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 "normalized parent
coordinates" (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hstep, vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.type</code></td>
<td>
<p>character One of "expression", "LaTeX", "text",
"markdown" or "numeric".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either "x" or "y" controlling the default for
<code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This stat can be used to automatically annotate a plot with
<code class="reqn">R^2</code>, <code class="reqn">P</code>-value, <code class="reqn">n</code> and/or the fitted model equation. It
supports linear major axis (MA), standard major axis (SMA) and ranged major
axis (RMA) regression by means of function <code>lmodel2</code>.
Formulas describing a straight line and including an intercept are the
only ones currently supported. Please see the documentation, including the
vignette of package 'lmodel2' for details. The parameters in
<code>stat_ma_eq()</code> follow the same naming as in function <code>lmodel2()</code>.
</p>
<p>It is important to keep in mind that although the fitted line does not
depend on whether the <code class="reqn">x</code> or <code class="reqn">y</code> appears on the rhs of the model
formula, the numeric estimates for the parameters do depend on this.
</p>
<p>A ggplot statistic receives as <code>data</code> a data frame that is not the one
passed as argument by the user, but instead a data frame with the variables
mapped to aesthetics. <code>stat_ma_eq()</code> mimics how <code>stat_smooth()</code>
works, except that Model II regressions can be fitted. Similarly to
<code>stat_smooth()</code> the model is fitted separately to data from each
group, so the variables mapped to <code>x</code> and <code>y</code> should both be
continuous rather than discrete as well as the corresponding scales.
</p>
<p>The minimum number of observations with distinct values can be set through
parameter <code>n.min</code>. The default <code>n.min = 2L</code> is the smallest
possible value. However, model fits with very few observations are of
little interest and using a larger number for <code>n.min</code> than the default
is usually wise.
</p>


<h3>Value</h3>

<p>A data frame, with a single row and columns as described under
<strong>Computed variables</strong>. In cases when the number of observations is
less than <code>n.min</code> a data frame with no rows or columns is returned
rendered as an empty/invisible plot layer.
</p>


<h3>User-defined methods</h3>

<p>User-defined functions can be passed as
argument to <code>method</code>. The requirements are 1) that the signature is
similar to that of function <code>lmodel2()</code> and 2) that the value returned
by the function is an object as returned by <code>lmodel2()</code> or an atomic
<code>NA</code> value. Thus, user-defined methods can implement conditional
skipping of labelling.
</p>


<h3>Aesthetics</h3>

<p><code>stat_ma_eq</code> understands <code>x</code> and <code>y</code>, to
be referenced in the <code>formula</code> while the <code>weight</code> aesthetic is
ignored. Both <code>x</code> and <code>y</code> must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"text"</code> is the default) are understood and grouping respected.
</p>
<p><em>Transformation of <code>x</code> or <code>y</code> within the model formula
is not supported by <code>stat_ma_eq()</code>. In this case, transformations
should not be applied in the model formula, but instead in the mapping
of the variables within <code>aes</code> or in the scales.</em>
</p>


<h3>Computed variables</h3>

<p>If <code>output.type</code> is different from <code>"numeric"</code> the returned tibble
contains columns listed below. If the fitted model does not contain a given
value, the label is set to <code>character(0L)</code>.
</p>

<dl>
<dt>x,npcx</dt>
<dd>
<p>x position</p>
</dd>
<dt>y,npcy</dt>
<dd>
<p>y position</p>
</dd>
<dt>eq.label</dt>
<dd>
<p>equation for the fitted polynomial as a character string to be parsed</p>
</dd>
<dt>rr.label</dt>
<dd>
<p><code class="reqn">R^2</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>p.value.label</dt>
<dd>
<p>P-value if available, depends on <code>method</code>.</p>
</dd>
<dt>theta.label</dt>
<dd>
<p>Angle in degrees between the two OLS lines for lines estimated from <code>y ~ x</code> and <code>x ~ y</code> linear model (<code>lm</code>) fits.</p>
</dd>
<dt>n.label</dt>
<dd>
<p>Number of observations used in the fit.</p>
</dd>
<dt>grp.label</dt>
<dd>
<p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>method.label</dt>
<dd>
<p>Set according <code>method</code> used.</p>
</dd>
<dt>r.squared, theta, p.value, n</dt>
<dd>
<p>numeric values, from the model fit object</p>
</dd>
</dl>
<p>If output.type is <code>"numeric"</code> the returned tibble contains columns
listed below. If the model fit function used does not return a value,
the variable is set to <code>NA_real_</code>.
</p>

<dl>
<dt>x,npcx</dt>
<dd>
<p>x position</p>
</dd>
<dt>y,npcy</dt>
<dd>
<p>y position</p>
</dd>
<dt>coef.ls</dt>
<dd>
<p>list containing the "coefficients" matrix from the summary of the fit object</p>
</dd>
<dt>r.squared, theta, p.value, n</dt>
<dd>
<p>numeric values, from the model fit object</p>
</dd>
<dt>grp.label</dt>
<dd>
<p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>b_0.constant</dt>
<dd>
<p>TRUE is polynomial is forced through the origin</p>
</dd>
<dt>b_i</dt>
<dd>
<p>One or two columns with the coefficient estimates</p>
</dd>
</dl>
<p>To explore the computed values returned for a given input we suggest the use
of <code>geom_debug</code> as shown in the last examples below.
</p>


<h3>Note</h3>

<p>For backward compatibility a logical is accepted as argument for
<code>eq.with.lhs</code>. If <code>TRUE</code>, the default is used, either
<code>"x"</code> or <code>"y"</code>, depending on the argument passed to <code>formula</code>.
However, <code>"x"</code> or <code>"y"</code> can be substituted by providing a
suitable replacement character string through <code>eq.x.rhs</code>.
Parameter <code>orientation</code> is redundant as it only affects the default
for <code>formula</code> but is included for consistency with
<code>ggplot2::stat_smooth()</code>.
</p>
<p>Methods in <code>lmodel2</code> are all computed always except
for RMA that requires a numeric argument to at least one of <code>range.y</code>
or <code>range.x</code>. The results for specific methods are extracted a
posteriori from the model fit object. When a function is passed as argument
to <code>method</code>, the method can be passed in a list to <code>method.args</code>
as member <code>method</code>. More easily, the name of the function can be
passed as a character string together with the <code>lmodel2</code>-supported
method.
</p>
<p>R option <code>OutDec</code> is obeyed based on its value at the time the plot
is rendered, i.e., displayed or printed. Set <code>options(OutDec = ",")</code>
for languages like Spanish or French.
</p>


<h3>See Also</h3>

<p>The major axis regression model is fitted with function
<code>lmodel2</code>, please consult its documentation. Statistic
<code>stat_ma_eq()</code> can return different ready formatted labels depending
on the argument passed to <code>output.type</code>. If ordinary least squares
polynomial regression is desired, then <code>stat_poly_eq</code>. If
quantile-fitted polynomial regression is desired,
<code>stat_quant_eq</code> should be used. For other types of models such
as non-linear models, statistics <code>stat_fit_glance</code> and
<code>stat_fit_tidy</code> should be used and the code for construction of
character strings from numeric values and their mapping to aesthetic
<code>label</code> explicitly supplied in the call.
</p>
<p>Other ggplot statistics for major axis regression: 
<code>stat_ma_line()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># generate artificial data
set.seed(98723)
my.data &lt;- data.frame(x = rnorm(100) + (0:99) / 10 - 5,
                      y = rnorm(100) + (0:99) / 10 - 5,
                      group = c("A", "B"))

# using defaults (major axis regression)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line() +
  stat_ma_eq()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line() +
  stat_ma_eq(mapping = use_label("eq"))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line() +
  stat_ma_eq(mapping = use_label("eq"), decreasing = TRUE)

# use_label() can assemble and map a combined label
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA") +
  stat_ma_eq(mapping = use_label("eq", "R2", "P"))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA") +
  stat_ma_eq(mapping = use_label("R2", "P", "theta", "method"))

# using ranged major axis regression
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "RMA",
               range.y = "interval",
               range.x = "interval") +
  stat_ma_eq(mapping = use_label("eq", "R2", "P"),
             method = "RMA",
             range.y = "interval",
             range.x = "interval")

# No permutation-based test
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA") +
  stat_ma_eq(mapping = use_label("eq", "R2"),
             method = "MA",
             nperm = 0)

# explicit formula "x explained by y"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(formula = x ~ y) +
  stat_ma_eq(formula = x ~ y,
             mapping = use_label("eq", "R2", "P"))

# modifying both variables within aes()
ggplot(my.data, aes(log(x + 10), log(y + 10))) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(mapping = use_label("eq"),
               eq.x.rhs = "~~log(x+10)",
               eq.with.lhs = "log(y+10)~~`=`~~")

# grouping
ggplot(my.data, aes(x, y, color = group)) +
  geom_point() +
  stat_ma_line() +
  stat_ma_eq()

# labelling equations
ggplot(my.data,
       aes(x, y,  shape = group, linetype = group, grp.label = group)) +
  geom_point() +
  stat_ma_line(color = "black") +
  stat_ma_eq(mapping = use_label("grp", "eq", "R2")) +
  theme_classic()

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics with after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

# default is output.type = "expression"
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(geom = "debug")

## Not run: 
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(mapping = aes(label = after_stat(eq.label)),
               geom = "debug",
               output.type = "markdown")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(geom = "debug", output.type = "text")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(geom = "debug", output.type = "numeric")

## End(Not run)

</code></pre>


</div>