<div class="container">

<table style="width: 100%;"><tr>
<td>with_circle_dither</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dither image using a threshold dithering map</h2>

<h3>Description</h3>

<p>These filters reduces the number of colours in your layer and uses various
threshold maps along with a dithering algorithm to disperse colour error.
</p>


<h3>Usage</h3>

<pre><code class="language-R">with_circle_dither(
  x,
  map_size = 7,
  levels = NULL,
  black = TRUE,
  colourspace = "sRGB",
  offset = NULL,
  ...
)

with_custom_dither(
  x,
  map = "checks",
  levels = NULL,
  colourspace = "sRGB",
  offset = NULL,
  ...
)

with_halftone_dither(
  x,
  map_size = 8,
  levels = NULL,
  angled = TRUE,
  colourspace = "sRGB",
  offset = NULL,
  ...
)

with_ordered_dither(x, map_size = 8, levels = NULL, colourspace = "sRGB", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A ggplot2 layer object, a ggplot, a grob, or a character string
naming a filter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map_size</code></td>
<td>
<p>One of 2, 3, 4, or 8. Sets the threshold map used for
dithering. The larger, the better approximation of the input colours</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>The number of threshold levels in each channel. Either a single
integer to set the same number of levels in each channel, or 3 values to set
the levels individually for each colour channel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>black</code></td>
<td>
<p>Should the map consist of dark circles expanding into the light,
or the reverse</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colourspace</code></td>
<td>
<p>In which colourspace should the dithering be calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>The angle offset between the colour channels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed on to methods. See
the documentation of supported object for a description of
object specific arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>The name of the threshold map to use as understood by
<code>magick::image_ordered_dither()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angled</code></td>
<td>
<p>Should the halftone pattern be at an angle or orthogonal</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Depending on the input, either a <code>grob</code>, <code>Layer</code>, list of <code>Layer</code>s,
<code>guide</code>, or <code>element</code> object. Assume the output can be used in the same
context as the input.
</p>


<h3>See Also</h3>

<p>Other dithering filters: 
<code>with_dither()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(ggplot2)

# Ordered dither
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_ordered_dither(
    geom_raster(aes(fill = density), interpolate = TRUE)
  ) +
  scale_fill_continuous(type = 'viridis')

# Halftone dither
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_halftone_dither(
    geom_raster(aes(fill = density), interpolate = TRUE)
  ) +
  scale_fill_continuous(type = 'viridis')

# Circle dither with offset
ggplot(faithfuld, aes(waiting, eruptions)) +
  with_circle_dither(
    geom_raster(aes(fill = density), interpolate = TRUE),
    offset = 29,
    colourspace = 'cmyk'
  ) +
  scale_fill_continuous(type = 'viridis')

</code></pre>


</div>