<div class="container">

<table style="width: 100%;"><tr>
<td>focus</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Show features and regions of interest</h2>

<h3>Description</h3>

<p>Show loci containing features of interest. Loci can either be provided
as predefined regions directly (<code style="white-space: pre;">⁠loci=⁠</code>), or are constructed automatically
based on pre-selected features (via <code>...</code>). Features within <code>max_dist</code> are
greedily combined into the same locus. <code>locate()</code> adds these loci as new
track so that they can be easily visualized. <code>focus()</code> extracts those loci
from their parent sequences making them the new sequence set. These sequences
will have their <code>locus_id</code> as their new <code>seq_id</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">focus(
  x,
  ...,
  .track_id = 2,
  .max_dist = 10000,
  .expand = 5000,
  .overhang = c("drop", "trim", "keep"),
  .locus_id = str_glue("{seq_id}_lc{row_number()}"),
  .locus_id_group = seq_id,
  .locus_bin = c("bin", "seq", "locus"),
  .locus_score = n(),
  .locus_filter = TRUE,
  .loci = NULL
)

locate(
  x,
  ...,
  .track_id = 2,
  .max_dist = 10000,
  .expand = 5000,
  .locus_id = str_glue("{seq_id}_lc{row_number()}"),
  .locus_id_group = .data$seq_id,
  .locus_bin = c("bin", "seq", "locus"),
  .locus_score = n(),
  .locus_filter = TRUE,
  .locus_track = "loci"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A gggenomes object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Logical predicates defined in terms of the variables in the track
given by <code>.track_id</code>. Multiple conditions are combined with ‘&amp;’. Only rows
where the condition evaluates to ‘TRUE’ are kept.
</p>
<p>The arguments in ‘...’ are automatically quoted and evaluated in the
context of the data frame. They support unquoting and splicing. See
‘vignette("programming")’ for an introduction to these concepts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.track_id</code></td>
<td>
<p>the track to filter from - defaults to first feature track,
usually "genes". Can be a quoted or unquoted string or a positional
argument giving the index of a track among all tracks (seqs, feats &amp;
links).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.max_dist</code></td>
<td>
<p>Maximum distance between adjacent features to be included
into the same locus, default 10kb.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.expand</code></td>
<td>
<p>The amount to nucleotides to expand the focus around the
target features. Default 2kb. Give two values for different up- and
downstream expansions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.overhang</code></td>
<td>
<p>How to handle features overlapping the locus boundaries
(including expand). Options are to "keep" them, "trim" them exactly at the
boundaries, or "drop" all features not fully included within the
boundaries.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.locus_id, .locus_id_group</code></td>
<td>
<p>How to generate the ids for the new loci
which will eventually become their new <code>seq_id</code>s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.locus_bin</code></td>
<td>
<p>What bin to assign new locus to. Defaults to keeping the
original binning, but can be set to the "seq" to bin all loci originating
from the same parent sequence, or to "locus" to separate all loci into
individual bins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.locus_score</code></td>
<td>
<p>An expression evaluated in the context of all features
that are combined into a new locus. Results are stored in the column
<code>locus_score</code>. Defaults to the <code>n()</code>, i.e. the number of features per
locus. Set, for example, to <code>sum(bitscore)</code> to sum over all blast hit
bitscore of per locus. Usually used in conjunction with <code>.locus_filter</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.locus_filter</code></td>
<td>
<p>An predicate expression used to post-filter identified
loci. Set <code>.locus_filter=locus_score &gt;= 3</code> to only return loci comprising
at least 3 target features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.loci</code></td>
<td>
<p>A data.frame specifying loci directly. Required columns are
<code style="white-space: pre;">⁠seq_id,start,end⁠</code>. Supersedes <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.locus_track</code></td>
<td>
<p>The name of the new track containing the identified loci.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A gggenomes object focused on the desired loci
</p>
<p>A gggenomes object with the new loci track added
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>focus()</code>: Identify regions of interest and zoom in on them
</p>
</li>
<li> <p><code>locate()</code>: Identify regions of interest and add them as new feature track
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
# Let's hunt some defense systems in marine SAGs
# read the genomes
s0 &lt;- read_seqs(ex("gorg/gorg.fna.fai"))
s1 &lt;- s0 %&gt;%
  # strip trailing number from contigs to get bins
  dplyr::mutate(bin_id = stringr::str_remove(seq_id, "_\\d+$"))
# gene annotations from prokka
g0 &lt;- read_feats(ex("gorg/gorg.gff.xz"))

# best hits to the PADS Arsenal database of prokaryotic defense-system genes
# $ mmseqs easy-search gorg.fna pads-arsenal-v1-prf gorg-pads-defense.o6 /tmp \
#     --greedy-best-hits
f0 &lt;- read_feats(ex("gorg/gorg-pads-defense.o6"))
f1 &lt;- f0 %&gt;%
  # parser system/gene info
  tidyr::separate(seq_id2, into = c("seq_id2", "system", "gene"), sep = ",") %&gt;%
  dplyr::filter(
    evalue &lt; 1e-10, # get rid of some spurious hits
    # and let's focus just on a few systems for this example
    system %in% c("CRISPR-CAS", "DISARM", "GABIJA", "LAMASSU", "THOERIS")
  )

# plot the distribution of hits across full genomes
gggenomes(g0, s1, f1, wrap = 2e5) +
  geom_seq() + geom_bin_label() +
  scale_color_brewer(palette = "Dark2") +
  geom_point(aes(x = x, y = y, color = system), data = feats())

# hilight the regions containing hits
gggenomes(g0, s1, f1, wrap = 2e5) %&gt;%
  locate(.track_id = feats) %&gt;%
  identity() +
  geom_seq() + geom_bin_label() +
  scale_color_brewer(palette = "Dark2") +
  geom_feat(data = feats(loci), color = "plum3") +
  geom_point(aes(x = x, y = y, color = system), data = feats())

# zoom in on loci
gggenomes(g0, s1, f1, wrap = 5e4) %&gt;%
  focus(.track_id = feats) +
  geom_seq() + geom_bin_label() +
  geom_gene() +
  geom_feat(aes(color = system)) +
  geom_feat_tag(aes(label = gene)) +
  scale_color_brewer(palette = "Dark2")
</code></pre>


</div>