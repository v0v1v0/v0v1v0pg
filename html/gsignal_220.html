<div class="container">

<table style="width: 100%;"><tr>
<td>pwelch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Welch’s power spectral density estimate</h2>

<h3>Description</h3>

<p>Compute power spectral density (PSD) using Welch's method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pwelch(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.5,
  nfft = if (isScalar(window)) window else length(window),
  fs = 1,
  detrend = c("long-mean", "short-mean", "long-linear", "short-linear", "none"),
  range = if (is.numeric(x)) "half" else "whole"
)

## S3 method for class 'pwelch'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  plot.type = c("spectrum", "cross-spectrum", "phase", "coherence", "transfer"),
  yscale = c("linear", "log", "dB"),
  ...
)

## S3 method for class 'pwelch'
print(
  x,
  plot.type = c("spectrum", "cross-spectrum", "phase", "coherence", "transfer"),
  yscale = c("linear", "log", "dB"),
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input data, specified as a numeric vector or matrix. In case of a
vector it represents a single signal; in case of a matrix each column is a
signal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(length(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detrend</code></td>
<td>
<p>character string specifying detrending option; one of:
</p>

<dl>
<dt><code>long-mean</code></dt>
<dd>
<p>remove the mean from the data before
splitting into segments (default)</p>
</dd>
<dt><code>short-mean</code></dt>
<dd>
<p>remove the mean value of each segment</p>
</dd>
<dt><code>long-linear</code></dt>
<dd>
<p>remove linear trend from the data before
splitting into segments</p>
</dd>
<dt><code>short-linear</code></dt>
<dd>
<p>remove linear trend from each segment</p>
</dd>
<dt><code>none</code></dt>
<dd>
<p>no detrending</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>character string. one of:
</p>

<dl>
<dt>
<code>"half"</code> or <code>"onesided"</code>
</dt>
<dd>
<p>frequency range of the spectrum
is from zero up to but not including <code>fs / 2</code>. Power from negative
frequencies is added to the positive side of the spectrum.</p>
</dd>
<dt>
<code>"whole"</code> or <code>"twosided"</code>
</dt>
<dd>
<p>frequency range of the spectrum
is <code>-fs / 2</code> to <code>fs / 2</code>, with negative frequencies stored in
"wrap around order" after the positive frequencies; e.g. frequencies for a
10-point <code>"twosided"</code> spectrum are 0 0.1 0.2 0.3 0.4 0.5 -0.4 -0.3
-0.2. -0.1.</p>
</dd>
<dt>
<code>"shift"</code> or <code>"centerdc"</code>
</dt>
<dd>
<p>same as <code>"whole"</code> but with
the first half of the spectrum swapped with second half to put the
zero-frequency value in the middle.</p>
</dd>
</dl>
<p>Default: If <code>x</code> are real, the default range is <code>"half"</code>,
otherwise the default range is <code>"whole"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab, main</code></td>
<td>
<p>labels passed to plotting function. Default: NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.type</code></td>
<td>
<p>character string specifying which plot to produce; one of
<code>"spectrum"</code>, <code>"cross-spectrum"</code>, <code>"phase"</code>,
<code>"coherence"</code>, <code>"transfer"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yscale</code></td>
<td>
<p>character string specifying scaling of Y-axis; one of
<code>"linear"</code>, <code>"log"</code>, <code>"dB"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Welch method [1] reduces the variance of the periodogram estimate to the
PSD by splitting the signal into (usually) overlapping segments and windowing
each segment, for instance by a Hamming window. The periodogram is then
computed for each segment, and the squared magnitude is computed, which is
then averaged for all segments. See also [2].
</p>
<p>The spectral density is the mean of the modified periodograms, scaled so that
area under the spectrum is the same as the mean square of the data.  This
equivalence is supposed to be exact, but in practice there is a mismatch of
up to 0.5
the data.
</p>
<p>In case of multivariate signals, Cross-spectral density, phase, and coherence
are also returned. The input data can be demeaned or detrended, overall or
for each segment separately.
</p>


<h3>Value</h3>

<p>An object of class <code>"pwelch"</code>, which is a list containing the
following elements:
</p>

<dl>
<dt><code>freq</code></dt>
<dd>
<p>vector of frequencies at which the spectral variables
are estimated. If <code>x</code> is numeric, power from negative frequencies is
added to the positive side of the spectrum, but not at zero or Nyquist
(fs/2) frequencies. This keeps power equal in time and spectral domains.
If <code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>spec</code></dt>
<dd>
<p>Vector (for univariate series) or matrix (for
multivariate series) of estimates of the spectral density at frequencies
corresponding to freq.</p>
</dd>
<dt><code>cross</code></dt>
<dd>
<p>NULL for univariate series. For multivariateseries, a
matrix containing the cross-spectral density estimates between different
series. Column <code class="reqn">i + (j - 1) * (j - 2)/2 </code> of contains the
cross-spectral estimates between columns <code class="reqn">i</code> and <code class="reqn">j</code> of <code class="reqn">x</code>,
where <code class="reqn">i &lt; j</code>.</p>
</dd>
<dt><code>phase</code></dt>
<dd>
<p>NULL for univariate series. For multivariate series,
a matrix containing the cross-spectrum phase between different series.
The format is the same as <code>cross</code>.</p>
</dd>
<dt><code>coh</code></dt>
<dd>
<p>NULL for univariate series. For multivariate series, a
matrix containing the squared coherence between different series. The
format is the same as <code>cross</code>.</p>
</dd>
<dt><code>trans</code></dt>
<dd>
<p>NULL for univariate series. For multivariate series,
a matrix containing estimates of the transfer function between different
series. The format is the same as <code>cross</code>.</p>
</dd>
<dt><code>x_len</code></dt>
<dd>
<p>The length of the input series.</p>
</dd>
<dt><code>seg_len</code></dt>
<dd>
<p>The length of each segment making up the averages.</p>
</dd>
<dt><code>psd_len</code></dt>
<dd>
<p>The number of frequencies. See <code>freq</code></p>
</dd>
<dt><code>nseries</code></dt>
<dd>
<p>The number of series</p>
</dd>
<dt><code>series</code></dt>
<dd>
<p>The name of the series</p>
</dd>
<dt><code>snames</code></dt>
<dd>
<p>For multivariate input, the names of the individual
series</p>
</dd>
<dt><code>window</code></dt>
<dd>
<p>The window used to compute the modified periodogram</p>
</dd>
<dt><code>fs</code></dt>
<dd>
<p>The sampling frequency</p>
</dd>
<dt><code>detrend</code></dt>
<dd>
<p>Character string specifying detrending option</p>
</dd>
</dl>
<h3>Note</h3>

<p>Unlike the 'Octave' function 'pwelch', the current implementation
does not compute confidence intervals because they can be inaccurate in
case of overlapping segments.
</p>


<h3>Author(s)</h3>

<p>Peter V. Lanspeary <a href="mailto:pvl@mecheng.adelaide.edu.au">pvl@mecheng.adelaide.edu.au</a>.<br>
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p>[1] Welch, P.D. (1967). The use of Fast Fourier Transform for
the estimation of power spectra: A method based on time averaging over
short, modified periodograms. IEEE Transactions on Audio and
Electroacoustics, AU-15 (2): 70–73.<br></p>
<p>[2] <a href="https://en.wikipedia.org/wiki/Welch%27s_method">https://en.wikipedia.org/wiki/Welch%27s_method</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">fs &lt;- 256
secs &lt;- 10
freq &lt;- 30
ampl &lt;- 1
t &lt;- seq(0, secs, length.out = fs * secs)

x &lt;- ampl * cos(freq * 2 * pi * t) + runif(length(t))
Pxx &lt;- pwelch(x, fs = fs)              # no plot
pwelch(x, fs = fs)                     # plot

# 90 degrees phase shift with with respect to x
y &lt;- ampl * sin(freq * 2 * pi * t) + runif(length(t))
Pxy &lt;- pwelch(cbind(x, y), fs = fs)
plot(Pxy, yscale = "dB")
plot(Pxy, plot.type = "phase")
# note the phase shift around 30 Hz is pi/2
plot(Pxy, plot.type = "coherence")

# Transfer function estimate example
fs &lt;- 1000                 # Sampling frequency
t &lt;- (0:fs) / fs           # One second worth of samples
A &lt;- c(1, 2)               # Sinusoid amplitudes
f &lt;- c(150, 140)           # Sinusoid frequencies
xn &lt;- A[1] * sin(2 * pi * f[1] * t) +
      A[2] * sin(2 * pi * f[2] * t) +  0.1 * runif(length(t))
h &lt;- Ma(rep(1L, 10) / 10)      # Moving average filter
yn &lt;- filter(h, xn)
atfm &lt;- freqz(h, fs = fs)
etfm &lt;- pwelch(cbind(xn, yn), fs = fs)
op &lt;- par(mfrow = c(2, 1))
xl &lt;- "Frequency (Hz)"; yl &lt;- "Magnitude"
plot(atfm$w, abs(atfm$h), type = "l", main = "Actual", xlab = xl, ylab = yl)
plot(etfm$freq, abs(etfm$trans), type = "l", main = "Estimated",
     xlab = xl, ylab = yl)
par(op)

</code></pre>


</div>