<div class="container">

<table style="width: 100%;"><tr>
<td>stat_pop_etho</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute and display a population aggregate for a variable of interest</h2>

<h3>Description</h3>

<p>This function displays the temporal (time on the x axis) trend of variable of interest,
on the y axis as a line with confidence interval as a shaded area.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_pop_etho(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = mean_se,
  method.args = list(),
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function used to compute the aggregate and  confidence intervals.
It should return (<code>y</code>, <code>ymin</code> and <code>ymax</code>).
The default is ggplot2::mean_se, which computes the mean + or - standard error.
ggplot2::mean_cl_boot can be used instead to generate bootstrap confidence interval instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>List of additional arguments passed on to the modelling
function defined by <code>method</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A ggplot layer.
</p>


<h3>References</h3>


<ul><li>
<p> The relevant <a href="https://rethomics.github.io/ggetho.html#population-plots">rethomic tutorial section</a>
</p>
</li></ul>
<h3>See Also</h3>


<ul>
<li> <p>ggetho to generate a plot object
</p>
</li>
<li> <p>stat_tile_etho to show variable of interest as colour intensity
</p>
</li>
<li> <p>stat_ld_annotations to show light and dark phases on the plot
</p>
</li>
<li> <p>ggplot2::stat_smooth to understand how to change the type of confidence interval, line colour and so forth
</p>
</li>
</ul>
<p>Other layers: 
<code>geom_peak()</code>,
<code>stat_bar_tile_etho()</code>,
<code>stat_ld_annotations()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(behavr)
metadata &lt;- data.frame(id = sprintf("toy_experiment | %02d", 1:4),
                   age=c(1, 5, 10, 20),
                   condition=c("A", "B"))
dt &lt;- toy_activity_data(metadata, 3)
# We build a plot object
pl &lt;-  ggetho(dt, aes(y = asleep))
# A standard plot of the whole population:
pl + stat_pop_etho()
# We can also split by condition, and display the two population on different facets:
pl + stat_pop_etho() + facet_grid(condition ~ .)
## Not run: 
# Instead, we can use different colour for separate conditions:
pl &lt;-  ggetho(dt, aes(y = asleep, colour = condition))
pl + stat_pop_etho()

# Sometimes, we also have numeric condition (e.g. age)
pl &lt;-  ggetho(dt, aes(y = asleep, colour = age))
pl + stat_pop_etho()
# We could want to aggregate several days of data to one circadian day (i.e. time wrapping)
# here, we also plot the invert of moving (!moving)
pl &lt;-  ggetho(dt, aes(y = !moving), time_wrap = hours(24))
pl + stat_pop_etho()

## End(Not run)
</code></pre>


</div>