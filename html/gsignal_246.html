<div class="container">

<table style="width: 100%;"><tr>
<td>sgolay</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Savitzky-Golay filter design</h2>

<h3>Description</h3>

<p>Compute the filter coefficients for all Savitzky-Golay FIR smoothing filters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sgolay(p, n, m = 0, ts = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Polynomial filter order; must be smaller than <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Filter length; must a an odd positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Return the m-th derivative of the filter coefficients. Default: 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ts</code></td>
<td>
<p>Scaling factor. Default: 1</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The early rows of the resulting filter smooth based on future values and
later rows smooth based on past values, with the middle row using half future
and half past.  In particular, you can use row <code>i</code> to estimate
<code>x(k)</code> based on the <code>i-1</code> preceding values and the <code>n-i</code>
following values of <code>x</code> values as <code>y(k) = F[i, ] *
x[(k - i + 1):(k + n -i)]</code>.
</p>
<p>Normally, you would apply the first <code>(n-1)/2</code> rows to the first <code>k</code>
points of the vector, the last <code>k</code> rows to the last <code>k</code> points of
the vector and middle row to the remainder, but for example if you were
running on a real-time system where you wanted to smooth based on the all the
data collected up to the current time, with a lag of five samples, you could
apply just the filter on row <code>n - 5</code> to your window of length <code>n</code>
each time you added a new sample.
</p>


<h3>Value</h3>

<p>An square matrix with dimensions <code>length(n)</code> that is of class
<code>"sgolayFilter"</code>, so it can be used with <code>filter</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Kienzle <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>,<br>
Pascal Dupuis, <a href="mailto:Pascal.Dupuis@esat.kuleuven.ac.be">Pascal.Dupuis@esat.kuleuven.ac.be</a>.<br>
Conversion to R Tom Short,<br>
adapted by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code>sgolayfilt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate a signal that consists of a 0.2 Hz sinusoid embedded
## in white Gaussian noise and sampled five times a second for 200 seconds.
dt &lt;- 1 / 5 
t &lt;- seq(0, 200 - dt, dt)
x &lt;- 5 * sin(2 * pi * 0.2 * t) + rnorm(length(t))
## Use sgolay to smooth the signal.
## Use 21-sample frames and fourth order polynomials.
p &lt;- 4
n &lt;- 21
sg &lt;- sgolay(p, n)
## Compute the steady-state portion of the signal by convolving it
## with the center row of b.
ycenter &lt;- conv(x, sg[(n + 1)/2, ], 'valid')
## Compute the transients. Use the last rows of b for the startup
## and the first rows of b for the terminal.
ybegin &lt;- sg[seq(nrow(sg), (n + 3) / 2, -1), ] %*% x[seq(n, 1, -1)]
yend &lt;- sg[seq((n - 1)/2, 1, -1), ] %*%
        x[seq(length(x), (length(x) - (n - 1)), -1)]
## Concatenate the transients and the steady-state portion to
## generate the complete smoothed signal.
## Plot the original signal and the Savitzky-Golay estimate.
y = c(ybegin, ycenter, yend)
plot(t, x, type = "l", xlab = "", ylab = "", ylim = c(-8, 10))
lines(t, y, col = 2)
legend("topright", c('Noisy Sinusoid','S-G smoothed sinusoid'),
  lty = 1, col = c(1,2))

</code></pre>


</div>