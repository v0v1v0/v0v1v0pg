<div class="container">

<table style="width: 100%;"><tr>
<td>gesso.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
gesso fit
</h2>

<h3>Description</h3>

<p>Fits gesso model over the two dimentional grid of hyperparmeters <code>lambda_1</code> and <code>lambda_2</code>, returns estimated coefficients for each pair of hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gesso.fit(G, E, Y, C = NULL, normalize = TRUE, normalize_response = FALSE,
          grid = NULL, grid_size = 20, grid_min_ratio = NULL, 
          alpha = NULL, family = "gaussian", weights = NULL,
          tolerance = 1e-3, max_iterations = 5000, 
          min_working_set_size = 100,
          verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>matrix of main effects of size <code>n x p</code>, variables organized by columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>vector of environmental measurments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>outcome vector. Set <code>family="gaussian"</code> for the continuous outcome and 
<code>family="binomial"</code> for the binary outcome with 0/1 levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>matrix of confounders of size <code>n x m</code>, variables organized by columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p><code>TRUE</code> to normalize matrix <code>G</code> and vector <code>E</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize_response</code></td>
<td>
<p><code>TRUE</code> to normalize vector <code>Y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>grid sequence for tuning hyperparameters, we use the same grid for <code>lambda_1</code> and <code>lambda_2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_size</code></td>
<td>
<p>specify <code>grid_size</code> to generate grid automatically. Grid is generated by calculating <code>max_lambda</code> from the data (smallest lambda such that all the coefficients are zero). <code>min_lambda</code> is calculated as a product of <code>max_lambda</code> and <code>grid_min_ratio</code>. The program then generates <code>grid_size</code> values equidistant on the log10 scale from <code>min_lambda</code> to <code>max_lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_min_ratio</code></td>
<td>
<p>parameter to determine <code>min_lambda</code> (smallest value for the grid of lambdas),
default is 0.1 for p &gt; n, 0.01 otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>if <code>NULL</code> independent 2D grid is used for (<code>lambda_1</code>, <code>lambda_2</code>), else 1D grid is used where <code>lambda_2</code> = <code>alpha</code> * <code>lambda_1</code>, i.e. (<code>lambda_1</code>, <code>alpha</code> * <code>lambda_1</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p><code>"gaussian"</code> for continuous outcome and <code>"binomial"</code> for binary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>tolerance for the dual gap convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iterations</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_working_set_size</code></td>
<td>
<p>minimum size of the working set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>inner fitting parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> to print messages</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of estimated coefficients and other model fit metrics for each pair of hyperparameters (<code>lambda_1</code>, <code>lambda_2</code>)
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta_0</code></td>
<td>
<p>vector of estimated intercept values of size <code>lambda_1</code>*<code>lambda_2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_e</code></td>
<td>
<p>vector of estimated environment coefficients of size <code>lambda_1</code>*<code>lambda_2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_g</code></td>
<td>
<p>matrix of estimated main effects coefficients organized by rows, size (<code>lambda_1</code>*<code>lambda_2</code>) by <code>p</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_gxe</code></td>
<td>
<p>matrix of estimated interactions coefficients organized by rows, size (<code>lambda_1</code>*<code>lambda_2</code>) by <code>p</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_c</code></td>
<td>
<p>matrix of estimated confounders coefficients organized by rows, size (<code>lambda_1</code>*<code>lambda_2</code>) by <code>m</code>, where <code>m</code> is the number of confounders</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_iterations</code></td>
<td>
<p>number of iterations until convergence for each fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>working_set_size</code></td>
<td>
<p>maximum number of variables in the working set for each fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>has_converged</code></td>
<td>
<p>1 if the model converged within given <code>max_iterations</code>, 0 otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective_value</code></td>
<td>
<p>objective function (loss) value for each fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_g_nonzero</code></td>
<td>
<p>number of estimated non-zero main effects for each fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_gxe_nonzero</code></td>
<td>
<p>number of estimated non-zero interactions for each fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_1</code></td>
<td>
<p><code>lambda_1</code> path values, decreasing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_2</code></td>
<td>
<p><code>lambda_2</code> path values, oscillating</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>vector of values used for hyperparameters tuning</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">data = data.gen()
fit = gesso.fit(G=data$G_train, E=data$E_train, Y=data$Y_train, normalize=TRUE)
plot(fit$beta_g_nonzero, pch=19, cex=0.4, 
     ylab="num of non-zero features", xlab="lambdas path")
points(fit$beta_gxe_nonzero, pch=19, cex=0.4, col="red")
</code></pre>


</div>