<div class="container">

<table style="width: 100%;"><tr>
<td>invfreq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inverse Frequency Response</h2>

<h3>Description</h3>

<p>Identify filter parameters from frequency response data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">invfreq(
  h,
  w,
  nb,
  na,
  wt = rep(1, length(w)),
  plane = c("z", "s"),
  method = c("ols", "tls", "qr"),
  norm = TRUE
)

invfreqs(
  h,
  w,
  nb,
  na,
  wt = rep(1, length(w)),
  method = c("ols", "tls", "qr"),
  norm = TRUE
)

invfreqz(
  h,
  w,
  nb,
  na,
  wt = rep(1, length(w)),
  method = c("ols", "tls", "qr"),
  norm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Frequency response, specified as a vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Angular frequencies at which <code>h</code> is computed, specified as a
vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb, na</code></td>
<td>
<p>Desired order of the numerator and denominator polynomials,
specified as positive integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>Weighting factors, specified as a vector of the same length as
<code>w</code>. Default: <code>rep(1, length(w))</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plane</code></td>
<td>
<p><code>"z"</code> (default) for discrete-time spectra; <code>"s"</code> for
continuous-time spectra</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>minimization method used to solve the normal equations, one of:
</p>

<dl>
<dt>"ols"</dt>
<dd>
<p>ordinary least squares (default)</p>
</dd>
<dt>"tls"</dt>
<dd>
<p>total least squares</p>
</dd>
<dt>"qr"</dt>
<dd>
<p>QR decomposition</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>logical indicating whether frequencies must be normalized to
avoid matrices with rank deficiency. Default: TRUE</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a desired (one-sided, complex) spectrum <code>h(w)</code> at equally spaced
angular frequencies <code class="reqn">w = (2 \pi k) / N</code>, k = 0, ... N-1, this function
finds the filter <code>B(z)/A(z)</code> or <code>B(s)/A(s)</code> with <code>nb</code> zeroes
and <code>na</code> poles. Optionally, the fit-errors can be weighted with respect
to frequency according to the weights <code>wt</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>'Arma'</code> with the following list elements:
</p>

<dl>
<dt>b</dt>
<dd>
<p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt>
<dd>
<p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Julius O. Smith III, Rolf Schirmacher, Andrew Fitting, Pascal
Dupuis.<br> Conversion to R by Geert van Boxtel,
<a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://ccrma.stanford.edu/~jos/filters/FFT_Based_Equation_Error_Method.html">https://ccrma.stanford.edu/~jos/filters/FFT_Based_Equation_Error_Method.html</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">order &lt;- 6  # order of test filter
fc &lt;- 1/2   # sampling rate / 4
n &lt;- 128    # frequency grid size
ba &lt;- butter(order, fc)
hw &lt;- freqz(ba, n)
BA = invfreq(hw$h, hw$w, order, order)
HW = freqz(BA, n)
plot(hw$w, abs(hw$h), type = "l", xlab = "Frequency (rad/sample)",
  ylab = "Magnitude")
lines(HW$w, abs(HW$h), col = "red")
legend("topright", legend = c("Original", "Measured"), lty  = 1, col = 1:2)
err &lt;- norm(hw$h - HW$h, type = "2")
title(paste('L2 norm of frequency response error =', err))

</code></pre>


</div>