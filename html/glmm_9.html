<div class="container">

<table style="width: 100%;"><tr>
<td>glmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Generalized Linear Mixed Models using MCML</h2>

<h3>Description</h3>

<p>This function fits generalized linear mixed models (GLMMs) by approximating the likelihood with ordinary Monte Carlo, then maximizing the approximated likelihood. </p>


<h3>Usage</h3>

<pre><code class="language-R">glmm(fixed, random, varcomps.names, data, family.glmm, m, 
varcomps.equal, weights=NULL, doPQL = TRUE,debug=FALSE, p1=1/3,p2=1/3, p3=1/3,
rmax=1000,iterlim=1000, par.init, zeta=5, cluster=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>an object of class "<code>formula</code>" (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under  "Details."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>an object of class "<code>formula</code>" (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under "Details."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcomps.names</code></td>
<td>
<p>The names of the distinct variance components in order of <code>varcomps.equal</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which <code>glmm</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family.glmm</code></td>
<td>
<p>The name of the family. Must be class <code>glmm.family</code>. Current options are <code>bernoulli.glmm</code>, <code>poisson.glmm</code>, and <code>binomial.glmm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The desired Monte Carlo sample size. See a note under "Details."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcomps.equal</code></td>
<td>
<p>An optional vector with elements 1 through the number of distinct variance components. Denotes variance components are to be set equal by assigning them the same integer. The length of varcomps.equal must be equal to the length of the list of random effects formulas. If omitted, varcomps.equal assumes no variance component should be set equal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector with length equal to the length of the response vector. This argument makes the specified observations more or less informative for the model. See a note under "Details."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doPQL</code></td>
<td>
<p>logical. If <code>TRUE</code>, PQL estimates are used in the importance sampling distribution. If FALSE, the importance sampling distribution will use 0 for the fixed effects and 1 for the variance components. For advanced users, since <code>glmm</code> is generally more efficient when <code>doPQL=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>logical. If <code>TRUE</code>, extra output useful for testing will be provided. For advanced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>A probability for mixing the random effects generated from three distributions. <code>p1</code> is the proportion of random effects from the first distribution specified in "Details." For advanced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p2</code></td>
<td>
<p>A probability for mixing the random effects generated from three distributions. <code>p2</code> is the proportion of random effects from the second distribution specified in "Details." For advanced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p3</code></td>
<td>
<p>A probability for mixing the random effects generated from three distributions. <code>p3</code> is the proportion of random effects from the third distribution specified in "Details." For advanced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmax</code></td>
<td>
<p>The maximum allowed trust region radius. This may be set very large. If set small, the algorithm traces a steepest ascent path. This is an argument for <code>trust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterlim</code></td>
<td>
<p>A positive integer specifying the maximum number of trust iterations to be performed before the trust program is terminated. This is an argument for <code>trust</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.init</code></td>
<td>
<p>An optional argument. A single vector that specifies the initial values of the fixed effects and variance components. The parameters should be inputted in the order that <code>summary.glmm</code> outputs them, with fixed effects followed by variance components. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta</code></td>
<td>
<p>A scalar that specifies the degrees of freedom for the t-distribution from which random effects are generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>An optional argument. A cluster created by the user to enable computations to be done in parallel. See "Details" for more information on the default value.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">\beta</code> be a vector of fixed effects and let <code class="reqn">u</code> be a vector of random effects. Let <code class="reqn">X</code> and <code class="reqn">Z</code> be design matrices for the fixed and random effects, respectively. The random effects are assumed to be normally distributed with mean 0 and variance matrix <code class="reqn">D</code>, where <code class="reqn">D</code> is diagonal with entries from the unknown vector <code class="reqn">\nu</code>. Letting <code class="reqn">g</code> be the link function, <code class="reqn">g(\mu)=X \beta+ZU</code>. If the response type is Bernoulli or Binomial, then the logit function is the link; if the response type is Poisson, then the natural logarithm is the link function.
</p>
<p>Models for glmm are specified symbolically. A typical fixed effects model has the form <code>response ~ terms</code> where <code>response</code> is the (numeric) response vector and <code>terms</code> is a series of terms which specifies a linear predictor for response. A terms specification of the form <code>first + second</code> indicates all the terms in <code>first</code> together with all the terms in <code>second</code> with duplicates removed. 
</p>
<p>A specification of the form <code>first:second</code> indicates the set of terms obtained by taking the interactions of all terms in <code>first</code> with all terms in <code>second</code>. The specification <code>first*second</code> indicates the cross of <code>first</code> and <code>second</code>. This is the same as <code>first + second + first:second</code>.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this, pass a <code>terms</code> object as the formula. 
</p>
<p>If you choose <code>binomial.glmm</code> as the <code>family.glmm</code>, then your response should be a two-column matrix: the first column reports the number of successes and the second reports the number of failures.
</p>
<p>The random effects for glmm are also specified symbolically. The random effects model specification is typically a list. Each element of the <code>random</code> list has the form <code>response ~ 0 + term</code>. The 0 centers the random effects at 0. If you want your random effects to have a nonzero mean, then include that term in the fixed effects.  Each variance component must have its own formula in the list.
</p>
<p>To set some variance components equal to one another, use the <code>varcomps.equal</code> argument. The argument <code>varcomps.equal</code> should be a vector whose length is equal to the length of the random effects list. The vector should contain positive integers, and the first element of the <code>varcomps.equal</code> should be 1. To set variance components equal to one another, assign the same integer to the corresponding elements of <code>varcomps.equal</code>. For example, to set the first and second variance components equal to each other, the first two elements of <code>varcomps.equal</code> should be 1. If <code>varcomps.equal</code> is omitted, then the variance components are assumed to be distinct. 
</p>
<p>Each distinct variance component should have a name. The length of <code>varcomps.names</code> should be equal to the number of distinct variance components. If <code>varcomps.equal</code> is omitted, then the length of <code>varcomps.names</code> should be equal to the length of <code>random</code>.
</p>
<p>The package uses a relevance-weighted log density weighting scheme, similar to that described in Hu and Zidek (1997). This means that the <code>weights</code> argument functions in the following manner: a model built for a data set with three observations (obs. 1, obs. 2, obs. 3) and weighting scheme 1, 1, 2 gives the same results as the model built for a data set with four observations (obs. 1, obs. 2, obs. 3, obs. 3 - the last two observations are identical) and weighting scheme 1, 1, 1, 1.
</p>
<p>Monte Carlo likelihood approximation relies on an importance sampling distribution. Though infinitely many importance sampling distributions should yield the correct MCMLEs eventually, the importance sampling distribution used in this package was chosen to reduce the computation cost. When <code>doPQL</code> is <code>TRUE</code>, the importance sampling distribution relies on PQL estimates (as calculated in this package). When <code>doPQL</code> is <code>FALSE</code>, the random effect estimates in the distribution are taken to be 0, the fixed effect estimates are taken to be 0, and the variance component estimates are taken to be 1.
</p>
<p>This package's importance sampling distribution is a mixture of three distributions: a t centered at 0 with scale matrix determined by the PQL estimates of the variance components and with <code>zeta</code> degrees of freedom, a normal distribution centered at the PQL estimates of the random effects and with a variance matrix containing the PQL estimates of the variance components, and a normal distribution centered at the PQL estimates of the random effects and with a variance matrix based on the Hessian of the penalized log likelihood. The first component is included to guarantee the gradient of the MCLA has a central limit theorem. The second component is included to mirror our best guess of the distribution of the random effects. The third component is included so that the numerator and the denominator are similar when calculating the MCLA value.
</p>
<p>The Monte Carlo sample size <code>m</code> should be chosen as large as possible. You may want to run the model a couple times to begin to understand the variability inherent to Monte Carlo. There are no hard and fast rules for choosing <code>m</code>, and more research is needed on this area. For a general idea, I believe the <code>BoothHobert</code> model produces stable enough estimates at <code class="reqn">m=10^3</code> and the <code>salamander</code> model produces stable enough estimates at <code class="reqn">m=10^5</code>, as long as <code>doPQL</code> is <code>TRUE</code>.
</p>
<p>To decrease the computation time involved with larger Monte Carlo sample sizes, a parallel computing component has been added to this package. Generally, the larger the Monte Carlo sample size <code>m</code>, the greater the benefit of utilizing additional cores. By default, <code>glmm</code> will create a cluster that uses a single core. This forces all computations to be done sequentially rather than simultaneously. 
</p>
<p>To see the summary of the model, use summary().
</p>


<h3>Value</h3>

<p><code>glmm</code> returns an object of class <code>glmm</code> is a list containing at least the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta </code></td>
<td>
<p>A vector of the Monte Carlo maximum likelihood estimates (MCMLEs) for the fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu </code></td>
<td>
<p>A vector of the Monte Carlo maximum likelihood estimates for the variance components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike.value</code></td>
<td>
<p>The Monte Carlo log likelihood evaluated at the MCMLEs <code>beta</code> and <code>nu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike.gradient</code></td>
<td>
<p>The Monte Carlo log likelihood gradient vector at the MCMLEs <code>beta</code> and <code>nu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike.hessian</code></td>
<td>
<p>The Monte Carlo log likelihood Hessian matrix at the MCMLEs <code>beta</code> and <code>nu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.mcml</code></td>
<td>
<p>A list containing the weighted (if applicable) fixed effect design matrix, the list of weighted (if applicable) random effect design matrices, the weighted (if applicable) response, and the number of trials (for the Binomial family).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixedcall</code></td>
<td>
<p>The fixed effects call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randcall</code></td>
<td>
<p>The random effects call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The unweighted design matrix for the fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The unweighted response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>The unweighted design matrix for the random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The weights vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family.glmm</code></td>
<td>
<p>The name of the family. Must be class <code>glmm.family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcomps.names</code></td>
<td>
<p>The vector of names for the distinct variance components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varcomps.equal</code></td>
<td>
<p>The vector denoting equal variance components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>umat</code></td>
<td>
<p>A matrix with <code>m</code> rows. Each row is a vector of random effects generated from the importance sampling distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvec</code></td>
<td>
<p>A vector containing <code>p1</code>, <code>p2</code>, and <code>p3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.pql</code></td>
<td>
<p>PQL estimate of <code class="reqn">\beta</code>, when <code>doPQL</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.pql</code></td>
<td>
<p>PQL estimate of <code class="reqn">\nu</code>, when <code>doPQL</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u.pql</code></td>
<td>
<p>PQL predictions of the random effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zeta</code></td>
<td>
<p>The number of degrees of freedom used in the t component of the importance sampling distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>A cluster created by the user for use during the approximation of the log-likelihood value, gradient and hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>If <code>TRUE</code> extra output useful for testing.</p>
</td>
</tr>
</table>
<p>The function <code>summary</code> (i.e., <code>summary.glmm</code>) can
be used to obtain or print a summary of the results. The generic accessor function <code>coef</code> (i.e., <code>coef.glmm</code>) can be used to extract the coefficients.
</p>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>References</h3>

<p>Geyer, C. J. (1994)  On the convergence of Monte Carlo maximum likelihood calculations.  <em>Journal of the Royal Statistical Society, Series B</em>, <b>61</b>, 261–274.
<a href="https://doi.org/10.1111/j.2517-6161.1994.tb01976.x">doi:10.1111/j.2517-6161.1994.tb01976.x</a>.
</p>
<p>Geyer, C. J. and Thompson, E. (1992)  Constrained Monte Carlo maximum likelihood for dependent data.  <em>Journal of the Royal Statistical Society, Series B</em>, <b>54</b>, 657–699.
<a href="https://doi.org/10.1111/j.2517-6161.1992.tb01443.x">doi:10.1111/j.2517-6161.1992.tb01443.x</a>.
</p>
<p>Knudson, C. (2016). Monte Carlo likelihood approximation for generalized linear mixed models. PhD thesis, University of Minnesota.  <a href="http://hdl.handle.net/11299/178948">http://hdl.handle.net/11299/178948</a>
</p>
<p>Knudson, C., Benson, S., Geyer, J., Jones, G. (2021) Likelihood-based inference for generalized linear mixed models: Inference with the R package glmm. <em>Stat</em>, 10:e339. <a href="https://doi.org/10.1002/sta4.339">doi:10.1002/sta4.339</a>.
</p>
<p>Sung, Y. J. and Geyer, C. J. (2007)  Monte Carlo likelihood inference for missing data models.  <em>Annals of Statistics</em>, <b>35</b>, 990–1011.
<a href="https://doi.org/10.1214/009053606000001389">doi:10.1214/009053606000001389</a>.
</p>
<p>Hu, F. and Zidek, J. V. (2001) The relevance weighted likelihood with
applications. In: Ahmed, S. E. and Reid N. (eds).
<em>Empirical Bayes and Likelihood Inference</em>.
Lecture Notes in Statistics, <b>148</b>, 211–235. Springer, New York.
<a href="https://doi.org/10.1007/978-1-4613-0141-7_13">doi:10.1007/978-1-4613-0141-7_13</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#First, using the basic Booth and Hobert dataset
#to fit a glmm with a logistic link, one variance component,
#one fixed effect, and an intercept of 0. The Monte Carlo
#sample size is 100 to save time.
library(glmm)
data(BoothHobert)
set.seed(1234)
mod.mcml1 &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)
mod.mcml1$beta
mod.mcml1$nu
summary(mod.mcml1)
coef(mod.mcml1)

# This next example has crossed random effects but we assume
# all random effects have the same variance. The Monte Carlo
#sample size is 100 to save time.
#data(salamander)
#set.seed(1234)
#onenu &lt;- glmm(Mate~Cross, random=list(~0+Female,~0+Male), 
#varcomps.names=c("only"), varcomps.equal=c(1,1), data=salamander, 
#family.glmm=bernoulli.glmm, m=100, debug=TRUE, doPQL=TRUE)
#summary(onenu)

</code></pre>


</div>