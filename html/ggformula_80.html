<div class="container">

<table style="width: 100%;"><tr>
<td>gf_linerange</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Formula interface to geom_linerange() and geom_pointrange()</h2>

<h3>Description</h3>

<p>Various ways of representing a vertical interval defined by <code>x</code>,
<code>ymin</code> and <code>ymax</code>. Each case draws a single graphical object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gf_linerange(
  object = NULL,
  gformula = NULL,
  data = NULL,
  ...,
  alpha,
  color,
  group,
  linetype,
  linewidth,
  xlab,
  ylab,
  title,
  subtitle,
  caption,
  geom = "linerange",
  stat = "identity",
  position = "identity",
  show.legend = NA,
  show.help = NULL,
  inherit = TRUE,
  environment = parent.frame()
)

gf_pointrange(
  object = NULL,
  gformula = NULL,
  data = NULL,
  ...,
  alpha,
  color,
  group,
  linetype,
  linewidth,
  size,
  fatten = 2,
  xlab,
  ylab,
  title,
  subtitle,
  caption,
  geom = "pointrange",
  stat = "identity",
  position = "identity",
  show.legend = NA,
  show.help = NULL,
  inherit = TRUE,
  environment = parent.frame()
)

gf_summary(
  object = NULL,
  gformula = NULL,
  data = NULL,
  ...,
  alpha,
  color,
  group,
  linetype,
  linewidth,
  size,
  fun.y = NULL,
  fun.ymax = NULL,
  fun.ymin = NULL,
  fun.args = list(),
  fatten = 2,
  xlab,
  ylab,
  title,
  subtitle,
  caption,
  geom = "pointrange",
  stat = "summary",
  position = "identity",
  show.legend = NA,
  show.help = NULL,
  inherit = TRUE,
  environment = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>When chaining, this holds an object produced in the earlier portions
of the chain.  Most users can safely ignore this argument.
See details and examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gformula</code></td>
<td>
<p>A formula with shape <code>ymin + ymax ~ x</code>.
Faceting can be achieved by including <code>|</code> in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments.  Typically these are
(a) ggplot2 aesthetics to be set with <code>attribute = value</code>,
(b) ggplot2 aesthetics to be mapped with <code>attribute = ~ expression</code>, or
(c) attributes of the layer as a whole, which are set with <code>attribute = value</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Opacity (0 = invisible, 1 = opaque).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>A color or a formula used for mapping color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Used for grouping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linetype</code></td>
<td>
<p>A linetype (numeric or "dashed", "dotted", etc.) or a formula used
for mapping linetype.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linewidth</code></td>
<td>
<p>A numerical line width or a formula used for mapping linewidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Label for x-axis. See also <code>gf_labs()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Label for y-axis. See also <code>gf_labs()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title, subtitle, caption</code></td>
<td>
<p>Title, sub-title, and caption for the plot.
See also <code>gf_labs()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.help</code></td>
<td>
<p>If <code>TRUE</code>, display some minimal help.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit</code></td>
<td>
<p>A logical indicating whether default attributes are inherited.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>environment</code></td>
<td>
<p>An environment in which to look for variables not found in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>size aesthetic for points (<code>gf_pointrange()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fatten</code></td>
<td>
<p>A multiplicative factor used to increase the size of the
middle bar in <code>geom_crossbar()</code> and the middle point in
<code>geom_pointrange()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.ymin, fun.y, fun.ymax</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Use the
versions specified above instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun.args</code></td>
<td>
<p>Optional additional arguments passed on to the functions.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>ggplot2::geom_linerange()</code>
</p>
<p><code>ggplot2::geom_pointrange()</code>
</p>
<p><code>ggplot2::geom_pointrange()</code>, <code>ggplot2::stat_summary()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">gf_linerange()

gf_ribbon(low_temp + high_temp ~ date,
  data = mosaicData::Weather,
  fill = ~city, alpha = 0.4
) |&gt;
  gf_theme(theme = theme_minimal())
gf_linerange(
  low_temp + high_temp ~ date | city ~ .,
  data = mosaicData::Weather,
  color = ~ ((low_temp + high_temp) / 2)
) |&gt;
  gf_refine(scale_colour_gradientn(colors = rev(rainbow(5)))) |&gt;
  gf_labs(color = "mid-temp")

gf_ribbon(low_temp + high_temp ~ date | city ~ ., data = mosaicData::Weather)

# Chaining in the data
mosaicData::Weather |&gt;
  gf_ribbon(low_temp + high_temp ~ date, alpha = 0.4) |&gt;
  gf_facet_grid(city ~ .)
if (require(mosaicData) &amp;&amp; require(dplyr)) {
  HELP2 &lt;- HELPrct |&gt;
    group_by(substance, sex) |&gt;
    summarise(
      age = NA,
      mean.age = mean(age),
      median.age = median(age),
      max.age = max(age),
      min.age = min(age),
      sd.age = sd(age),
      lo = mean.age - sd.age,
      hi = mean.age + sd.age
    )

  gf_jitter(age ~ substance, data = HELPrct,
      alpha = 0.5, width = 0.2, height = 0, color = "skyblue") |&gt;
    gf_pointrange(mean.age + lo + hi ~ substance, data = HELP2) |&gt;
    gf_facet_grid(~sex)

  gf_jitter(age ~ substance, data = HELPrct,
    alpha = 0.5, width = 0.2, height = 0, color = "skyblue") |&gt;
    gf_errorbar(lo + hi ~ substance, data = HELP2, inherit = FALSE) |&gt;
    gf_facet_grid(~sex)

  # width is defined differently for gf_boxplot() and gf_jitter()
  #   * for gf_boxplot() it is the full width of the box.
  #   * for gf_jitter() it is half that -- the maximum amount added or subtracted.
  gf_boxplot(age ~ substance, data = HELPrct, width = 0.4) |&gt;
    gf_jitter(width = 0.4, height = 0, color = "skyblue", alpha = 0.5)

  gf_boxplot(age ~ substance, data = HELPrct, width = 0.4) |&gt;
    gf_jitter(width = 0.2, height = 0, color = "skyblue", alpha = 0.5)
}
p &lt;- gf_jitter(mpg ~ cyl, data = mtcars, height = 0, width = 0.15); p
p |&gt; gf_summary(fun.data = "mean_cl_boot", color = "red", size = 2, linewidth = 1.3)
# You can supply individual functions to summarise the value at
# each x:
p |&gt; gf_summary(fun.y = "median", color = "red", size = 3, geom = "point")
p |&gt;
  gf_summary(fun.y = "mean", color = "red", size = 3, geom = "point") |&gt;
  gf_summary(fun.y = mean, geom = "line")
p |&gt;
  gf_summary(fun.y = mean, fun.ymin = min, fun.ymax = max, color = "red")
## Not run: 
  p |&gt;
  gf_summary(fun.ymin = min, fun.ymax = max, color = "red", geom = "linerange")

## End(Not run)

gf_bar(~ cut, data = diamonds)
gf_col(price ~ cut, data = diamonds, stat = "summary_bin", fun.y = "mean")

# Don't use gf_lims() to zoom into a summary plot - this throws the
# data away
p &lt;- gf_summary(mpg ~ cyl, data = mtcars, fun.y = "mean", geom = "point")
p
p |&gt; gf_lims(y = c(15, 30))
# Instead use coord_cartesian()
p |&gt; gf_refine(coord_cartesian(ylim = c(15, 30)))
# A set of useful summary functions is provided from the Hmisc package.
## Not run: 
p &lt;- gf_jitter(mpg ~ cyl, data = mtcars, width = 0.15, height = 0); p
p |&gt; gf_summary(fun.data = mean_cl_boot, color = "red")
p |&gt; gf_summary(fun.data = mean_cl_boot, color = "red", geom = "crossbar")
p |&gt; gf_summary(fun.data = mean_sdl, group = ~ cyl, color = "red",
                   geom = "crossbar", width = 0.3)
p |&gt; gf_summary(group = ~ cyl, color = "red", geom = "crossbar", width = 0.3,
        fun.data = mean_sdl, fun.args = list(mult = 1))
p |&gt; gf_summary(fun.data = median_hilow, group = ~ cyl, color = "red",
        geom = "crossbar", width = 0.3)

## End(Not run)

# An example with highly skewed distributions:
if (require("ggplot2movies")) {
  set.seed(596)
  Mov &lt;- movies[sample(nrow(movies), 1000), ]
  m2 &lt;- gf_jitter(votes ~ factor(round(rating)), data = Mov, width = 0.15, height = 0, alpha = 0.3)
  m2 &lt;- m2 |&gt;
    gf_summary(fun.data = "mean_cl_boot", geom = "crossbar",
               colour = "red", width = 0.3) |&gt;
    gf_labs(x = "rating")
  m2
  # Notice how the overplotting skews off visual perception of the mean
  # supplementing the raw data with summary statistics is _very_ important

  # Next, we'll look at votes on a log scale.

  # Transforming the scale means the data are transformed
  # first, after which statistics are computed:
  m2 |&gt; gf_refine(scale_y_log10())
  # Transforming the coordinate system occurs after the
  # statistic has been computed. This means we're calculating the summary on the raw data
  # and stretching the geoms onto the log scale.  Compare the widths of the
  # standard errors.
  m2 |&gt; gf_refine(coord_trans(y="log10"))
}
</code></pre>


</div>