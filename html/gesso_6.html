<div class="container">

<table style="width: 100%;"><tr>
<td>gesso.cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cross-Validation
</h2>

<h3>Description</h3>

<p>Performs <code>nfolds</code>-fold cross-validation to tune hyperparmeters <code>lambda_1</code> and <code>lambda_2</code> for the gesso model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gesso.cv(G, E, Y, C = NULL, normalize = TRUE, normalize_response = FALSE, grid = NULL,
         grid_size = 20, grid_min_ratio = NULL, alpha = NULL, family = "gaussian", 
         type_measure = "loss", fold_ids = NULL, nfolds = 4, 
         parallel = TRUE, seed = 42, tolerance = 1e-3, max_iterations = 5000, 
         min_working_set_size = 100, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>matrix of main effects of size <code>n x p</code>, variables organized by columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>vector of environmental measurments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>outcome vector. Set <code>family="gaussian"</code> for the continuous outcome and 
<code>family="binomial"</code> for the binary outcome with 0/1 levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>matrix of confounders of size <code>n x m</code>, variables organized by columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p><code>TRUE</code> to normalize matrix <code>G</code> and vector <code>E</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize_response</code></td>
<td>
<p><code>TRUE</code> to normalize vector <code>Y</code> (for <code>family="gaussian"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>grid sequence for tuning hyperparameters, we use the same grid for <code>lambda_1</code> and <code>lambda_2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_size</code></td>
<td>
<p>specify <code>grid_size</code> to generate grid automatically. Grid is generated by calculating <code>max_lambda</code> from the data (smallest lambda such that all the coefficients are zero). <code>min_lambda</code> is calculated as a product of <code>max_lambda</code> and <code>grid_min_ratio</code>. The program then generates <code>grid_size</code> values equidistant on the log10 scale from <code>min_lambda</code> to <code>max_lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_min_ratio</code></td>
<td>
<p>parameter to determine <code>min_lambda</code> (smallest value for the grid of lambdas),
default is 0.1 for p &gt; n, 0.01 otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>if <code>NULL</code> independent 2D grid is used for (<code>lambda_1</code>, <code>lambda_2</code>), else 1D grid is used where <code>lambda_2</code> = <code>alpha</code> * <code>lambda_1</code>, i.e. (<code>lambda_1</code>, <code>alpha</code> * <code>lambda_1</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p><code>"gaussian"</code> for continuous outcome and <code>"binomial"</code> for binary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_measure</code></td>
<td>
<p>loss to use for cross-validation. Specity <code>type_measure="loss"</code> for neative log likelihood or <code>type_measure="auc"</code> for AUC (for <code>family="binomial"</code> only) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold_ids</code></td>
<td>
<p>option to input custom folds assignments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>tolerance for the dual gap convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iterations</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_working_set_size</code></td>
<td>
<p>minimum size of the working set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of cross-validation splits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p><code>TRUE</code> to enable parallel cross-validation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>set random seed to control random folds assignments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> to print messages</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of objects
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cv_result</code></td>
<td>
<p>a tibble with cross-validation results: averaged across folds loss and the number of non-zero coefficients for each value of (<code>lambda_1</code>, <code>lambda_2</code>) path. Could be used for custom parameters tuning (ex: select (<code>lambda_1</code>, <code>lambda_2</code>) with a sertain number of non-zero main effects and/or a sertain number of interactions).
</p>

<ul>
<li>
<p><code>mean_loss  </code>averaged across folds loss value, vector of size <code>lambda_1</code>*<code>lambda_2</code>
</p>
</li>
<li>
<p><code>mean_beta_g_nonzero  </code>averaged across folds number of non-zero main effects, vector of size <code>lambda_1</code>*<code>lambda_2</code>
</p>
</li>
<li>
<p><code>mean_beta_gxe_nonzero  </code>  averaged across folds number of non-zero interactions, vector of size <code>lambda_1</code>*<code>lambda_2</code>
</p>
</li>
<li>
<p><code>lambda_1  </code><code>lambda_1</code> pass, decreasing
</p>
</li>
<li>
<p><code>lambda_2  </code><code>lambda_2</code> pass, oscillating
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_min</code></td>
<td>
<p>a tibble of optimal (<code>lambda_1</code>, <code>lambda_2</code>) values, tuning parameter values that give minimum cross-validation loss (<code>mean_loss</code>)</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>list, return of the function gesso.fit on the full data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>vector of values used for hyperparameters tuning</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full_cv_result</code></td>
<td>
<p>inner variables</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">data = data.gen()
tune_model = gesso.cv(data$G_train, data$E_train, data$Y_train, 
                      grid_size=20, parallel=TRUE, nfolds=3)
gxe_coefficients = gesso.coef(tune_model$fit, tune_model$lambda_min)$beta_gxe        
g_coefficients = gesso.coef(tune_model$fit, tune_model$lambda_min)$beta_g          
</code></pre>


</div>