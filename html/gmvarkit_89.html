<div class="container">

<table style="width: 100%;"><tr>
<td>plot.qrtest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quantile residual tests</h2>

<h3>Description</h3>

<p><code>quantile_residual_tests</code> performs quantile residual tests described
by <em>Kalliovirta and Saikkonen 2010</em>, testing autocorrelation, conditional heteroskedasticity,
and normality.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'qrtest'
plot(x, ...)

## S3 method for class 'qrtest'
print(x, ..., digits = 3)

quantile_residual_tests(
  gsmvar,
  lags_ac = c(1, 3, 6, 12),
  lags_ch = lags_ac,
  nsim = 1,
  ncores = 1,
  print_res = TRUE,
  stat_tol,
  posdef_tol,
  df_tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>'qrtest'</code> generated by the function <code>quantile_residual_tests)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of decimals to print</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags_ac</code></td>
<td>
<p>a positive integer vector specifying the lags used to test autocorrelation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lags_ch</code></td>
<td>
<p>a positive integer vector specifying the lags used to test conditional heteroskedasticity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>to how many simulations should the covariance matrix Omega used in the qr-tests be based on?
If smaller than sample size, then the covariance matrix will be evaluated from the sample. Larger number
of simulations might improve the tests size properties but it increases the computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number of CPU cores to be used in numerical differentiation. Multiple cores
are not supported on Windows, though.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_res</code></td>
<td>
<p>should the test results be printed while computing the tests?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the "bold A" matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the function fails to calculate the tests because of numerical problems and the parameter values
are near the border of the parameter space, it might help to use smaller numerical tolerance for the
stationarity and positeve definiteness conditions. The numerical tolerance of an existing model
can be changed with the function <code>update_numtols</code> or you can set it directly with the arguments
<code>stat_tol</code> and <code>posdef_tol</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'qrtest'</code> which has its own print method. The returned object
is a list containing the quantile residual test results for normality, autocorrelation, and conditional
heteroskedasticity. The autocorrelation and conditional heteroskedasticity results also contain the
associated (vectorized) individual statistics divided by their standard errors
(see <em>Kalliovirta and Saikkonen 2010</em>, s.17-20) under the label <code>$ind_stats</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(qrtest)</code>: Plot p-values of the autocorrelation and conditional
heteroskedasticity tests.
</p>
</li>
<li> <p><code>print(qrtest)</code>: Print method for class 'qrtest'
</p>
</li>
</ul>
<h3>References</h3>


<ul>
<li>
<p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li>
<p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li>
<p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li>
<p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>fitGSMVAR</code>, <code>GSMVAR</code>, <code>quantile_residuals</code>, <code>GIRF</code>,
<code>diagnostic_plot</code>, <code>predict.gsmvar</code>, <code>profile_logliks</code>,
<code>LR_test</code>, <code>Wald_test</code>, <code>cond_moment_plot</code>, <code>update_numtols</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# GMVAR(3,2) model
fit32 &lt;- fitGSMVAR(gdpdef, p=3, M=2, ncalls=1, seeds=2)
qrtests32 &lt;- quantile_residual_tests(fit32)
qrtests32
plot(qrtests32)

# Structural GMVAR(1,2) model identified with sign
# constraints and build with hand-specified parameter values.
# Tests based on simulation procedure with nsim=1000:
params12s &lt;- c(0.55, 0.112, 0.619, 0.173, 0.344, 0.055, -0.009, 0.718,
 0.255, 0.017, -0.136, 0.858, 0.541, 0.057, -0.162, 0.162, 3.623,
 4.726, 0.674)
W_12 &lt;- matrix(c(1, 1, -1, 1), nrow=2)
mod12s &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12s,
                structural_pars=list(W=W_12))
qrtests12s &lt;- quantile_residual_tests(mod12s, nsim=1000)
qrtests12s

</code></pre>


</div>