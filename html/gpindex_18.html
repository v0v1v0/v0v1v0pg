<div class="container">

<table style="width: 100%;"><tr>
<td>geks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GEKS index</h2>

<h3>Description</h3>

<p>Calculate a generalized inter-temporal GEKS price index over a rolling
window.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geks(f, r = 0)

tornqvist_geks(
  p,
  q,
  period,
  product,
  window = nlevels(period),
  n = window - 1L,
  na.rm = FALSE
)

fisher_geks(
  p,
  q,
  period,
  product,
  window = nlevels(period),
  n = window - 1L,
  na.rm = FALSE
)

walsh_geks(
  p,
  q,
  period,
  product,
  window = nlevels(period),
  n = window - 1L,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A price index function that uses information on
both base and current-period prices and quantities, and satisfies the
time-reversal test. Usually a Törnqvist, Fisher, or Walsh index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A finite number giving the order of the generalized mean used to
average price indexes over the rolling window. The default uses a
geometric mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>A numeric vector of prices, the same length as <code>q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>A numeric vector of quantities, the same length as <code>p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the corresponding time period for each element in <code>p</code> and
<code>q</code>. The ordering of time periods follows the levels of <code>period</code>
to agree with <code>cut()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>product</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the corresponding product identifier for each element in <code>p</code> and
<code>q</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>A positive integer giving the length of the rolling window.
The default is a window that encompasses all periods in <code>period</code>.
Non-integers are truncated towards zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>A positive integer giving the length of the index series for each
window, starting from the end of the window. For example, if there are 13
periods in <code>window</code>, setting <code>n = 1</code> gives the index for period 13. The
default gives an index for each period in <code>window</code>. Non-integers are
truncated towards zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Passed to <code>f</code> to control if missing values are removed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>geks()</code> returns a function:
</p>
<pre>function(p, q, period, product, window = nlevels(period), n =
         window - 1, na.rm = FALSE){...}</pre>
<p>This calculates a period-over-period GEKS index with the desired
index-number formula, returning a list for each window with a named-numeric
vector of index values.
</p>
<p><code>tornqvist_geks()</code>, <code>fisher_geks()</code>, and <code>walsh_geks()</code> each return a list
with a named numeric vector giving the value of the respective
period-over-period GEKS index for each window.
</p>


<h3>Note</h3>

<p>Like <code>back_period()</code>, if multiple prices
correspond to a period-product pair, then the back price at a point in time
is always the first price for that product in the previous period. Unlike a
bilateral index, however, duplicated period-product pairs can have more
subtle implications for a multilateral index.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>IMF, ILO, Eurostat, UNECE, OECD, and World Bank. (2020).
<em>Consumer Price Index Manual: Concepts and Methods</em>.
International Monetary Fund.
</p>
<p>Ivancic, L., Diewert, W. E., and Fox, K. J. (2011). Scanner data, time
aggregation and the construction of price indexes.
<em>Journal of Econometrics</em>, 161(1): 24–35.
</p>


<h3>See Also</h3>

<p><code>GEKSIndex()</code> in the <span class="pkg">indexNumR</span> package for an implementation of the
GEKS index with more options.
</p>
<p>Other price index functions: 
<code>index_weights()</code>,
<code>price_indexes</code>,
<code>splice_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">price &lt;- 1:10
quantity &lt;- 10:1
period &lt;- rep(1:5, 2)
product &lt;- rep(letters[1:2], each = 5)

cumprod(tornqvist_geks(price, quantity, period, product)[[1]])

# Calculate the index over a rolling window

(tg &lt;- tornqvist_geks(price, quantity, period, product, window = 3))

# Use a movement splice to combine the indexes in each window

splice_index(tg, 2)

# ... or use a mean splice

splice_index(tg)

#---- Missing data ----

quantity[2] &lt;- NA

# Use all non-missing data

fisher_geks(price, quantity, period, product, na.rm = TRUE)

# Remove records with any missing data

fg &lt;- geks(balanced(fisher_index))
fg(price, quantity, period, product, na.rm = TRUE)

#---- Make a Jevons GEKS index ----

jevons_geks &lt;- geks(\(p1, p0, ..., na.rm) jevons_index(p1, p0, na.rm))
jevons_geks(price, quantity, period, product)

</code></pre>


</div>