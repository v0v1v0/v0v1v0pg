<div class="container">

<table style="width: 100%;"><tr>
<td>glmnet.model.matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model matrix options for glmnet</h2>

<h3>Description</h3>

<p>This page describes the options available for generating the model matrix.
</p>


<h3>Details</h3>

<p>There are two ways in which glmnetUtils can generate a model matrix out of a formula and data frame. The first is to use the standard R machinery comprising model.frameand model.matrix; and the second is to build the matrix one variable at a time. These options are discussed and contrasted below.
</p>


<h3>Using <code>model.frame</code>
</h3>

<p>This is the simpler option, and the one that is most compatible with other R modelling functions. The <code>model.frame</code> function takes a formula and data frame and returns a <em>model frame</em>: a data frame with special information attached that lets R make sense of the terms in the formula. For example, if a formula includes an interaction term, the model frame will specify which columns in the data relate to the interaction, and how they should be treated. Similarly, if the formula includes expressions like <code>exp(x)</code> or <code>I(x^2)</code> on the RHS, <code>model.frame</code> will evaluate these expressions and include them in the output.
</p>
<p>The major disadvantage of using <code>model.frame</code> is that it generates a terms object, which encodes how variables and interactions are organised. One of the attributes of this object is a matrix with one row per variable, and one column per main effect and interaction. At minimum, this is (approximately) a <code class="reqn">p \times p</code> square matrix where <code class="reqn">p</code> is the number of main effects in the model. For wide datasets with <code class="reqn">p &gt; 10000</code>, this matrix can approach or exceed a gigabyte in size. Even if there is enough memory to store such an object, generating the model matrix can take a significant amount of time.
</p>
<p>Another issue with the standard R approach is the treatment of factors. Normally, <code>model.matrix</code> will turn an <code class="reqn">N</code>-level factor into an indicator matrix with <code class="reqn">N-1</code> columns, with one column being dropped. This is necessary for unregularised models as fit with <code>lm</code> and <code>glm</code>, since the full set of <code class="reqn">N</code> columns is linearly dependent. With the usual treatment contrasts, the interpretation is that the dropped column represents a baseline level, while the coefficients for the other columns represent the difference in the response relative to the baseline.
</p>
<p>This may not be appropriate for a regularised model as fit with glmnet. The regularisation procedure shrinks the coefficients towards zero, which forces the estimated differences from the baseline to be smaller. But this only makes sense if the baseline level was chosen beforehand, or is otherwise meaningful as a default; otherwise it is effectively making the levels more similar to an arbitrarily chosen level.
</p>


<h3>Manually building the model matrix</h3>

<p>To deal with the problems above, glmnetUtils by default will avoid using <code>model.frame</code>, instead building up the model matrix term-by-term. This avoids the memory cost of creating a <code>terms</code> object, and can be noticeably faster than the standard approach. It will also include one column in the model matrix for <em>all</em> levels in a factor; that is, no baseline level is assumed. In this situation, the coefficients represent differences from the overall mean response, and shrinking them to zero <em>is</em> meaningful (usually).
</p>
<p>This works in an additive fashion, ie the formula <code>~ a + b:c + d*e</code> is treated as consisting of three terms, <code>a</code>, <code>b:c</code> and <code>d*e</code> each of which is processed independently of the others. A dot in the formula includes all main effect terms, ie <code>~ . + a:b + f(x)</code> expands to <code>~ a + b + x + a:b + f(x)</code> (assuming a, b and x are the only columns in the data). Note that a formula like <code>~ (a + b) + (c + d)</code> will be treated as two terms, <code>a + b</code> and <code>c + d</code>.
</p>
<p>The code can handle fairly complex formulas, but it is not as sophisticated as base <code>model.frame</code> and <code>model.matrix</code>. In particular, terms that are to be <em>omitted</em> from the model must be at the end of the formula: <code>~ . - c</code> works, but not <code>~ -c + .</code>.
</p>


</div>