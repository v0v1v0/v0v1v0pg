<div class="container">

<table style="width: 100%;"><tr>
<td>grand_summary_rows</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add grand summary rows using aggregation functions</h2>

<h3>Description</h3>

<p>Add grand summary rows by using the table data and any suitable aggregation
functions. With grand summary rows, all of the available data in the <strong>gt</strong>
table is incorporated (regardless of whether some of the data are part of row
groups). Multiple grand summary rows can be added via expressions given to
<code>fns</code>. You can selectively format the values in the resulting grand summary
cells by use of formatting expressions in <code>fmt</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grand_summary_rows(
  data,
  columns = everything(),
  fns = NULL,
  fmt = NULL,
  side = c("bottom", "top"),
  missing_text = "---",
  formatter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><em>The gt table data object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;gt_tbl&gt;⁠</code> // <strong>required</strong>
</p>
<p>This is the <strong>gt</strong> table object that is commonly created through use of the
<code>gt()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>The columns for which the summaries should be calculated. Can either
be a series of column names provided in <code>c()</code>, a vector of column indices,
or a select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fns</code></td>
<td>
<p><em>Aggregation Expressions</em>
</p>
<p><code style="white-space: pre;">⁠&lt;expression|list of expressions&gt;⁠</code>
</p>
<p>Functions used for aggregations. This can include base functions like
<code>mean</code>, <code>min</code>, <code>max</code>, <code>median</code>, <code>sd</code>, or <code>sum</code> or any other user-defined
aggregation function. Multiple functions, each of which would generate a
different row, are to be supplied within a <code>list()</code>. We can specify the
functions by use of function names in quotes (e.g., <code>"sum"</code>), as bare
functions (e.g., <code>sum</code>), or in formula form (e.g., <code>minimum ~ min(.)</code>)
where the LHS could be used to supply the summary row label and ID values.
More information on this can be found in the
<em>Aggregation expressions for <code>fns</code></em> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fmt</code></td>
<td>
<p><em>Formatting expressions</em>
</p>
<p><code style="white-space: pre;">⁠&lt;expression|list of expressions&gt;⁠</code>
</p>
<p>Formatting expressions in formula form. The RHS of <code>~</code> should contain a
formatting call (e.g., <code style="white-space: pre;">⁠~ fmt_number(., decimals = 3, use_seps = FALSE⁠</code>).
Optionally, the LHS could contain a group-targeting expression (e.g.,
<code>"group_a" ~ fmt_number(.)</code>). More information on this can be found in the
<em>Formatting expressions for <code>fmt</code></em> section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>
<p><em>Side used for placement of grand summary rows</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[bottom|top]⁠</code> // <em>default:</em> <code>"bottom"</code>
</p>
<p>Should the grand summary rows be placed at the <code>"bottom"</code> (the default) or
the <code>"top"</code> of the table?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_text</code></td>
<td>
<p><em>Replacement text for <code>NA</code> values</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>"---"</code>
</p>
<p>The text to be used in place of <code>NA</code> values in summary cells with no data
outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formatter</code></td>
<td>
<p><em>Deprecated Formatting function</em>
</p>
<p><code style="white-space: pre;">⁠&lt;expression&gt;⁠</code>
</p>
<p>Deprecated, please use <code>fmt</code> instead. This was previously used as a way to
input a formatting function name, which could be any of the <code style="white-space: pre;">⁠fmt_*()⁠</code>
functions available in the package (e.g., <code>fmt_number()</code>, <code>fmt_percent()</code>,
etc.), or a custom function using <code>fmt()</code>. The options of a formatter can
be accessed through <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><em>Deprecated Formatting arguments</em>
</p>
<p><code style="white-space: pre;">⁠&lt;Named arguments&gt;⁠</code>
</p>
<p>Deprecated (along with <code>formatter</code>) but otherwise used for argument values
for a formatting function supplied in <code>formatter</code>. For example, if using
<code>formatter = fmt_number</code>, options such as <code>decimals = 1</code>, <code>use_seps = FALSE</code>, and the like can be used here.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>gt_tbl</code>.
</p>


<h3>Using <code>columns</code> to target column data for aggregation</h3>

<p>Targeting of column data for which aggregates should be generated is done
through the <code>columns</code> argument. We can declare column names in <code>c()</code> (with
bare column names or names in quotes) or we can use
<strong>tidyselect</strong>-style expressions. This can be as basic as supplying a select
helper like <code>starts_with()</code>, or, providing a more complex incantation like
</p>
<p><code>where(~ is.numeric(.x) &amp; max(.x, na.rm = TRUE) &gt; 1E6)</code>
</p>
<p>which targets numeric columns that have a maximum value greater than
1,000,000 (excluding any <code>NA</code>s from consideration).
</p>
<p>By default all columns are selected (with the <code>everything()</code> default). This
default may be not what's needed unless all columns can undergo useful
aggregation by expressions supplied in <code>fns</code>.
</p>


<h3>Aggregation expressions for <code>fns</code>
</h3>

<p>There are a number of ways to express how an aggregation should work for
each summary row. In addition to that, we have the ability to pass important
information such as the summary row ID value and its label (the former
necessary for targeting within <code>tab_style()</code> or <code>tab_footnote()</code> and the
latter used for display in the rendered table). Here are a number of
instructive examples for how to supply such expressions.
</p>


<h4>Double-sided formula with everything supplied</h4>

<p>We can be explicit and provide a double-sided formula (in the form
<code style="white-space: pre;">⁠&lt;LHS&gt; ~ &lt;RHS&gt;⁠</code>) that expresses everything about a summary row. That is, it
has an aggregation expression (where <code>.</code> represents the data in the
focused column). Here's an example:
</p>
<p><code>list(id = "minimum", label = "min") ~ min(., na.rm = TRUE)</code>
</p>
<p>The left side (the list) contains named elements that identify the <code>id</code> and
<code>label</code> for the summary row. The right side has an expression for obtaining
a minimum value (dropping <code>NA</code> values in the calculation).
</p>
<p>The <code>list()</code> can be replaced with <code>c()</code> but the advantage of a list is
allowing the use of the <code>md()</code> and <code>html()</code> helper functions. The above
example can be written as:
</p>
<p><code>list(id = "minimum", label = md("**Minimum**")) ~ min(., na.rm = TRUE)</code>
</p>
<p>and we can have that label value interpreted as Markdown text.
</p>



<h4>Function names in quotes</h4>

<p>With <code>fns = "min"</code> we get the equivalent of the fuller expression:
</p>
<p><code>list(id = "min", label = "min") ~ min(., na.rm = TRUE)</code>
</p>
<p>For sake of convenience, common aggregation functions with the <code>na.rm</code>
argument will be rewritten with the <code>na.rm = TRUE</code> option. These functions
are: <code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"sd"</code>, and <code>"sum"</code>.
</p>
<p>Should you need to specify multiple aggregation functions in this way (giving
you multiple summary rows), use <code>c()</code> or <code>list()</code>.
</p>



<h4>RHS formula expressions</h4>

<p>With <code>fns = ~ min(.)</code> or <code>fns = list(~ min(.))</code>, <strong>gt</strong> will use the function
name as the <code>id</code> and <code>label</code>. The expansion of this shorthand to full form
looks like this:
</p>
<p><code>list(id = "min", label = "min") ~ min(.)</code>
</p>
<p>The RHS expression is kept as written and the name portion is both the <code>id</code>
and the <code>label</code>.
</p>



<h4>Named vector or list with RHS formula expression</h4>

<p>Using <code>fns = c(minimum = ~ min(.))</code> or <code>fns = list(minimum = ~ min(.))</code>
expands to this:
</p>
<p><code>list(id = "minimum", label = "minimum") ~ min(.)</code>
</p>



<h4>Unnamed vector or list with RHS formula expression</h4>

<p>With <code>fns = c("minimum", "min") ~ min(.)</code> or
<code>fns = list("minimum", "min") ~ min(.)</code> the LHS contains the <code>label</code> and <code>id</code>
values and, importantly, the order is <code>label</code> first and <code>id</code> second. This can
be rewritten as:
</p>
<p><code>list(id = "min", label = "minimum") ~ min(.)</code>
</p>
<p>If the vector or list is partially named, <strong>gt</strong> has enough to go on to
disambiguate the unnamed element. So with
<code>fns = c("minimum", label = "min") ~ min(.)</code>, <code>"min"</code> is indeed the <code>label</code>
and <code>"minimum"</code> is taken as the <code>id</code> value.
</p>



<h4>A fully named list with three specific elements</h4>

<p>We can avoid using a formula if we are satisfied with the default options of
a function (except some of those functions with the <code>na.rm</code> options, see
above). Instead, a list with the named elements <code>id</code>, <code>label</code>, and <code>fn</code> could
be used. It can look like this:
</p>
<p><code>fns = list(id = "mean_id", label = "average", fn = "mean")</code>
</p>
<p>which translates to
</p>
<p><code>list(id = "mean_id", label = "average") ~ mean(., na.rm = TRUE)</code>
</p>



<h3>Formatting expressions for <code>fmt</code>
</h3>

<p>Given that we are generating new data in a table, we might also want to
take the opportunity to format those new values right away. We can do this
in the <code>fmt</code> argument, either with a single expression or a number of them
in a list.
</p>
<p>We can supply a one-sided (RHS only) expression to <code>fmt</code>, and, several can
be provided in a list. The expression uses a formatting function (e.g.,
<code>fmt_number()</code>, <code>fmt_currency()</code>, etc.) and it must contain an initial <code>.</code>
that stands for the data object. If performing numeric formatting on all
columns in the new grand summary rows, it might look something like this:
</p>
<p><code>fmt = ~ fmt_number(., decimals = 1, use_seps = FALSE)</code>
</p>
<p>We can use the <code>columns</code> and <code>rows</code> arguments that are available in every
formatting function. This allows us to format only a subset of columns or
rows. Summary rows can be targeted by using their ID values and these are
settable within expressions given to <code>fns</code> (see the <em>Aggregation expressions
for <code>fns</code></em> section for details on this). Here's an example with hypothetical
column and row names:
</p>
<p><code>fmt = ~ fmt_number(., columns = num, rows = "mean", decimals = 3)</code>
</p>


<h3>Extraction of summary rows</h3>

<p>Should we need to obtain the summary data for external purposes,
<code>extract_summary()</code> can be used with a <code>gt_tbl</code> object where summary rows
were added via <code>grand_summary_rows()</code> or <code>summary_rows()</code>.
</p>


<h3>Examples</h3>

<p>Use a modified version of the <code>sp500</code> dataset to create a <strong>gt</strong> table with
row groups and row labels. Create the grand summary rows <code>min</code>, <code>max</code>, and
<code>avg</code> for the table with <code>grand_summary_rows()</code>.
</p>
<div class="sourceCode r"><pre>sp500 |&gt;
  dplyr::filter(date &gt;= "2015-01-05" &amp; date &lt;= "2015-01-16") |&gt;
  dplyr::arrange(date) |&gt;
  dplyr::mutate(week = paste0("W", strftime(date, format = "%V"))) |&gt;
  dplyr::select(-adj_close, -volume) |&gt;
  gt(
    rowname_col = "date",
    groupname_col = "week"
  ) |&gt;
  grand_summary_rows(
    columns = c(open, high, low, close),
    fns = list(
      min ~ min(.),
      max ~ max(.),
      avg ~ mean(.)
    ),
    fmt = ~ fmt_number(., use_seps = FALSE)
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_grand_summary_rows_1.png" alt="This image of a table was generated from the first code example in the `grand_summary_rows()` help file." style="width:100%;"><p>Let's take the <code>countrypops</code> dataset and process that a bit before handing
it off to <strong>gt</strong>. We can create a single grand summary row with totals that
appears at the top of the table body (with <code>side = "top"</code>). We can define the
aggregation with a list that contains parameters for the grand summary row
label (<code>"TOTALS"</code>), the ID value of that row (<code>"totals"</code>), and the
aggregation function (expressed as <code>"sum"</code>, which <strong>gt</strong> recognizes as the
<code>sum()</code> function). Finally, we'll add a background fill to the grand summary
row with <code>tab_style()</code>.
</p>
<div class="sourceCode r"><pre>countrypops |&gt;
  dplyr::filter(country_code_2 %in% c("BE", "NL", "LU")) |&gt;
  dplyr::filter(year %% 10 == 0) |&gt;
  dplyr::select(country_name, year, population) |&gt;
  tidyr::pivot_wider(names_from = year, values_from = population) |&gt;
  gt(rowname_col = "country_name") |&gt;
  tab_header(title = "Populations of the Benelux Countries") |&gt;
  tab_spanner(columns = everything(), label = "Year") |&gt;
  fmt_integer() |&gt;
  grand_summary_rows(
    fns =  list(label = "TOTALS", id = "totals", fn = "sum"),
    fmt = ~ fmt_integer(.),
    side = "top"
  ) |&gt;
  tab_style(
    locations = cells_grand_summary(),
    style = cell_fill(color = "lightblue" |&gt; adjust_luminance(steps = +1))
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_grand_summary_rows_2.png" alt="This image of a table was generated from the second code example in the `grand_summary_rows()` help file." style="width:100%;"><h3>Function ID</h3>

<p>6-2
</p>


<h3>Function Introduced</h3>

<p><code>v0.2.0.5</code> (March 31, 2020)
</p>


<h3>See Also</h3>

<p>Other row addition/modification functions: 
<code>row_group_order()</code>,
<code>rows_add()</code>,
<code>summary_rows()</code>
</p>


</div>