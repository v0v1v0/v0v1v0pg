<div class="container">

<table style="width: 100%;"><tr>
<td>georobSimulation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulating Realizations of Gaussian Processes</h2>

<h3>Description</h3>

<p>This page documents the function <code>condsim</code> that
simulates (un)conditional realizations of Gaussian processes from the
parameters of a spatial linear model estimated by the function
<code>georob</code>.</p>


<h3>Usage</h3>

<pre><code class="language-R">  condsim(object, newdata, nsim, seed, type =  c("response", "signal"),
    locations, trend.coef = NULL,
    variogram.model = NULL, param = NULL, aniso = NULL, variogram.object = NULL,
    control = control.condsim(), verbose = 0)

  control.condsim(use.grid = FALSE, grid.refinement = 2.,
    condsim = TRUE, ce.method = c( "standard", "approximate" ),
    ce.grid.expansion = 1., include.data.sites = FALSE,
    means = FALSE, trend.covariates = FALSE, covariances = FALSE,
    ncores = 1, mmax = 10000, pcmp = control.pcmp())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>georob</code> (mandatory argument), see
<code>georobObject</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a mandatory data frame,
<code>SpatialPointsDataFrame</code>,
<code>SpatialPixelsDataFrame</code>,
<code>SpatialGridDataFrame</code>,
<code>SpatialPoints</code>,
<code>SpatialPixels</code> or
<code>SpatialGrid</code> object,
with the coordinates of points for which simulations are computed
and in which to look for variables required for computing fitted values
or Kriging predictions,  see <code>predict.georob</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>a positive interger with the number of (condititional)
realizations to compute (mandatory argument).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>an integer seed to initialize random number generation,
see <code>set.seed</code> (mandatory argument).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character keyword defining what target quantity should be
simulated.  Possible values are
</p>

<ul>
<li> <p><code>"signal"</code>: the “signal”
<code class="reqn">Z(\boldsymbol{s}) =
      \boldsymbol{x}(\boldsymbol{s})^\mathrm{T}
      \boldsymbol{\beta} +
      B(\boldsymbol{s})</code> of
the process,
</p>
</li>
<li> <p><code>"response"</code>: the observations
<code class="reqn">Y(\boldsymbol{s}) =
      Z(\boldsymbol{s}) +
      \varepsilon(\boldsymbol{s}),</code>  (default),
</p>
</li>
</ul>
<p>see <code>georobPackage</code> for details on the model specification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locations</code></td>
<td>
<p>an optional one-sided formula specifying what variables
of <code>newdata</code> are the coordinates of the points for which simulations
are computed (default<br><code>object[["locations.objects"]][["locations"]]</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend.coef</code></td>
<td>
<p>an optional numeric vector with the coefficients of the
trend model to be used for computing the (conditional) mean function of
the random process see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variogram.model</code></td>
<td>
<p>an optional character keyword defining the
variogram model to be used for the simulations, see <code>georob</code>
and <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>an optional named numeric vector with values of the
variogram parameters used for the simulations, see <code>georob</code>
and <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aniso</code></td>
<td>
<p>an optional named numeric vector with values of anisotropy
parameters of a variogram used for the simulations, see
<code>georob</code> and <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variogram.object</code></td>
<td>
<p>an optional list that defines a possibly nested
variogram model used for the simulations, see <code>georob</code> and
<em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list with the components <code>use.grid</code>,
<code>grid.refinement</code>, <code>condsim</code>,
<code>ce.method</code>, <code>ce.grid.expansion</code>,
<code>include.data.sites</code>,
<code>means</code>, <code>trend.covariates</code>,<br><code>covariances</code>,
<code>ncores</code>, <code>mmax</code> and <code>pcmp</code> or a function such as
<code>control.condsim</code> that generates such a list, see
arguments of <code>control.condsim</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console.<br><code>verbose = 0</code> (default) suppresses
such messages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.grid</code></td>
<td>
<p>a logical scalar (default <code>FALSE</code>) to control whether
(conditional) realizations are computed for a rectangular grid instead of
the coordinates of points contained in <code>newdata</code>, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid.refinement</code></td>
<td>
<p>a numeric that defines a factor by which the
minimum differences of the coordinates between any pair of points in
<code>newdata</code> are divided to setup the simulation grid, should be &gt; 1
(default 2), see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condsim</code></td>
<td>
<p>a logical scalar to control whether conditional
(<code>TRUE</code> default) or unconditional simulations (<code>FALSE</code>) are
computed.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ce.method</code></td>
<td>
<p>a character keyword to select the method to simulate
realizations by the circulant embedding algorithm, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ce.grid.expansion</code></td>
<td>
<p>a numeric with the factor by which the
dimensions of the simulation grid is expanded in the circulant embedding
algorithm. Should be <code class="reqn">\ge 1</code> (default 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.data.sites</code></td>
<td>
<p>a logical scalar, to control whether
(conditionally) simulated values are computed also for the points of the
original data set used to estimate the model parameters and contained in
<code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>means</code></td>
<td>
<p>a logical scalar, to control whether
the (un)conditional means are included in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend.covariates</code></td>
<td>
<p>a logical scalar, to control whether
the covariates required for the trend model are included in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariances</code></td>
<td>
<p>a logical scalar, to control whether the covariances
between the points of the original data set used to estimate the model
parameters (<code>attr gcvmat.d.d</code>, <br><code>compress</code>ed matrix) and
the covariances between the simulation and the original data points
(<code>attr gcvmat.s.d</code>, matrix) are returned as attributes of the
output.  Note that these covariances are only returned if
<code>condsim = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer controlling how many cores are
used for parallelized computations, defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mmax</code></td>
<td>
<p>a positive integer equal to the maximum number (default
<code>10000</code>) of prediction items, computed in sub-tasks executed in
parallel, see section <em>Details</em> of <code>predict.georob</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcmp</code></td>
<td>
<p>a list of arguments, passed  e.g. to <code>pmm</code> or a
function such as <code>control.pcmp</code> that generates such a list
(see <code>control.pcmp</code> for allowed arguments).</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>General</h4>

<p><code>condsim</code> (conditionally) simulates from a Gaussian process that
has a linear mean function with parameters
<code class="reqn">\boldsymbol{\beta}</code> and an auto-correlation structure
characterized by a parametric variogram model and variogram parameters
<code class="reqn">\tau^2</code> and <code class="reqn">\boldsymbol{\theta}</code> (see
<code>georobPackage</code> for the employed parametrization of the
spatial linear model).  The parameters of the mean and auto-correlation
function are either taken from the spatial linear model estimated by
<code>georob</code> and passed by the argument
<code>object</code> to <code>condsim</code> or from the optional arguments
<code>trend.coef</code> (<code class="reqn">\boldsymbol{\beta}</code>)
and <code>variogram.model</code>, <code>param</code>, <code>aniso</code> or <br><code>variogram.object</code> (<code class="reqn">\tau^2</code>,
<code class="reqn">\boldsymbol{\theta}</code>).
</p>
<p>Simulated values are computed for the points in <code>newdata</code> and
optionally also for the data points in <code>object</code> if
<code>include.data.sites = TRUE</code>.  Both unconditional and conditional
simulations can be computed.  In the latter cases, the simulated values
are always conditioned to the response data used to fit the spatial
linear model by <code>georob</code> and contained in <code>object</code>.
</p>



<h4>Unconditional simulation</h4>

<p>Unconditional realizations are either computed for the exact locations of
the points in <code>newdata</code> (<code>use.grid = FALSE</code>), irrespective of
the fact whether these are arranged on a regular grid or not.
Simulations are then generated by the Cholesky matrix decomposition
method (e.g. <cite>Chilès and Delfiner, 1999, sec.
7.2.2</cite>).
</p>
<p>For <code>use.grid = TRUE</code> the points in <code>newdata</code> are matched to a
rectangular simulation grid and the simulations are generated for all
nodes of this grid by the circulant embedding method (<cite>Davis and
Bryant, 2013</cite>; <cite>Dietrich and Newsam, 1993</cite>; <cite>Wood and Chan,
1994</cite>).  For large problems this approach may be substantially faster and
less memory demanding than the Cholesky matrix decomposition method.
</p>
<p>For circulant embedding, first a rectangular simulation grid is
constructed from the coordinates of the points in <code>newdata</code> and
<code>object</code>.  The spacings of the simulation grid is equal to the
minimum coordinate differences between any pair of points in
<code>newdata</code>, divided by <code>grid.refinement</code>.  The spatial extent of
the simulation grid is chosen such that it covers the bounding boxes of
all points in <code>newdata</code> and <code>object</code>.  The points in
<code>newdata</code> and <code>object</code> are then matched to the closest nodes of
the simulation grid.  If the same node is assigned to a point in
<code>object</code> and <code>newdata</code> then the point in <code>object</code> is kept
and the concerned point in <code>newdata</code> is omitted.
</p>
<p>The rectangular simulation grid is then expanded to the larger circulant
embedding grid, and the eigenvalues of the so-called <em>base matrix</em>
(= first row of the covariance matrix of the nodes of the circulant
embedding grid with block circulant structure, see <cite>Davies and Bryant,
2013)</cite> are computed by fast discrete Fourier transform (FFT).  It may
happen that some of the eigenvalues of the base matrix are negative.  The
standard circulant embedding algorithm then fails.
</p>
<p>Two approaches are implemented in <code>condsim</code> to handle this
situation:
</p>

<ul>
<li>
<p> First, one may use the <em>approximate circulant embedding</em>
method by choosing <code>ce.method = "approximate"</code>.  This sets the
negative eigenvalues of the base matrix to zero and scales the
eigenvalues, see <cite>Chan and Wood (1994, sec.  4</cite>, choice <code class="reqn">\rho =
    \rho_2</code>).
</p>
</li>
<li>
<p> Second, one may attempt to avoid the problem of negative
eigenvalues by increasing the size of the simulation (and circulant
embedding) grids.  This can be achieved by choosing a value <code class="reqn">&gt; 1</code>
for the argument <code>ce.grid.expansion</code>, see respective parts in
<cite>Dietrich and Newsam (1993, sec.  4)</cite> and <cite>Wood and Chan
(1994, sec.  3)</cite>.
</p>
</li>
</ul>
<p>Note that the dimension of the simulation and embedding grids are chosen
such that the number of nodes is a highly composite integer.  This allows
efficient FFT.
</p>



<h4>Conditional simulation</h4>

<p>For both the Cholesky matrix decomposition and the circulant embedding
approach, simulations are conditioned to data by the Kriging method,
see <cite>Chilès and Delfiner, 1999, sec. 7.3</cite>.
</p>



<h4>Parallelized computations</h4>

<p><code>condsim</code> uses the packages <span class="pkg">parallel</span> and <span class="pkg">snowfall</span> for
parallelized computations.  Three tasks can be executed in parallel:
</p>

<ul>
<li>
<p> Computation of (generalized correlations), see
<code>control.pcmp</code> how to do this.
</p>
</li>
<li>
<p> Computation of Kriging predictions required for conditional
simulations, see section <em>Details</em> of
<code>predict.georob</code>.
</p>
</li>
<li>
<p> Fast Fourier transform of realizations of standard normal
deviates generated for the nodes of the base matrix (see
<cite>Davies and Bryant, 2013, steps 3–5 of algorithm)</cite>.  If there are
<code>nsim</code> realizations to simulate, the task is split into
<code>ceiling(nsim / ncores)</code> sub-tasks that are then distributed to
<code>ncores</code> CPUs.  Evidently, <code>ncores = 1</code> (default) suppresses
parallel execution.
</p>
</li>
</ul>
<h3>Value</h3>

<p>The output generated by <code>condsim</code> is an object of a “similar”
class as <code>newdata</code> (data frame,<br><code>SpatialPointsDataFrame</code>,
<code>SpatialPixelsDataFrame</code>,
<code>SpatialGridDataFrame</code>, <br><code>SpatialPolygonsDataFrame</code>).
</p>
<p>The data frame or the
<code>data</code> slot of the <code>Spatial...DataFrame</code> objects
have the following components:
</p>

<ul>
<li>
<p> the coordinates of the prediction points (only present if
<code>newdata</code> is a data frame).
</p>
</li>
<li> <p><code>expct</code>: optionally the (un)conditional means.
</p>
</li>
<li>
<p> optionally the covariates required for the trend model.
</p>
</li>
<li> <p><code>sim.1</code>, <code>sim.2</code>, ...: the (un)conditionally
simulated realizations.
</p>
</li>
</ul>
<p>The function <code>control.condsim</code> returns a list with parameters to
steer <code>condsim</code>, see arguments above.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Chilès, J.-P., Delfiner, P. (1999) <em>Geostatistics
Modeling Spatial Uncertainty</em>, Wiley, New York,
<a href="https://doi.org/10.1002/9780470316993">doi:10.1002/9780470316993</a>.
</p>
<p>Davies, T. M., Bryant, D. (2013) On circulant embedding for gaussian
random fields in R, <em>Journal of Statistical Software</em>, <b>55</b>,
1–21, <a href="https://doi.org/10.18637/jss.v055.i09">doi:10.18637/jss.v055.i09</a>.
</p>
<p>Dietrich, C. R., Newsam, G. N. (1993) A fast and exact method for
multidimensional gaussian stochastic simulations, <em>Water Resources
Research</em>, <b>9</b>, 2861–2869, <a href="https://doi.org/10.1029/93WR01070">doi:10.1029/93WR01070</a>.
</p>
<p>Wood, A. T. A., Chan, G. (1994) Simulation of stationary gaussian
processes in <code class="reqn">[0,1]^d</code>, <em>Journal of Computational and Graphcal
Statistics</em>, <b>3</b>, 409–432, <a href="https://doi.org/10.2307/1390903">doi:10.2307/1390903</a>.
</p>


<h3>See Also</h3>

<p><code>georobPackage</code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code>georob</code> for (robust) fitting of spatial linear models;
</p>
<p><code>georobObject</code> for a description of the class <code>georob</code>;
</p>
<p><code>profilelogLik</code> for computing profiles of Gaussian likelihoods;
</p>
<p><code>plot.georob</code> for display of RE(ML) variogram estimates;
</p>
<p><code>control.georob</code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code>georobModelBuilding</code> for stepwise building models of class <code>georob</code>;
</p>
<p><code>cv.georob</code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code>georobMethods</code> for further methods for the class <code>georob</code>;
</p>
<p><code>predict.georob</code> for computing robust Kriging predictions;
</p>

<p><code>lgnpp</code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>


<p><code>sample.variogram</code> and <code>fit.variogram.model</code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(meuse)
data(meuse.grid)

## convert to SpatialGridDataFrame
meuse.grid.sgdf &lt;- meuse.grid
coordinates(meuse.grid.sgdf) &lt;- ~ x + y
gridded(meuse.grid.sgdf) &lt;- TRUE
fullgrid(meuse.grid.sgdf) &lt;- TRUE

## Gaussian REML fit
r.logzn.reml &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse,
    locations = ~ x + y, variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1000)

## Unconditional simulations using circulant embedding on rectangular
## simulation grid
r.sim.1 &lt;- condsim(r.logzn.reml, newdata = meuse.grid.sgdf, nsim = 2, seed = 1,
    control = control.condsim(use.grid = TRUE, condsim = FALSE))
spplot(r.sim.1, zcol = "sim.1", at = seq(3.5, 8.5, by = 0.5))

## Conditional simulations using circulant embedding
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.sim.2 &lt;- condsim(r.logzn.reml, newdata = meuse.grid.sgdf, nsim = 2, seed = 1,
      control = control.condsim(use.grid = FALSE, condsim = TRUE))
  spplot(r.sim.2, zcol = "sim.2", at = seq(3.5, 8.5, by = 0.5))
}
</code></pre>


</div>