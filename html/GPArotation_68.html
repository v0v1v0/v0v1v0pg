<div class="container">

<table style="width: 100%;"><tr>
<td>vgQ</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rotations</h2>

<h3>Description</h3>

<p>vgQ routines to compute value and gradient of the criterion (not exported from NAMESPACE)
</p>


<h3>Usage</h3>

<pre><code class="language-R">    vgQ.oblimin(L, gam=0)
    vgQ.quartimin(L)
    vgQ.target(L, Target=NULL)
    vgQ.pst(L, W=NULL, Target=NULL)
    vgQ.oblimax(L)
    vgQ.entropy(L)
    vgQ.quartimax(L)
    vgQ.varimax(L)
    vgQ.simplimax(L, k=nrow(L))
    vgQ.bentler(L)
    vgQ.tandemI(L)
    vgQ.tandemII(L)
    vgQ.geomin(L, delta=.01)
    vgQ.bigeomin(L, delta=.01)
    vgQ.cf(L, kappa=0)
    vgQ.infomax(L)
    vgQ.mccammon(L)
    vgQ.varimin(L)
    vgQ.bifactor(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a factor loading matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam</code></td>
<td>
<p>0=Quartimin, .5=Biquartimin, 1=Covarimin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Target</code></td>
<td>
<p>rotation target for objective calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>weighting of each element in target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of close to zero loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>constant added to Lambda^2 in objective calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>see details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>vgQ.*</code> versions of the code are called by the optimization routine and
would typically not be used directly, so these methods are not exported
from the package NAMESPACE. (They simply return the function value and gradient
for a given rotation matrix.) You can print these functions, but the package 
name needs to be specified since they are not exported. For example, use
<code>GPArotation:::vgQ.oblimin</code> to view the function <code>vgQ.oblimin</code>.
The T or Q ending on function names should be omitted for the <code>vgQ.*</code> 
versions of the code so, for example, use <code>GPArotation:::vgQ.target</code> to view the target
criterion calculation.
</p>

<table>
<tr>
<td style="text-align: left;">
<code>vgQ.oblimin</code>   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  oblimin family</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.quartimin</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.target</code>    </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.pst</code>	   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.oblimax</code>   </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.entropy</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  minimum entropy			</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.quartimax</code> </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 					</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.varimax</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 					</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.simplimax</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.bentler</code>   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.tandemI</code> </td>
<td style="text-align: left;"> orthogonal	   </td>
<td style="text-align: left;"> Tandem principle I criterion	</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.tandemII</code> </td>
<td style="text-align: left;"> orthogonal	   </td>
<td style="text-align: left;"> Tandem principle II criterion	</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.geomin</code>    </td>
<td style="text-align: left;"> orthogonal or oblique  </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.bigeomin</code>    </td>
<td style="text-align: left;"> orthogonal or oblique  </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.cf</code>		   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.cubimax</code>   </td>
<td style="text-align: left;"> orthogonal    </td>
<td style="text-align: left;">  	</td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.infomax</code>   </td>
<td style="text-align: left;"> orthogonal or oblique   </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.mccammon</code>   </td>
<td style="text-align: left;"> orthogonal    </td>
<td style="text-align: left;"> McCammon minimum entropy ratio  </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.varimin</code> </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> varimin criterion </td>
</tr>
<tr>
<td style="text-align: left;">
<code>vgQ.bifactor</code> </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;"> bifactor/biquartimin rotation</td>
</tr>
<tr>
<td style="text-align: left;">
 </td>
</tr>
</table>
<p>See rotations for use of arguments.
</p>
<p>New rotation methods can be programmed with a name "vgQ.newmethod". The 
inputs are the matrix L, and optionally any additional arguments. The
output should be a list with elements <code>f</code>, <code>Gq</code>, and <code>Method</code>.
</p>
<p>Gradient projection <em>without</em> derivatives can be performed using the
<code>GPArotateDF</code> package; type <code>vignette("GPArotateDF", package = "GPArotation")</code>
at the command line.
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>GPForth</code> and <code>GPFoblq</code>) with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>The value of the criterion at L.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gq</code></td>
<td>
<p>The gradient at L.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Method</code></td>
<td>
<p>A string indicating the criterion.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676â€“696.
</p>


<h3>See Also</h3>

<p><code>rotations</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  GPArotation:::vgQ.oblimin
  getAnywhere(vgQ.oblimax)	
  
</code></pre>


</div>