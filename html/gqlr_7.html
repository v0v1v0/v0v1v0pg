<div class="container">

<table style="width: 100%;"><tr>
<td>server</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run basic GraphQL server</h2>

<h3>Description</h3>

<p>Run a basic GraphQL server using plumber.  This server is provided to show basic interaction with GraphQL.  The server will run until the function execution is canceled.
</p>


<h3>Usage</h3>

<pre><code class="language-R">server(schema, port = 8000L, log = TRUE, initial_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>schema</code></td>
<td>
<p>Schema object to use execute requests</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>port</code></td>
<td>
<p>web port to serve the server from.  Set port to <code>NULL</code> to not run the plumber server and return it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>boolean that determines if server logging is done.  Defaults to TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_value</code></td>
<td>
<p>default value to use in <code>execute_request()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>server()</code> implements the basic necessities described in <a href="http://graphql.org/learn/serving-over-http/">http://graphql.org/learn/serving-over-http/</a>.  There are three routes implemented:
</p>

<dl>
<dt><code>'/'</code></dt>
<dd>
<p>GET. Returns a GraphQL formatted schema definition</p>
</dd>
<dt><code>'/graphql'</code></dt>
<dd>
<p>GET. Executes a query.  The parameter <code>'query'</code> (which contains a GraphQL formatted query string) must be included.  Optional parameters include: <code>'variables'</code> a JSON string containing a dictionary of variables (defaults to an empty named list), <code>'operationName'</code> name of the particular query operation to execute (defaults to NULL), and <code>'pretty'</code> boolean to determine if the response should be compact (FALSE, default) or expanded (TRUE)</p>
</dd>
<dt><code>'/graphql'</code></dt>
<dd>
<p>POST. Executes a query.  Must provide Content-Type of either 'application/json' or 'application/graphql'.
</p>
<p>If 'application/json' is provided, a named JSON list containing 'query', 'operationName' (optional, default = <code>NULL</code>), 'variables' (optional, default = list()) and 'pretty' (optional, default = <code>TRUE</code>).  The information will used just the same as the GET-'/graphql' route.
</p>
<p>If 'application/graphql' is provided, the POST body will be interpreted as the query string.  All other possible parameters will take on their default value.
</p>
</dd>
</dl>
<p>Using bash's curl, we can ask the server questions:
</p>
<pre> #R
  # load Star Wars schema from 'execute_request' example
  example(gqlr_schema)
  # run server
  server(star_wars_schema, port = 8000)
</pre>
<pre> #bash
  # GET Schema definition
  curl '127.0.0.1:8000/'

  ## POST for R2-D2 and his friends' names
  # defaults to parse as JSON
  curl --data '{"query":"{hero{name, friends { name }}}", "pretty": true}' '127.0.0.1:8000/graphql'
  # send json header
  curl --data '{"query":"{hero{name, friends { name }}}"}' '127.0.0.1:8000/graphql' --header "Content-Type:application/json"
  # send graphql header
  curl --data '{hero{name, friends { name }}}' '127.0.0.1:8000/graphql' --header "Content-Type:application/graphql"
  # use variables
  curl --data '{"query":"query Droid($someId: String!) {droid(id: $someId) {name, friends { name }}}", "variables": {"someId": "2001"}}' '127.0.0.1:8000/graphql'

  # GET R2-D2 and his friends' names
  curl '127.0.0.1:8000/graphql?query=
  # ... using a variable
  curl '127.0.0.1:8000/graphql?query=query

</pre>


</div>