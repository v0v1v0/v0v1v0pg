<div class="container">

<table style="width: 100%;"><tr>
<td>improve_cut_flip</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Improving a cut with local search</h2>

<h3>Description</h3>

<p>Local search to improve a cut by using "neighboring" vertex
subsets differing in just one element from the initial subset.
</p>


<h3>Usage</h3>

<pre><code class="language-R">improve_cut_flip(G, K, w = NA, return.cut = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>A graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>A cut list with components $set, $size, $weight and $cut
as returned by routines build_cut_greedy, build_cut_random
or compute_cut_weight.  Only the $set and $weight components
are used.  K represents the cut to be improved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Weight matrix (defaults to NA).  It should be zero for
those edges not in G</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.cut</code></td>
<td>
<p>Boolean.  Should the routine return the cut?  It
is passed on to compute_cut_weight on return.  It defaults
to TRUE</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given some cut specified by a vertex subset S in a graph, this
routine scans the neighboring subsets obtained from S by
adding/removing a vertex from S looking for a larger cut.  If
such a cut is found, it replaces the starting cut and the
search starts again.  This iterative procedure continues until
no larger cut can be found.  Of course, the resulting cut is
only a local maximum.
</p>


<h3>Value</h3>

<p>A list with four components: $set contains the subset of
V(g) representing the cut, $size contains the number of edges
of the cut, $weight contains the weight of the cut (which
coincides with $size if w is NA) and $cut contains the edges
of the cut, joining vertices inside $set with vertices outside
$set.  When return.cut is FALSE, components $set and $cut are
omitted.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p>build_cut_random builds a random cut,
build_cut_greedy builds a cut using a greedy algorithm,
compute_cut_weight computes cut size, weight and edges,
plot_cut plots a cut.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph

c1 &lt;- build_cut_random(g)
c1$size    # 44
plot_cut(c1, g)

c2 &lt;- build_cut_greedy(g)
c2$size    # 59
plot_cut(c2, g)

c3 &lt;- improve_cut_flip(g, c1)
c3$size    # 65
plot_cut(c3,g)

c4 &lt;- improve_cut_flip(g, c2)
c4$size    # 60
plot_cut(c4,g)

</code></pre>


</div>