<div class="container">

<table style="width: 100%;"><tr>
<td>simMuFu</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate multivariate functional data</h2>

<h3>Description</h3>

<p>This function provides a unified simulation structure for multivariate
functional data <code class="reqn">f_1, \ldots, f_N</code> on one- or two-dimensional domains,
based on a truncated multivariate Karhunen-Loeve representation: </p>
<p style="text-align: center;"><code class="reqn">f_i(t)
= \sum_{m = 1}^M \rho_{i,m} \psi_m(t).</code>
</p>
<p> The multivariate eigenfunctions
(basis functions) <code class="reqn">\psi_m</code>  are constructed from univariate orthonormal
bases. There are two different concepts for the construction, that can be
chosen by the parameter <code>type</code>: A split orthonormal basis (<code>split</code>,
only one-dimensional domains) and weighted univariate orthonormal bases
(<code>weighted</code>, one- and two-dimensional domains). The scores
<code class="reqn">\rho_{i,m}</code> in the Karhunen-Loeve representation are simulated
independently from a normal distribution with zero mean and decreasing
variance. See Details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simMuFu(
  type,
  argvals,
  M,
  eFunType,
  ignoreDeg = NULL,
  eValType,
  N,
  seed,
  seed_funs = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A character string, specifying the construction method for the
multivariate eigenfunctions (either <code>"split"</code> or <code>"weighted"</code>).
See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>A list, containing the observation points for each element of
the multivariate functional data that is to be simulated. The length of
<code>argvals</code> determines the number of elements in the resulting simulated
multivariate functional data. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>An integer (<code>type = "split"</code>) or a list of integers (<code>type
= "weighted"</code>), giving the number of univariate basis functions to use. See
Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eFunType</code></td>
<td>
<p>A character string (<code>type = "split"</code>)   or a list of
character strings (<code>type = "weighted"</code>), specifying the type of
univariate orthonormal basis functions to use. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreDeg</code></td>
<td>
<p>A vector of integers (<code>type = "split"</code>)   or a list of
integer vectors (<code>type = "weighted"</code>), specifying the degrees to
ignore when generating the univariate orthonormal bases. Defaults to
<code>NULL</code>. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eValType</code></td>
<td>
<p>A character string, specifying the type of
eigenvalues/variances used for the simulation of the multivariate functions
based on the truncated Karhunen-Loeve representation. See
<code>eVal</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>An integer, specifying the number of multivariate functions to be
generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A random seed for the score generation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed_funs</code></td>
<td>
<p>A random seed to make the eigenfunction creation
reproducible.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The parameter <code>type</code> defines how the eigenfunction basis for the
multivariate Karhunen-Loeve representation is constructed: </p>
 <ul>
<li>
<p><code>type = "split"</code>: The basis functions of an underlying 'big' orthonormal
basis are split in <code>M</code> parts, translated and possibly reflected. This
yields an orthonormal basis of multivariate functions with <code>M</code>
elements. This option is implemented only for one-dimensional domains. </p>
</li>
<li>
<p><code>type = "weighted":</code> The multivariate eigenfunction basis consists of
weighted univariate orthonormal bases.  This yields an orthonormal basis of
multivariate functions with <code>M</code> elements. For data on two-dimensional
domains (images), the univariate basis is constructed as a tensor product of
univariate bases in each direction (x- and y-direction). </p>
</li>
</ul>
<p>Depending on <code>type</code>, the other parameters have to be specified as
follows: </p>


<h4>Split 'big' orthonormal basis</h4>

<p> The parameters <code>M</code>
(integer), <code>eFunType</code> (character string) and <code>ignoreDeg</code> (integer
vector or <code>NULL</code>) are passed to the function <code>eFun</code> to
generate a univariate orthonormal basis on a 'big' interval. Subsequently,
the basis functions are split and translated, such that the <code class="reqn">j</code>-th part
of the split function is defined on the interval corresponding to
<code>argvals[[j]]</code>. The elements of the multivariate basis functions are
given by these split parts of the original basis functions multiplied by a
random sign <code class="reqn">\sigma_j \in \{-1,1\}, j = 1, \ldots, p</code>.</p>



<h4>Weighted orthonormal bases</h4>

<p> The parameters <code>argvals, M,
eFunType</code> and <code>ignoreDeg</code> are all lists of a similar structure. They are
passed element-wise to the function <code>eFun</code> to generate
orthonormal basis functions for each element of the multivariate functional
data to be simulated. In case of bivariate elements (images), the
corresponding basis functions are constructed as tensor products of
orthonormal basis functions in each direction (x- and y-direction).
</p>
<p>If the <code class="reqn">j</code>-th element of the simulated data should be defined on a
one-dimensional domain, then </p>
 <ul>
<li> <p><code>argvals[[j]]</code> is a list,
containing one vector of observation points. </p>
</li>
<li> <p><code>M[[j]]</code> is an
integer, specifying the number of basis functions to use for this entry.
</p>
</li>
<li>  <p><code>eFunType[[j]]</code> is a character string, specifying the type of
orthonormal basis functions to use for this entry (see <code>eFun</code> for
possible options). </p>
</li>
<li> <p><code>ignoreDeg[[j]]</code> is a vector of integers,
specifying the degrees to ignore when constructing the orthonormal basis
functions. The default value is <code>NULL</code>. </p>
</li>
</ul>
<p>If the <code class="reqn">j</code>-th element of the simulated data should be defined on a
two-dimensional domain, then </p>
 <ul>
<li> <p><code>argvals[[j]]</code> is a list,
containing two vectors of observation points, one for each direction
(observation points in x-direction and in y-direction). </p>
</li>
<li> <p><code>M[[j]]</code>
is a vector of two integers, giving the number of basis functions for each
direction (x- and y-direction). </p>
</li>
<li> <p><code>eFunType[[j]]</code> is a vector of two
character strings, giving the type of orthonormal basis functions for each
direction (x- and y-direction, see <code>eFun</code> for possible options).
The corresponding basis functions are constructed as tensor products of
orthonormal basis functions in each direction. </p>
</li>
<li> <p><code>ignoreDeg[[j]]</code> is
a list, containing two integer vectors that specify the degrees to ignore
when constructing the orthonormal basis functions in each direction. The
default value is <code>NULL</code>. </p>
</li>
</ul>
<p> The total number of basis functions (i.e. the
product of <code>M[[j]]</code> for all <code>j</code>) must be equal!</p>

<p>This code is a direct copy of the function <code>simMultiFunData</code> in the
<code>funData</code> package (version 1.3-9) and slightly adapted. It also returns
the simulated scores and needs the additional argument <code>seed</code> to
generate reproducible eigenvalues and eigenfunctions.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>simData</code></td>
<td>
<p>A <code>multiFunData</code> object with
<code>N</code> observations, representing the simulated multivariate functional
data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trueFuns</code></td>
<td>
<p>A <code>multiFunData</code> object with
<code>M</code> observations, representing the multivariate eigenfunction basis
used for simulating the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trueVals</code></td>
<td>
<p>A vector of numerics,
representing the eigenvalues used for simulating the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>A
matrix containing the simulated scores.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>C. Happ, S. Greven (2018): Multivariate Functional Principal
Component Analysis for Data Observed on Different (Dimensional) Domains.
Journal of the American Statistical Association, 113(522): 649-659.
</p>


<h3>Examples</h3>

<pre><code class="language-R">oldPar &lt;- par(no.readonly = TRUE)
library(funData)

# split
split &lt;- simMuFu(type = "split", argvals = list(seq(0,1,0.01),
                                                seq(-0.5,0.5,0.02)),
                 M = 5, eFunType = "Poly", eValType = "linear", N = 7,
                 seed = 2)

par(mfrow = c(1,2))
plot(split$trueFuns, main = "Split: True Eigenfunctions", ylim = c(-2,2))
plot(split$simData, main = "Split: Simulated Data")

# weighted (one-dimensional domains)

par(oldPar)

</code></pre>


</div>