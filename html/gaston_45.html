<div class="container">

<table style="width: 100%;"><tr>
<td>LD.thin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> LD thinning </h2>

<h3>Description</h3>

<p> Select SNPs in LD below a given threshold. </p>


<h3>Usage</h3>

<pre><code class="language-R">LD.thin(x, threshold, max.dist = 500e3, beg = 1, end = ncol(x),
        which.snps, dist.unit = c("bases", "indices", "cM"), 
        extract = TRUE, keep = c("left", "right", "random"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> A <code>bed.matrix</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p> The maximum LD (measured by <code class="reqn">r^2</code>) between SNPs </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.dist</code></td>
<td>
<p> The maximum distance for which the LD is computed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beg</code></td>
<td>
<p> The index of the first SNP to consider </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p> The index of the last SNP to consider </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.snps</code></td>
<td>
<p> Logical vector, giving which SNPs are considerd. The default is to use all SNPs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.unit</code></td>
<td>
<p> Distance unit in <code>max.dist</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extract</code></td>
<td>
<p> A <code>logical</code> indicating whether the function return a <code>bed.matrix</code> (<code>TRUE</code>) 
or a logical vector indicating which SNPs are selected (<code>FALSE</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p> Which SNP is selected in a pair with LD above <code>threshold</code> </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The SNPs to keep are selected by a greedy algorithm. The LD is computed only for SNP pairs for which distance is inferior to 
<code>max.dist</code>, expressed in number of bases if <code>dist.unit = "bases"</code>, in number of SNPs if <code>dist.unit = "indices"</code>,
or in centiMorgan if <code>dist.unit = "cM"</code>. 
</p>
<p>The argument <code>which.snps</code> allows to consider only a subset of SNPs.
</p>
<p>The algorithm tries to keep the largest possible number of SNPs: it is not appropriate to select tag-SNPs.
</p>


<h3>Value</h3>

<p>If <code>extract = TRUE</code>, a <code>bed.matrix</code> extracted from <code>x</code> with SNPs in pairwise LD below the given threshold.
If <code>extract = FALSE</code>, a logical vector of length <code>end - beg + 1</code>, where <code>TRUE</code> indicates that 
the corresponding SNPs is selected.
</p>


<h3>Author(s)</h3>

<p> Herv√© Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code>LD</code>, <code>set.dist</code> </p>


<h3>Examples</h3>

<pre><code class="language-R"># Load data
data(TTN)
x &lt;- as.bed.matrix(TTN.gen, TTN.fam, TTN.bim)

# Select SNPs in LD r^2 &lt; 0.4, max.dist = 500 kb
y &lt;- LD.thin(x, threshold = 0.4, max.dist = 500e3)
y

# Verifies that there is no SNP pair with LD r^2 &gt; 0.4
# (note that the matrix ld.y has ones on the diagonal)
ld.y &lt;- LD( y, lim = c(1, ncol(y)) )
sum( ld.y &gt; 0.4 )  
</code></pre>


</div>