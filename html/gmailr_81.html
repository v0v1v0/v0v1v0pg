<div class="container">

<table style="width: 100%;"><tr>
<td>gm_token_write</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Write/read a gmailr user token</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>This pair of functions writes an OAuth2 user token to file and reads it back
in. This is rarely necessary when working in your primary, interactive
computing environment. In that setting, it is recommended to lean into the
automatic token caching built-in to gmailr / gargle. However, when preparing
a user token for use elsewhere, such as in CI or in a deployed data product,
it can be useful to take the full control granted by <code>gm_token_write()</code> and
<code>gm_token_read()</code>.
</p>
<p>Below is an outline of the intended workflow, but you will need to fill in
particulars, such as filepaths and environment variables:
</p>

<ul>
<li>
<p> Do auth in your primary, interactive environment as the target user, with
the desired OAuth client and scopes.
</p>
<div class="sourceCode r"><pre>gm_auth_configure()
gm_auth("jane@example.com", cache = FALSE)
</pre></div>
</li>
<li>
<p> Confirm you are logged in as the intended user:
</p>
<div class="sourceCode r"><pre>gm_profile()
</pre></div>
</li>
<li>
<p> Write the current token to file:
</p>
<div class="sourceCode r"><pre>gm_token_write(
  path = "path/to/gmailr-token.rds",
  key = "GMAILR_KEY"
)
</pre></div>
</li>
<li>
<p> In the deployed, non-interactive setting, read the token from file and
tell gmailr to use it:
</p>
<div class="sourceCode r"><pre>gm_auth(token = gm_token_read(
  path = "path/to/gmailr-token.rds",
  key = "GMAILR_KEY"
)
</pre></div>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">gm_token_write(token = gm_token(), path = "gmailr-token.rds", key = NULL)

gm_token_read(path = "gmailr-token.rds", key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>token</code></td>
<td>
<p>A token with class Token2.0 or an object of
httr's class <code>request</code>, i.e. a token that has been prepared with
<code>httr::config()</code> and has a Token2.0 in the
<code>auth_token</code> component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>The path to write to (<code>gm_token_write()</code>) or to read from
(<code>gm_token_read()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key</code></td>
<td>
<p>Encryption key, as implemented by httr2's <a href="https://httr2.r-lib.org/reference/secrets.html">secret functions</a>. If absent, a
built-in <code>key</code> is used. If supplied, the <code>key</code> should usually be the name
of an environment variable whose value was generated with
<code>gargle::secret_make_key()</code> (which is a copy of
<code>httr2::secret_make_key()</code>). The <code>key</code> argument of <code>gm_token_read()</code> must
match the <code>key</code> used in <code>gm_token_write()</code>.</p>
</td>
</tr>
</table>
<h3>Security</h3>

<p><code>gm_token_write()</code> and <code>gm_token_read()</code> have a more security-oriented
implementation than the default token caching strategy. OAuth2 user tokens
are somewhat opaque by definition, because they aren't written to file in a
particularly transparent format. However, <code>gm_token_write()</code> always applies
some additional obfuscation to make such credentials even more resilient
against scraping by an automated tool. However, a knowledgeable R programmer
could decode the credential with some effort. The default behaviour of
<code>gm_token_write()</code> (called without <code>key</code>) is suitable for tokens stored in a
relatively secure place, such as on Posit Connect within your organization.
</p>
<p>To prepare a stored credential for exposure in a more public setting, such as
on GitHub or CRAN, you must actually encrypt it, using a <code>key</code> known only to
you. You must make the encryption <code>key</code> available via a secure environment
variable in any setting where you wish to decrypt and use the token, such as
on GitHub Actions.
</p>


</div>