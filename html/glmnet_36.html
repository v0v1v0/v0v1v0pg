<div class="container">

<table style="width: 100%;"><tr>
<td>cv.glmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for glmnet</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation for glmnet, produces a plot, and returns a
value for <code>lambda</code> (and <code>gamma</code> if <code>relax=TRUE</code>)
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.glmnet(
  x,
  y,
  weights = NULL,
  offset = NULL,
  lambda = NULL,
  type.measure = c("default", "mse", "deviance", "class", "auc", "mae", "C"),
  nfolds = 10,
  foldid = NULL,
  alignment = c("lambda", "fraction"),
  grouped = TRUE,
  keep = FALSE,
  parallel = FALSE,
  gamma = c(0, 0.25, 0.5, 0.75, 1),
  relax = FALSE,
  trace.it = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>x</code> matrix as in <code>glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response <code>y</code> as in <code>glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Offset vector (matrix) as in <code>glmnet</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code>glmnet</code> chooses its own sequence. Note that this is done
for the full model (master sequence), and separately for each fold.
The fits are then alligned using the master sequence (see the <code>allignment</code>
argument for additional details). Adapting <code>lambda</code> for each fold
leads to better convergence. When <code>lambda</code> is supplied, the same sequence
is used everywhere, but in some GLMs can lead to convergence issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently five
options, not all available for all models. The default is
<code>type.measure="deviance"</code>, which uses squared-error for gaussian models
(a.k.a <code>type.measure="mse"</code> there), deviance for logistic and poisson
regression, and partial-likelihood for the Cox model.
<code>type.measure="class"</code> applies to binomial and multinomial logistic
regression only, and gives misclassification error.
<code>type.measure="auc"</code> is for two-class logistic regression only, and
gives area under the ROC curve. <code>type.measure="mse"</code> or
<code>type.measure="mae"</code> (mean absolute error) can be used by all models
except the <code>"cox"</code>; they measure the deviation from the fitted mean to
the response.
<code>type.measure="C"</code> is Harrel's concordance measure, only available for <code>cox</code> models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds - default is 10. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds=3</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfolds</code>
identifying what fold each observation is in. If supplied, <code>nfolds</code> can
be missing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alignment</code></td>
<td>
<p>This is an experimental argument, designed to fix the
problems users were having with CV, with possible values <code>"lambda"</code>
(the default) else <code>"fraction"</code>. With <code>"lambda"</code> the <code>lambda</code>
values from the master fit (on all the data) are used to line up the
predictions from each of the folds. In some cases this can give strange
values, since the effective <code>lambda</code> values in each fold could be quite
different. With <code>"fraction"</code> we line up the predictions in each fold
according to the fraction of progress along the regularization. If in the
call a <code>lambda</code> argument is also provided, <code>alignment="fraction"</code>
is ignored (with a warning).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouped</code></td>
<td>
<p>This is an experimental argument, with default <code>TRUE</code>,
and can be ignored by most users. For all models except the <code>"cox"</code>,
this refers to computing <code>nfolds</code> separate statistics, and then using
their mean and estimated standard error to describe the CV curve. If
<code>grouped=FALSE</code>, an error matrix is built up at the observation level
from the predictions from the <code>nfolds</code> fits, and then summarized (does
not apply to <code>type.measure="auc"</code>). For the <code>"cox"</code> family,
<code>grouped=TRUE</code> obtains the CV partial likelihood for the Kth fold by
<em>subtraction</em>; by subtracting the log partial likelihood evaluated on
the full dataset from that evaluated on the on the (K-1)/K dataset. This
makes more efficient use of risk sets. With <code>grouped=FALSE</code> the log
partial likelihood is computed only on the Kth fold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>If <code>keep=TRUE</code>, a <em>prevalidated</em> array is returned
containing fitted values for each observation and each value of
<code>lambda</code>. This means these fits are computed with this observation and
the rest of its fold omitted. The <code>foldid</code> vector is also returned.
Default is keep=FALSE.  If <code>relax=TRUE</code>, then a list of such arrays is
returned, one for each value of 'gamma'. Note: if the value 'gamma=1' is
omitted, this case is included in the list since it corresponds to the
original 'glmnet' fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>If <code>TRUE</code>, use parallel <code>foreach</code> to fit each
fold.  Must register parallel before hand, such as <code>doMC</code> or others.
See the example below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>The values of the parameter for mixing the relaxed fit with the
regularized fit, between 0 and 1; default is <code>gamma = c(0, 0.25, 0.5,
0.75, 1)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relax</code></td>
<td>
<p>If <code>TRUE</code>, then CV is done with respect to the mixing
parameter <code>gamma</code> as well as <code>lambda</code>. Default is
<code>relax=FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then progress bars are displayed;
useful for big models that take a long time to fit. Limited tracing if
<code>parallel=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function runs <code>glmnet</code> <code>nfolds</code>+1 times; the first to get the
<code>lambda</code> sequence, and then the remainder to compute the fit with each
of the folds omitted. The error is accumulated, and the average error and
standard deviation over the folds is computed.  Note that <code>cv.glmnet</code>
does NOT search for values for <code>alpha</code>. A specific value should be
supplied, else <code>alpha=1</code> is assumed by default. If users would like to
cross-validate <code>alpha</code> as well, they should call <code>cv.glmnet</code> with
a pre-computed vector <code>foldid</code>, and then use this same fold vector in
separate calls to <code>cv.glmnet</code> with different values of <code>alpha</code>.
Note also that the results of <code>cv.glmnet</code> are random, since the folds
are selected at random. Users can reduce this randomness by running
<code>cv.glmnet</code> many times, and averaging the error curves.
</p>
<p>If <code>relax=TRUE</code> then the values of <code>gamma</code> are used to mix the
fits. If <code class="reqn">\eta</code> is the fit for lasso/elastic net, and <code class="reqn">\eta_R</code> is
the relaxed fit (with unpenalized coefficients), then a relaxed fit mixed by
<code class="reqn">\gamma</code> is </p>
<p style="text-align: center;"><code class="reqn">\eta(\gamma)=(1-\gamma)\eta_R+\gamma\eta.</code>
</p>
<p> There is
practically no extra cost for having a lot of values for <code>gamma</code>.
However, 5 seems sufficient for most purposes. CV then selects both
<code>gamma</code> and <code>lambda</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.glmnet"</code> is returned, which is a list
with the ingredients of the cross-validation fit.  If the object was created
with <code>relax=TRUE</code> then this class has a prefix class of
<code>"cv.relaxed"</code>.  </p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the
fits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p>The mean cross-validated error - a vector of length
<code>length(lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvsd</code></td>
<td>
<p>estimate of standard error of
<code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>lower
curve = <code>cvm-cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients at
each <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>a text string indicating type of measure
(for plotting purposes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glmnet.fit</code></td>
<td>
<p>a fitted glmnet object for the
full data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>value of <code>lambda</code> that gives minimum
<code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>largest value of <code>lambda</code> such that
error is within 1 standard error of the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.preval</code></td>
<td>
<p>if
<code>keep=TRUE</code>, this is the array of prevalidated fits. Some entries can
be <code>NA</code>, if that and subsequent values of <code>lambda</code> are not reached
for that fold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>if <code>keep=TRUE</code>, the fold assignments used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>a one column matrix with the indices of <code>lambda.min</code> and <code>lambda.1se</code> in the sequence of coefficients, fits etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relaxed</code></td>
<td>
<p>if <code>relax=TRUE</code>, this additional item has the CV info
for each of the mixed fits. In particular it also selects <code>lambda,
gamma</code> pairs corresponding to the 1se rule, as well as the minimum error. It also has a component <code>index</code>, a two-column matrix  which contains the <code>lambda</code> and <code>gamma</code> indices corresponding to the "min" and "1se" solutions.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jerome Friedman, Trevor Hastie and Rob Tibshirani<br> Noah Simon
helped develop the 'coxnet' function.<br> Jeffrey Wong and B. Narasimhan
helped with the parallel option<br> Maintainer: Trevor Hastie
<a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008)
<em>Regularization Paths for Generalized Linear Models via Coordinate
Descent (2010), Journal of Statistical Software, Vol. 33(1), 1-22</em>,
<a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>.<br>
Simon, N., Friedman, J., Hastie, T. and Tibshirani, R. (2011)
<em>Regularization Paths for Cox's Proportional
Hazards Model via Coordinate Descent, Journal of Statistical Software, Vol.
39(5), 1-13</em>,
<a href="https://doi.org/10.18637/jss.v039.i05">doi:10.18637/jss.v039.i05</a>.
</p>


<h3>See Also</h3>

<p><code>glmnet</code> and <code>plot</code>, <code>predict</code>, and <code>coef</code>
methods for <code>"cv.glmnet"</code> and <code>"cv.relaxed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(1010)
n = 1000
p = 100
nzc = trunc(p/10)
x = matrix(rnorm(n * p), n, p)
beta = rnorm(nzc)
fx = x[, seq(nzc)] %*% beta
eps = rnorm(n) * 5
y = drop(fx + eps)
px = exp(fx)
px = px/(1 + px)
ly = rbinom(n = length(px), prob = px, size = 1)
set.seed(1011)
cvob1 = cv.glmnet(x, y)
plot(cvob1)
coef(cvob1)
predict(cvob1, newx = x[1:5, ], s = "lambda.min")
title("Gaussian Family", line = 2.5)
set.seed(1011)
cvob1a = cv.glmnet(x, y, type.measure = "mae")
plot(cvob1a)
title("Gaussian Family", line = 2.5)
set.seed(1011)
par(mfrow = c(2, 2), mar = c(4.5, 4.5, 4, 1))
cvob2 = cv.glmnet(x, ly, family = "binomial")
plot(cvob2)
title("Binomial Family", line = 2.5)
frame()
set.seed(1011)
cvob3 = cv.glmnet(x, ly, family = "binomial", type.measure = "class")
plot(cvob3)
title("Binomial Family", line = 2.5)
## Not run: 
cvob1r = cv.glmnet(x, y, relax = TRUE)
plot(cvob1r)
predict(cvob1r, newx = x[, 1:5])
set.seed(1011)
cvob3a = cv.glmnet(x, ly, family = "binomial", type.measure = "auc")
plot(cvob3a)
title("Binomial Family", line = 2.5)
set.seed(1011)
mu = exp(fx/10)
y = rpois(n, mu)
cvob4 = cv.glmnet(x, y, family = "poisson")
plot(cvob4)
title("Poisson Family", line = 2.5)

# Multinomial
n = 500
p = 30
nzc = trunc(p/10)
x = matrix(rnorm(n * p), n, p)
beta3 = matrix(rnorm(30), 10, 3)
beta3 = rbind(beta3, matrix(0, p - 10, 3))
f3 = x %*% beta3
p3 = exp(f3)
p3 = p3/apply(p3, 1, sum)
g3 = glmnet:::rmult(p3)
set.seed(10101)
cvfit = cv.glmnet(x, g3, family = "multinomial")
plot(cvfit)
title("Multinomial Family", line = 2.5)
# Cox
beta = rnorm(nzc)
fx = x[, seq(nzc)] %*% beta/3
hx = exp(fx)
ty = rexp(n, hx)
tcens = rbinom(n = n, prob = 0.3, size = 1)  # censoring indicator
y = cbind(time = ty, status = 1 - tcens)  # y=Surv(ty,1-tcens) with library(survival)
foldid = sample(rep(seq(10), length = n))
fit1_cv = cv.glmnet(x, y, family = "cox", foldid = foldid)
plot(fit1_cv)
title("Cox Family", line = 2.5)
# Parallel
require(doMC)
registerDoMC(cores = 4)
x = matrix(rnorm(1e+05 * 100), 1e+05, 100)
y = rnorm(1e+05)
system.time(cv.glmnet(x, y))
system.time(cv.glmnet(x, y, parallel = TRUE))

## End(Not run)

</code></pre>


</div>