<div class="container">

<table style="width: 100%;"><tr>
<td>RRprofStop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
RRprofStop
</h2>

<h3>Description</h3>

<p>Once the R expressions to be profiled have finished, the profile is stopped.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RRprofStop()
</code></pre>


<h3>Author(s)</h3>

<p>Fernando de Villar and Angel Rubio
</p>


<h3>See Also</h3>

<p><code>RRprofStart</code>, <code>RRprofReport</code>, <code>Rprof</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">temp&lt;-tempdir()
# Definition of two functions
normal.solve &lt;- function(A,b) {
  Output &lt;- solve(crossprod(A), t(A)%*%b)
}

chol.solve &lt;- function(A,b) {
  L &lt;- chol(crossprod(A))
  Output1 &lt;- backsolve(L, t(A)%*%b, transpose=TRUE)
  Output2 &lt;- backsolve(L, Output1)
}

compareMethods &lt;- function() {
  library(MASS)
  # Call the functions
  source(paste(temp,"/normal.solve.R",sep=""))
  source(paste(temp,"/chol.solve.R",sep=""))
  # Solving a big system of equations
  nrows &lt;- 1000
  ncols &lt;- 500
  A &lt;- matrix(rnorm(nrows*ncols),nrows,ncols)
  b &lt;- rnorm(nrows)
  # Testing different possibilities
  Sol1 &lt;- qr.solve(A,b) # Using QR factorization
  Sol2 &lt;- coefficients(lm.fit(A,b)) # lm.fit, based on QR but with some overhead
  Sol3 &lt;- ginv(A) %*% b # Using the pseudoinverse based on SVD
  Sol4 &lt;- normal.solve(A,b) # Using a function based on the normal equations.
  Sol5 &lt;- chol.solve(A,b) # Using a function based on the Choleski factorization.
}

# Dump these functions to three different files

dump("normal.solve",file=paste(temp,"/normal.solve.R",sep=""))
dump("chol.solve",file=paste(temp,"/chol.solve.R",sep=""))
dump("compareMethods",file=paste(temp,"/compareMethods.R",sep=""))
source(paste(temp,"/compareMethods.R",sep=""))

# Profile the code

RRprofStart()
compareMethods()
RRprofStop()
# Uncomment to open the report
#RRprofReport()

</code></pre>


</div>