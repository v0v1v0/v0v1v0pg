<div class="container">

<table style="width: 100%;"><tr>
<td>anis_GSLIBpar2A</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Produce anisotropy scaling matrix from angle and anisotropy ratios</h2>

<h3>Description</h3>

<p>Produce anisotropy matrix (as the transposed of the Cholesky
decomposition) from angle and anisotropy ratios
</p>


<h3>Usage</h3>

<pre><code class="language-R">anis_GSLIBpar2A(ratios, angles, inv = FALSE)

anis2D_par2A(ratio, angle, inv = FALSE)

anis3D_par2A(ratios, angles, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ratios</code></td>
<td>
<p>vector of two values between 0 and 1 giving the anisotropy ratios of
medium/largest smallest/largest ranges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angles</code></td>
<td>
<p>as defined in gstat::vgm (and indeed GSLIB). For <code>anis2D_par2A</code> 'angle' is the direction of maximum range, i.e. largest spatial continuity, measured clockwise from North</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv</code></td>
<td>
<p>boolean or integer, see <code>return</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>an anisotropy ratio (min/max range)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle</code></td>
<td>
<p>direction of maximum range, i.e. largest spatial continuity, measured
clockwise from North</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a 3x3 matrix of anisotropy.
</p>
<p>If <code>inv=TRUE</code> (or 1) the output is a matrix <code>A</code> such that <code>norm(h %*% A)</code>
allows to use isotropic variograms, being <code>h = c(hx, hy, hz)</code> the lag vectors.
</p>
<p>If <code>inv=FALSE</code> (or 0) the output is a matrix <code>A</code> such that <code>norm(h %*% solve(A))</code>
allows to use isotropic variograms.
</p>
<p>Other values are meaningless.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>anis2D_par2A</code>: 2D case
</p>
</li>
<li> <p><code>anis3D_par2A</code>: 3D case
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other anisotropy: 
<code>AnisotropyRangeMatrix()</code>,
<code>AnisotropyScaling()</code>,
<code>as.AnisotropyRangeMatrix()</code>,
<code>as.AnisotropyScaling()</code>,
<code>is.anisotropySpecification()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ratio=0.5, azimuth 30?? (i.e. direction 60??)
A = anis2D_par2A(1, 30)
A
AAt = A %*% t(A)
 #  project the bisector 1:1 (i.e. 45??)
(k = c(1,1,0) %*% A)
atan2(k[2], k[1]) * 180/pi  # should be 15
sqrt(sum(k^2))
sqrt( c(1,1,0) %*% AAt %*% c(1,1,0) )
A = anis2D_par2A(0.5, 60)
rd = 60 * pi/180
A
A %*% t(A)
c(cos(rd), sin(rd),0) %*% A #  should be 1
c(-sin(rd), cos(rd),0) %*% A #  should be +/- sqrt(2)
c60 = cos(60*pi/180)
s60 = sin(60*pi/180)
c30 = cos(30*pi/180)
s30 = sin(30*pi/180)
#  in the new coordinates, 60cwN is (0,1,0)
R60p = anis3D_par2A(ratios=c(1,1), angles=c(60,0,0))
c(s60, c60, 0) %*% R60p
R6030 = anis3D_par2A(ratios=c(1,1), angles=c(60,30,0))
# the original X axis is positive on newX and newY, but negative on newZ
c(1,0,0) %*% R6030
# rotate first direction 60 degrees azimuth, then dip 30degrees upwards
c( c60*c30, -s60*c30, s30) %*% R6030
(Ranis = anis3D_par2A(ratios=c(0.5,0.25), angles=c(60,30,0)) )
</code></pre>


</div>