<div class="container">

<table style="width: 100%;"><tr>
<td>graph-triangulate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Triangulation of an undirected graph</h2>

<h3>Description</h3>

<p>This function will triangulate an undirected graph by
adding fill-ins.
</p>


<h3>Usage</h3>

<pre><code class="language-R">triangulate(object, ...)

## Default S3 method:
triangulate(object, nLevels = NULL, result = NULL, check = TRUE, ...)

triang_mcwh(object, ...)

triang_elo(object, ...)

triang(object, ...)

## Default S3 method:
triang(object, control = list(), ...)

## Default S3 method:
triang_mcwh(object, nLevels = NULL, result = NULL, check = TRUE, ...)

## Default S3 method:
triang_elo(object, order = NULL, result = NULL, check = TRUE, ...)

triangulateMAT(amat, nLevels = rep(2, ncol(amat)), ...)

triang_mcwhMAT_(amat, nLevels = rep(2, ncol(amat)), ...)

triang_eloMAT_(amat, order)

triang_eloMAT(amat, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An undirected graph represented either as a <code>graphNEL</code>
object, an <code>igraph</code>, a (dense) <code>matrix</code>, a (sparse)
<code>dgCMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nLevels</code></td>
<td>
<p>The number of levels of the variables (nodes) when these are
discrete. Used in determining the triangulation using a
"minimum clique weight heuristic". See section 'details'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>The type (representation) of the result. Possible values are
<code>"graphNEL"</code>, <code>"igraph"</code>, <code>"matrix"</code>, <code>"dgCMatrix"</code>.
Default is the same as the type of <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>If <code>TRUE</code> (the default) it is checked whether the graph is
triangulated before doing the triangulation; gives a speed up if <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list controlling the triangulation; see 'examples'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Elimation order; a character vector or numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amat</code></td>
<td>
<p>Adjacency matrix; a (dense) <code>matrix</code>, or a (sparse)
<code>dgCMatrix</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are two type of functions: <code>triang</code> and <code>triangulate</code>
</p>
<p>The workhorse is the <code>triangulateMAT</code> function.
</p>
<p>The triangulation is made so as the total state space is kept low
by applying a minimum clique weight heuristic: When a fill-in is
necessary, the algorithm will search for an edge to add such that
the complete set to be formed will have as small a state-space as
possible. It is in this connection that the <code>nLevels</code> values
are used.
</p>
<p>Default (when <code>nLevels=NULL</code>) is to take <code>nLevels=2</code> for all
nodes. If <code>nLevels</code> is the same for all nodes then the heuristic aims
at keeping the clique sizes small.
</p>


<h3>Value</h3>

<p>A triangulated graph represented either as a <code>graphNEL</code>, a
(dense) <code>matrix</code> or a (sparse) <code>dgCMatrix</code>.
</p>


<h3>Note</h3>

<p>Care should be taken when specifying <code>nLevels</code> for other
representations than adjacency matrices: Since the <code>triangulateMAT</code>
function is the workhorse, any other representation is transformed to an
adjacency matrix and the order of values in <code>nLevels</code> most come in
the order of the nodes in the adjacency matrix representation.
</p>
<p>Currently there is no check for that the graph is undirected.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code>ug</code>, <code>dag</code>, <code>mcs</code>,
<code>mcsMAT</code>, <code>rip</code>, <code>ripMAT</code>,
<code>moralize</code>, <code>moralizeMAT</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## graphNEL
uG1 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a)
uG2 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="matrix")
uG3 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="dgCMatrix")

## Default triangulation: minimum clique weight heuristic
# (default is that each node is given the same weight):

tuG1 &lt;- triang(uG1)
## Same as
triang_mcwh(uG1)

## Alternative: Triangulation from a desired elimination order
# (default is that the order is order of the nodes in the graph):

triang(uG1, control=list(method="elo"))
## Same as:
triang_elo(uG1)

## More control: Define the number of levels for each node:
tuG1 &lt;- triang(uG1, control=list(method="mcwh", nLevels=c(2, 3, 2, 6, 4, 9))) 
tuG1 &lt;- triang_mcwh(uG1, nLevels=c(2, 3, 2, 6, 4, 9))

tuG1 &lt;- triang(uG1, control=list(method="elo", order=c("a", "e", "f")))
tuG1 &lt;- triang_elo(uG1, order=c("a", "e", "f"))

## graphNEL
uG1 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a)
tuG1 &lt;- triangulate(uG1)

## adjacency matrix
uG2 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="matrix")
tuG2 &lt;- triangulate(uG2)

## adjacency matrix (sparse)
uG2 &lt;- ug(~a:b + b:c + c:d + d:e + e:f + f:a, result="dgCMatrix")
tuG2 &lt;- triangulate(uG2)

</code></pre>


</div>