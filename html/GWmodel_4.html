<div class="container">

<table style="width: 100%;"><tr>
<td>gwr.model.selection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model selection for GWR with a given set of independent variables</h2>

<h3>Description</h3>

<p>This function selects one GWR model from many alternatives based on the AICc values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gwr.model.selection(DeVar=NULL,InDeVars=NULL, data=list(),bw=NULL,approach="CV",
               adaptive=F,kernel="bisquare",dMat=NULL,p=2, theta=0, longlat=F,
               parallel.method=F,parallel.arg=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>DeVar</code></td>
<td>
<p>dependent variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>InDeVars</code></td>
<td>
<p>a vector of independent variables for model selection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span>, or a sf object defined in package <span class="pkg">sf</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>bandwidth used in the weighting function, possibly calculated by <code>bw.gwr</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approach</code></td>
<td>
<p>specified by <b>CV</b> (<b>cv</b>) for cross validation approach or <b>AIC</b> (<b>aic</b>) 
for selecting bandwidth by AICc values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dMat</code></td>
<td>
<p>a pre-specified distance matrix, it can be calculated by the function <code>gw.dist</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the power of the Minkowski distance, default is 2, i.e. the Euclidean distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>an angle in radians to rotate the coordinate system, default is 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.method</code></td>
<td>
<p>Specified by 'FALSE' for serial approach, 
by '"omp"' for multi-thread approach implemented via OpenMP, 
by '"cluster"' for multi-process approach implemented via 'parallel' package,
by '"cuda"' for parallel approach implemented via CUDA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.arg</code></td>
<td>
<p>Set the argument for parallel approach. 
If 'parallel.method' is 'FALSE', there is no need to set its value. 
If 'parallel.method' is '"omp"', its value is used to set how many threads should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '"cluster"', its value is used to set how many R session should be created (default by cores of *cores of CPU* - 1).
If 'parallel.method' is '"cuda"', its value is used to set how many samples is included in one group during the calibration. This value should not be too big to avoid the overflow of GPU memory. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model.list</code></td>
<td>
<p>a list of all the tried GWR models consisted of formulas and variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GWR.df</code></td>
<td>
<p>a data frame consited of four columns: bandwidth, AIC, AICc, RSS</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The algorithm for selecting GWR models consists of the following four steps:
</p>
<p>Step 1. Start by calibrating all the possible bivariate GWR models by sequentially regressing
a single independent variable against the dependent variable; 
</p>
<p>Step 2. Find the best performing model which produces the minimum AICc value, and permanently include the corresponding independent
variable in subsequent models; 
</p>
<p>Step 3. Sequentially introduce a variable from the remaining
group of independent variables to construct new models with the permanently included independent variables,
and determine the next permanently included variable from the best fitting model that has
the minimum AICc value; 
</p>
<p>Step 4. Repeat step 3 until all the independent variables are permanently
included in the model.
</p>
<p>In this procedure, the independent variables are iteratively included into the model in a "forward" direction.
Note that there is a clear distinction between the different number of involved variables in a
selection step, which can be called model levels.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Lu, B, Charlton, M, Harris, P, Fotheringham, AS (2014) Geographically weighted regression 
with a non-Euclidean distance metric: a case study using hedonic house price data. 
International Journal of Geographical Information Science 28(4): 660-681
</p>


<h3>See Also</h3>

<p><code>gwr.model.view</code>, <code>gwr.model.sort</code></p>


</div>