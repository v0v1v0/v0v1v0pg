<div class="container">

<table style="width: 100%;"><tr>
<td>penalty</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract and tidy penalty matrices</h2>

<h3>Description</h3>

<p>Extract and tidy penalty matrices
</p>


<h3>Usage</h3>

<pre><code class="language-R">penalty(object, ...)

## Default S3 method:
penalty(object, rescale = FALSE, data, knots = NULL, constraints = FALSE, ...)

## S3 method for class 'gam'
penalty(
  object,
  select = NULL,
  smooth = deprecated(),
  rescale = FALSE,
  partial_match = FALSE,
  ...
)

## S3 method for class 'mgcv.smooth'
penalty(object, rescale = FALSE, ...)

## S3 method for class 'tensor.smooth'
penalty(object, margins = FALSE, ...)

## S3 method for class 't2.smooth'
penalty(object, margins = FALSE, ...)

## S3 method for class 're.smooth.spec'
penalty(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted GAM or a smooth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale</code></td>
<td>
<p>logical; by default, <em>mgcv</em> will scale the penalty matrix for
better performance in <code>mgcv::gamm()</code>. If <code>rescale</code> is <code>TRUE</code>, this scaling
will be undone to put the penalty matrix back on the original scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame; a data frame of values for terms mentioned in the
smooth specification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>a list or data frame with named components containing
knots locations. Names must match the covariates for which the basis
is required. See <code>mgcv::smoothCon()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>logical; should identifiability constraints be applied to
the smooth basis. See argument <code>absorb.cons</code> in <code>mgcv::smoothCon()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>character, logical, or numeric; which smooths to extract
penalties for. If <code>NULL</code>, the default, then penalties for all model
smooths are drawn. Numeric <code>select</code> indexes the smooths in the order they
are specified in the formula and stored in <code>object</code>. Character <code>select</code>
matches the labels for smooths as shown for example in the output from
<code>summary(object)</code>. Logical <code>select</code> operates as per numeric <code>select</code> in
the order that smooths are stored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Use <code>select</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margins</code></td>
<td>
<p>logical; extract the penalty matrices for the tensor
product or the marginal smooths of the tensor product?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A 'tibble' (data frame) of class <code>penalty_df</code> inheriting from
<code>tbl_df</code>, with the following components:
</p>

<ul>
<li> <p><code>.smooth</code> - character; the label <em>mgcv</em> uses to refer to the smooth,
</p>
</li>
<li> <p><code>.type</code> - character; the type of smooth,
</p>
</li>
<li> <p><code>.penalty</code> - character; the label for the specific penalty. Some smooths
have multiple penalty matrices, so the <code>penalty</code> component identifies the
particular penalty matrix and uses the labelling that <em>mgcv</em> uses
internally,
</p>
</li>
<li> <p><code>.row</code> - character; a label of the form <code>fn</code> where <code>n</code> is an integer for
the <code>n</code>th basis function, referencing the columns of the penalty matrix,
</p>
</li>
<li> <p><code>.col</code> - character; a label of the form <code>fn</code> where <code>n</code> is an integer for
the <code>n</code>th basis function, referencing the columns of the penalty matrix,
</p>
</li>
<li> <p><code>.value</code> - double; the value of the penalty matrix for the combination of
<code>row</code> and <code>col</code>,
</p>
</li>
</ul>
<h3>Note</h3>

<p>The <code>print()</code> method uses <code>base::zapsmall()</code> to turn very small numbers
into 0s for display purposes only; the underlying values of the penalty
matrix or matrices are not changed.
</p>
<p>For smooths that are subject to an eigendecomposition (e.g. the default
thin plate regression splines, <code>bs = "tp"</code>), the signs of the eigenvectors
are not defined and as such you can expect differences across systems in
the penalties for such smooths that are system-, OS-, and CPU architecture-
specific.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class="language-R">
load_mgcv()
dat &lt;- data_sim("eg4", n = 400, seed = 42)
m &lt;- gam(
  y ~ s(x0, bs = "cr") + s(x1, bs = "cr") +
    s(x2, by = fac, bs = "cr"),
  data = dat, method = "REML"
)

# penalties for all smooths
penalty(m)

# for a specific smooth
penalty(m, select = "s(x2):fac1")


</code></pre>


</div>