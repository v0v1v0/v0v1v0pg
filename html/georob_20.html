<div class="container">

<table style="width: 100%;"><tr>
<td>cv.georob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-Validating a Spatial Linear Model Fitted by <code>georob</code>
</h2>

<h3>Description</h3>

<p>This function assesses the goodness-of-fit of a spatial linear model by
<var>K</var>-fold cross-validation.  In more detail, the model is re-fitted
<var>K</var> times by robust (or Gaussian) (RE)ML, excluding each time
<var>1/K</var>th of the data.  The re-fitted models are used to compute robust
(or customary) external Kriging predictions for the omitted observations.
If the response variable is log-transformed then the Kriging predictions
can be optionally transformed back to the original scale of the
measurements.  S3methods for evaluating and plotting diagnostic summaries
of the cross-validation errors are described for the function
<code>validate.predictions</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'georob'
cv(object, formula = NULL, subset = NULL,
    method = c("block", "random"), nset = 10L, seed = NULL,
    sets = NULL, duplicates.in.same.set = TRUE, re.estimate = TRUE,
    param = object[["variogram.object"]][[1]][["param"]],
    fit.param = object[["variogram.object"]][[1]][["fit.param"]],
    aniso = object[["variogram.object"]][[1]][["aniso"]],
    fit.aniso = object[["variogram.object"]][[1]][["fit.aniso"]],
    variogram.object = NULL,
    use.fitted.param = TRUE, return.fit = FALSE,
    reduced.output = TRUE, lgn = FALSE,
    mfl.action = c("offset", "stop"),
    ncores = min(nset, parallel::detectCores()), verbose = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class of <code>"georob"</code>, see
<code>georobObject</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an optional formula for the regression model passed by
<code>update</code> to <code>georob</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character keyword, controlling whether subsets are formed
by partitioning data set into contiguous spatial <code>block</code>s by
<code>kmeans</code> (default) or <code>random</code>ly.  Ignored if
<code>sets</code> is non-<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nset</code></td>
<td>
<p>a positive integer defining the number <var>K</var> of subsets into
which the data set is partitioned (default: <code>nset = 10</code>).  Ignored
if <code>sets</code> is non-<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>an optional integer seed to initialize random number generation,
see <code>set.seed</code>. Ignored if <code>sets</code> is non-<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sets</code></td>
<td>
<p>an optional vector of the same length as the response vector
of the fitted model and with positive integers taking values in
<code class="reqn">(1,2,\ldots,K)</code>, defining in this way the <code class="reqn">K</code> subsets into which
the data set is split.  If <code>sets = NULL</code> (default) the partition is
randomly generated by <code>kmeans</code> or
<code>runif</code> (using possibly <code>seed</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duplicates.in.same.set</code></td>
<td>
<p>a logical scalar controlling whether
replicated observations at a given location are assigned to the same
subset when partitioning the data (default <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re.estimate</code></td>
<td>
<p>a logical scalar controlling whether the model is
re-fitted to the reduced data sets before computing the Kriging
predictions (<code>TRUE</code>, default) or whether the model passed in
<code>object</code> is used to compute the predictions for the omitted
observations, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>a named numeric vector or a matrix or data frame with
initial values of variogram parameters passed by
<code>update</code> to <code>georob</code>.  If <code>param</code> is
a matrix (or a data frame) then it must have <code>nset</code> rows and<br><code>length(object[["variogram.object"]][[1]][["param"]])</code> columns with
initial values of variogram parameters for the <code>nset</code>
cross-validation sets, and <code>colnames(param)</code> must match<br><code>names(object[["variogram.object"]][[1]][["param"]])</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.param</code></td>
<td>
<p>a named logical vector or a matrix or data frame
defining which variogram parameters should be adjusted by
<code>update</code>.  If <code>fit.param</code> is a matrix (or a data
frame) then it must have <code>nset</code> rows and<br><code>length(object[["variogram.object"]][[1]][["fit.param"]])</code> columns
with variogram parameter fitting flags for the <code>nset</code>
cross-validation sets, and <code>colnames(param)</code> must match<br><code>names(object[["variogram.object"]][[1]][["fit.param"]])</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aniso</code></td>
<td>
<p>a named numeric vector or a matrix or data frame with
initial values of anisotropy parameters passed by
<code>update</code> to <code>georob</code>.  If <code>aniso</code> is
a matrix (or a data frame) then it must have <code>nset</code> rows and<br><code>length(object[["variogram.object"]][[1]][["aniso"]])</code> columns with
initial values of anisotropy parameters for the <code>nset</code>
cross-validation sets, and <code>colnames(aniso)</code> must match<br><code>names(object[["variogram.object"]][[1]][["aniso"]])</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.aniso</code></td>
<td>
<p>a named logical vector or a matrix or data frame
defining which anisotropy parameters should be adjusted by
<code>update</code>.  If <code>fit.aniso</code> is a matrix (or a data
frame) then it must have <code>nset</code> rows and<br><code>length(object[["variogram.object"]][[1]][["fit.aniso"]])</code> columns
with anisotropy parameter fitting flags for the <code>nset</code>
cross-validation sets, and <code>colnames(param)</code> must match<br><code>names(object[["variogram.object"]][[1]][["fit.aniso"]])</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variogram.object</code></td>
<td>
<p>an optional list that gives initial values for
fitting a possibly nested variogram model for the cross-validation sets.
Each component is a list with the following components:
</p>

<ul>
<li>
<p><code>param</code>: an optional named numeric vector or a matrix or
data frame with initial values of variogram parameters passed by
<code>update</code> to <code>georob</code>.  If <code>param</code>
is a matrix (or a data frame) then it must have <code>nset</code> rows
and<br><code>length(object[["variogram.object"]][[i]][["param"]])</code>
columns with initial values of variogram parameters for the
<code>nset</code> cross-validation sets (<var>i</var> is the <var>i</var>th variogram
structure), and <code>colnames(param)</code> must match<br><code>names(object[["variogram.object"]][[i]][["param"]])</code>.
</p>
</li>
<li>
<p><code>fit.param</code>: an optional named logical vector or a matrix
or data frame defining which variogram parameters should be adjusted
by <code>update</code>.  If <code>fit.param</code> is a matrix (or
a data frame) then it must have <code>nset</code> rows and<br><code>length(object[["variogram.object"]][[i]][["fit.param"]])</code>
columns with variogram parameter fitting flags for the <code>nset</code>
cross-validation sets (<var>i</var> is the <var>i</var>th variogram structure),
and <code>colnames(param)</code> must match<br><code>names(object[["variogram.object"]][[i]][["fit.param"]])</code>.
</p>
</li>
<li>
<p><code>aniso</code>: an optional named numeric vector or a matrix or
data frame with initial values of anisotropy parameters passed by
<code>update</code> to <code>georob</code>.  If <code>aniso</code>
is a matrix (or a data frame) then it must have <code>nset</code> rows
and<br><code>length(object[["variogram.object"]][[i]][["aniso"]])</code>
columns with initial values of anisotropy parameters for the
<code>nset</code> cross-validation sets (<var>i</var> is the <var>i</var>th variogram
structure), and <code>colnames(aniso)</code> must match<br><code>names(object[["variogram.object"]][[i]][["aniso"]])</code>.
</p>
</li>
<li>
<p><code>fit.aniso</code>: an optional named logical vector or a matrix
or data frame defining which anisotropy parameters should be adjusted
by <code>update</code>.  If <code>fit.aniso</code> is a matrix (or
a data frame) then it must have <code>nset</code> rows and<br><code>length(object[["variogram.object"]][[i]][["fit.aniso"]])</code>
columns with anisotropy parameter fitting flags for the <code>nset</code>
cross-validation sets(<var>i</var> is the <var>i</var>th variogram structure),
and <code>colnames(param)</code> must match<br><code>names(object[["variogram.object"]][[i]][["fit.aniso"]])</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.fitted.param</code></td>
<td>
<p>a logical scalar controlling whether fitted values
of <code>param</code> (and <code>aniso</code> are used as initial values when
variogram parameters are fitted for the cross-validation sets (default
<code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.fit</code></td>
<td>
<p>a logical scalar controlling whether information about the fit
should be returned when re-estimating the model with the reduced data
sets (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduced.output</code></td>
<td>
<p>a logical scalar controlling whether the complete fitted
model objects, fitted to the reduced data sets, are returned
(<code>FALSE</code>) or only some components (<code>TRUE</code>, default, see
<em>Value</em>).  Ignored if <code>return.fit = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lgn</code></td>
<td>
<p>a logical scalar controlling whether Kriging predictions of a
log-transformed response should be transformed back to the original scale
of the measurements (default <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mfl.action</code></td>
<td>
<p>a character keyword controlling what is done when some
levels of factor(s) are not present in any of the subsets used to fit the
model.  The function either stops (<code>"stop"</code>) or treats the
respective factors as model offset (<code>"offset"</code>, default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer controlling how many cores are used for
parallelized computations, see <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console during model fitting.  Passed by
<code>update</code> to <code>georob</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed by <code>update</code>
to <code>georob</code>, see <em>Details</em>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><b>Note</b> that <em>the data frame passed as</em> <code>data</code>
<em>argument to</em> <code>georob</code> <em>must exist in the user workspace
when calling <code>cv.georob</code></em>.
</p>
<p><code>cv.georob</code> uses the packages <span class="pkg">parallel</span> and <span class="pkg">snowfall</span> for
parallelized computations.  By default, the function uses <code class="reqn">K</code> CPUs
but not more than are physically available (as returned by
<code>detectCores</code>).
</p>
<p><code>cv.georob</code> uses the function <code>update</code> to
re-estimated the model with the reduced data sets.  Therefore, any
argument accepted by <code>georob</code> except <code>data</code> can be
changed when re-fitting the model.  Some of them (e.g. <code>formula</code>,
<code>subset</code>, etc.)  are explicit arguments of <code>cv.georob</code>, but
also the remaining ones can be passed by <code>...</code> to the function.
</p>
<p>Practitioners in geostatistics commonly cross-validate a fitted model
without re-estimating the model parameters with the reduced data sets.
This is clearly an unsound practice (see <cite>Hastie et al., 2009, sec.
7.10</cite>).  Therefore, the argument <code>re.estimate</code> should always be set
to <code>TRUE</code>.  The alternative is provided only for historic reasons.
</p>


<h3>Value</h3>

<p>The method <code>cv.georob</code> returns an object of class <code>cv.georob</code>,
which is a list with the two
components <code>pred</code> and <code>fit</code>.
</p>
<p><code>pred</code> is a data frame with the coordinates and the
cross-validation prediction results with the following variables:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an integer vector defining to which of the <code class="reqn">K</code> subsets
an observation was assigned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the values of the (possibly log-transformed) response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>the Kriging predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>the Kriging standard errors.</p>
</td>
</tr>
</table>
<p>If <code>lgn = TRUE</code> then <code>pred</code> has the additional variables:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lgn.data</code></td>
<td>
<p>the untransformed response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lgn.pred</code></td>
<td>
<p>the unbiased back-transformed predictions of a
log-transformed response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lgn.se</code></td>
<td>
<p>the Kriging standard errors of the back-transformed
predictions of a<br> log-transformed response.</p>
</td>
</tr>
</table>
<p>The second component <code>fit</code> contains either the full outputs of
<code>georob</code>, fitted for the <code class="reqn">K</code> reduced data sets
(<code>reduced.output = FALSE</code>), or <code class="reqn">K</code> lists with the components
<code>tuning.psi</code>, <code>converged</code>, <br><code>convergence.code</code>,
<code>gradient</code>, <code>variogram.object</code>, <code>coefficients</code> along with
the standard errors of
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>, see
<code>georobObject</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Hastie, T., Tibshirani, R. and Friedman, J. (2009) <em>The Elements of
Statistical Learning; Data Mining, Inference and Prediction</em>, Springer,
New York, <a href="https://doi.org/10.1007/978-0-387-84858-7">doi:10.1007/978-0-387-84858-7</a> </p>


<h3>See Also</h3>

<p><code>georobPackage</code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code>georob</code> for (robust) fitting of spatial linear models;
</p>
<p><code>georobObject</code> for a description of the class <code>georob</code>;
</p>
<p><code>profilelogLik</code> for computing profiles of Gaussian likelihoods;
</p>
<p><code>plot.georob</code> for display of RE(ML) variogram estimates;
</p>
<p><code>control.georob</code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code>georobModelBuilding</code> for stepwise building models of class <code>georob</code>;

</p>
<p><code>georobMethods</code> for further methods for the class <code>georob</code>;
</p>
<p><code>predict.georob</code> for computing robust Kriging predictions;
</p>
<p><code>validate.predictions</code> for validating Kriging predictions;
</p>
<p><code>lgnpp</code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code>georobSimulation</code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code>sample.variogram</code> and <code>fit.variogram.model</code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## define number of cores for parallel computations
if(interactive()) ncpu &lt;- 10L else ncpu &lt;- 1L

data(meuse)

r.logzn &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
  variogram.model = "RMexp",
  param = c(variance = 0.15, nugget = 0.05, scale = 200),
  tuning.psi = 1000)

if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.logzn.cv.1 &lt;- cv(r.logzn, seed = 1, lgn = TRUE, ncores = 1, verbose = 1)

  r.logzn.cv.2 &lt;- cv(r.logzn, formula = .~. + ffreq, seed = 1, lgn = TRUE,
      ncores = ncpu)

  plot(r.logzn.cv.1, type = "bs")
  plot(r.logzn.cv.2, type = "bs", add = TRUE, col = "red")

  legend("topright", lty = 1, col = c("black", "red"), bty = "n",
      legend = c("log(Zn) ~ sqrt(dist)", "log(Zn) ~ sqrt(dist) + ffreq"))
}
</code></pre>


</div>