<div class="container">

<table style="width: 100%;"><tr>
<td>fitContinuous</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Model fitting for continuous comparative data </h2>

<h3>Description</h3>

<p>fitting macroevolutionary models to phylogenetic trees
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitContinuous(phy, dat, SE = 0,
    model = c("BM","OU","EB","rate_trend","lambda","kappa","delta","mean_trend","white"),
    bounds= list(), control = list(method = c("subplex","L-BFGS-B"),
    niter = 100, FAIL = 1e+200, hessian = FALSE, CI = 0.95), ncores=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phy</code></td>
<td>
<p> a phylogenetic tree of class phylo</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p> data vector for a single trait, with names matching tips in <code>phy</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SE</code></td>
<td>
<p> a single value or named vector of standard errors associated with values in <code>dat</code>; if any elements in the vector <code>SE</code> are NA, SE will be estimated </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p> model to fit to comparative data (see <b>Details</b>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p> range to constrain parameter estimates (see <b>Details</b>)  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p> settings used for optimization of the model likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p> Number of cores. If <code>NULL</code> then number of cores is detected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to the internal likelihood function <code>bm.lik</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function fits various likelihood models for continuous character evolution. The function
returns parameter estimates and the likelihood for univariate datasets.
</p>
<p>The model likelihood is maximized using methods available in <code>optim</code> as well as <code>subplex</code>.
Optimization methods to be used within <code>optim</code> can be specified through the <code>control</code> object (i.e., <code>control$method</code>).
</p>
<p>A number of random starting points are used in optimization and are given through the <code>niter</code> element within the <code>control</code> object
(e.g., <code>control$niter</code>). The <code>FAIL</code> value within the <code>control</code> object should be a large value
that will be considerably far from -lnL of the maximum model likelihood. In most cases, the default setting
for <code>control$FAIL</code> will be appropriate. The Hessian may be used to compute confidence intervals
(<code>CI</code>) for the parameter estimates if the <code>hessian</code> element in <code>control</code> is TRUE.
</p>
<p><em>Beware</em>: difficulty in finding the optimal solution is determined by an interaction between the nature and complexity of the
likelihood space (which is data- and model-dependent) and the numerical optimizer used to explore the space.  There is never a
guarantee that the optimal solution is found, but using many random starting points (<code>control$niter</code>) and many optimization methods
(<code>control$method</code>) will increase these odds.
</p>
<p>Bounds for the relevant parameters of the fitted model may be given through the <code>bounds</code> argument. Bounds
may be necessary (particularly under the <code>OU</code> model) if the likelihood surface is characterized by a long,
flat ridge which can be exceedingly difficult for optimization methods. Several bounds can be given at a time
(e.g., <code>bounds=list(SE=c(0,0.1),alpha=c(0,1))</code> would constrain measurement error as well as the 'constraint'
parameter of the Ornstein-Uhlenbeck model).  Default bounds under the different models are given below.
</p>
<p>Possible models are as follows:
</p>

<ul>
<li>
<p><b>BM</b> is the Brownian motion model (Felsenstein 1973), which assumes the correlation structure among trait values is proportional to the extent of shared ancestry
for pairs of species. Default bounds on the rate parameter are <code>sigsq=c(min=exp(-500),max=exp(100))</code>. The same bounds are applied to all other
models, which also estimate <code>sigsq</code>
</p>
</li>
<li>
<p><b>OU</b> is the Ornstein-Uhlenbeck model (Butler and King 2004), which fits a random walk with a central tendency with an attraction strength proportional to the parameter <code>alpha</code>.
The <code>OU</code> model is called the <code>hansen</code> model in <span class="pkg">ouch</span>, although the way the parameters are fit is slightly different here. Default
bounds are <code>alpha = c(min = exp(-500), max = exp(1))</code>
</p>
</li>
<li>
<p><b>EB</b> is the Early-burst model (Harmon et al. 2010) and also called the <code>ACDC</code> model (accelerating-decelerating; Blomberg et al. 2003). Set by the <code>a</code> rate parameter, <code>EB</code>
fits a model where the rate of evolution increases or decreases exponentially through time, under the model r[t] = r[0] * exp(a * t), where <code>r[0]</code> is the
initial rate, <code>a</code> is the rate change parameter, and <code>t</code> is time. The maximum bound is set to <code>-0.000001</code>, representing a decelerating rate of evolution. The minimum bound is set to log(10^-5)/depth of the tree.
</p>
</li>
<li>
<p><b>rate_trend</b> is a diffusion model with linear trend in rates through time (toward larger or smaller rates). Used to be denominated the <code>"trend"</code> model, which is still accepted by <code>fitContinuous</code> for backward compatibility. Default bounds are <code>slope = c(min = -100, max = 100)</code>
</p>
</li>
<li>
<p><b>lambda</b> is one of the Pagel (1999) models that fits the extent to which the phylogeny predicts covariance among trait values for species. The model effectively transforms the tree:
values of <code>lambda</code> near 0 cause the phylogeny to become more star-like, and a <code>lambda</code> value of 1 recovers the <code>BM</code> model. Default
bounds are <code>lambda = c(min = exp(-500), max = 1</code>
</p>
</li>
<li>
<p><b>kappa</b> is a punctuational (speciational) model of trait evolution (Pagel 1999), where character divergence is related to the number of speciation events between two species. Note that if
there are speciation events that are missing from the given phylogeny (due to extinction or incomplete sampling), interpretation under the <code>kappa</code> model may be difficult. Considered as a tree
transformation, the model raises all branch lengths to an estimated power (<code>kappa</code>). Default bounds are <code>kappa = c(min = exp(-500), max = 1)</code>  
</p>
</li>
<li>
<p><b>delta</b> is a time-dependent model of trait evolution (Pagel 1999).  The <code>delta</code> model is similar to <code>ACDC</code> insofar as the <code>delta</code> model fits the relative contributions of
early versus late evolution in the tree to the covariance of species trait values.  Where <code>delta</code> is greater than 1, recent evolution has been relatively fast; if <code>delta</code> is less
than 1, recent evolution has been comparatively slow. Intrepreted as a tree transformation, the model raises all node depths to an estimated power (<code>delta</code>). Default bounds are <code>delta = c(min = exp(-500), max = 3)</code>
</p>
</li>
<li>
<p><b>mean_trend</b> is a model of trait evolution with a directional drift or <em>trend</em> component (i.e., toward smaller or larger values through time).  This model is sensible only for non-ultrametric trees, as the likelihood surface is entirely flat with respect to the slope of the trend if the tree is ultrametric. The model used to be denominated the <code>"drift"</code> model, which is still accepted by <code>fitContinuous</code> for backward compatibility. Default bounds are <code>drift = c(min = -100, max = 100)</code>
</p>
</li>
<li>
<p><b>white</b> is a <code>white</code>-noise (non-phylogenetic) model, which assumes data come from a single normal distribution with no covariance structure among species. The variance parameter <code>sigsq</code>
takes the same bounds defined under the <code>BM</code> model
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>fitContinuous</code> returns a list with the following four elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code><b>lik</b> </code></td>
<td>
<p>is the function used to compute the model likelihood. The returned function (<code>lik</code>) takes arguments that are necessary for the given model.
For instance, if estimating a Brownian-motion model with unknown standard error, the arguments (<code>pars</code>) to the <code>lik</code> function would be <code>sigsq</code> and <code>SE</code>. By default, the function evaluates the likelihood of the model by assuming the maximum likelihood root state. This behavior can be changed in the call to <code>lik</code> with <code>lik(pars, root=ROOT.GIVEN)</code> where <code>pars</code> includes a value for the root state (z0). See <b>Examples</b> for a demonstration. The tree and data are stored internally within the <code>lik</code> function, which permits those elements to be efficiently reused when computing the likelihood under different parameter values
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code><b>bnd</b> </code></td>
<td>
<p>is a matrix of the used bounds for the relevant parameters estimated in the model. Warnings will be issued if any parameter estimates occur at the supplied (or default) parameter bounds
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code><b>res</b> </code></td>
<td>
<p>is a matrix of results from optimization. Rownames of the <code>res</code> matrix are the optimization methods
(see <code>optim</code> and <code>subplex</code>). The columns in the <code>res</code> matrix are the estimated
parameter values, the estimated model likelihood, and an indication of optimization convergence. Values of convergence not
equal to zero are not to be trusted
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code><b>opt</b> </code></td>
<td>
<p>is a list of the primary results: estimates of the parameters, the maximum-likelihood estimate (<code>lnL</code>) of the model, the
optimization method used to compute the MLE, the number of model parameters (<code>k</code>, including one parameter for the root state), the AIC (<code>aic</code>),
sample-size corrected AIC (<code>aicc</code>). The number of observations for AIC computation is taken to be the number of trait values observed.
If the Hessian is used, confidence intervals on the parameter estimates (<code>CI</code>) and the Hessian matrix (<code>hessian</code>) are also returned
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>To speed the likelihood search, one may set an environment variable to make use of parallel processing, used by <code>mclapply</code>. To set the environment variable, use <code>options(mc.cores=INTEGER)</code>, where <code>INTEGER</code> is the number of available cores. Alternatively, the <code>mc.cores</code> variable may be preset upon the initiation of an R session (see <code>Startup</code> for details).
</p>


<h3>Author(s)</h3>

<p>LJ Harmon, W Challenger, and JM Eastman</p>


<h3>References</h3>

<p>Blomberg SP, T Garland, and AR Ives. 2003. Testing for phylogenetic signal in comparative data: behavioral traits are more labile. <em>Evolution</em> 57:717-745.
</p>
<p>Butler MA and AA King, 2004. Phylogenetic comparative analysis: a modeling approach for adaptive evolution. <em>American Naturalist</em> 164:683-695.
</p>
<p>Felsenstein J. 1973. Maximum likelihood estimation of evolutionary trees from continuous characters. <em>American Journal of Human Genetics</em> 25:471-492.
</p>
<p>Harmon LJ et al. 2010. Early bursts of body size and shape evolution are rare in comparative data. <em>Evolution</em> 64:2385-2396.
</p>
<p>Pagel M. 1999. Inferring the historical patterns of biological evolution. <em>Nature</em> 401:877-884
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
geo=get(data(geospiza))

tmp=treedata(geo$phy, geo$dat)
phy=tmp$phy
dat=tmp$data

#---- STORE RESULTS
brownFit &lt;-  fitContinuous(phy, dat[,"wingL"], SE=NA, control=list(niter=50), ncores=2)

#---- PRINT RESULTS
print(names(brownFit))
print(brownFit)

\donttest{
#---- COMPUTE LIKELIHOOD
flik=brownFit$lik
print(argn(flik))

#---- CREATE a FUNCTION to COMPARE MODELS
fitGeospiza=function(trait=c("wingL","tarsusL","culmenL","beakD","gonysW")){

	trait=match.arg(trait, c("wingL","tarsusL","culmenL","beakD","gonysW"))

	# define set of models to compare
	models=c("BM", "OU", "EB", "white")
	summaries=c("diffusion", "Ornstein-Uhlenbeck", "early burst", "white noise")

	## ESTIMATING measurement error ##
	aic.se=numeric(length(models))
	lnl.se=numeric(length(models))

	for(m in 1:length(models)){
		cat("\n\n\n\n\t*** ", paste(toupper(summaries[m]),": fitting ", sep=""), models[m],
			" with SE *** \n", sep="")
		tmp=fitContinuous(phy,dat[,trait],SE=NA, model=models[m],
                                    bounds=list(SE=c(0,0.5)), ncores=2)
		print(tmp)
		aic.se[m]=tmp$opt$aicc
		lnl.se[m]=tmp$opt$lnL
	}


	## ASSUMING no measurement error ##
	aic=numeric(length(models))
	lnl=numeric(length(models))

	for(m in 1:length(models)){
		cat("\n\n\n\n\t*** ", paste(toupper(summaries[m]),": fitting ", sep=""), models[m],
			 " *** \n", sep="")
		tmp=fitContinuous(phy,dat[,trait],SE=0,model=models[m], ncores=2)
		print(tmp)
		aic[m]=tmp$opt$aicc
		lnl[m]=tmp$opt$lnL
	}

	## COMPARE AIC ##
	names(aic.se)&lt;-names(lnl.se)&lt;-names(aic)&lt;-names(lnl)&lt;-models
	delta_aic&lt;-function(x) x-x[which(x==min(x))]

	# no measurement error
	daic=delta_aic(aic)
	cat("\n\n\n\t\t\t\t*** MODEL COMPARISON: ",trait," *** \n",sep="")
	cat("\tdelta-AIC values for models assuming no measurement error
    \t\t\t\t zero indicates the best model\n\n")
	print(daic, digits=2)

		# measurement error
	daic.se=delta_aic(aic.se)
	cat("\n\n\n\n\t\t\t\t*** MODEL COMPARISON: ",trait," ***\n",sep="")
	cat("\t\t   delta-AIC values for models estimating SE
    \t\t\t\t zero indicates the best model\n\n")
	print(daic.se, digits=2)
	cat("\n\n\n")

	res_aicc=rbind(aic, aic.se, daic, daic.se)
	rownames(res_aicc)=c("AICc","AICc_SE","dAICc", "dAICc_SE")

	return(res_aicc)
}

#---- COMPARE MODELS for WING LENGTH
res=fitGeospiza("wingL")
print(res)
}

## End(Not run)
</code></pre>


</div>