<div class="container">

<table style="width: 100%;"><tr>
<td>summarylr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summarizes a glm, adding a column of GLRT or Rao score P-values</h2>

<h3>Description</h3>

<p><code>summarylr</code> is an improved summary function for standard glm (stats package) adding LRT or Rao score P-values
</p>


<h3>Usage</h3>

<pre><code class="language-R">summarylr(
  object,
  dispersion = NULL,
  correlation = FALSE,
  symbolic.cor = FALSE,
  ...,
  force = FALSE,
  debuglevel = level_warning,
  method = "LRT",
  keep.wald = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>glm object; as obtained by calling <code>stats::glm</code> or <code>MASS::glm.nb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p>the dispersion parameter for the family used. Either a single numerical value or NULL (the default), when it is inferred from object (see <code>stats::summary.glm</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation</code></td>
<td>
<p>logical; if TRUE, the correlation matrix of the estimated parameters is returned and printed (see <code>stats::summary.glm</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symbolic.cor</code></td>
<td>
<p>logical; if TRUE, print the correlations in a symbolic form (see <code>symnum</code>) rather than as numbers (see <code>stats::summary.glm</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to <code>stats::summary.glm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force</code></td>
<td>
<p>logical; if TRUE, force computation of P-values in case of convergence problems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debuglevel</code></td>
<td>
<p>integer value; set to 0 (default) to disable warnings, 1 to enable warnings and 2 to enable warnings and notes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>NULL or character vector of length 0, 1 or 2; may be code"LRT" or <code>"Rao"</code> or <code>c("LRT", "Rao")</code> to compute specified P-values.
You can set <code>method=NULL</code> to compute no additional P-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.wald</code></td>
<td>
<p>logical; if TRUE, the standard Wald's P-values are kept in the output of <code>print.summary.glmglrt</code>. Even if keep.wald=FALSE, the standard wald P-values are not erased from the <code>summary.glmglrt</code> object. They are only hidden by <code>print.summary.glmglrt</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function works the same as the standard <code>summary.glm</code> function but provides additionnal parameters
The core parameter <code>method="LRT"</code> makes <code>summarylr</code> adds a column <code>LRT P-value</code>
to the output. This P-value is computed by repeatdly fitting the model dropping
one coefficient at a time and using the <code>anova.glm(test="Chisq")</code> function to perform
generalized likelihood ratio test by approximation of the deviance difference
to a chi-square distribution. This provides P-values less biased than the standard Wald P-values
that <code>summary</code> provides. Moreover, this LRT method is consistent with the profile likelihood
confidence intervals that <code>confint.glm</code> provides.
The option <code>method="Rao"</code> generates Rao's score P-values. <code>method="Chisq"</code> is synonymous to <code>method="LRT"</code>.
For exhaustivity, the option <code>method="Wald"</code> (synonym "wald", "F") generates Wald's P-values.
Several methods can be used, e.g. <code>method=c("LRT","Rao")</code> computes both LRT and Rao P-values. New methods may be added in the future.
</p>
<p>Extra parameters are passed-through to the <code>summary.glm</code> function.
</p>


<h3>Value</h3>

<p>It returns a summary object of type <code>summary.glmglrt</code> that gets pretty printed by <code>link[glmglrt:print.summary.glmglrt]{print.summary.glmglrt}</code>
The return value is an S3 object compatible with <code>stats::summary.glm</code> but with an additional field <code>$extra</code> field having sub-fields.
<code>$extra$pvalues</code> is a numeric matrix with columns "LRT P-value" and/or "Rao P-value", containing the relevant P-values. As new columns may be added in future, you should rely on column names rather than column indexes. Only P-values of methods requested in the <code>method</code> parameter are stored in this matrix.
<code>$extra$debuglevel</code> is equal to the <code>debuglevel</code> passed to <code>summarylr</code>.
<code>$extra$keep.wald</code> is equal to the <code>keep.wald</code> passed to <code>summarylr</code>.
In case of convergence problems, the field <code>$extra$problem_of_convergence</code> will be added. It will be a character string with the value <code>"general"</code> (because model$converged = FALSE), <code>"all"</code> (because all coefficients have huge variances) or <code>"specific"</code> (because at least one coefficient has a huge variance). Other problem strings may be added in the future.
If weights are specified in a way that make P-values invalid, the field <code>$extra$problem_weights</code> will be added as a character string describing the problem. Actually, the only known problem is <code>"non-constant"</code>.
</p>


<h3>See Also</h3>

<p>Other Extended GLM summary functions: 
<code>override_summary()</code>,
<code>print.summary.glmglrt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">summarylr(glm(family="binomial", cbind(5,3)~1))
data(mtcars)
# do not properly converge (warnings)
mtcars$outcome = mtcars$disp &gt; median(mtcars$disp)
mod=glm(family=binomial(log), data=mtcars,outcome ~ 0+qsec+wt,start=c(-0.1,0.3))
summarylr(mod) # warns that P-values are not computed because model did not converge
summarylr(mod, force=TRUE) # compute P-values anyway !
# also works with negative binomial models
summarylr(MASS::glm.nb(data=mtcars, I(cyl*gear) ~ 1+wt,link="sqrt"),test="LRT")
</code></pre>


</div>