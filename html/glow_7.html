<div class="container">

<table style="width: 100%;"><tr>
<td>LightMapper4</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LightMapper4</h2>

<h3>Description</h3>

<p>This class provides a framework for creating scatter plots based on a point light simulation  with explicit color intensities. Points are mapped with a inverse power gradient to a raster with specified dimensions and properties.
</p>


<h3>Usage</h3>

<pre>m &lt;- GlowMapper$new(xdim=1000, ydim=800, blend_mode = "additive", background_color = "#00000000", nthreads = 1)

m$map(x, y, radius, color = NULL, r=NULL, g=NULL, b=NULL, falloff_exponent = 1, distance_exponent = 2, xlimits = c(NA_real_, NA_real_), ylimits = c(NA_real_, NA_real_), append = FALSE)

m$output_raw(saturation = 1, saturation_mode = "overflow")

m$output_dataframe(saturation = 1, saturation_mode = "overflow")

m$aspect()

m$xlim()

m$ylim()
</pre>


<h3>Arguments</h3>


<dl>
<dt>xdim</dt>
<dd>
<p>- The first dimension of the output matrix raster.</p>
</dd>
<dt>ydim</dt>
<dd>
<p>- The second dimension of the output matrix raster.</p>
</dd>
<dt>blend_mode</dt>
<dd>
<p>- Either screen or additive blending mode. See details.</p>
</dd>
<dt>background_color</dt>
<dd>
<p>- A color that can be coerced to RGBA with 'col2rgb', or a vector of four values between 0 and 1.</p>
</dd>
<dt>nthreads</dt>
<dd>
<p>- Number of threads to use.</p>
</dd>
<dt>x</dt>
<dd>
<p>- X coordinate of points.</p>
</dd>
<dt>y</dt>
<dd>
<p>- Y coordinate of points.</p>
</dd>
<dt>radius</dt>
<dd>
<p>- Relative spread of glow intensity. The radius should be proportional to the x and y-ranges of the plot. Values between 1/10 to 1/100 of the range of the plot generally produce good results.</p>
</dd>
<dt>color</dt>
<dd>
<p>- Color of points. If NULL, r, g, and b parameters must be defined (and vice versa).</p>
</dd>
<dt>r</dt>
<dd>
<p>- Red intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>g</dt>
<dd>
<p>- Green intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>b</dt>
<dd>
<p>- Blue intensity of points. Must be between 0 and 1 if using screen blending.</p>
</dd>
<dt>falloff_exponent</dt>
<dd>
<p>- Exponent to determine how fast light intensity decreases from the point origin. A value of 0.5 corresponds to a linear falloff; a value of 2 corresponds to an inverse square. Generally you want this value to be high, otherwise you'll flood your plot with light.</p>
</dd>
<dt>distance_exponent</dt>
<dd>
<p>- Exponent of the distance calculation when calculating intensities. A value of 2 corresponds to euclidean distance; a value of 1 corresponds to manhattan distance.</p>
</dd>
<dt>xlimits</dt>
<dd>
<p>- The x-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>ylimits</dt>
<dd>
<p>- The y-limits of the output plot. If NA, the limits are +/- 5% of the maximum and minimum points.</p>
</dd>
<dt>append</dt>
<dd>
<p> - Whether to add to the existing output or overwrite.</p>
</dd>
<dt>saturation</dt>
<dd>
<p>- When retrieving the output with <code>$output_raw</code> or <code>$output_dataframe</code>, maximum intensity values are capped at the given value. This is often useful when using additive blend mode to increase contrast.</p>
</dd>
<dt>saturation_mode</dt>
<dd>
<p>- When intensity values are above the saturation threshold, values can be overflowed into other color channels ("overflow") or simply clipped at the threshold ("clip"). "Overflow" always produces a gradient to white for intensities above the threshold, which may produce artistically better results.</p>
</dd>
</dl>
<h3>Details</h3>

<p>This 'LightMapper4' class is similar to the 'LightMapper' class, but instead of a single intensity matrix output, color is specified explicitly.
</p>
<p><code>$new()</code> creates a new LightMapper4 object, which holds parameters, plotting data, and the output (a matrix of glow intensities). Creates a canvas to plot point data. With additive blending, the intensities of each point are added arithmetically, which is how light intensities are added in the physical world. This is equivalent to an fast/approximate un-normalized 2D kernel density estimate. 
</p>
<p>With "screen" blending,  two intensities are added according to the formula: <code>I_out = 1 - (1-I_a)*(1-I_b)</code>. Both additive blending and screen blending are commutative operations, meaning the order of points in a plot does not affect the output.
</p>
<p>Screen blending can often improve contrast in a plot and is the default. 
</p>
<p><code>$map()</code> maps points to the canvas. 
</p>
<p><code>$output_raw()</code> output raw matrix rasters (a list of four matrices, one for each RGBA channel). Useful for plotting in base R.
</p>
<p><code>$output_dataframe()</code> output the raster as a dataframe with XY coordinates. This is meant to pipe directly into ggplot.
</p>
<p><code>$aspect()</code>, <code>$xlim()</code>, <code>$ylim()</code> return the aspect ratio, x-limits and y-limits of the raster. These functions are intended to be used with plotting functions (e.g. <code>ggplot2::coord_fixed()</code>) so that the output raster is not distorted. See example below.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Plot Data: x,y,r
x &lt;- numeric(length=50)
y &lt;- numeric(length=50)
r &lt;- numeric(length=50)
color &lt;- character(length=50)
for(t in 1:50) {
  xy &lt;- exp(1i * t/2 - t/12)
  x[t] &lt;- Re(xy)
  y[t] &lt;- Im(xy)
  r[t] &lt;- sqrt(x[t]^2 + y[t]^2)
  color[t] &lt;- rgb(t/50,0,1-t/50)
}

# New class object
m &lt;- LightMapper4$new(xdim=500, ydim = 400, blend_mode = "additive")

# Map data on to raster
m$map(x=x, y=y, color = color, radius = r/30+0.01, falloff_exponent = 1, distance_exponent = 2)

# Output raster data as a dataframe
pd &lt;- m$output_dataframe(saturation = 1)

# Plot with ggplot
ggplot(pd, aes(x = x, y = y, fill = rgb(r,g,b,a))) + 
  geom_raster(show.legend = FALSE) +
  scale_fill_identity() +
  coord_fixed(ratio = m$aspect(), xlim = m$xlim(), ylim = m$ylim(), expand = FALSE) + 
  theme_night(bgcolor = "black")
</code></pre>


</div>