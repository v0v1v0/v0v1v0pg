<div class="container">

<table style="width: 100%;"><tr>
<td>ch6.solutions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution code for Chapter 6: GAM Theory</h2>

<h3>Description</h3>

<p>R code for Chapter 6 exercise solutions.</p>


<h3>Author(s)</h3>

<p>Simon Wood &lt;simon@r-project.org&gt;
</p>
<p>Maintainer: Simon Wood &lt;simon@r-project.org&gt;
</p>


<h3>References</h3>

<p>Wood, S.N. (2017) <em>Generalized Additive Models: An Introduction with R</em>, CRC
</p>


<h3>See Also</h3>

<p><code>mgcv</code>, <code>ch6</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(gamair); library(mgcv)

## code from Chapter 5 solutions...

## Q.3

pspline.XB &lt;- function(x,q=10,m=2,p.m=2)
# Get model matrix and sqrt Penalty matrix for P-spline
{ # first make knot sequence, k
  k &lt;- seq(min(x),max(x),length=q-m)
  dk &lt;- k[2]-k[1]
  k &lt;- c(k[1]-dk*((m+1):1),k,k[q-m]+dk*(1:(m+1)))
  # now get model matrix and root penalty
  X &lt;- splineDesign(k,x,ord=m+2)
  B &lt;- diff(diag(q),difference=p.m)
  list(X=X,B=B)
} ## pspline.XB

## a) and b)
fit.wPs &lt;- function(y,X,B,lambda=0,w=rep(1,length(y)))
# fit to y by weighted penalized least squares, X is
# model matrix, B is sqrt penalty, lambda is smoothing p.
{ w &lt;- as.numeric(w^.5)
  n &lt;- nrow(X)
  X&lt;-rbind(w*X,sqrt(lambda)*B)
  y&lt;-c(w*y,rep(0,nrow(B)))
  b &lt;- lm(y~X-1) # actually estimate model
  trA &lt;- sum(influence(b)$hat[1:n])
  rss &lt;- sum((y-fitted(b))[1:n]^2) ## not really needed here
  list(trA=trA,rss=rss,b=coef(b))
}

fitPoiPs &lt;- function(y,X,B,lambda=0)
# Fit Poisson model with log-link by P-IRLS
{ mu &lt;- y;mu[mu==0] &lt;- .1
  eta &lt;- log(mu)
  converged &lt;- FALSE
  dev &lt;- ll.sat &lt;- sum(dpois(y,y,log=TRUE))
  while (!converged) {
    z &lt;- (y-mu)/mu + eta
    w &lt;- mu
    fPs &lt;- fit.wPs(z,X,B,lambda,w)
    eta &lt;- X%*%fPs$b
    mu=exp(eta)
    old.dev &lt;- dev
    dev &lt;- 2*(ll.sat-sum(dpois(y,mu,log=TRUE)))
    if (abs(dev-old.dev)&lt;1e-6*dev) converged &lt;- TRUE
  }
  list(dev=dev,rss=fPs$rss,trA=fPs$trA,b=fPs$b,fv=mu)
}

## c)
## simulate data as in question...
set.seed(1)
f &lt;- function(x) .04*x^11*(10*(1-x))^6+2*(10*x)^3*(1-x)^10
n &lt;- 100;x &lt;- sort(runif(n))
y &lt;- rpois(rep(1,n),exp(f(x)))

## fitting...
library(splines)
ps &lt;- pspline.XB(x,q=10,m=2,p.m=2)
lambda &lt;- 1e-4;reps &lt;- 60
sp &lt;- trA &lt;- gcv &lt;- rep(0,reps)
for (i in 1:reps) { # loop through trial s.p.s
  fps &lt;- fitPoiPs(y,ps$X,ps$B,lambda=lambda)
  trA[i] &lt;- fps$trA;sp[i] &lt;- lambda
  gcv[i] &lt;- n*fps$dev/(n-trA[i])^2
  lambda &lt;- lambda*1.3
}
plot(trA,gcv,type="l")
fps1 &lt;- fitPoiPs(y,ps$X,ps$B,lambda=sp[gcv==min(gcv)])
plot(x,y);lines(x,fps1$fv)

## Q.6 Fellner-Schall for GCV and AIC...

## b)
library(mgcv);library(MASS)
sm &lt;- smoothCon(s(times,k=20),data=mcycle)[[1]]
X &lt;- sm$X; S &lt;- sm$S[[1]]; y &lt;- mcycle$accel
lambda &lt;- 1; n &lt;- length(y)
XX &lt;- crossprod(X);
with(mcycle,plot(times,accel))
for (i in 1:20) {
  R &lt;- chol(XX+lambda*S)
  b &lt;- backsolve(R,forwardsolve(t(R),t(X) %*% y))
  f &lt;- X %*% b
  lines(mcycle$times,f,col="grey")
  HiS &lt;- backsolve(R,forwardsolve(t(R),S))
  HiH &lt;- backsolve(R,forwardsolve(t(R),XX))
  tau &lt;- sum(diag(HiH))
  if (i&gt;1) { ## convergence test
    if (abs(tau-tau0)&lt;1e-5*tau) break  
  } 
  tau0 &lt;- tau
  dt.dl &lt;- -sum(t(HiH)*HiS)
  db.dl &lt;- -HiS %*% b
  dD.db &lt;- 2*t(X) %*% (f - y)
  lambda &lt;- -sum(2*(y-f)^2)/(n-tau)*dt.dl/sum(db.dl*dD.db) * lambda
}
lines(mcycle$times,f)

## c)
y &lt;- c(12,14,33,50,67,74,123,141,165,204,253,246,240)
t &lt;- 1:13
sm &lt;- smoothCon(s(t),data=data.frame(t=t,y=y))[[1]]
X &lt;- sm$X; S &lt;- sm$S[[1]]; lambda &lt;- .001; n &lt;- length(y)
plot(t,y)
mu &lt;- y; eta &lt;- log(mu)
for (i in 1:50) {
  w &lt;- mu; z &lt;- (y-mu)/mu + eta
  XWX &lt;- crossprod(sqrt(w)*X)
  R &lt;- chol(XWX+lambda*S)
  b &lt;- backsolve(R,forwardsolve(t(R),t(X) %*% (w*z)))
  eta &lt;- drop(X %*% b);mu &lt;- exp(eta)
  lines(t,mu,col="grey")
  HiS &lt;- backsolve(R,forwardsolve(t(R),S))
  HiH &lt;- backsolve(R,forwardsolve(t(R),XWX))
  tau &lt;- sum(diag(HiH))
  if (i&gt;1) { ## convergence test
    if (abs(tau-tau0)&lt;1e-5*tau) break  
  } 
  tau0 &lt;- tau
  dt.dl &lt;- -sum(t(HiH)*HiS)
  db.dl &lt;- -HiS %*% b
  dl.db &lt;- t(X) %*% (y-mu) ## especially simple for this case
  lambda &lt;- dt.dl/sum(db.dl*dl.db) * lambda
}
i;tau;lines(t,mu)

## Q.8 log det stabilty (or lack of)

set.seed(1);lam &lt;- 1
A1 &lt;- crossprod(diff(diag(3),diff=1))
A2 &lt;- crossprod(matrix(runif(9),3,3))
A &lt;- matrix(0,5,5);A[1:3,1:3] &lt;- A1
A[3:5,3:5] &lt;- A[3:5,3:5] + lam * A2

ldetA.qr &lt;- ldetA.ev &lt;- ldetA.svd &lt;- ldetA &lt;-
            rho &lt;- seq(-40,-25,length=100)
for (i in 1:length(rho)) {
  lam &lt;- exp(rho[i])
  A &lt;- matrix(0,5,5);A[1:3,1:3] &lt;- A1
  A[3:5,3:5] &lt;- A[3:5,3:5] + lam * A2
  ea1 &lt;- eigen(A1)
  Q &lt;- diag(5);Q[1:3,1:3] &lt;- ea1$vectors
  At &lt;- matrix(0,5,5)
  At[3:5,3:5] &lt;- At[3:5,3:5] + lam * A2
  At &lt;- t(Q)%*%At%*%Q
  diag(At)[1:2] &lt;- diag(At)[1:2]+ea1$values[1:2]

  ldetA[i] &lt;- sum(log(abs(diag(qr.R(qr(At))))))
  ldetA.qr[i] &lt;- sum(log(abs(diag(qr.R(qr(A))))))
  ldetA.ev[i] &lt;- sum(log(abs(eigen(A)$values))) 
  ldetA.svd[i] &lt;- sum(log(abs(svd(A)$d)))
}
plot(rho,ldetA,type="l") ## nice and stable
## not...
lines(rho,ldetA.qr,lty=2)
lines(rho,ldetA.ev,lty=3)
lines(rho,ldetA.svd,lty=4)



</code></pre>


</div>