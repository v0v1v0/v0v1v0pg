<div class="container">

<table style="width: 100%;"><tr>
<td>fun.auto.bimodal.qs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Fitting mixtures of generalied lambda distribtions to data using 
quantile matching method </h2>

<h3>Description</h3>

<p>This function will fit mixture of generalised lambda distributions to dataset. 
It is restricted to two generalised lambda distributions. The method of fitting 
is quantile matching method. It is a two step optimization procedure, 
each unimodal part of the bimodal distribution is modelled using quantile 
matching method. The initial values obtained are then used to maximise the 
theoretical and empirical quantile match for the entire bimodal distribution. 
It fits mixture of the form p*(f1)+(1-p)*(f2) where f1 and f2 are pdfs of the 
generalised lambda distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fun.auto.bimodal.qs(data, per.of.mix = 0.01, clustering.m = clara, 
init1.sel = "rprs", init2.sel = "rprs", init1=c(-1.5, 1.5), init2=c(-1.5, 1.5), 
leap1=3, leap2=3, fun1 = "runif.sobol", fun2 = "runif.sobol", trial.n = 100, 
len = 1000, type = 7, no = 10000, maxit = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> A numerical vector representing the dataset. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>per.of.mix</code></td>
<td>
<p> Level of mix between two parts of the distribution, 
usually 1-2% of cross mix is sufficient. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering.m</code></td>
<td>
<p> Clustering method used in classifying the dataset into 
two parts. Valid arguments include clara, fanny and pam from the cluster 
library. Default is clara. Or a logical vector specifying how data should
be split. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init1.sel</code></td>
<td>
<p> This can be <code>"rprs"</code> or <code>"rmfmkl"</code>, 
representing the choice (RS or FMKL) of the first distribution </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init2.sel</code></td>
<td>
<p> This can be <code>"rprs"</code> or <code>"rmfmkl"</code>,  
representing the choice (RS or FMKL) of the second distribution </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init1</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the first generalised 
lambda distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init2</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the second generalised 
lambda distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap1</code></td>
<td>
<p> See scrambling argument in <code>fun.gen.qrn</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun1</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap2</code></td>
<td>
<p> See scrambling argument in <code>fun.gen.qrn</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun2</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trial.n</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be
used in the checking phase, to find the best set of initial values for 
optimisation, this is intended to be lower than <code>len</code> to speed up the 
fitting algorithm. Default is 100. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p> Number of evenly spaced quantile ranging from 0 to 1 to be used,
default is 1000 </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> Type of quantile to be used, default is 7, see <code>quantile</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no</code></td>
<td>
<p> Number of initial random values to find the best initial values 
for optimisation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p> Maximum number of iterations for numerical optimisation. Default
is 5000. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The initial values that work well for RPRS are <code>c(-1.5,1.5)</code> and for RMFMKL 
are <code>c(-0.25,1.5)</code>. For scrambling, if <code>1</code>, <code>2</code> or <code>3</code> the 
sequence is scrambled otherwise not. If <code>1</code>, Owen type type of scrambling 
is applied, if <code>2</code>, Faure-Tezuka type of scrambling, is applied, and if 
<code>3</code>, both Owen+Faure-Tezuka type of scrambling is applied. The <code>star</code> 
method uses the same initial values as <code>rmfmkl</code> since it uses the FMKL 
generalised lambda distribution. Nelder-Simplex algorithm is used in the 
numerical optimization. <code>rprs</code> stands for revised percentile method for 
RS generalised lambda distribution and "rmfmkl" stands for revised method of 
moment for FMKL generalised lambda distribution. These acronyms represents the 
initial optimization algorithm used to get a reasonable set of initial values 
for the subsequent optimization procedues.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p> The best set of parameters found, the first four corresponds to the 
first distribution fit, the second four corresponds to the second distribution 
fit, the last value correspond to p for the first distribution fit. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p> The value of -ML for the paramters obtained. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to 
<code>fn</code> and <code>gr</code> respectively. This excludes those calls needed to 
compute the Hessian, if requested, and any calls to <code>fn</code> to compute a 
finite-difference approximation to the gradient. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
 <p><code>0</code> indicates successful convergence, <code>1</code> 
indicates the iteration limit <code>maxit</code> had been reached, <code>10</code> indicates 
degeneracy of the Nelder-Mead simplex. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p> A character string giving any additional information returned by 
the optimizer, or <code>NULL</code>. </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p> If the number of observations is small, 
<code>rprs</code> can sometimes fail as the percentiles may not exist for this data. 
Also, if the initial values do not span a valid generalised lambda distribution, 
try another set of initial values. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Bratley P. and Fox B.L. (1988) Algorithm 659: Implementing Sobol's quasi random 
sequence generator, ACM Transactions on Mathematical Software 14, 88-100.
</p>
<p>Joe S. and Kuo F.Y. (1998) Remark on Algorithm 659: Implementing Sobol's quasi 
random Sequence Generator.
</p>
<p>Nelder, J. A. and Mead, R. (1965) A simplex algorithm for function minimization. 
Computer Journal *7*, 308-313.
</p>
<p>Su (2008). Fitting GLD to data via quantile matching method. (Book chapter to
appear)
</p>


<h3>See Also</h3>

 <p><code>fun.auto.bimodal.pml</code>, <code>fun.auto.bimodal.ml</code>,
<code>fun.plot.fit.bm</code>, 
<code>fun.diag.ks.g.bimodal</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">

# Fitting faithful data from the dataset library, with the clara clustering 
# regime. The first distribution is RS and the second distribution is fmkl. 
# The percentage of data mix is 1%.

fun.auto.bimodal.qs(faithful[,1],per.of.mix=0.01,clustering.m=clara,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
leap1=3,leap2=3)

</code></pre>


</div>