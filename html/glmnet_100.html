<div class="container">

<table style="width: 100%;"><tr>
<td>coef.glmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract coefficients from a glmnet object</h2>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values,
logits, coefficients and more from a fitted <code>"glmnet"</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'glmnet'
coef(object, s = NULL, exact = FALSE, ...)

## S3 method for class 'glmnet'
predict(
  object,
  newx,
  s = NULL,
  type = c("link", "response", "coefficients", "nonzero", "class"),
  exact = FALSE,
  newoffset,
  ...
)

## S3 method for class 'relaxed'
predict(
  object,
  newx,
  s = NULL,
  gamma = 1,
  type = c("link", "response", "coefficients", "nonzero", "class"),
  exact = FALSE,
  newoffset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Fitted <code>"glmnet"</code> model object or a <code>"relaxed"</code>
model (which inherits from class "glmnet").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the entire sequence used to create the
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>This argument is relevant only when predictions are made at
values of <code>s</code> (lambda) <em>different</em> from those used in the fitting
of the original model. Not available for <code>"relaxed"</code> objects. If
<code>exact=FALSE</code> (default), then the predict function uses linear
interpolation to make predictions for values of <code>s</code> (lambda) that do
not coincide with those used in the fitting algorithm. While this is often a
good approximation, it can sometimes be a bit coarse.  With
<code>exact=TRUE</code>, these different values of <code>s</code> are merged (and
sorted) with <code>object$lambda</code>, and the model is refit before predictions
are made. In this case, it is required to supply the original data <code>x=</code>
and <code>y=</code> as additional named arguments to <code>predict()</code> or
<code>coef()</code>.  The workhorse <code>predict.glmnet()</code> needs to <code>update</code>
the model, and so needs the data used to create it. The same is true of
<code>weights</code>, <code>offset</code>, <code>penalty.factor</code>, <code>lower.limits</code>,
<code>upper.limits</code> if these were used in the original call. Failure to do
so will result in an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code>x=</code> when
<code>exact=TRUE</code>; see<code>exact</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newx</code></td>
<td>
<p>Matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix; can be sparse as in <code>Matrix</code> package. This
argument is not used for <code>type=c("coefficients","nonzero")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of prediction required. Type <code>"link"</code> gives the linear
predictors for <code>"binomial"</code>, <code>"multinomial"</code>, <code>"poisson"</code> or
<code>"cox"</code> models; for <code>"gaussian"</code> models it gives the fitted
values. Type <code>"response"</code> gives the fitted probabilities for
<code>"binomial"</code> or <code>"multinomial"</code>, fitted mean for <code>"poisson"</code>
and the fitted relative-risk for <code>"cox"</code>; for <code>"gaussian"</code> type
<code>"response"</code> is equivalent to type <code>"link"</code>. Type
<code>"coefficients"</code> computes the coefficients at the requested values for
<code>s</code>.  Note that for <code>"binomial"</code> models, results are returned only
for the class corresponding to the second level of the factor response.
Type <code>"class"</code> applies only to <code>"binomial"</code> or
<code>"multinomial"</code> models, and produces the class label corresponding to
the maximum probability. Type <code>"nonzero"</code> returns a list of the indices
of the nonzero coefficients for each value of <code>s</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newoffset</code></td>
<td>
<p>If an offset is used in the fit, then one must be supplied
for making predictions (except for <code>type="coefficients"</code> or
<code>type="nonzero"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Single value of <code>gamma</code> at which predictions are required,
for "relaxed" objects.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The shape of the objects returned are different for <code>"multinomial"</code>
objects. This function actually calls <code>NextMethod()</code>, and the
appropriate predict method is invoked for each of the three model types.
<code>coef(...)</code> is equivalent to <code>predict(type="coefficients",...)</code>
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Jerome Friedman, Trevor Hastie and Rob Tibshirani<br> Maintainer:
Trevor Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008)
<em>Regularization Paths for Generalized Linear Models via Coordinate
Descent (2010), Journal of Statistical Software, Vol. 33(1), 1-22</em>,
<a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>.<br>
Simon, N., Friedman, J., Hastie, T. and Tibshirani, R. (2011)
<em>Regularization Paths for Cox's Proportional
Hazards Model via Coordinate Descent, Journal of Statistical Software, Vol.
39(5), 1-13</em>,
<a href="https://doi.org/10.18637/jss.v039.i05">doi:10.18637/jss.v039.i05</a>.<br>
Glmnet webpage with four vignettes, <a href="https://glmnet.stanford.edu">https://glmnet.stanford.edu</a>.
</p>


<h3>See Also</h3>

<p><code>glmnet</code>, and <code>print</code>, and <code>coef</code> methods, and
<code>cv.glmnet</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
g2=sample(1:2,100,replace=TRUE)
g4=sample(1:4,100,replace=TRUE)
fit1=glmnet(x,y)
predict(fit1,newx=x[1:5,],s=c(0.01,0.005))
predict(fit1,type="coef")
fit2=glmnet(x,g2,family="binomial")
predict(fit2,type="response",newx=x[2:5,])
predict(fit2,type="nonzero")
fit3=glmnet(x,g4,family="multinomial")
predict(fit3,newx=x[1:3,],type="response",s=0.01)
</code></pre>


</div>