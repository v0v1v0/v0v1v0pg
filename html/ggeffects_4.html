<div class="container">

<table style="width: 100%;"><tr>
<td>new_data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a data frame from all combinations of predictor values</h2>

<h3>Description</h3>

<p>Create a data frame for the "newdata"-argument that contains
all combinations of values from the terms in questions. Similar to
<code>expand.grid()</code>. The <code>terms</code>-argument accepts all shortcuts
for representative values as in <code>predict_response()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">new_data(model, terms, typical = "mean", condition = NULL, ...)

data_grid(model, terms, typical = "mean", condition = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A fitted model object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>Character vector with the names of those terms from <code>model</code> for
which all combinations of values should be created. This argument works in
the same way as the <code>terms</code> argument in <code>predict_response()</code>. See also
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typical</code></td>
<td>
<p>Character vector, naming the function to be applied to the
covariates (non-focal terms) over which the effect is "averaged". The
default is <code>"mean"</code>. Can be <code>"mean"</code>, "<code>weighted.mean</code>", <code>"median"</code>, <code>"mode"</code>
or <code>"zero"</code>, which call the corresponding R functions (except <code>"mode"</code>,
which calls an internal function to compute the most common value); <code>"zero"</code>
simply returns 0. By default, if the covariate is a factor, only <code>"mode"</code> is
applicable; for all other values (including the default, <code>"mean"</code>) the
reference level is returned. For character vectors, only the mode is returned.
You can use a named vector to apply different functions to integer, numeric and
categorical covariates, e.g. <code>typical = c(numeric = "median", factor = "mode")</code>.
If <code>typical</code> is <code>"weighted.mean"</code>, weights from the model are used. If no
weights are available, the function falls back to <code>"mean"</code>. <strong>Note</strong> that this
argument is ignored for <code>predict_response()</code>, because the <code>margin</code> argument
takes care of this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>Named character vector, which indicates covariates that
should be held constant at specific values. Unlike <code>typical</code>, which
applies a function to the covariates to determine the value that is used
to hold these covariates constant, <code>condition</code> can be used to define
exact values, for instance <code>condition = c(covariate1 = 20, covariate2 = 5)</code>.
See 'Examples'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data frame containing one row for each combination of values of the
supplied variables.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(efc, package = "ggeffects")
fit &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)
new_data(fit, c("c12hour [meansd]", "c161sex"))

nd &lt;- new_data(fit, c("c12hour [meansd]", "c161sex"))
pr &lt;- predict(fit, type = "response", newdata = nd)
nd$predicted &lt;- pr
nd

# compare to
predict_response(fit, c("c12hour [meansd]", "c161sex"))

</code></pre>


</div>