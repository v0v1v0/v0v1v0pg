<div class="container">

<table style="width: 100%;"><tr>
<td>layer_histograms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Display binned data</h2>

<h3>Description</h3>

<p>Display binned data
</p>


<h3>Usage</h3>

<pre><code class="language-R">layer_histograms(
  vis,
  ...,
  width = NULL,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  stack = TRUE,
  binwidth
)

layer_freqpolys(
  vis,
  ...,
  width = NULL,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  binwidth
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vis</code></td>
<td>
<p>Visualisation to modify</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Visual properties used to override defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>The width of the bins. The default is <code>NULL</code>, which yields
30 bins that cover the range of the data. You should always override this
value, exploring multiple widths to find the best to illustrate the stories
in your data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>The center of one of the bins.  Note that if center is above or
below the range of the data, things will be shifted by an appropriate
number of <code>width</code>s. To center on integers, for example, use
<code>width=1</code> and <code>center=0</code>, even if <code>0</code> is outside the range
of the data.  At most one of <code>center</code> and <code>boundary</code> may be
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>A boundary between two bins. As with <code>center</code>, things
are shifted when <code>boundary</code> is outside the range of the data. For
example, to center on integers, use <code>width = 1</code> and <code>boundary =
0.5</code>, even if <code>1</code> is outside the range of the data.  At most one of
<code>center</code> and <code>boundary</code> may be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stack</code></td>
<td>
<p>If <code>TRUE</code>, will automatically stack overlapping bars.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binwidth</code></td>
<td>
<p>Deprecated; use <code>width</code> instead.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>layer_bars</code> For bar graphs of counts at each unique
x value, in contrast to a histogram's bins along x ranges.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create histograms and frequency polygons with layers
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_histograms()
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_histograms(width = 2)
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_freqpolys(width = 2)

# These are equivalent to combining compute_bin with the corresponding
# mark
mtcars %&gt;% compute_bin(~mpg) %&gt;% ggvis(~x_, ~count_) %&gt;% layer_paths()

# With grouping
mtcars %&gt;% ggvis(~mpg, fill = ~factor(cyl)) %&gt;% group_by(cyl) %&gt;%
  layer_histograms(width = 2)
mtcars %&gt;% ggvis(~mpg, stroke = ~factor(cyl)) %&gt;% group_by(cyl) %&gt;%
  layer_freqpolys(width = 2)
</code></pre>


</div>