<div class="container">

<table style="width: 100%;"><tr>
<td>nested_mean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nested generalized mean</h2>

<h3>Description</h3>

<p>Calculate the (outer) generalized mean of two (inner) generalized means
(i.e., crossing generalized means).
</p>


<h3>Usage</h3>

<pre><code class="language-R">nested_mean(r1, r2, t = c(1, 1))

fisher_mean(x, w1 = NULL, w2 = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r1</code></td>
<td>
<p>A finite number giving the order of the outer generalized mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r2</code></td>
<td>
<p>A pair of finite numbers giving the order of the inner generalized
means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>A pair of strictly positive weights for the inner generalized
means. The default is equal weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w1, w2</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length
as <code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing values in <code>x</code>, <code>w1</code>, and <code>w2</code> be
removed? By default missing values in <code>x</code>, <code>w1</code>, or <code>w2</code>
return a missing value.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>nested_mean()</code> returns a function:
</p>
<pre>function(x, w1 = NULL, w2 = NULL, na.rm = FALSE){...}</pre>
<p>This computes the generalized mean of order <code>r1</code> of the generalized
mean of order <code>r2[1]</code> of <code>x</code> with weights <code>w1</code> and the
generalized mean of order <code>r2[2]</code> of <code>x</code> with weights <code>w2</code>.
</p>
<p><code>fisher_mean()</code> returns a numeric value for the geometric mean of the
arithmetic and harmonic means (i.e., <code>r1 = 0</code> and <code>r2 = c(1, -1)</code>).
</p>


<h3>Note</h3>

<p>There is some ambiguity about how to remove missing values in
<code>w1</code> or <code>w2</code> when <code>na.rm = TRUE</code>. The approach here is to
remove missing values when calculating each of the inner means individually,
rather than removing all missing values prior to any calculations. This
means that a different number of data points could be used to calculate the
inner means. Use the <code>balanced()</code> operator to balance
missing values across <code>w1</code> and <code>w2</code> prior to any calculations.
</p>


<h3>References</h3>

<p>Diewert, W. E. (1976). Exact and superlative index numbers.
<em>Journal of Econometrics</em>, 4(2): 114–145.
</p>
<p>ILO, IMF, OECD, UNECE, and World Bank. (2004).
<em>Producer Price Index Manual: Theory and Practice</em>. International Monetary
Fund.
</p>
<p>Lent, J. and Dorfman, A. H. (2009). Using a weighted average of base period
price indexes to approximate a superlative index.
<em>Journal of Official Statistics</em>, 25(1):139–149.
</p>


<h3>See Also</h3>

<p><code>nested_contributions()</code> for percent-change contributions for
indexes based on nested generalized means, like the Fisher index.
</p>
<p>Other means: 
<code>extended_mean()</code>,
<code>generalized_mean()</code>,
<code>lehmer_mean()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 1:3
w1 &lt;- 4:6
w2 &lt;- 7:9

#---- Making superlative indexes ----

# A function to make the superlative quadratic mean price index by
# Diewert (1976) as a product of generalized means

quadratic_mean_index &lt;- function(r) nested_mean(0, c(r / 2, -r / 2))

quadratic_mean_index(2)(x, w1, w2)

# The arithmetic AG mean index by Lent and Dorfman (2009)

agmean_index &lt;- function(tau) nested_mean(1, c(0, 1), c(tau, 1 - tau))

agmean_index(0.25)(x, w1, w1)

#---- Walsh index ----

# The (arithmetic) Walsh index is the implicit price index when using a
# superlative quadratic mean quantity index of order 1

p1 &lt;- price6[[2]]
p0 &lt;- price6[[1]]
q1 &lt;- quantity6[[2]]
q0 &lt;- quantity6[[1]]

walsh &lt;- quadratic_mean_index(1)

sum(p1 * q1) / sum(p0 * q0) / walsh(q1 / q0, p0 * q0, p1 * q1)

sum(p1 * sqrt(q1 * q0)) / sum(p0 * sqrt(q1 * q0))

# Counter to the PPI manual (par. 1.105), it is not a superlative
# quadratic mean price index of order 1

walsh(p1 / p0, p0 * q0, p1 * q1)

# That requires using the average value share as weights

walsh_weights &lt;- sqrt(scale_weights(p0 * q0) * scale_weights(p1 * q1))
walsh(p1 / p0, walsh_weights, walsh_weights)

#---- Missing values ----

x[1] &lt;- NA
w1[2] &lt;- NA

fisher_mean(x, w1, w2, na.rm = TRUE)

# Same as using obs 2 and 3 in an arithmetic mean, and obs 3 in a
# harmonic mean

geometric_mean(c(
  arithmetic_mean(x, w1, na.rm = TRUE),
  harmonic_mean(x, w2, na.rm = TRUE)
))

# Use balanced() to use only obs 3 in both inner means

balanced(fisher_mean)(x, w1, w2, na.rm = TRUE)

</code></pre>


</div>