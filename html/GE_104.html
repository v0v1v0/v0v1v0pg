<div class="container">

<table style="width: 100%;"><tr>
<td>gemQuasilinearPureExchange_2_2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Pure Exchange Economy with a Quasilinear Utility Function</h2>

<h3>Description</h3>

<p>An example of a pure exchange economy with a quasilinear utility function (Karaivanov, see the reference).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gemQuasilinearPureExchange_2_2(
  A,
  Endowment = matrix(c(3, 4, 7, 0), 2, 2, TRUE),
  policy = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>a demand structure tree list, a demand coefficient 2-by-2 matrix (alias demand structure matrix)
or a function A(state) which returns a 2-by-2 matrix (see <code>sdm2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Endowment</code></td>
<td>
<p>a 2-by-2 matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>policy</code></td>
<td>
<p>a policy function (see <code>sdm2</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Suppose there are only two goods (bananas and fish) and 2 consumers (Annie and Ben) in an exchange economy.
Annie has a utility function x_1^(1/3) * x_2^(2/3) where x_1 is the amount of fish she eats and x_2 is the amount of
bananas she eats.
Annie has an endowment of 3 kilos of fish and 7 bananas.
Ben has a utility function x_1 + 1.5 * log(x_2) and endowments of 4 kilos of fish and 0 bananas.
Assume the price of bananas is 1.
See the reference for more details.
</p>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>References</h3>

<p>http://www.sfu.ca/~akaraiva/CE_example.pdf
</p>


<h3>Examples</h3>

<pre><code class="language-R">
demand_consumer2 &lt;- function(w, p) {
  QL_demand(w = w, p = p, alpha = 1.5, type = "log")
}

A &lt;- function(state) {
  a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3), state$p)
  a2 &lt;- demand_consumer2(state$w[2], state$p)
  cbind(a1, a2)
}

ge.mat &lt;- gemQuasilinearPureExchange_2_2(A = A)
ge.mat

## Use a dstl and a policy function to compute the general equilibrium above.
dst.consumer1 &lt;- node_new("util",
                          type = "CD", alpha = 1, beta = c(1 / 3, 2 / 3),
                          "fish", "banana"
)
dst.consumer2 &lt;- node_new("util",
                          type = "Leontief", a = c(1, 1),
                          "fish", "banana"
)

dstl &lt;- list(dst.consumer1, dst.consumer2)

policy.quasilinear &lt;- function(A, state) {
  wealth &lt;- t(state$p) %*% state$S
  A[[2]]$a &lt;- demand_consumer2(wealth[2], state$p)
}

ge.dstl &lt;- gemQuasilinearPureExchange_2_2(
  A = dstl,
  policy = policy.quasilinear
)
ge.dstl

#### Another example. Now Ben has a utility function x_1 + sqrt(x_2).
demand_consumer2 &lt;- function(w, p) {
  QL_demand(w = w, p = p, alpha = 1, beta = 0.5, type = "power")
}

A &lt;- function(state) {
  a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3), state$p)
  a2 &lt;- demand_consumer2(state$w[2], state$p)
  cbind(a1, a2)
}

ge.2_2 &lt;- gemQuasilinearPureExchange_2_2(A = A)
ge.2_2

## another computation method for the economy above
A &lt;- function(state) {
  a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3, 0, 0), state$p)
  a2 &lt;- c(0, 0, 1, 0)
  a3 &lt;- c(1, 0, 0, 0) # firm 1
  a4 &lt;- CD_A(1, rbind(0, 1 / 2, 0, 1 / 2), state$p) # firm 2
  cbind(a1, a2, a3, a4)
}

ge.4_4 &lt;- sdm2(
  A = A,
  B = {
    B &lt;- matrix(0, 4, 4)
    B[3, 3] &lt;- 1
    B[3, 4] &lt;- 1
    B
  },
  S0Exg = {
    S0Exg &lt;- matrix(NA, 4, 4)
    S0Exg[1:2, 1] &lt;- c(3, 7)
    S0Exg[1:2, 2] &lt;- c(4, 0)
    S0Exg[4, 1:2] &lt;- c(0, 1)
    S0Exg
  },
  names.commodity = c("fish", "banana", "util2", "land"),
  names.agent = c("Annie", "Ben", "firm1", "firm2"),
  numeraire = "banana"
)
ge.4_4

#### another example
n.fish.demander &lt;- 21
wealth &lt;- 20 # the wealth (or income) of each fish demander
fish.supply &lt;- 12
aggregare.demand &lt;- function(p) {
  result &lt;- 0
  for (alpha in seq(5, 15, length.out = n.fish.demander)) {
    result &lt;- result + QL_demand(w = wealth, p = p, alpha = alpha, beta = 1, type = "min")
  }
  result
}

ge &lt;- sdm2(
  A = function(state) {
    a1 &lt;- aggregare.demand(state$p / state$p[1])
    a2 &lt;- c(1, 0)
    cbind(a1, a2)
  },
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    n.fish.demander * wealth, 0,
    0, fish.supply
  ), 2, 2, TRUE),
  names.commodity = c("gold", "fish"),
  names.agent = c("fish.demander", "fish.supplier"),
  numeraire = "gold",
  p0 = c(1, 1) # p0 = c(1, 9.25)
)

ge$p
ge$z
ge$D
ge$S

aggregare.demand.fish &lt;- c()
p2.set &lt;- seq(0, 16, 0.01)
for (p2 in p2.set) {
  aggregare.demand.fish &lt;- c(
    aggregare.demand.fish,
    aggregare.demand(c(1, p2))[2]
  )
}

plot(aggregare.demand.fish,
     p2.set,
     xlab = "demand for fish", ylab = "price of fish", pch = 20
)
abline(v = fish.supply)
grid()
points(ge$D[2, 1], ge$p[2], pch = 8, col = "red")

</code></pre>


</div>