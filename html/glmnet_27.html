<div class="container">

<table style="width: 100%;"><tr>
<td>cox.path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Cox regression model with elastic net regularization for a path of
lambda values</h2>

<h3>Description</h3>

<p>Fit a Cox regression model via penalized maximum likelihood for a path of
lambda values. Can deal with (start, stop] data and strata, as well as
sparse design matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cox.path(
  x,
  y,
  weights = NULL,
  offset = NULL,
  alpha = 1,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  standardize = TRUE,
  thresh = 1e-10,
  exclude = NULL,
  penalty.factor = rep(1, nvars),
  lower.limits = -Inf,
  upper.limits = Inf,
  maxit = 1e+05,
  trace.it = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Survival response variable, must be a <code>Surv</code> or
<code>stratifySurv</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each inner
coordinate-descent loop continues until the maximum change in the objective
after any coefficient update is less than thresh times the null deviance.
Default value is <code>1e-10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>See glmnet help file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>Controls how much information is printed to screen. Default is
<code>trace.it=0</code> (no information printed). If <code>trace.it=1</code>, a progress
bar is displayed. If <code>trace.it=2</code>, some information about the fitting
procedure is printed to the console as the model is being fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed from glmnet (not used right now).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Sometimes the sequence is truncated before <code>nlambda</code> values of lambda
have been used. This happens when <code>cox.path</code> detects that the
decrease in deviance is marginal (i.e. we are near a saturated fit).
</p>


<h3>Value</h3>

<p>An object of class "coxnet" and "glmnet".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept value, <code>NULL</code> for "cox" family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients, stored in
sparse matrix format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used. When alpha=0, the
largest lambda reported does not quite give the zero coefficients reported
(lambda=inf would in principle). Instead, the largest lambda for alpha=0.001
is used, and the sequence of lambda values is derived from this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the 0 model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>Total passes over the data summed over all lambda values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">set.seed(2)
nobs &lt;- 100; nvars &lt;- 15
xvec &lt;- rnorm(nobs * nvars)
xvec[sample.int(nobs * nvars, size = 0.4 * nobs * nvars)] &lt;- 0
x &lt;- matrix(xvec, nrow = nobs)
beta &lt;- rnorm(nvars / 3)
fx &lt;- x[, seq(nvars / 3)] %*% beta / 3
ty &lt;- rexp(nobs, exp(fx))
tcens &lt;- rbinom(n = nobs, prob = 0.3, size = 1)
jsurv &lt;- survival::Surv(ty, tcens)
fit1 &lt;- glmnet:::cox.path(x, jsurv)

# works with sparse x matrix
x_sparse &lt;- Matrix::Matrix(x, sparse = TRUE)
fit2 &lt;- glmnet:::cox.path(x_sparse, jsurv)

# example with (start, stop] data
set.seed(2)
start_time &lt;- runif(100, min = 0, max = 5)
stop_time &lt;- start_time + runif(100, min = 0.1, max = 3)
status &lt;- rbinom(n = nobs, prob = 0.3, size = 1)
jsurv_ss &lt;- survival::Surv(start_time, stop_time, status)
fit3 &lt;- glmnet:::cox.path(x, jsurv_ss)

# example with strata
jsurv_ss2 &lt;- stratifySurv(jsurv_ss, rep(1:2, each = 50))
fit4 &lt;- glmnet:::cox.path(x, jsurv_ss2)
</code></pre>


</div>