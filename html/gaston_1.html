<div class="container">

<table style="width: 100%;"><tr>
<td>gaston-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> gaston </h2>

<h3>Description</h3>

<p>Manipulation of genetic data (SNPs), computation of Genetic Relationship Matrix, Linkage Disequilibrium, etc. 
Efficient algorithms for Linear Mixed Model (AIREML, diagonalisation trick).</p>


<h3>Introducing gaston</h3>

<p>Gaston offers functions for efficient manipulation of 
large genotype (SNP) matrices, and state-of-the-art implementation of algorithms
to fit Linear Mixed Models, that can be used to compute heritability 
estimates or to perform association tests.
</p>
<p>Thanks to the packages <code>Rcpp</code>, 
<code>RcppParallel</code>,
<code>RcppEigen</code>, gaston 
functions are mainly written in C++. 
</p>
<p>Many functions are multithreaded;
the number of threads can be setted through <code>RcppParallel</code>
function <code>setThreadOptions</code>.
It is advised to try several values for the number of threads, as 
using too many threads might be conterproductive due to an important
overhead.
</p>
<p>Some functions have a <code>verbose</code> argument, which controls the
function verbosity. To mute all functions at once you can use 
<code>options(gaston.verbose = FALSE)</code>.
</p>


<h3>Genotype matrices</h3>

<p>An S4 class for genotype matrices is defined, named <code>bed.matrix</code>.
Each row corresponds to an individual, and each column to a SNP. They can
be read from files using <code>read.bed.matrix</code> 
and saved using <code>write.bed.matrix</code>.  The function <code>read.vcf</code> reads
VCF files.
</p>
<p>In first approach, a bed.matrix behaves as a "read-only" matrix containing only 
0, 1, 2 and NAs, unless the genotypes are standardized (use <code>standardize&lt;-</code>).
They are stored in a compact form, each genotype being coded on 2 bits (hence
4 genotypes per byte).
</p>
<p>Bed.matrices can be converted to numerical matrices with <code>as.matrix</code>,
and multiplied with numeric vectors or matrices with <code>%*%</code> (this 
feature can be used e.g. to simulate quantitative phenotypes, see a basic example in the example
section of <code>association.test</code>).
</p>
<p>It is possible to subset bed.matrices just as base matrices, writing e.g.
<code>x[1:100,]</code> to extract the first 100 individuals, or <code>x[1:100,1000:1999]</code>
for extract the SNPs 1000 to 1999 for these 100 individuals. The use of logical
vectors for subsetting is allowed too. The functions 
<code>select.inds</code> and <code>select.snps</code> can also be used for 
subsetting with a nice syntax.
</p>
<p>Some basic descriptive statistics can be added to a bed.matrix with <code>set.stats</code> (since
<code>gaston 1.4</code>, this function is called by default by all functions that create a bed.matrix, unless
<code>options(gaston.auto.set.stats = FALSE)</code> was set.
Hardy-Weinberg Equilibrium can be tested for all SNPs with <code>set.hwe</code>. 
</p>


<h3>Crossproducts of standardized matrices</h3>

<p>If <code class="reqn">X</code> is a standardized <code class="reqn">n\times q</code> genotype matrix, a Genetic Relationship Matrix 
(GRM) of the individuals can be computed as
</p>
<p style="text-align: center;"><code class="reqn"> GRM = {1\over q-1} XX’ </code>
</p>

<p>where <code class="reqn">q</code> is the number of SNPs. 
This computation is done by the function <code>GRM</code>.  The eigen decomposition of the GRM produces
the Principal Components (PC) of the data set. If needed, the loadings 
corresponding to the PCs can be retrieved using <code>bed.loadings</code>.
</p>
<p>Doing the above crossproduct in the reverse order produces a moment estimate of the Linkage Disequilibrium:
</p>
<p style="text-align: center;"><code class="reqn"> LD = {1\over n-1} X’X </code>
</p>

<p>where <code class="reqn">n</code> is the number of individuals. This computation is done by the function
<code>LD</code> (usually, only parts of the whole LD matrix is computed). This method is 
also used by <code>LD.thin</code> to extract a set of SNPs in low linkage disequilibrium
(it is often recommended to perform this operation before computing the GRM).
</p>


<h3>Linear Mixed Models</h3>

<p><code>lmm.aireml</code> is a function for linear mixed models parameter estimation
and BLUP computations. 
</p>
<p>The model considered is of the form
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + \omega_1 + \ldots + \omega_k + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega_i \sim N(0,\tau_i K_i) </code> for <code class="reqn"> i \in 1, \dots,k </code> and
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
</p>
<p>Note that very often in genetics a mixed model is written as
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + Zu + \varepsilon </code>
</p>

<p>with <code class="reqn">Z</code> a standardized genotype matrix, and <code class="reqn">u\sim N(0, \tau I_q)</code>. In that case, 
denoting <code class="reqn">\omega = Zu</code>, <code class="reqn">\omega \sim N(0, \tau ZZ')</code>
and letting <code class="reqn">K=ZZ'</code> we get a mixed model of the previous form.
</p>
<p>When <code class="reqn">k=1</code> in the above general model (only one random term <code class="reqn">\omega</code>), the likelihood
can be computed very efficiently using the eigen decomposition of 
<code class="reqn">K = \mathrm{var}(\omega)</code>. This "diagonalization trick" 
is used in <code>lmm.diago.likelihood</code> and <code>lmm.diago</code>, to compute 
the likelihood and for parameter estimation, respectively. 
</p>
<p>Two small functions complete this set of functions: <code>lmm.simu</code>, to 
simulate data under a linear mixed model, and <code>random.pm</code>, to generate
random positive matrices. Both are used in examples and can be useful for data simulation.
</p>


<h3>Author(s)</h3>

<p>Hervé Perdry and Claire Dandine-Roulland
</p>
<p>Maintainer: Hervé Perdry
</p>


</div>