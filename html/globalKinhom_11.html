<div class="container">

<table style="width: 100%;"><tr>
<td>pcfglobal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> (cross) pair correlation functions with a global intensity reweighting </h2>

<h3>Description</h3>

<p>Compute <code class="reqn">g_\textrm{global}</code> or <code class="reqn">c_\textrm{global}</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">pcfglobal(X, lambda=NULL, ..., sigma=bw.CvL(X), r=NULL, rmax=NULL,
    kernel="epanechnikov", bw=NULL, stoyan=0.15, normtol=.005, ratio=FALSE,
    discrete.lambda=FALSE, divisor=c("r", "d"),
    leaveoneout=TRUE, interpolate=TRUE, interpolate.fac=10, exp_prs=NULL,
    interpolate.maxdx=diameter(as.owin(X))/100, dump=FALSE)

pcfcross.global(X,Y, lambdaX=NULL, lambdaY=NULL, ...,
    sigma=bw.CvL(X), r=NULL, rmax=NULL, kernel="epanechnikov", bw=NULL,
    stoyan=0.15, normtol=.005, ratio=FALSE, discrete.lambda=FALSE,
    divisor=c("r", "d"), analytical=NULL, interpolate=TRUE,
    interpolate.fac=10, exp_prs=NULL,
    interpolate.maxdx=diameter(as.owin(X))/100, dump=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X, Y</code></td>
<td>

<p>point process of type <code>ppp</code>, on which to evaluate the (cross) <code class="reqn">K</code>-function
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda, lambdaX, lambdaY</code></td>
<td>

<p>intensity function estimates corresponding to <code>X</code> and <code>Y</code>. If omitted, intensity
functions will be computed using
<code>density.ppp</code> or
<code>densityfun.ppp</code> (see discrete.lambda below)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>extra args passed to density.ppp or densityfun.ppp, if applicable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>Bandwidth value to use for kernel-based intensity estimation, intensity functions and
<code>exp_prs</code> are not provided by the user.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>

<p>Values of <code class="reqn">r</code> to evaluate <code class="reqn">K(r)</code> at. If omitted, a sensible default is chosen, using the same
conventions as <code>Kest</code> and <code>Kinhom</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmax</code></td>
<td>

<p>Maximum <code class="reqn">r</code> to evaluate <code class="reqn">K(r)</code> at. <code>rmax</code> is used to generate values for <code>r</code>,
if omitted. If missing, a sensible default is chosen.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>

<p>Kernel type for smoothing of pcf.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>

<p>Kernel bandwidth for smoothing of pcf.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stoyan</code></td>
<td>

<p>Coefficient for Stoyan's bandwidth selection rule. See
<code>pcf.ppp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normtol</code></td>
<td>

<p>A tolerance to use for expectedPairs or expectedCrossPairs when computing monte-carlo
estimates of the normalizing factor <code class="reqn">\gamma</code>. Expressed as a maximum fractional
standard error.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>

<p>If <code>TRUE</code>, assemble numerator and denominator of pcf estimator separately.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>divisor</code></td>
<td>

<p>Whether to use the evaluation distance (<code>"r"</code>) or the distance between points (<code>"d"</code>)
to normalize the contribution of each point pair.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>analytical</code></td>
<td>

<p>If <code>TRUE</code>, use Diggle-Jones weights 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete.lambda</code></td>
<td>

<p>If <code>TRUE</code>, and intensity function(s) are not supplied, estimate intensities by
interpolating the values on a discrete lattice (using
<code>interp.im</code> and
<code>density.ppp</code>), instead of exactly (using
<code>densityfun.ppp</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>

<p>If <code>TRUE</code>, evaluate the expectedCrossPairs on a lattice and interpolate,
rather than at the exact displacements observed in the pattern.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate.fac</code></td>
<td>

<p>If <code>interpolate</code>, the lattice spacing will be <code>sigma/interpolate.fac</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leaveoneout</code></td>
<td>

<p>Use the leave-one-out estimator for <code class="reqn">\gamma</code>. See Shaw et al 2020 for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exp_prs</code></td>
<td>

<p>A function that returns values for
<code class="reqn">\gamma_\textrm{iso}(r)</code>. If <code class="reqn">\gamma</code> is
known explicitly, or the same calculation is being used for several
point patterns, it can be much faster to compute it once and provide the function
as <code>exp_prs</code>, since the computation of <code class="reqn">\gamma</code> is usually the
slowest part.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate.maxdx</code></td>
<td>

<p>Upper bound on allowable lattice spacing for interpolation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dump</code></td>
<td>

<p>For debugging purposes, include computed values of <code class="reqn">\gamma</code> with the output,
as <code>attr</code>s.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The return value is an object of class <code>fv</code>,
just as for <code>pcf</code> and
<code>pcfinhom</code>. The object contains columns <code>r</code>,
<code>theo</code>, and <code>global</code>, corresponding respectively to the argument
<code class="reqn">r</code>, the theoretical values of <code class="reqn">g(r)</code> for a Poisson process, and
<code class="reqn">g_\mathrm{global}(r)</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Shaw &lt;shawtr@umich.edu&gt;
</p>


<h3>References</h3>

<p>T Shaw, J Møller, R Waagepetersen. 2020. “Globally Intensity-Reweighted Estimators for
<code class="reqn">K</code>- and pair correlation functions”. arXiv:2004.00527 [stat.ME].
</p>


<h3>See Also</h3>

<p><code>expectedPairs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">rho &lt;- funxy(function(x,y) 80*(1+x), owin())
X &lt;- rpoispp(rho)
g &lt;- pcfglobal(X)
#plot(g)
</code></pre>


</div>