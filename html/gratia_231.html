<div class="container">

<table style="width: 100%;"><tr>
<td>partial_derivatives</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partial derivatives of estimated multivariate smooths via finite
differences</h2>

<h3>Description</h3>

<p>Partial derivatives of estimated multivariate smooths via finite
differences
</p>


<h3>Usage</h3>

<pre><code class="language-R">partial_derivatives(object, ...)

## Default S3 method:
partial_derivatives(object, ...)

## S3 method for class 'gamm'
partial_derivatives(object, ...)

## S3 method for class 'gam'
partial_derivatives(
  object,
  select = NULL,
  term = deprecated(),
  focal = NULL,
  data = newdata,
  order = 1L,
  type = c("forward", "backward", "central"),
  n = 100,
  eps = 1e-07,
  interval = c("confidence", "simultaneous"),
  n_sim = 10000,
  level = 0.95,
  unconditional = FALSE,
  frequentist = FALSE,
  offset = NULL,
  ncores = 1,
  partial_match = FALSE,
  seed = NULL,
  ...,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an R object to compute derivatives for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>character; vector of one or more smooth terms for which
derivatives are required. If missing, derivatives for all smooth terms
will be returned. Can be a partial match to a smooth term; see argument
<code>partial_match</code> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> Use <code>select</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>focal</code></td>
<td>
<p>character; name of the focal variable. The partial derivative
of the estimated smooth with respect to this variable will be returned.
All other variables involved in the smooth will be held at constant. This
can be missing if supplying <code>data</code>, in which case, the focal variable will
be identified as the one variable that is not constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the values of the model covariates
at which to evaluate the first derivatives of the smooths. If supplied,
all but one variable must be held at a constant value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>numeric; the order of derivative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character; the type of finite difference used. One of
<code>"forward"</code>, <code>"backward"</code>, or <code>"central"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>numeric; the number of points to evaluate the derivative at.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>numeric; the finite difference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>character; the type of interval to compute. One of
<code>"confidence"</code> for point-wise intervals, or <code>"simultaneous"</code> for
simultaneous intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_sim</code></td>
<td>
<p>integer; the number of simulations used in computing the
simultaneous intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>numeric; <code style="white-space: pre;">⁠0 &lt; level &lt; 1⁠</code>; the confidence level of the
point-wise or simultaneous interval. The default is <code>0.95</code> for a 95%
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unconditional</code></td>
<td>
<p>logical; use smoothness selection-corrected Bayesian
covariance matrix?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frequentist</code></td>
<td>
<p>logical; use the frequentist covariance matrix?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>numeric; a value to use for any offset term</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>number of cores for generating random variables from a
multivariate normal distribution. Passed to <code>mvnfast::rmvn()</code>.
Parallelization will take place only if OpenMP is supported (but appears
to work on Windows with current <code>R</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>term</code>? If <code>TRUE</code>, <code>term</code> can only be a single string to match
against.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>numeric; RNG seed to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Deprecated: use <code>data</code> instead.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tibble, currently with the following variables:
</p>

<ul>
<li> <p><code>.smooth</code>: the smooth each row refers to,
</p>
</li>
<li> <p><code>.partial_deriv</code>: the estimated partial derivative,
</p>
</li>
<li> <p><code>.se</code>: the standard error of the estimated partial derivative,
</p>
</li>
<li> <p><code>.crit</code>: the critical value such that <code>derivative</code> ± <code>(crit * se)</code> gives
the upper and lower bounds of the requested confidence or simultaneous
interval (given <code>level</code>),
</p>
</li>
<li> <p><code>.lower_ci</code>: the lower bound of the confidence or simultaneous interval,
</p>
</li>
<li> <p><code>.upper_ci</code>: the upper bound of the confidence or simultaneous interval.
</p>
</li>
</ul>
<h3>Note</h3>

<p><code>partial_derivatives()</code> will ignore any random effect smooths it
encounters in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Gavin L. Simpson
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library("ggplot2")
library("patchwork")
load_mgcv()

df &lt;- data_sim("eg2", n = 2000, dist = "normal", scale = 0.5, seed = 42)

# fit the GAM (note: for execution time reasons, k is set articifially low)
m &lt;- gam(y ~ te(x, z, k = c(5, 5)), data = df, method = "REML")

# data slice through te(x,z) holding z == 0.4
ds &lt;- data_slice(m, x = evenly(x, n = 100), z = 0.4)

# evaluate te(x,z) at values of x &amp; z
sm &lt;- smooth_estimates(m, select = "te(x,z)", data = ds) |&gt;
  add_confint()

# partial derivatives
pd_x &lt;- partial_derivatives(m, data = ds, type = "central", focal = "x")

# draw te(x,z)
p1 &lt;- draw(m, rug = FALSE) &amp;
  geom_hline(yintercept = 0.4, linewidth = 1)
p1

# draw te(x,z) along slice
cap &lt;- expression(z == 0.4)
p2 &lt;- sm |&gt;
  ggplot(aes(x = x, y = .estimate)) +
  geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci), alpha = 0.2) +
  geom_line() +
  labs(
    x = "x", y = "Partial effect", title = "te(x,z)",
    caption = cap
  )
p2

# draw partial derivs
p3 &lt;- pd_x |&gt;
  draw() +
  labs(caption = cap)
p3

# draw all three panels
p1 + p2 + p3 + plot_layout(ncol = 3)

</code></pre>


</div>