<div class="container">

<table style="width: 100%;"><tr>
<td>index_weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Index weights</h2>

<h3>Description</h3>

<p>Calculate weights for a variety of different price indexes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">index_weights(
  type = c("Carli", "Jevons", "Coggeshall", "Dutot", "Laspeyres", "HybridLaspeyres",
    "LloydMoulton", "Palgrave", "Paasche", "HybridPaasche", "Drobisch", "Unnamed",
    "Tornqvist", "Walsh1", "Walsh2", "MarshallEdgeworth", "GearyKhamis", "Vartia1",
    "MontgomeryVartia", "Vartia2", "SatoVartia", "Theil", "Rao", "Lowe", "Young",
    "HybridCSWD")
)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The name of the index. See details for the possible types of
indexes.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The <code>index_weights()</code> function returns a function to calculate weights
for a variety of price indexes. Weights for the following types of indexes
can be calculated.
</p>

<ul>
<li>
<p> Carli / Jevons / Coggeshall
</p>
</li>
<li>
<p> Dutot
</p>
</li>
<li>
<p> Laspeyres / Lloyd-Moulton
</p>
</li>
<li>
<p> Hybrid Laspeyres (for use in a harmonic mean)
</p>
</li>
<li>
<p> Paasche / Palgrave
</p>
</li>
<li>
<p> Hybrid Paasche (for use in an arithmetic mean)
</p>
</li>
<li>
<p> TÃ¶rnqvist / Unnamed
</p>
</li>
<li>
<p> Drobisch
</p>
</li>
<li>
<p> Walsh-I (for an arithmetic Walsh index)
</p>
</li>
<li>
<p> Walsh-II (for a geometric Walsh index)
</p>
</li>
<li>
<p> Marshall-Edgeworth
</p>
</li>
<li>
<p> Geary-Khamis
</p>
</li>
<li>
<p> Montgomery-Vartia / Vartia-I
</p>
</li>
<li>
<p> Sato-Vartia / Vartia-II
</p>
</li>
<li>
<p> Theil
</p>
</li>
<li>
<p> Rao
</p>
</li>
<li>
<p> Lowe
</p>
</li>
<li>
<p> Young
</p>
</li>
<li>
<p> Hybrid-CSWD
</p>
</li>
</ul>
<p>The weights need not sum to 1, as this normalization isn't always
appropriate (i.e., for the Vartia-I weights).
</p>


<h3>Value</h3>

<p>A function of current and base period prices/quantities that calculates
the relevant weights.
</p>


<h3>Note</h3>

<p>Naming for the indexes and weights generally follows the CPI manual (2020),
Balk (2008), von der Lippe (2007), and Selvanathan and Rao (1994). In several
cases two or more names correspond to the same weights (e.g., Paasche and
Palgrave, or Sato-Vartia and Vartia-II). The calculations are given in the
examples.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>IMF, ILO, Eurostat, UNECE, OECD, and World Bank. (2020).
<em>Consumer Price Index Manual: Concepts and Methods</em>.
International Monetary Fund.
</p>
<p>von der Lippe, P. (2007). <em>Index Theory and Price Statistics</em>. Peter Lang.
</p>
<p>Selvanathan, E. A. and Rao, D. S. P. (1994).
<em>Index Numbers: A Stochastic Approach</em>. MacMillan.
</p>


<h3>See Also</h3>

<p><code>update_weights()</code> for price-updating weights.
</p>
<p><code>quantity_index()</code> to remap the arguments in these functions for a
quantity index.
</p>
<p>Other price index functions: 
<code>geks()</code>,
<code>price_indexes</code>,
<code>splice_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">p0 &lt;- price6[[2]]
p1 &lt;- price6[[3]]
q0 &lt;- quantity6[[2]]
q1 &lt;- quantity6[[3]]
pb &lt;- price6[[1]]
qb &lt;- quantity6[[1]]

#---- Making the weights for different indexes ----

# Explicit calculation for each of the different weights
# Carli/Jevons/Coggeshall

all.equal(index_weights("Carli")(p1), rep(1, length(p0)))

# Dutot

all.equal(index_weights("Dutot")(p0), p0)

# Laspeyres / Lloyd-Moulton

all.equal(index_weights("Laspeyres")(p0, q0), p0 * q0)

# Hybrid Laspeyres

all.equal(index_weights("HybridLaspeyres")(p1, q0), p1 * q0)

# Paasche / Palgrave

all.equal(index_weights("Paasche")(p1, q1), p1 * q1)

# Hybrid Paasche

all.equal(index_weights("HybridPaasche")(p0, q1), p0 * q1)

# Tornqvist / Unnamed

all.equal(
  index_weights("Tornqvist")(p1, p0, q1, q0),
  0.5 * p0 * q0 / sum(p0 * q0) + 0.5 * p1 * q1 / sum(p1 * q1)
)

# Drobisch

all.equal(
  index_weights("Drobisch")(p1, p0, q1, q0),
  0.5 * p0 * q0 / sum(p0 * q0) + 0.5 * p0 * q1 / sum(p0 * q1)
)

# Walsh-I

all.equal(
  index_weights("Walsh1")(p0, q1, q0),
  p0 * sqrt(q0 * q1)
)

# Marshall-Edgeworth

all.equal(
  index_weights("MarshallEdgeworth")(p0, q1, q0),
  p0 * (q0 + q1)
)

# Geary-Khamis

all.equal(
  index_weights("GearyKhamis")(p0, q1, q0),
  p0 / (1 / q0 + 1 / q1)
)

# Montgomery-Vartia / Vartia-I

all.equal(
  index_weights("MontgomeryVartia")(p1, p0, q1, q0),
  logmean(p0 * q0, p1 * q1) / logmean(sum(p0 * q0), sum(p1 * q1))
)

# Sato-Vartia / Vartia-II

all.equal(
  index_weights("SatoVartia")(p1, p0, q1, q0),
  logmean(p0 * q0 / sum(p0 * q0), p1 * q1 / sum(p1 * q1))
)

# Walsh-II

all.equal(
  index_weights("Walsh2")(p1, p0, q1, q0),
  sqrt(p0 * q0 * p1 * q1)
)

# Theil

all.equal(index_weights("Theil")(p1, p0, q1, q0), {
  w0 &lt;- scale_weights(p0 * q0)
  w1 &lt;- scale_weights(p1 * q1)
  (w0 * w1 * (w0 + w1) / 2)^(1 / 3)
})

# Rao

all.equal(index_weights("Rao")(p1, p0, q1, q0), {
  w0 &lt;- scale_weights(p0 * q0)
  w1 &lt;- scale_weights(p1 * q1)
  w0 * w1 / (w0 + w1)
})

# Lowe

all.equal(index_weights("Lowe")(p0, qb), p0 * qb)

# Young

all.equal(index_weights("Young")(pb, qb), pb * qb)

# Hybrid CSWD (to approximate a CSWD index)

all.equal(index_weights("HybridCSWD")(p1, p0), sqrt(p0 / p1))

</code></pre>


</div>