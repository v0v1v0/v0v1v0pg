<div class="container">

<table style="width: 100%;"><tr>
<td>GSMVAR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a class 'gsmvar' object defining a reduced form or structural GMVAR, StMVAR, or G-StMVAR model</h2>

<h3>Description</h3>

<p><code>GSMVAR</code> creates a class <code>'gsmvar'</code> object that defines
a reduced form or structural GMVAR, StMVAR, or G-StMVAR model
</p>


<h3>Usage</h3>

<pre><code class="language-R">GSMVAR(
  data,
  p,
  M,
  d,
  params,
  conditional = TRUE,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  calc_cond_moments,
  calc_std_errors = FALSE,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)

## S3 method for class 'gsmvar'
logLik(object, ...)

## S3 method for class 'gsmvar'
residuals(object, ...)

## S3 method for class 'gsmvar'
summary(object, ..., digits = 2)

## S3 method for class 'gsmvar'
plot(x, ..., type = c("both", "series", "density"))

## S3 method for class 'gsmvar'
print(x, ..., digits = 2, summary_print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a single times series. <code>NA</code> values are not supported. Ignore if defining a model without data is desired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt>
<dd>
<p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt>
<dd>
<p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>number of times series in the system, i.e. <code>ncol(data)</code>. This can be
used to define GSMVAR models without data and can be ignored if <code>data</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt>
<dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li>
<p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li>
</ul>
</dd>
<dt><strong>For constrained models:</strong></dt>
<dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul><li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>
</dd>
<dt><strong>For same_means models:</strong></dt>
<dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li>
<p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li>
</ul>
</dd>
<dt><strong>For models with weight_constraints:</strong></dt>
<dd>
<p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt>
<dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul><li>
<p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>
<dl>
<dt><strong>If AR parameters are constrained: </strong></dt>
<dd>
<p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt>
<dd>
<p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt>
<dd>
<p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt>
<dd>
<p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt>
<dd>
<p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>is "GMVAR", "StMVAR", or "G-StMVAR" model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li>
</ul>
<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc_cond_moments</code></td>
<td>
<p>should conditional means and covariance matrices should be calculated?
Default is <code>TRUE</code> if the model contains data and <code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the "bold A" matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>which type figure should be produced? Or both?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary_print</code></td>
<td>
<p>if set to <code>TRUE</code> then the print
will include log-likelihood and information criteria values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If data is provided, then also multivariate quantile residuals (<em>Kalliovirta and Saikkonen 2010</em>)
are computed and included in the returned object.
</p>
<p>If the function fails to calculate approximative standard errors and the parameter values are near the border
of the parameter space, it might help to use smaller numerical tolerance for the stationarity and positive
definiteness conditions.
</p>
<p>The first plot displays the time series together with estimated mixing weights.
The second plot displays a (Gaussian) kernel density estimates of the individual series
together with the marginal stationary density implied by the model. The colored regimewise
stationary densities are multiplied with the mixing weight parameter estimates.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the specified reduced form or structural GMVAR,
StMVAR, or G-StMVAR model. Can be used to work with other functions provided in <code>gmvarkit</code>.
</p>
<p>Note that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>logLik(gsmvar)</code>: Log-likelihood method
</p>
</li>
<li> <p><code>residuals(gsmvar)</code>: residuals method to extract multivariate quantile residuals
</p>
</li>
<li> <p><code>summary(gsmvar)</code>: summary method
</p>
</li>
<li> <p><code>plot(gsmvar)</code>: plot method for class 'gsmvar'
</p>
</li>
<li> <p><code>print(gsmvar)</code>: print method
</p>
</li>
</ul>
<h3>About S3 methods</h3>

<p>If data is not provided, only the <code>print</code> and <code>simulate</code> methods are available.
If data is provided, then in addition to the ones listed above, <code>predict</code> method is also available.
See <code>?simulate.gsmvar</code> and <code>?predict.gsmvar</code> for details about the usage.
</p>


<h3>References</h3>


<ul>
<li>
<p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li>
<p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li>
<p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li>
<p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>fitGSMVAR</code>, <code>add_data</code>, <code>swap_parametrization</code>, <code>GIRF</code>,
<code>gsmvar_to_sgsmvar</code>, <code>stmvar_to_gstmvar</code>, <code>reorder_W_columns</code>,
<code>swap_W_signs</code>, <code>update_numtols</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># GMVAR(1, 2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
  0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
  0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
mod12

# GMVAR(1, 2), d=2 model without data
mod12_2 &lt;- GSMVAR(p=1, M=2, d=2, params=params12)
mod12_2

# StMVAR(1, 2), d=2 model:
mod12t &lt;- GSMVAR(gdpdef, p=1, M=2, params=c(params12, 10, 20),
                 model="StMVAR")
mod12t

# G-StMVAR(1, 1, 1), d=2 model:
mod12gs &lt;- GSMVAR(gdpdef, p=1, M=c(1, 1), params=c(params12, 20),
                  model="G-StMVAR")
mod12gs

# GMVAR(2, 2), d=2 model with mean-parametrization:
params22 &lt;- c(0.869, 0.549, 0.223, 0.059, -0.151, 0.395, 0.406,
 -0.005, 0.083, 0.299, 0.215, 0.002, 0.03, 0.576, 1.168, 0.218,
 0.02, -0.119, 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004,
 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22, parametrization="mean")
mod22

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s,
 structural_pars=list(W=W_22))
mod22s
</code></pre>


</div>