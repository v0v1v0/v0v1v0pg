<div class="container">

<table style="width: 100%;"><tr>
<td>gamVinePDF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conditional density function of a gamVine</h2>

<h3>Description</h3>

<p>This function returns the density of a conditional pair-copula constructions,
where either the copula parameters or the Kendall's taus are modeled as a function
of the covariates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gamVinePDF(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>gamVine-class</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>(Same as in <code>predict.gam</code> from the
<code>mgcv</code> package) A matrix or data frame
containing the values of the model covariates at which predictions are
required, along with a number of additional columns corresponding to the
variables in the pair copula decomposition.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The conditional density.
</p>


<h3>See Also</h3>

<p><code>gamVine</code>, <code>gamVineCopSelect</code>,
<code>gamVineStructureSelect</code>, <code>gamVine-class</code>,
<code>gamVineSimulate</code> and <code>gamBiCopFit</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(mgcv)
set.seed(0)

##  Simulation parameters
# Sample size
n &lt;- 1e3
# Copula families
familyset &lt;- c(1:2, 301:304, 401:404)
# Define a 4-dimensional R-vine tree structure matrix
d &lt;- 4
Matrix &lt;- c(2, 3, 4, 1, 0, 3, 4, 1, 0, 0, 4, 1, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, d, d)
nnames &lt;- paste("X", 1:d, sep = "")

## A function factory
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

##  Create the model
# Define gam-vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d * (d - 1) / 2)
sel &lt;- seq(d, d^2 - d, by = d)

# First tree
for (i in 1:(d - 1)) {
  # Select a copula family
  family &lt;- sample(familyset, 1)
  model[[count]]$family &lt;- family

  # Use the canonical link and a randomly generated parameter
  if (is.element(family, c(1, 2))) {
    model[[count]]$par &lt;- tanh(rnorm(1) / 2)
    if (family == 2) {
      model[[count]]$par2 &lt;- 2 + exp(rnorm(1))
    }
  } else {
    if (is.element(family, c(401:404))) {
      rr &lt;- rnorm(1)
      model[[count]]$par &lt;- sign(rr) * (1 + abs(rr))
    } else {
      model[[count]]$par &lt;- rnorm(1)
    }
    model[[count]]$par2 &lt;- 0
  }
  count &lt;- count + 1
}

# A dummy dataset
data &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), matrix(runif(1e2 * d), 1e2, d))

# Trees 2 to (d-1)
for (j in 2:(d - 1)) {
  for (i in 1:(d - j)) {
    # Select a copula family
    family &lt;- sample(familyset, 1)

    # Select the conditiong set and create a model formula
    cond &lt;- nnames[sort(Matrix[(d - j + 2):d, i])]
    tmpform &lt;- paste("~", paste(paste("s(", cond, ", k=10, bs='cr')",
      sep = ""
    ), collapse = " + "))
    l &lt;- length(cond)
    temp &lt;- sample(3, l, replace = TRUE)

    # Spline approximation of the true function
    m &lt;- 1e2
    x &lt;- matrix(seq(0, 1, length.out = m), nrow = m, ncol = 1)
    if (l != 1) {
      tmp.fct &lt;- paste("function(x){eta0+",
        paste(sapply(1:l, function(x)
          paste("calib.surf[[", temp[x], "]](x[", x, "])",
            sep = ""
          )), collapse = "+"), "}",
        sep = ""
      )
      tmp.fct &lt;- eval(parse(text = tmp.fct))
      x &lt;- eval(parse(text = paste0("expand.grid(",
        paste0(rep("x", l), collapse = ","), ")",
        collapse = ""
      )))
      y &lt;- apply(x, 1, tmp.fct)
    } else {
      tmp.fct &lt;- function(x) eta0 + calib.surf[[temp]](x)
      colnames(x) &lt;- cond
      y &lt;- tmp.fct(x)
    }

    # Estimate the gam model
    form &lt;- as.formula(paste0("y", tmpform))
    dd &lt;- data.frame(y, x)
    names(dd) &lt;- c("y", cond)
    b &lt;- gam(form, data = dd)
    # plot(x[,1],(y-fitted(b))/y)

    # Create a dummy gamBiCop object
    tmp &lt;- gamBiCopFit(data = data, formula = form, family = 1, n.iters = 1)$res

    # Update the copula family and the model coefficients
    attr(tmp, "model")$coefficients &lt;- coefficients(b)
    attr(tmp, "model")$smooth &lt;- b$smooth
    attr(tmp, "family") &lt;- family
    if (family == 2) {
      attr(tmp, "par2") &lt;- 2 + exp(rnorm(1))
    }
    model[[count]] &lt;- tmp
    count &lt;- count + 1
  }
}

# Create the gamVineCopula object
GVC &lt;- gamVine(Matrix = Matrix, model = model, names = nnames)
print(GVC)
## Not run: 
## Simulate and fit the model
sim &lt;- gamVineSimulate(n, GVC)
fitGVC &lt;- gamVineSeqFit(sim, GVC, verbose = TRUE)
fitGVC2 &lt;- gamVineCopSelect(sim, Matrix, verbose = TRUE)
(gamVinePDF(GVC, sim[1:10, ]))

## Plot the results
dev.off()
par(mfrow = c(3, 4))
plot(GVC, ylim = c(-2.5, 2.5))

plot(fitGVC, ylim = c(-2.5, 2.5))

plot(fitGVC2, ylim = c(-2.5, 2.5))

## End(Not run)

</code></pre>


</div>