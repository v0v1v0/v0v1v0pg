<div class="container">

<table style="width: 100%;"><tr>
<td>stat_quant_line</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicted line from quantile regression fit</h2>

<h3>Description</h3>

<p>Predicted values are computed and, by default, plotted. Depending on the
fit method, a confidence band can be computed and plotted. The confidence
band can be interpreted similarly as that produced by <code>stat_smooth()</code>
and <code>stat_poly_line()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_quant_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  se = length(quantiles) == 1L,
  fm.values = FALSE,
  n = 80,
  method = "rq",
  method.args = list(),
  n.min = 3L,
  level = 0.95,
  type = "direct",
  interval = "confidence",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>numeric vector Values in 0..1 indicating the quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>logical Passed to <code>quantreg::predict.rq()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fm.values</code></td>
<td>
<p>logical Add n as a column to returned data? ('FALSE' by
default.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function or character If character, "rq", "rqss" or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>). If a
function different to <code>rq()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, <code>tau</code> and <code>method</code>
and return a model fit object of class <code>rq</code>, <code>rqs</code> or
<code>rqss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>named list with additional arguments passed to
<code>rq()</code>, <code>rqss()</code> or to a function passed as argument to
<code>method</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>numeric in range [0..1] Passed to <code>quantreg::predict.rq()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character Passed to <code>quantreg::predict.rq()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>character Passed to <code>quantreg::predict.rq()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either "x" or "y" controlling the default for
<code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stat_quant_line()</code> behaves similarly to
<code>ggplot2::stat_smooth()</code> and <code>stat_poly_line()</code> but supports
fitting regressions for multiple quantiles in the same plot layer. This
statistic interprets the argument passed to <code>formula</code> accepting
<code>y</code> as well as <code>x</code> as explanatory variable, matching
<code>stat_quant_eq()</code>. While <code>stat_quant_eq()</code> supports only method
<code>"rq"</code>, <code>stat_quant_line()</code> and <code>stat_quant_band()</code> support
both <code>"rq"</code> and <code>"rqss"</code>, In the case of <code>"rqss"</code> the model
formula makes normally use of <code>qss()</code> to formulate the spline and its
constraints.
</p>
<p><code>geom_smooth</code>, which is used by default, treats each
axis differently and thus is dependent on orientation. If no argument is
passed to <code>formula</code>, it defaults to <code>y ~ x</code>. Formulas with
<code>y</code> as explanatory variable are treated as if <code>x</code> was the
explanatory variable and <code>orientation = "y"</code>.
</p>
<p>Package 'ggpmisc' does not define a new geometry matching this statistic as
it is enough for the statistic to return suitable <code>x</code>, <code>y</code>,
<code>ymin</code>, <code>ymax</code> and <code>group</code> values.
</p>
<p>The minimum number of observations with distinct values in the explanatory
variable can be set through parameter <code>n.min</code>. The default <code>n.min
  = 3L</code> is the smallest usable value. However, model fits with very few
observations are of little interest and using larger values of <code>n.min</code>
than the default is wise.
</p>
<p>There are multiple uses for double regression on x and y. For example, when
two variables are subject to mutual constrains, it is useful to consider
both of them as explanatory and interpret the relationship based on them.
So, from version 0.4.1 'ggpmisc' makes it possible to easily implement the
approach described by Cardoso (2019) under the name of "Double quantile
regression".
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values and and their confidence limits for each
quantile, with each quantile in a group. The variables are <code>x</code> and
<code>y</code> with <code>y</code> containing predicted values. In addition,
<code>quantile</code> and <code>quantile.f</code> indicate the quantile used and
and edited <code>group</code> preserves the original grouping adding a new
"level" for each quantile. Is <code>se = TRUE</code>, a confidence band is
computed and values for it returned in <code>ymax</code> and <code>ymin</code>.
</p>
<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values and their confidence limits. Optionally
it will also include additional values related to the model fit.
</p>


<h3>Computed variables</h3>

<p>'stat_quant_line()' provides the following
variables, some of which depend on the orientation: </p>
 <dl>
<dt>y *or*
x</dt>
<dd>
<p>predicted value</p>
</dd> <dt>ymin *or* xmin</dt>
<dd>
<p>lower confidence
interval around the mean</p>
</dd> <dt>ymax *or* xmax</dt>
<dd>
<p>upper confidence
interval around the mean</p>
</dd>
</dl>
<p>If <code>fm.values = TRUE</code> is passed then one column with the number of
observations <code>n</code> used for each fit is also included, with the same
value in each row within a group. This is wasteful and disabled by default,
but provides a simple and robust approach to achieve effects like colouring
or hiding of the model fit line based on the number of observations.
</p>


<h3>Aesthetics</h3>

<p><code>stat_quant_line</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code>. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"geom_smooth"</code> is the default) are understood and grouping
respected.
</p>


<h3>References</h3>

<p>Cardoso, G. C. (2019) Double quantile regression accurately assesses
distance to boundary trade-off. Methods in ecology and evolution,
10(8), 1322-1331.
</p>


<h3>See Also</h3>

<p><code>rq</code>, <code>rqss</code> and
<code>qss</code>.
</p>
<p>Other ggplot statistics for quantile regression: 
<code>stat_quant_band()</code>,
<code>stat_quant_eq()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line()

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(se = TRUE)

# If you need the fitting to be done along the y-axis set the orientation
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(orientation = "y")

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(orientation = "y", se = TRUE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = x ~ poly(y, 3))

# Instead of rq() we can use rqss() to fit an additive model:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(method = "rqss",
                  formula = y ~ qss(x, constraint = "D"),
                  quantiles = 0.5)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(method = "rqss",
                  formula = x ~ qss(y, constraint = "D"),
                  quantiles = 0.5)

ggplot(mpg, aes(displ, hwy)) +
  geom_point()+
  stat_quant_line(method="rqss",
                  interval="confidence",
                  se = TRUE,
                  mapping = aes(fill = factor(after_stat(quantile)),
                                color = factor(after_stat(quantile))),
                  quantiles=c(0.05,0.5,0.95))

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = drv, fill = drv)) +
  geom_point() +
  stat_quant_line(method = "rqss",
                  formula = y ~ qss(x, constraint = "V"),
                   quantiles = 0.5)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ poly(x, 2)) +
  facet_wrap(~drv)

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_line(geom = "debug")

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_line(geom = "debug", fm.values = TRUE)

</code></pre>


</div>