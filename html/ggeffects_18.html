<div class="container">

<table style="width: 100%;"><tr>
<td>as.data.frame.ggeffects</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adjusted predictions from regression models</h2>

<h3>Description</h3>

<p>After fitting a model, it is useful generate model-based estimates (expected
values, or <em>adjusted predictions</em>) of the response variable for different
combinations of predictor values. Such estimates can be used to make
inferences about relationships between variables.
</p>
<p>The <strong>ggeffects</strong> package computes marginal means and adjusted predicted
values for the response, at the margin of specific values or levels from
certain model terms. The package is built around three core functions:
<code>predict_response()</code> (understanding results), <code>test_predictions()</code> (testing
results for statistically significant differences) and <code>plot()</code> (communicate
results).
</p>
<p>By default, adjusted predictions or marginal means are by returned on the
<em>response</em> scale, which is the easiest and most intuitive scale to interpret
the results. There are other options for specific models as well, e.g. with
zero-inflation component (see documentation of the <code>type</code>-argument). The
result is returned as consistent data frame, which is nicely printed by
default. <code>plot()</code> can be used to easily create figures.
</p>
<p>The main function to calculate marginal means and adjusted predictions is
<code>predict_response()</code>. In previous versions of <strong>ggeffects</strong>, the functions
<code>ggpredict()</code>, <code>ggemmeans()</code>, <code>ggeffect()</code> and <code>ggaverage()</code> were used to
calculate marginal means and adjusted predictions. These functions are still
available, but <code>predict_response()</code> as a "wrapper" around these functions is
the preferred way to do this now.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ggeffects'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  stringsAsFactors = FALSE,
  terms_to_colnames = FALSE
)

ggaverage(
  model,
  terms,
  ci_level = 0.95,
  type = "fixed",
  typical = "mean",
  condition = NULL,
  back_transform = TRUE,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  weights = NULL,
  verbose = TRUE,
  ...
)

ggeffect(
  model,
  terms,
  ci_level = 0.95,
  bias_correction = FALSE,
  verbose = TRUE,
  ci.lvl = ci_level,
  ...
)

ggemmeans(
  model,
  terms,
  ci_level = 0.95,
  type = "fixed",
  typical = "mean",
  condition = NULL,
  back_transform = TRUE,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  interval = "confidence",
  bias_correction = FALSE,
  verbose = TRUE,
  ci.lvl = ci_level,
  back.transform = back_transform,
  ...
)

ggpredict(
  model,
  terms,
  ci_level = 0.95,
  type = "fixed",
  typical = "mean",
  condition = NULL,
  back_transform = TRUE,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  interval,
  verbose = TRUE,
  ci.lvl = ci_level,
  back.transform = back_transform,
  vcov.fun = vcov_fun,
  vcov.type = vcov_type,
  vcov.args = vcov_args,
  bias_correction = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>ggeffects</code>, as returned by <code>predict_response()</code>,
<code>ggpredict()</code>, <code>ggeffect()</code>, <code>ggaverage()</code> or <code>ggemmeans()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code>make.names</code>) is optional.  Note that all of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code>data.frame(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments are passed down to <code>ggpredict()</code> (further down to <code>predict()</code>)
or <code>ggemmeans()</code> (and thereby to <code>emmeans::emmeans()</code>), If <code>type = "simulate"</code>,
<code>...</code> may also be used to set the number of simulation, e.g. <code>nsim = 500</code>.
When calling <code>ggeffect()</code>, further arguments passed down to <code>effects::Effect()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stringsAsFactors</code></td>
<td>
<p>logical: should the character vector be converted
to a factor?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms_to_colnames</code></td>
<td>
<p>Logical, if <code>TRUE</code>, standardized column names (like
<code>"x"</code>, <code>"group"</code> or <code>"facet"</code>) are replaced by the variable names of the focal
predictors specified in <code>terms</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A model object, or a list of model objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>Names of those terms from <code>model</code>, for which predictions should
be displayed (so called <em>focal terms</em>). Can be:
</p>

<ul>
<li>
<p> A character vector, specifying the names of the focal terms. This is the
preferred and probably most flexible way to specify focal terms, e.g.
<code>terms = "x [40:60]"</code>, to calculate predictions for the values 40 to 60.
</p>
</li>
<li>
<p> A list, where each element is a named vector, specifying the focal terms
and their values. This is the "classical" R way to specify focal terms,
e.g. <code>list(x = 40:60)</code>.
</p>
</li>
<li>
<p> A formula, e.g. <code>terms = ~ x + z</code>, which is internally converted to a
character vector. This is probably the least flexible way, as you cannot
specify representative values for the focal terms.
</p>
</li>
<li>
<p> A data frame representing a "data grid" or "reference grid". Predictions
are then made for all combinations of the variables in the data frame.
</p>
</li>
</ul>
<p><code>terms</code> at least requires one variable name. The maximum length is four terms,
where the second to fourth term indicate the groups, i.e. predictions of the first
term are grouped at meaningful values or levels of the remaining terms (see
<code>values_at()</code>). It is also possible to define specific values for focal
terms, at which adjusted predictions should be calculated (see details below).
All remaining covariates that are not specified in <code>terms</code> are "marginalized",
see the <code>margin</code> argument in <code>?predict_response</code>. See also argument <code>condition</code>
to fix non-focal terms to specific values, and argument <code>typical</code> for
<code>ggpredict()</code> or <code>ggemmeans()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_level</code></td>
<td>
<p>Numeric, the level of the confidence intervals. Use
<code>ci_level = NA</code> if confidence intervals should not be calculated
(for instance, due to computation time). Typically, confidence intervals are
based on the returned standard errors for the predictions, assuming a t- or
normal distribution (based on the model and the available degrees of freedom,
i.e. roughly <code style="white-space: pre;">⁠+/- 1.96 * SE⁠</code>). See introduction of
<a href="https://strengejacke.github.io/ggeffects/articles/ggeffects.html">this vignette</a>
for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character, indicating whether predictions should be conditioned
on specific model components or not. Consequently, most options only apply
for survival models, mixed effects models and/or models with zero-inflation
(and their Bayesian counter-parts); only exception is <code>type = "simulate"</code>,
which is available for some other model classes as well (which respond to
<code>simulate()</code>).
</p>
<p><strong>Note 1:</strong> For <code>brmsfit</code>-models with zero-inflation component, there is no
<code>type = "zero_inflated"</code> nor <code>type = "zi_random"</code>; predicted values for these
models <em>always</em> condition on the zero-inflation part of the model. The same
is true for <code>MixMod</code>-models from <strong>GLMMadaptive</strong> with zero-inflation
component (see 'Details').
</p>
<p><strong>Note 2:</strong> If <code>margin = "empirical"</code>, or when calling <code>ggaverage()</code> respectively,
(i.e. counterfactual predictions), the <code>type</code> argument is handled differently.
It is set to <code>"response"</code> by default, but usually accepts all possible options
from the <code>type</code>-argument of the model's respective <code>predict()</code> method. E.g.,
passing a <code>glm</code> object would allow the options <code>"response"</code>, <code>"link"</code>, and
<code>"terms"</code>. For models with zero-inflation component, the below mentioned
options <code>"fixed"</code>, <code>"zero_inflated"</code> and <code>"zi_prob"</code> can also be used and will
be "translated" into the corresponding <code>type</code> option of the model's respective
<code>predict()</code>-method.
</p>

<ul>
<li> <p><code>"fixed"</code> (or <code>"count"</code>)
</p>
<p>Predicted values are conditioned on the fixed effects or conditional
model only (for mixed models: predicted values are on the population-level
and <em>confidence intervals</em> are returned, i.e. <code>re.form = NA</code> when calling
<code>predict()</code>). For instance, for models fitted with <code>zeroinfl</code> from <strong>pscl</strong>,
this would return the predicted mean from the count component (without
zero-inflation). For models with zero-inflation component, this type calls
<code>predict(..., type = "link")</code> (however, predicted values are
back-transformed to the response scale, i.e. the conditional mean of the
response).
</p>
</li>
<li> <p><code>"random"</code>
</p>
<p>This only applies to mixed models, and <code>type = "random"</code> does not condition
on the zero-inflation component of the model. <code>type = "random"</code> still
returns population-level predictions, however, conditioned on random effects
and considering individual level predictions, i.e. <code>re.form = NULL</code> when
calling <code>predict()</code>. This may affect the returned predicted values, depending
on whether <code>REML = TRUE</code> or <code>REML = FALSE</code> was used for model fitting.
Furthermore, unlike <code>type = "fixed"</code>, intervals also consider the uncertainty
in the variance parameters (the mean random effect variance, see <em>Johnson
et al. 2014</em> for details) and hence can be considered as <em>prediction intervals</em>.
For models with zero-inflation component, this type calls
<code>predict(..., type = "link")</code> (however, predicted values are back-transformed
to the response scale).
</p>
<p>To get predicted values for each level of the random effects groups, add the
name of the related random effect term to the <code>terms</code>-argument
(for more details, see
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>).
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"zi"</code>)
</p>
<p>Predicted values are conditioned on the fixed effects and the zero-inflation
component. For instance, for models fitted with <code>zeroinfl</code> from <strong>pscl</strong>,
this would return the predicted (or expected) response (<code>mu*(1-p)</code>),
and for <strong>glmmTMB</strong>, this would return the expected response <code>mu*(1-p)</code>
<em>without</em> conditioning on random effects (i.e. random effect variances
are not taken into account for the confidence intervals). For models with
zero-inflation component, this type calls <code>predict(..., type = "response")</code>.
See 'Details'.
</p>
</li>
<li> <p><code>"zi_random"</code> (or <code>"zero_inflated_random"</code>)
</p>
<p>Predicted values are conditioned on the zero-inflation component and
take the random effects uncertainty into account. For models fitted with
<code>glmmTMB()</code>, <code>hurdle()</code> or <code>zeroinfl()</code>, this would return the
expected value <code>mu*(1-p)</code>. For <strong>glmmTMB</strong>, prediction intervals
also consider the uncertainty in the random effects variances. This
type calls <code>predict(..., type = "response")</code>. See 'Details'.
</p>
</li>
<li> <p><code>"zi_prob"</code>
</p>
<p>Predicted zero-inflation probability. For <strong>glmmTMB</strong> models with
zero-inflation component, this type calls <code>predict(..., type = "zlink")</code>;
models from <strong>pscl</strong> call <code>predict(..., type = "zero")</code> and for
<strong>GLMMadaptive</strong>, <code>predict(..., type = "zero_part")</code> is called.
</p>
</li>
<li> <p><code>"simulate"</code>
</p>
<p>Predicted values and confidence resp. prediction intervals are
based on simulations, i.e. calls to <code>simulate()</code>. This type
of prediction takes all model uncertainty into account, including
random effects variances. Currently supported models are objects of
class <code>lm</code>, <code>glm</code>, <code>glmmTMB</code>, <code>wbm</code>, <code>MixMod</code> and <code>merMod</code>.
See <code>...</code> for details on number of simulations.
</p>
</li>
<li> <p><code>"survival"</code> and <code>"cumulative_hazard"</code>
</p>
<p>Applies only to <code>coxph</code>-objects from the <strong>survial</strong>-package and
calculates the survival probability or the cumulative hazard of an event.
</p>
</li>
</ul>
<p>When <code>margin = "empirical"</code> (or when calling <code>ggaverage()</code>), the <code>type</code>
argument accepts all values from the <code>type</code>-argument of the model's respective
<code>predict()</code>-method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typical</code></td>
<td>
<p>Character vector, naming the function to be applied to the
covariates (non-focal terms) over which the effect is "averaged". The
default is <code>"mean"</code>. Can be <code>"mean"</code>, "<code>weighted.mean</code>", <code>"median"</code>, <code>"mode"</code>
or <code>"zero"</code>, which call the corresponding R functions (except <code>"mode"</code>,
which calls an internal function to compute the most common value); <code>"zero"</code>
simply returns 0. By default, if the covariate is a factor, only <code>"mode"</code> is
applicable; for all other values (including the default, <code>"mean"</code>) the
reference level is returned. For character vectors, only the mode is returned.
You can use a named vector to apply different functions to integer, numeric and
categorical covariates, e.g. <code>typical = c(numeric = "median", factor = "mode")</code>.
If <code>typical</code> is <code>"weighted.mean"</code>, weights from the model are used. If no
weights are available, the function falls back to <code>"mean"</code>. <strong>Note</strong> that this
argument is ignored for <code>predict_response()</code>, because the <code>margin</code> argument
takes care of this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>Named character vector, which indicates covariates that
should be held constant at specific values. Unlike <code>typical</code>, which
applies a function to the covariates to determine the value that is used
to hold these covariates constant, <code>condition</code> can be used to define
exact values, for instance <code>condition = c(covariate1 = 20, covariate2 = 5)</code>.
See 'Examples'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>back_transform</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default), predicted values for
log-, log-log, exp, sqrt and similar transformed responses will be
back-transformed to original response-scale. See
<code>insight::find_transformation()</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_fun</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty
estimates (e.g., for confidence intervals based on robust standard errors).
This argument accepts a covariance matrix, a function which returns a
covariance matrix, or a string which identifies the function to be used to
compute the covariance matrix.
</p>

<ul>
<li>
<p> A (variance-covariance) matrix
</p>
</li>
<li>
<p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li>
<p> A string which indicates the estimation type for the heteroscedasticity-consistent
variance-covariance matrix, e.g. <code>vcov_fun = "HC0"</code>. Possible values are
<code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, and <code>"HC5"</code>, which
will then call the <code>vcovHC()</code>-function from the <strong>sandwich</strong> package, using
the specified type. Further possible values are <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, and <code>"CR3"</code>, which will call the <code>vcovCR()</code>-function from
the <strong>clubSandwich</strong> package.
</p>
</li>
<li>
<p> A string which indicates the name of the <code style="white-space: pre;">⁠vcov*()⁠</code>-function from the
<strong>sandwich</strong> or <strong>clubSandwich</strong> packages, e.g. <code>vcov_fun = "vcovCL"</code>,
which is used to compute (cluster) robust standard errors for predictions.
</p>
</li>
</ul>
<p>If <code>NULL</code>, standard errors (and confidence intervals) for predictions are
based on the standard errors as returned by the <code>predict()</code>-function.
<strong>Note</strong> that probably not all model objects that work with <code>predict_response()</code>
are also supported by the <strong>sandwich</strong> or <strong>clubSandwich</strong> packages.
</p>
<p>See details in <a href="https://strengejacke.github.io/ggeffects/articles/practical_robustestimation.html">this vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_type</code></td>
<td>
<p>Character vector, specifying the estimation type for the
robust covariance matrix estimation (see <code>?sandwich::vcovHC</code>
or <code>?clubSandwich::vcovCR</code> for details). Only used when <code>vcov_fun</code> is a
character string indicating one of the functions from those packages.
When <code>vcov_fun</code> is a function, a possible <code>type</code> argument <em>must</em> be provided
via the <code>vcov_args</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_args</code></td>
<td>
<p>List of named vectors, used as additional arguments that
are passed down to <code>vcov_fun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>This argument is used in two different ways, depending on the
<code>margin</code> argument.
</p>

<ul>
<li>
<p> When <code>margin = "empirical"</code>, <code>weights</code> can either be a character vector,
naming the weigthing variable in the data, or a vector of weights (of same
length as the number of observations in the data). This variable will be
used to weight adjusted predictions.
</p>
</li>
<li>
<p> When <code>margin = "marginalmeans"</code>, <code>weights</code> must be a character vector and
is passed to <code>emmeans::emmeans()</code>, specifying weights to use in averaging
non-focal categorical predictors. See https://rvlenth.github.io/emmeans/reference/emmeans.html
for details.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Toggle messages or warnings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias_correction</code></td>
<td>
<p>Logical, if <code>TRUE</code>, adjusts for bias-correction when
back-transforming the predicted values (to the response scale) for
non-Gaussian <em>mixed models</em>. Back-transforming the the population-level
predictions ignores the effect of the variation around the population mean,
so the result on the original data scale is biased due to <em>Jensen's
inequality</em>. To apply bias-correction, a valid value of sigma is required,
which is extracted by default using <code>insight::get_variance_residual()</code>.
Optionally, to provide own estimates of uncertainty, use the <code>sigma</code>
argument. Note that <code>bias_correction</code> currently only applies to mixed models,
where there are additive random components involved and where that
bias-adjustment can be appropriate. If <code>ggemmeans()</code> is called,
bias-correction can also be applied to GEE-models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.lvl, vcov.fun, vcov.type, vcov.args, back.transform</code></td>
<td>
<p>Deprecated arguments.
Please use <code>ci_level</code>, <code>vcov_fun</code>, <code>vcov_type</code>, <code>vcov_args</code> and <code>back_transform</code>
instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>Type of interval calculation, can either be <code>"confidence"</code>
(default) or <code>"prediction"</code>. May be abbreviated. Unlike <em>confidence intervals</em>,
<em>prediction intervals</em> include the residual variance (sigma^2) to account for
the uncertainty of predicted values. For mixed models, <code>interval = "prediction"</code>
is the default for <code>type = "random"</code>. When <code>type = "fixed"</code>, the default is
<code>interval = "confidence"</code>. Note that prediction intervals are not available
for all models, but only for models that work with <code>insight::get_sigma()</code>.
For Bayesian models, when <code>interval = "confidence"</code>, predictions are based on
posterior draws of the linear predictor <code>rstantools::posterior_epred()</code>.
If <code>interval = "prediction"</code>, <code>rstantools::posterior_predict()</code> is called.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Please see <code>?predict_response</code> for details and examples.
</p>


<h3>Value</h3>

<p>A data frame (with <code>ggeffects</code> class attribute) with consistent data columns:
</p>

<ul>
<li> <p><code>"x"</code>: the values of the first term in <code>terms</code>, used as x-position in plots.
</p>
</li>
<li> <p><code>"predicted"</code>: the predicted values of the response, used as y-position in plots.
</p>
</li>
<li> <p><code>"std.error"</code>: the standard error of the predictions. <em>Note that the standard
errors are always on the link-scale, and not back-transformed for non-Gaussian
models!</em>
</p>
</li>
<li> <p><code>"conf.low"</code>: the lower bound of the confidence interval for the predicted values.
</p>
</li>
<li> <p><code>"conf.high"</code>: the upper bound of the confidence interval for the predicted values.
</p>
</li>
<li> <p><code>"group"</code>: the grouping level from the second term in <code>terms</code>, used as
grouping-aesthetics in plots.
</p>
</li>
<li> <p><code>"facet"</code>: the grouping level from the third term in <code>terms</code>, used to indicate
facets in plots.
</p>
<p>The estimated marginal means (or predicted values) are always on the
response scale!
</p>
<p>For proportional odds logistic regression (see <code>?MASS::polr</code>)
resp. cumulative link models (e.g., see <code>?ordinal::clm</code>),
an additional column <code>"response.level"</code> is returned, which indicates
the grouping of predictions based on the level of the model's response.
</p>
<p>Note that for convenience reasons, the columns for the intervals
are always named <code>"conf.low"</code> and <code>"conf.high"</code>, even though
for Bayesian models credible or highest posterior density intervals
are returned.
</p>
<p>There is an <code>as.data.frame()</code> method for objects of class <code>ggeffects</code>,
which has an <code>terms_to_colnames</code> argument, to use the term names as column
names instead of the standardized names <code>"x"</code> etc.
</p>
</li>
</ul>
</div>