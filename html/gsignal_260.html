<div class="container">

<table style="width: 100%;"><tr>
<td>stft</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Short-Term Fourier Transform</h2>

<h3>Description</h3>

<p>Compute the short-term Fourier transform of a vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stft(
  x,
  window = nextpow2(sqrt(NROW(x))),
  overlap = 0.75,
  nfft = ifelse(isScalar(window), window, length(window)),
  fs = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input data, specified as a numeric or complex vector or matrix. In
case of a vector it represents a single signal; in case of a matrix each
column is a signal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>If <code>window</code> is a vector, each segment has the same length
as <code>window</code> and is multiplied by <code>window</code> before (optional)
zero-padding and calculation of its periodogram. If <code>window</code> is a
scalar, each segment has a length of <code>window</code> and a Hamming window is
used. Default: <code>nextpow2(sqrt(NROW(x)))</code> (the square root of the
length of <code>x</code> rounded up to the next power of two). The window length
must be larger than 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap</code></td>
<td>
<p>segment overlap, specified as a numeric value expressed as a
multiple of window or segment length. 0 &lt;= overlap &lt; 1. Default: 0.75.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfft</code></td>
<td>
<p>Length of FFT, specified as an integer scalar. The default is the
length of the <code>window</code> vector or has the same value as the scalar
<code>window</code> argument.  If <code>nfft</code> is larger than the segment length,
(seg_len), the data segment is padded <code>nfft - seg_len</code> zeros. The
default is no padding. Nfft values smaller than the length of the data
segment (or window) are ignored. Note that the use of padding to increase
the frequency resolution of the spectral estimate is controversial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs</code></td>
<td>
<p>sampling frequency (Hertz), specified as a positive scalar.
Default: 1.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>f</code></dt>
<dd>
<p>vector of frequencies at which the STFT is estimated.
If <code>x</code> is numeric, power from negative frequencies is added to the
positive side of the spectrum, but not at zero or Nyquist (fs/2)
frequencies. This keeps power equal in time and spectral domains. If
<code>x</code> is complex, then the whole frequency range is returned.</p>
</dd>
<dt><code>t</code></dt>
<dd>
<p>vector of time points at which the STFT is estimated.</p>
</dd>
<dt><code>s</code></dt>
<dd>
<p>Short-time Fourier transform, returned as a matrix or
a 3-D array. Time increases across the columns of <code>s</code> and frequency
increases down the rows. The third dimension, if present, corresponds to
the input channels.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Andreas Weingessel, <a href="mailto:Andreas.Weingessel@ci.tuwien.ac.at">Andreas.Weingessel@ci.tuwien.ac.at</a>.<br>
Conversion to R by Geert van Boxtel, <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">fs &lt;- 8000
y &lt;- chirp(seq(0, 5 - 1/fs, by = 1/fs), 200, 2, 500, "logarithmic")
ft &lt;- stft (y, fs = fs)
filled.contour(ft$t, ft$f, t(ft$s), xlab = "Time (s)",
               ylab = "Frequency (Hz)")

</code></pre>


</div>