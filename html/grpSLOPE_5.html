<div class="container">

<table style="width: 100%;"><tr>
<td>lambdaGroupSLOPE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularizing sequence for Group SLOPE</h2>

<h3>Description</h3>

<p>Generate the regularizing sequence <code>lambda</code> for the Group SLOPE
problem according to one of multiple methods (see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">lambdaGroupSLOPE(method, fdr, group, wt, n.obs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Possible values are "max", "mean",
and "corrected". See under Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fdr</code></td>
<td>
<p>Target group false discovery rate (gFDR)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A vector describing the grouping structure. It should 
contain a group id for each predictor variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>A named vector of weights, one weight per group of predictors
(named according to names as in vector <code>group</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.obs</code></td>
<td>
<p>Number of observations (i.e., number of rows in <code>A</code>);
required only if method is "corrected"</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Multiple methods are available to generate the regularizing sequence <code>lambda</code>:
</p>

<ul>
<li>
<p> "max" – lambdas as in Theorem 2.5 in Brzyski et. al. (2016).
Provalby controls gFDR in orthogonal designs.
</p>
</li>
<li>
<p> "mean" – lambdas of equation (2.16) in Brzyski et. al. (2016).
Applicable for gFDR control in orthogonal designs. Less conservative than "max".
</p>
</li>
<li>
<p> "corrected" – lambdas of Procedure 1 in Brzyski et. al. (2016);
in the special case that all group sizes are equal and <code>wt</code> is a constant vector, 
Procedure 6 of Brzyski et. al. (2016) is applied.
Applicable for gFDR control when predictors from different groups are stochastically independent.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A vector containing the calculated lambda values.
</p>


<h3>References</h3>

<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2016) <em>Group SLOPE – adaptive selection of groups of predictors</em>, <a href="https://arxiv.org/abs/1610.04960">https://arxiv.org/abs/1610.04960</a>
</p>
<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2019) <em>Group SLOPE – adaptive selection of groups of predictors</em>. Journal of the American Statistical Association 114 (525): 419–33.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># specify 6 groups of sizes 2, 3, and 4
group &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3,
           4, 4, 5, 5, 5, 6, 6, 6, 6)
# set the weight for each group to the square root of the group's size
wt &lt;- rep(c(sqrt(2), sqrt(3), sqrt(4)), 2)
names(wt) &lt;- 1:6
# compute different lambda sequences
lambda.max &lt;- lambdaGroupSLOPE(method="max", fdr=0.1, group=group, wt=wt) 
lambda.mean &lt;- lambdaGroupSLOPE(method="mean", fdr=0.1, group=group, wt=wt) 
lambda.corrected &lt;- lambdaGroupSLOPE(method="corrected", fdr=0.1,
                                     group=group, wt=wt, n.obs=1000)
rbind(lambda.max, lambda.mean, lambda.corrected)
#                      [,1]     [,2]     [,3]     [,4]     [,5]     [,6]
# lambda.max       2.023449 1.844234 1.730818 1.645615 1.576359 1.517427
# lambda.mean      1.880540 1.723559 1.626517 1.554561 1.496603 1.447609
# lambda.corrected 1.880540 1.729811 1.637290 1.568971 1.514028 1.467551

</code></pre>


</div>