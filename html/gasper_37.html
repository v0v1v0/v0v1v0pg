<div class="container">

<table style="width: 100%;"><tr>
<td>SURE_MSEthresh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stein's Unbiased Risk Estimate with MSE</h2>

<h3>Description</h3>

<p>Adaptive Threshold Selection Using Principle of SURE with the inclusion of Mean Squared Error (MSE) for comparison.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SURE_MSEthresh(
  wcn,
  wcf,
  thresh,
  diagWWt,
  beta = 2,
  sigma,
  hatsigma = NA,
  policy = "uniform",
  keepwc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>wcn</code></td>
<td>
<p>Numeric vector of the noisy spectral graph wavelet coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wcf</code></td>
<td>
<p>Numeric vector of the true spectral graph wavelet coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Numeric vector of threshold values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagWWt</code></td>
<td>
<p>Numeric vector of weights typically derived from the diagonal elements of the wavelet frame matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A numeric value specifying the type of thresholding to be used, for example:
</p>

<ul>
<li>
<p> 1 for soft thresholding.
</p>
</li>
<li>
<p> 2 for James-Stein thresholding.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>A numeric value representing the standard deviation (sd) of the noise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatsigma</code></td>
<td>
<p>An optional numeric value providing an estimate of the noise standard deviation (default is NA).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>policy</code></td>
<td>
<p>A character string determining the thresholding policy. Valid options include:
</p>

<ul>
<li>
<p> "uniform" for a global threshold applied uniformly across all coefficients.
</p>
</li>
<li>
<p> "dependent" for threshold values that adaptively depend on the corresponding 'diagWWt' weights.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepwc</code></td>
<td>
<p>A logical value determining if the thresholded wavelet coefficients should be returned (Default is TRUE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>SURE_MSEthresh</code> function extends the <code>SUREthresh</code> function by providing an MSE between the true coefficients and their thresholded versions for a given thresholding function <code class="reqn">h</code>. This allows for a more comprehensive evaluation of the denoising quality in simulated scenarios where the true function is known.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li>
<p> A dataframe with calculated MSE, SURE, and hatSURE values.
</p>
</li>
<li>
<p> Minima of SURE, hatSURE, and MSE, and their corresponding optimal thresholds.
</p>
</li>
<li>
<p> Thresholded wavelet coefficients (if <code>keepwc = TRUE</code>).
</p>
</li>
</ul>
<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>Stein, C. M. (1981). Estimation of the mean of a multivariate normal distribution. The annals of Statistics, 1135-1151.
</p>


<h3>See Also</h3>

<p><code>SUREthresh</code>, <code>GVN</code>, <code>HPFVN</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Compute the Laplacian matrix and its eigen-decomposition
L &lt;- laplacian_mat(grid1$sA)
U &lt;- eigensort(L)

# Compute the tight frame coefficients
tf &lt;- tight_frame(U$evalues, U$evectors)

# Generate some noisy observation
n &lt;- nrow(L)
f &lt;- randsignal(0.01, 3, grid1$sA)
sigma &lt;- 0.01
noise &lt;- rnorm(n, sd = sigma)
tilde_f &lt;- f + noise

# Compute the transform coefficients
wcn &lt;- analysis(tilde_f, tf)
wcf &lt;- analysis(f, tf)

# Compute the weights and use DJ trick for the SURE evaluation
diagWWt &lt;- colSums(t(tf)^2)
thresh &lt;- sort(abs(wcn))

# Compute to optimal threshold
opt_thresh_u &lt;- SURE_MSEthresh(wcn,
                               wcf,
                               thresh,
                               diagWWt,
                               beta=2,
                               sigma,
                               NA,
                               policy = "uniform",
                               keepwc = TRUE)
# Extract corresponding wavelet coefficients
wc_oracle_u &lt;- opt_thresh_u$wc[, opt_thresh_u$min["xminMSE"]]
wc_SURE_u &lt;- opt_thresh_u$wc[, opt_thresh_u$min["xminSURE"]]

# Get the graph signal estimators
hatf_oracle_u &lt;- synthesis(wc_oracle_u, tf)
hatf_SURE_u  &lt;- synthesis(wc_SURE_u, tf)

# Compare the perfomance according to SNR measure
round(SNR(f, hatf_oracle_u), 2)
round(SNR(f, hatf_SURE_u), 2)

## End(Not run)

</code></pre>


</div>