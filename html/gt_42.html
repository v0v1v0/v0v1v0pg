<div class="container">

<table style="width: 100%;"><tr>
<td>cols_nanoplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add a new column of nanoplots, taking input data from selected columns</h2>

<h3>Description</h3>

<p>Nanoplots are tiny plots you can use in your <strong>gt</strong> table. They are simple by
design, mainly because there isn't a lot of space to work with. With that
simplicity, however, you do get a set of very succinct data visualizations
that adapt nicely to the amount of data you feed into them. With
<code>cols_nanoplot()</code> you take data from one or more columns as the basic inputs
for the nanoplots and generate a new column containing the plots. The
nanoplots are robust against missing values, and multiple strategies are
available for handling missingness.
</p>
<p>Nanoplots try to show individual data with reasonably good visibility.
Interactivity is included as a basic feature so one can hover over the data
points and vertical guides will display the value ascribed to each data
point. Because <strong>gt</strong> knows all about numeric formatting, values will be
compactly formatted so as to not take up valuable real estate. If you need to
create a nanoplot based on monetary values, that can be handled by providing
the currency code to the <code>nanoplot_options()</code> helper (then hook that up to
the <code>options</code> argument).  A guide on the left-hand side of the plot area will
appear on hover and display the minimal and maximal <em>y</em> values.
</p>
<p>There are three types of nanoplots available: <code>"line"</code>, <code>"bar"</code>, <code>"boxplot"</code>.
A line plot shows individual data points and has smooth connecting lines
between them to allow for easier scanning of values. You can opt for
straight-line connections between data points, or, no connections at all
(it's up to you). You can even eschew the data points and just have a simple
line. Regardless of how you mix and match difference plot layers, the plot
area focuses on the domain of the data points with the goal of showing you
the overall trend of the data. The data you feed into a line plot can consist
of a single vector of values (resulting in equally-spaced <em>y</em> values), or,
you can supply two vectors representative of <em>x</em> and <em>y</em>.
</p>
<p>A bar plot is built a little bit differently. The focus is on evenly-spaced
bars (requiring a single vector of values) that project from a zero line,
clearly showing the difference between positive and negative values. By
default, any type of nanoplot will have basic interactivity. One can hover
over the data points and vertical guides will display values ascribed to
each. A guide on the left-hand side of the plot area will display the minimal
and maximal <em>y</em> values on hover.
</p>
<p>Every box plot will take the collection of values for a row and construct the
plot horizontally. This is essentially a standard box-and-whisker diagram
where outliers are automatically displayed outside the left and right fences.
</p>
<p>While basic customization options are present in the <code>cols_nanoplot()</code>, many
more opportunities for customizing nanoplots on a more granular level are
possible with the <code>nanoplot_options()</code> helper function. That function should
be invoked at the <code>options</code> argument of <code>cols_nanoplot()</code>. Through that
helper, layers of the nanoplots can be selectively removed and the aesthetics
of the remaining plot components can be modified.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cols_nanoplot(
  data,
  columns,
  rows = everything(),
  plot_type = c("line", "bar", "boxplot"),
  plot_height = "2em",
  missing_vals = c("gap", "marker", "zero", "remove"),
  autoscale = FALSE,
  autohide = TRUE,
  columns_x_vals = NULL,
  reference_line = NULL,
  reference_area = NULL,
  expand_x = NULL,
  expand_y = NULL,
  new_col_name = NULL,
  new_col_label = NULL,
  before = NULL,
  after = NULL,
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><em>The gt table data object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;gt_tbl&gt;⁠</code> // <strong>required</strong>
</p>
<p>This is the <strong>gt</strong> table object that is commonly created through use of the
<code>gt()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns from which to get data for the dependent variable</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <strong>required</strong>
</p>
<p>The columns which contain the numeric data to be plotted as nanoplots. Can
either be a series of column names provided in <code>c()</code>, a vector of column
indices, or a select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>). Data
collected from the columns will be concatenated together in the order of
resolution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p><em>Rows that should contain nanoplots</em>
</p>
<p><code style="white-space: pre;">⁠&lt;row-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>With <code>rows</code> we can specify which rows should contain nanoplots in the new
column. The default <code>everything()</code> results in all rows in <code>columns</code> being
formatted. Alternatively, we can supply a vector of row IDs within <code>c()</code>, a
vector of row indices, or a select helper function (e.g. <code>starts_with()</code>,
<code>ends_with()</code>, <code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and
<code>everything()</code>). We can also use expressions to filter down to the rows we
need (e.g., <code style="white-space: pre;">⁠[colname_1] &gt; 100 &amp; [colname_2] &lt; 50⁠</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_type</code></td>
<td>
<p><em>The type of nanoplot to display</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[line|bar|boxplot]⁠</code> // <em>default:</em> <code>"line"</code>
</p>
<p>Nanoplots can either take the form of a line plot (using <code>"line"</code>), a bar
plot (with <code>"bar"</code>), or a box plot (<code>"boxplot"</code>). A line plot, by default,
contains layers for a data line, data points, and a data area. Each of
these can be deactivated by using <code>nanoplot_options()</code>. With a bar plot,
the always visible layer is that of the data bars. Furthermore, a line plot
can optionally take in <em>x</em> values through the <code>columns_x_vals</code> argument
whereas bar plots and box plots both ignore any data representing the
independent variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_height</code></td>
<td>
<p><em>The height of the nanoplots</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>"2em"</code>
</p>
<p>The height of the nanoplots. The default here is a sensible value of
<code>"2em"</code>. By way of comparison, this is a far greater height than the
default for icons through <code>fmt_icon()</code> (<code>"1em"</code>) and is the same height as
images inserted via <code>fmt_image()</code> (also having a <code>"2em"</code> height default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_vals</code></td>
<td>
<p><em>Treatment of missing values</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[gap|marker|zero|remove]⁠</code> // <em>default:</em> <code>"gap"</code>
</p>
<p>If missing values are encountered within the input data, there are three
strategies available for their handling: (1) <code>"gap"</code> will show data gaps
at the sites of missing data, where data lines will have discontinuities
and bar plots will have missing bars; (2) <code>"marker"</code> will behave like
<code>"gap"</code> but show prominent visual marks at the missing data locations; (3)
<code>"zero"</code> will replace <code>NA</code> values with zero values; and (4) <code>"remove"</code> will
remove any incoming <code>NA</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoscale</code></td>
<td>
<p><em>Automatically set x- and y-axis scale limits based on data</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Using <code>autoscale = TRUE</code> will ensure that the bounds of all nanoplots
produced are based on the limits of data combined from all input rows. This
will result in a shared scale across all of the nanoplots (for <em>y</em>- and
<em>x</em>-axis data), which is useful in those cases where the nanoplot data
should be compared across rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autohide</code></td>
<td>
<p><em>Automatically hide the <code>columns</code>/<code>columns_x_vals</code> column(s)</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>An option to automatically hide any columns specified in <code>columns</code> and also
<code>columns_x_vals</code> (if used). Any columns with their state changed to
'hidden' will behave the same as before, they just won't be displayed in
the finalized table. Should you want to have these 'input' columns be
viewable, set <code>autohide = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns_x_vals</code></td>
<td>
<p><em>Columns containing values for the optional x variable</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>We can optionally obtain data for the independent variable (i.e., the
<em>x</em>-axis data) if specifying columns in <code>columns_x_vals</code>. This is only for
the <code>"line"</code> type of plot (set via the <code>plot_type</code> argument). We can supply
either be a series of column names provided in <code>c()</code>, a vector of column
indices, or a select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>). Data
collected from the columns will be concatenated together in the order of
resolution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_line</code></td>
<td>
<p><em>Add a reference line</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;numeric|integer|character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A reference line requires a single input to define the line. It could be a
static numeric value, applied to all nanoplots generated. Or, the input can
be one of the following for generating the line from the underlying data:
(1) <code>"mean"</code>, (2) <code>"median"</code>, (3) <code>"min"</code>, (4) <code>"max"</code>, (5) <code>"q1"</code>, (6)
<code>"q3"</code>, (7) <code>"first"</code>, or (8) <code>"last"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_area</code></td>
<td>
<p><em>Add a reference area</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;numeric|integer|character&gt;|list⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A reference area requires two inputs to define bottom and top boundaries
for a rectangular area. The types of values supplied are the same as those
expected for <code>reference_line</code>, which is either a static numeric value or
one of the following keywords for the generation of the value: (1)
<code>"mean"</code>, (2) <code>"median"</code>, (3) <code>"min"</code>, (4) <code>"max"</code>, (5) <code>"q1"</code>, (6) <code>"q3"</code>,
(7) <code>"first"</code>, or (8) <code>"last"</code>. Input can either be a vector or list with
two elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand_x, expand_y</code></td>
<td>
<p><em>Expand plot scale in the x and y directions</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;numeric|integer&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>Should you need to have plots expand in the <em>x</em> or <em>y</em> direction, provide
one or more values to <code>expand_x</code> or <code>expand_y</code>. Any values provided that
are outside of the range of data provided to the plot should result in a
scale expansion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_col_name</code></td>
<td>
<p><em>Column name for the new column containing the plots</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A single column name in quotation marks. Values will be extracted from this
column and provided to compatible arguments. If not provided the new column
name will be <code>"nanoplots"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_col_label</code></td>
<td>
<p><em>Column label for the new column containing the plots</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A single column label. If not supplied then the column label will inherit
from <code>new_col_name</code> (if nothing provided to that argument, the label will
be <code>"nanoplots"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>before, after</code></td>
<td>
<p><em>Column used as anchor</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A single column-resolving expression or column index can be given to either
<code>before</code> or <code>after</code>. The column specifies where the new column containing
the nanoplots should be positioned among the existing columns in the input
data table. While select helper functions such as <code>starts_with()</code> and
<code>ends_with()</code> can be used for column targeting, it's recommended that a
single column name or index be used. This is to ensure that exactly one
column is provided to either of these arguments (otherwise, the function
will be stopped). If nothing is provided for either argument then the new
column will be placed at the end of the column series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p><em>Set options for the nanoplots</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;nanoplot_options⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>By using the <code>nanoplot_options()</code> helper function here, you can alter the
layout and styling of the nanoplots in the new column.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>gt_tbl</code>.
</p>


<h3>Targeting cells with <code>columns</code> and <code>rows</code>
</h3>

<p>Targeting of values to insert into the nanoplots is done through <code>columns</code>
and additionally by <code>rows</code> (if nothing is provided for <code>rows</code> then entire
columns are selected). Aside from declaring column names in <code>c()</code> (with bare
column names or names in quotes) we can use also
<strong>tidyselect</strong>-style expressions. This can be as basic as supplying a select
helper like <code>starts_with()</code>, or, providing a more complex incantation like
</p>
<p><code>where(~ is.numeric(.x) &amp; max(.x, na.rm = TRUE) &gt; 1E6)</code>
</p>
<p>which targets numeric columns that have a maximum value greater than
1,000,000 (excluding any <code>NA</code>s from consideration).
</p>
<p>Once the columns are targeted, we may also target the <code>rows</code> within those
columns. This can be done in a variety of ways. If a stub is present, then we
potentially have row identifiers. Those can be used much like column names in
the <code>columns</code>-targeting scenario. We can use simpler <strong>tidyselect</strong>-style
expressions (the select helpers should work well here) and we can use quoted
row identifiers in <code>c()</code>. It's also possible to use row indices (e.g.,
<code>c(3, 5, 6)</code>) though these index values must correspond to the row numbers of
the input data (the indices won't necessarily match those of rearranged rows
if row groups are present). One more type of expression is possible, an
expression that takes column values (can involve any of the available columns
in the table) and returns a logical vector.
</p>


<h3>How to supply data for nanoplots</h3>

<p>The input data for nanoplots naturally needs to be numeric and there are two
major ways to formulate that data: (1) from single values across many
columns, and (2) using text-based value streams. It's pretty easy to
rationalize the first, and we may already have wide data in the input data
frame anyway (take a look at the <code>illness</code> and <code>towny</code> datasets for
examples of this). There's one data value per column so the key thing here is
to reference the columns in the correct order. With a select helper, good
column naming, and the columns being in the intended order, this is a snap.
</p>
<p>The second option is to use text-based value streams. Sometimes you simply
don't want or don't need multiple columns and so a single column with all of
the data might be more practical. To make this work, you'd need to have a set
of numerical values separated by some sort of delimiter (could be a comma, a
space, a semicolon, you get the idea). Here's an example with three numbers,
written three ways: <code>"3.6 -2.44 1.98"</code>, <code>"3.6, -2.44, 1.98"</code>, and
<code>"3.6;-2.44;1.98"</code>. You can include <code>NA</code> values, not a problem, and here's an
example of that: <code>"6.232 NA 3.7 0.93"</code>. Another form of value stream involves
using datetimes in the ISO 8601 form of <code style="white-space: pre;">⁠YYYY-MM-DD HH:MM:SS⁠</code>. These will
be internally converted to numeric values (seconds elapsed since
<code>"1970-01-01 00:00:00"</code>). An example of a datetime-based value stream is:
<code>"2012-06-12 08:24:13, 2012-06-12 10:37:08, 2012-06-12 14:03:24"</code>.
</p>
<p>Value streams can be pretty big if you want them to be, and you don't have to
deal with containing individual values across multiple columns. For the case
where you need to provide two sets of values (<em>x</em> and <em>y</em>, for line plots
with <code>columns</code> and <code>columns_x_vals</code>), have two equivalently sized value
streams in two columns. Value streams can also be concatenated together by
referencing columns having their own separate value streams.
</p>


<h3>Reference line and reference area</h3>

<p>Neither a horizontal <em>reference line</em> nor a <em>reference area</em> is present in
the default view but these can be added by providing valid input values in
the <code>reference_line</code> and <code>reference_area</code> arguments. A reference line can
be either be a static numeric value (supply any number to <code>reference_line</code>),
or it can be a keyword that computes the reference line <em>y</em> value using the
data values for each nanoplot. The following keywords can be used:
</p>

<ol>
<li> <p><code>"mean"</code>: The mean of the data values
</p>
</li>
<li> <p><code>"median"</code>: Median of data values
</p>
</li>
<li> <p><code>"min"</code>: Minimum value in set of data values
</p>
</li>
<li> <p><code>"max"</code>: The maximum value
</p>
</li>
<li> <p><code>"q1"</code>: The first, or lower, quartile of the data values
</p>
</li>
<li> <p><code>"q3"</code>: The third quartile, otherwise known as the upper quartile
</p>
</li>
<li> <p><code>"first"</code>: The first data value
</p>
</li>
<li> <p><code>"last"</code>: The last data value
</p>
</li>
</ol>
<p>The <em>reference area</em> accepts two inputs, and this can be two of the above
keywords, a keyword and a static numeric value, or two numeric values.
</p>


<h3>Examples</h3>

<p>Let's make some nanoplots with the <code>illness</code> dataset. The columns beginning
with 'day' all contain ordered measurement values, comprising seven
individual daily results. Using <code>cols_nanoplot()</code> we create a new column to
hold the nanoplots (with <code>new_col_name = "nanoplots"</code>), referencing the
columns containing the data (with <code>columns = starts_with("day")</code>). It's also
possible to define a column label here using the <code>new_col_label</code> argument.
</p>
<div class="sourceCode r"><pre>illness |&gt;
  dplyr::slice_head(n = 10) |&gt;
  gt(rowname_col = "test") |&gt;
  tab_header("Partial summary of daily tests performed on YF patient") |&gt;
  tab_stubhead(label = md("**Test**")) |&gt;
  cols_hide(columns = starts_with("norm")) |&gt;
  fmt_units(columns = units) |&gt;
  cols_nanoplot(
    columns = starts_with("day"),
    new_col_name = "nanoplots",
    new_col_label = md("*Progression*")
  ) |&gt;
  cols_align(align = "center", columns = nanoplots) |&gt;
  cols_merge(columns = c(test, units), pattern = "{1} ({2})") |&gt;
  tab_footnote(
    footnote = "Measurements from Day 3 through to Day 8.",
    locations = cells_column_labels(columns = nanoplots)
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_1.png" alt="This image of a table was generated from the first code example in the `cols_nanoplot()` help file." style="width:100%;"><p>The previous table showed us some line-based nanoplots. We can also make very
small bar plots with <code>cols_nanoplot()</code>. Let's take the <code>pizzaplace</code> dataset
and make a small summary table showing daily pizza sales by type (there are
four types). This will be limited to the first ten days of pizza sales in
2015, so, there will be ten rows in total. We can use <code>plot_type = "bar"</code> to
make bar plots from the daily sales counts in the <code>chicken</code>, <code>classic</code>,
<code>supreme</code>, and <code>veggie</code> columns. Because we know there will always be four
bars (one for each type of pizza) we can be a little creative and apply
colors to each of the bars through use of the <code>data_bar_fill_color</code> argument
in <code>nanoplot_options()</code>.
</p>
<div class="sourceCode r"><pre>pizzaplace |&gt;
  dplyr::count(type, date) |&gt;
  tidyr::pivot_wider(names_from = type, values_from = n) |&gt;
  dplyr::slice_head(n = 10) |&gt;
  gt(rowname_col = "date") |&gt;
  tab_header(
    title = md("First Ten Days of Pizza Sales in 2015")
  ) |&gt;
  cols_nanoplot(
    columns = c(chicken, classic, supreme, veggie),
    plot_type = "bar",
    autohide = FALSE,
    new_col_name = "pizzas_sold",
    new_col_label = "Sales by Type",
    options = nanoplot_options(
      show_data_line = FALSE,
      show_data_area = FALSE,
      data_bar_stroke_color = "transparent",
      data_bar_fill_color = c("brown", "gold", "purple", "green")
    )
  ) |&gt;
  cols_width(pizzas_sold ~ px(150)) |&gt;
  cols_align(columns = -date, align = "center") |&gt;
  fmt_date(columns = date, date_style = "yMMMEd") |&gt;
  opt_all_caps()
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_2.png" alt="This image of a table was generated from the second code example in the `cols_nanoplot()` help file." style="width:100%;"><p>Now we'll make another table that contains two columns of nanoplots. Starting
from the <code>towny</code> dataset, we first reduce it down to a subset of columns
and rows. All of the columns related to either population or density will be
used as input data for the two nanoplots. Both nanoplots will use a reference
line that is generated from the median of the input data. And by naming the
new nanoplot-laden columns in a similar manner as the input data columns, we
can take advantage of select helpers (e.g., when using <code>tab_spanner()</code>). Many
of the input data columns are now redundant because of the plots, so we'll
elect to hide most of those with <code>cols_hide()</code>.
</p>
<div class="sourceCode r"><pre>towny |&gt;
  dplyr::select(name, starts_with("population"), starts_with("density")) |&gt;
  dplyr::filter(population_2021 &gt; 200000) |&gt;
  dplyr::arrange(desc(population_2021)) |&gt;
  gt() |&gt;
  fmt_integer(columns = starts_with("population")) |&gt;
  fmt_number(columns = starts_with("density"), decimals = 1) |&gt;
  cols_nanoplot(
    columns = starts_with("population"),
    reference_line = "median",
    autohide = FALSE,
    new_col_name = "population_plot",
    new_col_label = md("*Change*")
  ) |&gt;
  cols_nanoplot(
    columns = starts_with("density"),
    plot_type = "bar",
    autohide = FALSE,
    new_col_name = "density_plot",
    new_col_label = md("*Change*")
  ) |&gt;
  cols_hide(columns = matches("2001|2006|2011|2016")) |&gt;
  tab_spanner(
    label = "Population",
    columns = starts_with("population")
  ) |&gt;
  tab_spanner(
    label = "Density ({{*persons* km^-2}})",
    columns = starts_with("density")
  ) |&gt;
  cols_label_with(
    columns = -matches("plot"),
    fn = function(x) gsub("[^0-9]+", "", x)
  ) |&gt;
  cols_align(align = "center", columns = matches("plot")) |&gt;
  cols_width(
    name ~ px(140),
    everything() ~ px(100)
  ) |&gt;
  opt_horizontal_padding(scale = 2)
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_3.png" alt="This image of a table was generated from the third code example in the `cols_nanoplot()` help file." style="width:100%;"><p>The <code>sza</code> dataset can, with just some use of <strong>dplyr</strong> and <strong>tidyr</strong>, give
us a wide table full of nanoplottable values. We'll transform the solar
zenith angles to solar altitude angles and create a column of nanoplots using
the newly calculated values. There are a few <code>NA</code> values during periods where
the sun hasn't risen (usually before 06:30 in the winter months) and those
values will be replaced with <code>0</code> using <code>missing_vals = "zero"</code>. We'll also
elect to create bar plots using the <code>plot_type = "bar"</code> option. The height of
the plots will be bumped up to <code>"2.5em"</code> from the default of <code>"2em"</code>.
Finally, we will use <code>nanoplot_options()</code> to modify the coloring of the data
bars.
</p>
<div class="sourceCode r"><pre>sza |&gt;
  dplyr::filter(latitude == 20 &amp; tst &lt;= "1200") |&gt;
  dplyr::select(-latitude) |&gt;
  dplyr::filter(!is.na(sza)) |&gt;
  dplyr::mutate(saa = 90 - sza) |&gt;
  dplyr::select(-sza) |&gt;
  tidyr::pivot_wider(
    names_from = tst,
    values_from = saa,
    names_sort = TRUE
  ) |&gt;
  gt(rowname_col = "month") |&gt;
  tab_header(
    title = "Solar Altitude Angles",
    subtitle = "Average values every half hour from 05:30 to 12:00"
  ) |&gt;
  cols_nanoplot(
    columns = matches("0"),
    plot_type = "bar",
    missing_vals = "zero",
    new_col_name = "saa",
    plot_height = "2.5em",
    options = nanoplot_options(
      data_bar_stroke_color = "GoldenRod",
      data_bar_fill_color = "DarkOrange"
    )
  ) |&gt;
  tab_options(
    table.width = px(400),
    column_labels.hidden = TRUE
  ) |&gt;
  cols_align(
    align = "center",
    columns = everything()
  ) |&gt;
  tab_source_note(
    source_note = "The solar altitude angle is the complement to
    the solar zenith angle. TMYK."
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_4.png" alt="This image of a table was generated from the fourth code example in the `cols_nanoplot()` help file." style="width:100%;"><p>You can use number and time streams as data for nanoplots. Let's demonstrate
how we can make use of them with some creative transformation of the
<code>pizzaplace</code> dataset. A value stream is really a string with delimited
numeric values, like this: <code>"7.24,84.2,14"</code>. A value stream can also contain
dates and/or datetimes, and here's an example of that:
<code>"2020-06-02 13:05:13,2020-06-02 14:24:05,2020-06-02 18:51:37"</code>. Having data
in this form can often be more convenient since different nanoplots might
have varying amounts of data (and holding different amounts of data in a
fixed number of columns is cumbersome). There are <code>date</code> and <code>time</code> columns
in this dataset and we'll use that to get <em>x</em> values denoting high-resolution
time instants: the second of the day that a pizza was sold (this is true
pizza analytics). We also have the sell price for a pizza, and that'll serve
as the <em>y</em> values. The pizzas belong to four different groups (in the <code>type</code>
column) and we'll group by that and create value streams with
<code>paste(..., collapse = ",")</code> inside  the <code>dplyr::summarize()</code> call. With two
value streams in each row (having the same number of values) we can now make
a <strong>gt</strong> table with nanoplots.
</p>
<div class="sourceCode r"><pre>pizzaplace |&gt;
  dplyr::filter(date == "2015-01-01") |&gt;
  dplyr::mutate(date_time = paste(date, time)) |&gt;
  dplyr::select(type, date_time, price) |&gt;
  dplyr::group_by(type) |&gt;
  dplyr::summarize(
    date_time = paste(date_time, collapse = ","),
    sold = paste(price, collapse = ",")
  ) |&gt;
  gt(rowname_col = "type") |&gt;
  tab_header(
    title = md("Pizzas sold on **January 1, 2015**"),
    subtitle = "Between the opening hours of 11:30 to 22:30"
  ) |&gt;
  cols_nanoplot(
    columns = sold,
    columns_x_vals = date_time,
    expand_x = c("2015-01-01 11:30", "2015-01-01 22:30"),
    reference_line = "median",
    new_col_name = "pizzas_sold",
    new_col_label = "Pizzas Sold",
    options = nanoplot_options(
      show_data_line = FALSE,
      show_data_area = FALSE,
      currency = "USD"
    )
  ) |&gt;
  cols_width(pizzas_sold ~ px(200)) |&gt;
  cols_align(columns = pizzas_sold, align = "center") |&gt;
  opt_all_caps()
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_5.png" alt="This image of a table was generated from the fifth code example in the `cols_nanoplot()` help file." style="width:100%;"><p>Notice that the columns containing the value streams are hid due to the
default argument <code>autohide = TRUE</code> because, while useful, they don't need to
be displayed to anybody viewing a table. Since we have a lot of data points
and a connecting line is not as valuable here, we also set
<code>show_data_line = FALSE</code> in <code>nanoplot_options()</code>. It's more interesting to
see the clusters of the differently priced pizzas over the entire day.
Specifying a <code>currency</code> in <code>nanoplot_options()</code> is a nice touch since the <em>y</em>
values are sale prices in U.S. Dollars (hovering over data points gives
correctly formatted values). Finally, having a reference line based on the
median gives pretty useful information. Seems like customers preferred
getting the <code>"chicken"</code>-type pizzas in large size!
</p>
<p>Using the <code>gibraltar</code> dataset, let's make a series of nanoplots across the
meteorological parameters of temperature, humidity, and wind speed. We'll
want to customize the appearance of the plots across three columns and we
can make this somewhat simpler by assigning a common set of options through
<code>nanoplot_options()</code>. In this table we want to make comparisons across
nanoplots in a particular column easier, so, we'll set <code>autoscale = TRUE</code> so
that there is a common y-axis scale for each of the parameters (based on the
extents of the data).
</p>
<div class="sourceCode r"><pre>nanoplot_options_list &lt;-
  nanoplot_options(
    data_point_radius = px(4),
    data_point_stroke_width = px(2),
    data_point_stroke_color = "black",
    data_point_fill_color = "white",
    data_line_stroke_width = px(4),
    data_line_stroke_color = "gray",
    show_data_line = TRUE,
    show_data_points = TRUE,
    show_data_area = FALSE,
  )

gibraltar |&gt;
  dplyr::filter(date &lt;= "2023-05-14") |&gt;
  dplyr::mutate(time = as.numeric(hms::as_hms(paste0(time, ":00")))) |&gt;
  dplyr::mutate(humidity = humidity * 100) |&gt;
  dplyr::select(date, time, temp, humidity, wind_speed) |&gt;
  dplyr::group_by(date) |&gt;
  dplyr::summarize(
    time = paste(time, collapse = ","),
    temp = paste(temp, collapse = ","),
    humidity = paste(humidity, collapse = ","),
    wind_speed = paste(wind_speed, collapse = ","),
  ) |&gt;
  dplyr::mutate(is_satsun = lubridate::wday(date) %in% c(1, 7)) |&gt;
  gt(rowname_col = "date") |&gt;
  tab_header(
    title = "Meteorological Summary of Gibraltar Station",
    subtitle = "Data taken from May 1-14, 2023."
  ) |&gt;
  fmt_date(columns = stub(), date_style = "wd_m_day_year") |&gt;
  cols_nanoplot(
    columns = temp,
    columns_x_vals = time,
    expand_x = c(0, 86400),
    autoscale = TRUE,
    new_col_name = "temperature_nano",
    new_col_label = "Temperature",
    options = nanoplot_options_list
  ) |&gt;
  cols_nanoplot(
    columns = humidity,
    columns_x_vals = time,
    expand_x = c(0, 86400),
    autoscale = TRUE,
    new_col_name = "humidity_nano",
    new_col_label = "Humidity",
    options = nanoplot_options_list
  ) |&gt;
  cols_nanoplot(
    columns = wind_speed,
    columns_x_vals = time,
    expand_x = c(0, 86400),
    autoscale = TRUE,
    new_col_name = "wind_speed_nano",
    new_col_label = "Wind Speed",
    options = nanoplot_options_list
  ) |&gt;
  cols_units(
    temperature_nano = ":degree:C",
    humidity_nano = "% (RH)",
    wind_speed_nano = "m s^-1"
  ) |&gt;
  cols_hide(columns = is_satsun) |&gt;
  tab_style_body(
    style = cell_fill(color = "#E5FEFE"),
    values = TRUE,
    targets = "row",
    extents = c("body", "stub")
  ) |&gt;
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_6.png" alt="This image of a table was generated from the sixth code example in the `cols_nanoplot()` help file." style="width:100%;"><p>Box plots can be generated, and we just need to use <code>plot_type = "boxplot"</code>
to make that type of nanoplot. Using a small portion of the <code>pizzaplace</code>
dataset, we will create a simple table that displays a box plot of pizza
sales for a selection of days. By converting the string-time 24-hour-clock
time values to the number of seconds elapsed in a day, we get continuous
values that can be incorporated into each box plot. And, by supplying a
function to the <code>y_val_fmt_fn</code> argument within <code>nanoplot_options()</code>, we can
transform the integer seconds values back to clock times for display on
hover.
</p>
<div class="sourceCode r"><pre>pizzaplace |&gt;
  dplyr::filter(date &lt;= "2015-01-14") |&gt;
  dplyr::mutate(time = as.numeric(hms::as_hms(time))) |&gt;
  dplyr::summarize(time = paste(time, collapse = ","), .by = date) |&gt;
  dplyr::mutate(is_weekend = lubridate::wday(date) %in% 6:7) |&gt;
  gt() |&gt;
  tab_header(title = "Pizza Sales in Early January 2015") |&gt;
  fmt_date(columns = date, date_style = 2) |&gt;
  cols_nanoplot(
    columns = time,
    plot_type = "boxplot",
    options = nanoplot_options(y_val_fmt_fn = function(x) hms::as_hms(x))
  ) |&gt;
  cols_hide(columns = is_weekend) |&gt;
  cols_width(everything() ~ px(250)) |&gt;
  cols_align(align = "center", columns = nanoplots) |&gt;
  cols_align(align = "left", columns = date) |&gt;
  tab_style(
    style = cell_borders(
      sides = "left", color = "gray"),
    locations = cells_body(columns = nanoplots)
  ) |&gt;
  tab_style_body(
    style = cell_fill(color = "#E5FEFE"),
    values = TRUE,
    targets = "row"
  ) |&gt;
  tab_options(column_labels.hidden = TRUE)
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_7.png" alt="This image of a table was generated from the seventh code example in the `cols_nanoplot()` help file." style="width:100%;"><h3>Function ID</h3>

<p>5-8
</p>


<h3>Function Introduced</h3>

<p><code>v0.10.0</code> (October 7, 2023)
</p>


<h3>See Also</h3>

<p>Other column modification functions: 
<code>cols_add()</code>,
<code>cols_align()</code>,
<code>cols_align_decimal()</code>,
<code>cols_hide()</code>,
<code>cols_label()</code>,
<code>cols_label_with()</code>,
<code>cols_merge()</code>,
<code>cols_merge_n_pct()</code>,
<code>cols_merge_range()</code>,
<code>cols_merge_uncert()</code>,
<code>cols_move()</code>,
<code>cols_move_to_end()</code>,
<code>cols_move_to_start()</code>,
<code>cols_unhide()</code>,
<code>cols_units()</code>,
<code>cols_width()</code>
</p>


</div>