<div class="container">

<table style="width: 100%;"><tr>
<td>view_step</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Follow the data in steps</h2>

<h3>Description</h3>

<p>This view is a bit like <code>view_follow()</code> but will not match the data in each
frame. Instead it will switch between being static and zoom to the range of
the data. It is a great pairing with <code>transition_states()</code> as it can move the
view while the data is static and then be static while the data moves. The
standard version will look at the data present in the calculated frames and
set the ranges based on that, while the <code style="white-space: pre;">⁠_manual⁠</code> version will allow you to
define your own ranges.
</p>


<h3>Usage</h3>

<pre><code class="language-R">view_step(
  pause_length = 1,
  step_length = 1,
  nsteps = NULL,
  look_ahead = pause_length,
  delay = 0,
  include = TRUE,
  ease = "cubic-in-out",
  wrap = TRUE,
  pause_first = FALSE,
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)

view_step_manual(
  pause_length = 1,
  step_length = 1,
  xmin,
  xmax,
  ymin,
  ymax,
  delay = 0,
  ease = "cubic-in-out",
  wrap = TRUE,
  pause_first = FALSE,
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pause_length</code></td>
<td>
<p>The relative length the view will be kept static. Will
be recycled to match the number of steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step_length</code></td>
<td>
<p>The relative length the view will use to transition to the
new position. Will be recycled to match the number of steps</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsteps</code></td>
<td>
<p>The number of steps. If <code>NULL</code> it will be set to the max length
of <code>pause_length</code> or <code>step_length</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>look_ahead</code></td>
<td>
<p>A relative length to look ahead in the animation to get the
new zoom area. Allow the view to zoom to where the data will be</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delay</code></td>
<td>
<p>A relative length to switch the view back and forth relative to
the actual frames. E.g. if delay is calculated to 5 frames, frame 6 will get
the view intended for frame 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include</code></td>
<td>
<p>Should the steps include both the start and end frame range</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ease</code></td>
<td>
<p>The easing function used for the step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrap</code></td>
<td>
<p>As in <code>transition_states()</code>. Should the view wrap around and zoom
back to the first state.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pause_first</code></td>
<td>
<p>Should the view start with a pause. The default is to
start with a step so that it is aligned to the static period in
<code>transition_states()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_x, fixed_y</code></td>
<td>
<p>Either a logical indicating if the dimension should
not be modified by the view, or a numeric vector giving the lower and upper
bounds of the dimension. For the latter, an <code>NA</code> value will be substituted
for whatever is calculated by the view (e.g. <code>fixed_x = c(0, NA)</code>) will fix
the minimum x value to 0 and let the view calculate the upper bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_layer</code></td>
<td>
<p>Integer vector of layer indices that should be ignored
when calculating the view</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aspect_ratio</code></td>
<td>
<p>If the coord is fixed, ensure that the view matches the
given aspect ratio. Will override anything given in <code>fixed_x</code>/<code>fixed_y</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmin, xmax, ymin, ymax</code></td>
<td>
<p>Vectors of even length defining the boundaries of
the different views to go through</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p>Other views: 
<code>view_follow()</code>,
<code>view_static()</code>,
<code>view_zoom()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  view_step(pause_length = 2, step_length = 1, nsteps = 3)

# Default is to include the data from the two states you're stepping between
# but this can be turned off
anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  view_step(pause_length = 2, step_length = 1, nsteps = 3, include = FALSE)

# Default is to work off-beat of transition_states so that view changes while
# data is static. Setting pause_first=TRUE changes this
anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  view_step(pause_length = 1, step_length = 2, nsteps = 3, pause_first = TRUE)

# If the transition doesn't wrap, then the view shouldn't either
anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1, wrap = FALSE) +
  view_step(pause_length = 2, step_length = 1, nsteps = 3, wrap = FALSE)

</code></pre>


</div>