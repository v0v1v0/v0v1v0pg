<div class="container">

<table style="width: 100%;"><tr>
<td>sim_numbers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Simulation based on polar form specifications </h2>

<h3>Description</h3>

<p>Simulate real and complex numbers from polar form specifications. The
numbers may be partially or fully specified. The distributions of
absolute values and arguments/signs are specified independently.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sim_numbers(type = rep(as.character(NA), length(abs)),
            abs = rep(as.numeric(NA), length(type)),
            sign = rep(as.numeric(NA), length(type)), values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> character vector specifying the types of the eigenvalues,
see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abs</code></td>
<td>
<p> vector of absolute values (moduli).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign</code></td>
<td>
<p> vector of signs (for reals) and  arguments (for complex
numbers), see Details for interpretation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>values, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to be passed to <code>sim_real</code> and
<code>sim_complex</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p><code>sim_numbers</code> simulates a vector of real and complex numbers with
given distributions of their polar parts. It is possible also to fix
some of the numbers or one of their polar parts.
The length of the simulated vector is inferred from the length of
<code>type</code> or <code>abs</code>, so one of them must be
provided. <code>sim_numbers</code> is a flexible front-end for
<code>sim_real</code> and <code>sim_complex</code>.
</p>
<p><code>sim_numbers</code> generates a vector of values with types specified
by argument <code>type</code> and/or inferred from argument <code>values</code>.
The recommended way to use <code>sim_numbers</code> is to provide argument
<code>type</code>. 
</p>
<p><code>type[i]</code> specifies the type of the i-th element of the result:
real (<code>type[i]=="r"</code>), complex (<code>type[i]=="c"</code>) or
representing a complex conjugate pair (<code>type[i]=="cp"</code>).  If
<code>values</code> is provided, the imaginary parts of its non-NA elements
are used to fill <code>NA</code> elements of <code>type</code> ("r" if zero, "cp"
otherwise).
</p>
<p>Some (or even all) values may be fixed or partially fixed with the
help of arguments <code>abs</code>, <code>sign</code> and <code>values</code>. A
non-missing value of <code>values[i]</code> fixes the i-th element of the
result to that value. Simlarly <code>abs[i]</code> fixes the modulus and
<code>sign[i]</code> fixes the sign/argument of the i-th element. If
<code>values[i]</code> is not <code>NA</code>, then it takes precedence and
<code>abs[i]</code> and <code>sign[i]</code> are ignored.
</p>
<p>For real numbers <code>sign</code> is the sign with possible values 1
(positive) or -1 (negative). For complex numbers, <code>sign</code> is the
argument and is in the interval (-pi,pi).
</p>
<p>If <code>values</code> is supplied, then <code>NA</code> entries in <code>type</code>
are replaced by "r" or "cp" depending on whether or not the imaginary
parts of the corresponding entries in <code>values</code> are equal to zero.
A check is done for consistency when both <code>type[i]</code> and
<code>values[i]</code> are non-missing. Generally, <code>values</code> is meant to
be used for values that are fixed and available directly in Cartesian
form, to avoid having to fill the corresponding entries of <code>abs</code>
and <code>sign</code>.
</p>
<p><code>NA</code> entries of <code>abs</code> and <code>sign</code> are filled with
simulated values, the remaining entries are considered fixed and left
unchanged. The default generator is uniform (0,1) for <code>abs</code>,
uniform (-pi,pi) for the argument of complex values, and 1 or -1 with
p=1/2 for the sign of real values.
</p>
<p>To specify a different generator for the moduli and absolute values,
use argument <code>absgen</code>, giving it a function or the name of a
function. The arguments for this function can be specified by
<code>absarg</code> (as a list). Similarly, the generator for arguments of
complex numbers can be specified by <code>arggen</code> and <code>argarg</code>.
Finally, the probability for the real numbers to be positive is given
by <code>signprob</code>. These arguments are not in the signature of the
function since they are passed on directly (via <code>"..."</code>) to the
underlying <code>sim_complex</code> and <code>sim_real</code>, see their
documentation and the examples below for further details.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>vector of values; it is of type <code>numeric</code> if
all values are real and <code>complex</code> otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character vector of the types as above</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Values of type "cp" (complex pairs) are represented by one element, the
complex conjugate elements are NOT generated. (todo: maybe add an
argument to control this)
</p>
<p>The convention for the sign of a real eigenvalue is 1 and -1,
not 0 and pi.


</p>
<p>The checks for consistency between <code>type</code> and <code>values</code> are
not complete and only straightforward use is recommended.
</p>
<p>The current defaults for the arguments, see the signature
above, require that at least one of <code>type</code> and <code>abs</code> is not
missing.
</p>





<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>sim_real</code>
, <code>sim_complex</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## one real number and one complex conjugated pair
## (maybe to specify a cubic polynomial through its roots)
sim_numbers(type = c("r", "cp"))

## here the real value is fixed to have modulus 1, leaving the sign unspecified
sim_numbers(type = c("r", "cp"), abs = c(1, NA))

## now the real value is fixed to 1,
##     the complex pair has argument  +-pi/2, and free modulus:
sim_numbers(type = c("r", "cp"), abs = c(1, NA), sign = c(0, pi/2))


## using argument 'values' to fix some values;
## here the the third value is fixed:
sim_numbers(type = c("r", "cp", "r"), values = c(NA,NA,3))  # type[3] = "r"
sim_numbers(type = c("r", "cp", "cp"), values = c(NA,NA,3i)) # type[3] = "cp"

## type[3] can be left NA since it can be inferred from values[3]:
sim_numbers(type = c("r", "cp", NA), values = c(NA,NA,3))  # type[3] = "r"
sim_numbers(type = c("r", "cp", NA), values = c(NA,NA,3i)) # type[3] = "cp"

## it is an error to have a mismatch between args `type' and value:
## Not run: 
sim_numbers(type = c("r", "cp", "cp"), values = c(NA,NA,3))
sim_numbers(type = c("r", "cp", "r"), values = c(NA,NA,3i))

## End(Not run)

## simulate 10 reals with the default generators
sim_numbers(rep("r", 10))

## simulate modulus from Rayleigh distribution
##
rR &lt;- function(n, sigma = 1) sigma * sqrt(-2*log(runif(n)))
sim_numbers(type = c("cp", "cp"), absgen = rR, absarg = list())

# test the the components are N(0,1)
## (not run to save time for CRAN check)
## \dontrun{
## v &lt;- sim_numbers(type = rep("cp", 10000), absgen = "rR",
##                  absarg = list(sigma = 1))
## ks.test(Re(v$values), "pnorm")
## ks.test(Im(v$values), "pnorm")
## }
</code></pre>


</div>