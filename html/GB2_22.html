<div class="container">

<table style="width: 100%;"><tr>
<td>Varest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Variance Estimation of the Parameters of the GB2 Distribution
</h2>

<h3>Description</h3>

<p>Calculation of variance estimates of the estimated GB2 parameters and the estimated GB2 indicators under cluster sampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">varscore.gb2(x, shape1, scale, shape2, shape3, w=rep(1,length(x)), hs=rep(1,length(x)))
vepar.gb2(x, Vsc, shape1, scale, shape2, shape3, w=rep(1,length(x)), hs=rep(1,length(x)))
derivind.gb2(shape1, scale, shape2, shape3)
veind.gb2(Vpar, shape1, scale, shape2, shape3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric; vector of data values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vsc</code></td>
<td>
<p>numeric; 4 by 4 matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape1</code></td>
<td>
<p>numeric; positive parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>numeric; positive parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape2, shape3</code></td>
<td>
<p>numeric; positive parameters of the Beta distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>numeric; vector of weights. Must have the same length as <code>x</code>. By default <code>w</code> is a vector of 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hs</code></td>
<td>
<p>numeric; vector of household sizes. Must have the same length as <code>x</code>. By default <code>w</code> is a vector of 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vpar</code></td>
<td>
<p>numeric; 4 by 4 matrix.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Knowing the first and second derivatives of <code class="reqn">log(f)</code>, and using the sandwich variance estimator (see Freedman (2006)), the calculation of the variance estimates of the GB2
parameters is straightforward. <code>Vsc</code> is a square matrix of size the number of parameters, e.g. the estimated design variance-covariance matrix of the estimated parameters. We know that the GB2 estimates of the Laeken indicators are functions of the GB2 parameters. In this case, the variance estimates of the fitted indicators are obtained 
using the delta method. The function <code>veind.gb2</code> uses <code>Vpar</code>, the sandwich variance estimator of the vector of parameters, in order to obtain the sandwich variance estimator of the indicators. More details can be found in Graf and Nedyalkova (2011).
</p>


<h3>Value</h3>

<p><code>varscore.gb2</code> calculates the middle term of the sandwich variance estimator under simple random cluster sampling. <code>vepar.gb2</code> returns a list of two elements: 
the estimated variance-covariance matrix of the estimated GB2 parameters and the second-order partial derivative of the pseudo log-likelihood function.
The function <code>veind.gb2</code> returns the estimated variance-covariance matrix of the estimated GB2 indicators.  <code>derivind.gb2</code> calculates the numerical derivatives of the GB2 indicators and is for internal use only. 
</p>


<h3>Author(s)</h3>

<p>Monique Graf and Desislava Nedyalkova
</p>


<h3>References</h3>

<p>Davison, A. (2003),
<em>Statistical Models</em>.
Cambridge University Press.
</p>
<p>Freedman, D. A. (2006),
On The So-Called "Huber Sandwich Estimator" and "Robust Standard Errors".
<em>The American Statistician</em>, <b>60</b>, 299–302.
</p>
<p>Graf, M., Nedyalkova, D., Muennich, R., Seger, J. and Zins, S. (2011)
AMELI Deliverable 2.1: Parametric Estimation of Income Distributions and
Indicators of Poverty and Social Exclusion.
<em>Technical report</em>, AMELI-Project.
</p>
<p>Pfeffermann, D. and Sverchkov, M. Yu. (2003),
Fitting Generalized Linear Models under Informative Sampling.
In, Skinner, C.J. and Chambers, R.L. (eds.). 
<em>Analysis of Survey Data</em>, chapter 12, 175–195.
Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># An example of variance estimation of the GB2 parameters,
# using the dataset "eusilcP" from the R package simFrame.
# Takes long time to run

## Not run: 
library(survey)
library(simFrame)
data(eusilcP)

# Draw a sample from eusilcP
# 1-stage simple random cluster sampling of size 6000 (cluster = household)
# directly,
#s &lt;- draw(eusilcP[, c("hid", "hsize", "eqIncome")], grouping = "hid", size = 6000)

# or setting up 250 samples, and drawing the first one.
# This sample setup can be used for running a simulation.
set.seed(12345)
scs &lt;- setup(eusilcP, grouping = "hid", size = 6000, k = 250)
s &lt;- draw(eusilcP[, c("region", "hid", "hsize", "eqIncome")], scs, i=1)

# The number of observations (persons) in eusilcP (58654 persons)
\dontrun{N &lt;- dim(eusilcP)[1]} 
# The number of households in eusilcP (25000 households)
Nh &lt;- length(unique(eusilcP$hid)) 

# Survey design corresponding to the drawn sample
sdo = svydesign(id=~hid, fpc=rep(Nh,nrow(s)), data=s)
\dontrun{summary(sdo)}

# Truncated sample (truncate at 0)
s &lt;- s[!is.na(s$eqIncome),] 
str &lt;- s[s$eqIncome &gt; 0, ]
eqInc &lt;- str$eqIncome
w &lt;- str$.weight            

# Designs for the truncated sample
sdotr &lt;- subset(sdo, eqIncome &gt;0)
sddtr = svydesign(id=~hid, strata=~region, fpc=NULL, weights=~.weight, data=str)
\dontrun{summary(sdotr)}
\dontrun{summary(sddtr)}

# Fit by maximum likelihood
fit &lt;- ml.gb2(eqInc,w)$opt1
af &lt;- fit$par[1]
bf &lt;- fit$par[2]
pf &lt;- fit$par[3]
qf &lt;- fit$par[4]
mlik &lt;- -fit$value

# Estimated parameters and indicators, empirical indicators 
gb2.par &lt;- round(c(af, bf, pf, qf), digits=3)
emp.ind &lt;- main.emp(eqInc, w)
gb2.ind &lt;- main.gb2(0.6, af, bf, pf, qf)

# Scores
scores &lt;- matrix(nrow=length(eqInc), ncol=4)
for (i in 1:length(eqInc)){
scores[i,] &lt;- dlogf.gb2(eqInc[i], af, bf, pf, qf)
}

# Data on households only
sh &lt;- unique(str)
heqInc &lt;- sh$eqIncome
hw &lt;- sh$.weight
hhs &lt;- sh$hsize 
hs &lt;- as.numeric(as.vector(hhs))  

# Variance of the scores
VSC &lt;- varscore.gb2(heqInc, af, bf, pf, qf, hw, hs)

# Variance of the scores using the explicit designs, and package survey
DV1 &lt;- vcov(svytotal(~scores[,1]+scores[,2]+scores[,3]+scores[,4], design=sdotr))
DV2 &lt;- vcov(svytotal(~scores[,1]+scores[,2]+scores[,3]+scores[,4], design=sddtr))

# Estimated variance-covariance matrix of the parameters af, bf, pf and qf 
VCMP &lt;- vepar.gb2(heqInc, VSC, af, bf, pf, qf, hw, hs)[[1]]
DVCMP1 &lt;- vepar.gb2(heqInc, DV1, af, bf, pf, qf, hw, hs)[[1]]
DVCMP2 &lt;- vepar.gb2(heqInc, DV2, af, bf, pf, qf, hw, hs)[[1]]

\dontrun{diag(DVCMP1)/diag(VCMP)}
\dontrun{diag(DVCMP2)/diag(VCMP)}
\dontrun{diag(DV1)/diag(VSC)}
\dontrun{diag(DV2)/diag(VSC)}

# Standard errors of af, bf, pf and qf
se.par &lt;- sqrt(diag(VCMP))
sed1.par &lt;- sqrt(diag(DVCMP1))
sed2.par &lt;- sqrt(diag(DVCMP2))

# Estimated variance-covariance matrix of the indicators (VCMI)
VCMI &lt;- veind.gb2(VCMP, af, bf, pf, qf) 
DVCMI1 &lt;- veind.gb2(DVCMP1, af, bf, pf, qf)
DVCMI2 &lt;- veind.gb2(DVCMP2, af, bf, pf, qf)

# Standard errors and confidence intervals
varest.ind &lt;- diag(VCMI)
se.ind &lt;- sqrt(varest.ind)
lci.ind &lt;- gb2.ind - 1.96*se.ind
uci.ind &lt;- gb2.ind + 1.96*se.ind
inCI &lt;- as.numeric(lci.ind &lt;= emp.ind &amp; emp.ind &lt;= uci.ind)

# under the sampling design sdotr

varestd1.ind &lt;- diag(DVCMI1)
sed1.ind &lt;- sqrt(varestd1.ind)
lcid1.ind &lt;- gb2.ind - 1.96*sed1.ind
ucid1.ind &lt;- gb2.ind + 1.96*sed1.ind
inCId1 &lt;- as.numeric(lcid1.ind &lt;= emp.ind &amp; emp.ind &lt;= ucid1.ind)

#under the sampling design sddtr

varestd2.ind &lt;- diag(DVCMI2)
sed2.ind &lt;- sqrt(varestd2.ind)
lcid2.ind &lt;- gb2.ind - 1.96*sed2.ind
ucid2.ind &lt;- gb2.ind + 1.96*sed2.ind
inCId2 &lt;- as.numeric(lcid2.ind &lt;= emp.ind &amp; emp.ind &lt;= ucid2.ind)

#coefficients of variation .par (parameters), .ind (indicators)
cv.par &lt;- se.par/gb2.par
names(cv.par) &lt;- c("am","bm","pm","qm")
cvd1.par &lt;- sed1.par/gb2.par
names(cvd1.par) &lt;- c("am","bm","pm","qm")
cvd2.par &lt;- sed2.par/gb2.par
names(cvd2.par) &lt;- c("am","bm","pm","qm")

cv.ind &lt;- se.ind/gb2.ind
cvd1.ind &lt;- sed1.ind/gb2.ind
cvd2.ind &lt;- sed2.ind/gb2.ind


#results 
res &lt;- data.frame(am = af, bm = bf, pm = pf, qm = qf, lik = mlik,
  median = gb2.ind[[1]], mean = gb2.ind[[2]], ARPR = gb2.ind[[3]], 
    RMPG = gb2.ind[[4]], QSR = gb2.ind[[5]], Gini = gb2.ind[[6]],
  emedian = emp.ind[[1]], emean = emp.ind[[2]], eARPR = emp.ind[[3]], 
    eRMPG = emp.ind[[4]], eQSR = emp.ind[[5]], eGini = emp.ind[[6]],
  cva = cv.par[1], cvb = cv.par[2], cvp= cv.par[3], cvq = cv.par[4],
  cvd1a = cvd1.par[1], cvd1b = cvd1.par[2], cvd1p= cvd1.par[3], cvd1q = cvd1.par[4],
  cvd2a = cvd2.par[1], cvd2b = cvd2.par[2], cvd2p= cvd2.par[3], cvd2q = cvd2.par[4],
  cvmed = cv.ind[[1]], cvmean = cv.ind[[2]], cvARPR = cv.ind[[3]], 
  cvRMPG = cv.ind[[4]], cvQSR = cv.ind[[5]], cvGini = cv.ind[[6]],
  cvd1med = cvd1.ind[[1]], cvd1mean = cvd1.ind[[2]], cvd1ARPR = cvd1.ind[[3]], 
  cvd1RMPG = cvd1.ind[[4]], cvd1QSR = cvd1.ind[[5]], cvd1Gini = cvd1.ind[[6]],
  cvd2med = cvd2.ind[[1]], cvd2mean = cvd2.ind[[2]], cvd2ARPR = cvd2.ind[[3]], 
  cvd2RMPG = cvd2.ind[[4]], cvd2QSR = cvd2.ind[[5]], cvd2Gini = cvd2.ind[[6]])

  res &lt;- list(parameters = data.frame(am = af, bm = bf, pm = pf, qm = qf, lik = mlik),
              cv.parameters.naive = cv.par,
              cv.parameters.design1 = cvd1.par,
              cv.parameters.design2 = cvd2.par,
		  GB2.indicators = gb2.ind,
              emp.indicators = emp.ind,
              cv.indicators.naive = cv.ind,
              cv.indicators.design1 = cvd1.ind,
              cv.indicators.design2 = cvd2.ind)
res
\dontrun{inCI}

## End(Not run)
</code></pre>


</div>