<div class="container">

<table style="width: 100%;"><tr>
<td>stat_find_qtys</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find quantity value for target wavelength value.</h2>

<h3>Description</h3>

<p><code>stat_find_qtys</code> finds at which y positions values equal to an x target
are located.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_find_qtys(
  mapping = NULL,
  data = NULL,
  geom = "point",
  target = "half.maximum",
  interpolate = TRUE,
  chroma.type = "CMF",
  label.fmt = "%.3g",
  x.label.fmt = label.fmt,
  y.label.fmt = label.fmt,
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code> or <code>aes_</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>numeric value indicating the spectral quantity value for which
wavelengths are to be searched and interpolated if need. The character
string "half.maximum" is also accepted as argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>logical Indicating whether the nearest wavelength value
in <code>x</code> should be returned or a value calculated by linear
interpolation between wavelength values straddling the target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chroma.type</code></td>
<td>
<p>character one of "CMF" (color matching function) or "CC"
(color coordinates) or a <code>chroma_spct</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
values into character strings by means of function <code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $x$-values into character strings by means of function
<code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $y$-values into character strings by means of function
<code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These stats use <code>geom_point</code> by default as it is the geom most
likely to work well in almost any situation without need of tweaking. The
default aesthetics set by these stats allow their direct use with
<code>geom_text</code>, <code>geom_label</code>, <code>geom_line</code>, <code>geom_rug</code>,
<code>geom_hline</code> and <code>geom_vline</code>. The formatting of the labels
returned can be controlled by the user.
</p>


<h3>Value</h3>

<p>A data frame with one row for each match to the target subset from
the data or interpolated. As spectra are monotonic in wavelength, this
statistic will never return more than one row when used with spectra.
</p>


<h3>Computed variables</h3>

 <dl>
<dt>x</dt>
<dd>
<p>x-value at or nearest to the
match to the target as numeric</p>
</dd> <dt>y</dt>
<dd>
<p>target value or y-value nearest to
the target as numeric</p>
</dd> <dt>x.label</dt>
<dd>
<p>x-value at or nearest to the match
formatted as character</p>
</dd> <dt>y.label</dt>
<dd>
<p>target value or y-value nearest to
the target formatted as character</p>
</dd> <dt>color</dt>
<dd>
<p>color definition calculated
by assuming that x-values are wavelengths expressed in nanometres.</p>
</dd> </dl>
<h3>Default aesthetics</h3>

<p>Set by the statistic and available to geoms.
</p>
 <dl>
<dt>label</dt>
<dd>
<p>..x.label..</p>
</dd> <dt>xintercept</dt>
<dd>
<p>..x..</p>
</dd>
<dt>yintercept</dt>
<dd>
<p>..y..</p>
</dd> <dt>fill</dt>
<dd>
<p>..color..</p>
</dd> </dl>
<h3>Required aesthetics</h3>

<p>Required by the statistic and need to be set
with <code>aes()</code>. </p>
 <dl>
<dt>x</dt>
<dd>
<p>numeric, wavelength in nanometres</p>
</dd>
<dt>y</dt>
<dd>
<p>numeric, a spectral quantity</p>
</dd> </dl>
<h3>Note</h3>

<p>These stats work nicely together with geoms <code>geom_text_repel</code> and
<code>geom_label_repel</code> from package <code>ggrepel</code> to
solve the problem of overlapping labels by displacing them. To discard
overlapping labels use <code>check_overlap = TRUE</code> as argument to
<code>geom_text</code>. By default the labels are character values suitable to be
plotted as is, but with a suitable <code>label.fmt</code> labels suitable for
parsing by the geoms (e.g. into expressions containing greek letters or
super or subscripts) can be also easily obtained.
</p>


<h3>See Also</h3>

<p><code>find_peaks</code>.
</p>
<p>Other stats functions: 
<code>stat_color()</code>,
<code>stat_find_wls()</code>,
<code>stat_label_peaks()</code>,
<code>stat_peaks()</code>,
<code>stat_spikes()</code>,
<code>stat_wb_box()</code>,
<code>stat_wb_column()</code>,
<code>stat_wb_contribution()</code>,
<code>stat_wb_hbar()</code>,
<code>stat_wb_irrad()</code>,
<code>stat_wb_label()</code>,
<code>stat_wb_mean()</code>,
<code>stat_wb_relative()</code>,
<code>stat_wb_sirrad()</code>,
<code>stat_wb_total()</code>,
<code>stat_wl_strip()</code>,
<code>stat_wl_summary()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# ggplot() methods for spectral objects set a default mapping for x and y.
ggplot(yellow_gel.spct) + geom_line() +
  stat_find_qtys(target = "half.range")
ggplot(yellow_gel.spct) + geom_line() +
  stat_find_qtys(target = c(490, 500, 510))
ggplot(yellow_gel.spct) + geom_line() +
  stat_find_qtys(target = 500, geom = "point", colour = "red") +
  stat_find_qtys(target = 500, geom = "text", colour = "red",
             hjust = 1.1, label.fmt = "Tfr = %1.2f")
</code></pre>


</div>