<div class="container">

<table style="width: 100%;"><tr>
<td>qr_decomposition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The QR Decomposition of a GPUmatrix object</h2>

<h3>Description</h3>

<p>These functions mimic the base <code>qr</code> family functions to operate on gpu.matrix-class objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'gpu.matrix.tensorflow'
qr(x,...)
## S4 method for signature 'gpu.matrix.torch'
qr(x,...)

## S4 method for signature 'list'
qr.Q(qr,complete,Dvec)
## S4 method for signature 'list'
qr.R(qr,complete)
## S4 method for signature 'list'
qr.X(qr,complete)

## S4 method for signature 'list'
qr.coef(qr,y)
## S4 method for signature 'list'
qr.qy(qr,y)
## S4 method for signature 'list'
qr.qty(qr,y)
## S4 method for signature 'list'
qr.resid(qr,y)
## S4 method for signature 'ANY,gpu.matrix.tensorflow'
qr.solve(a,b)
## S4 method for signature 'ANY,gpu.matrix.torch'
qr.solve(a,b)
## S4 method for signature 'gpu.matrix.tensorflow,ANY'
qr.solve(a,b)
## S4 method for signature 'gpu.matrix.tensorflow,gpu.matrix.tensorflow'
qr.solve(a,b)
## S4 method for signature 'gpu.matrix.torch,ANY'
qr.solve(a,b)
## S4 method for signature 'gpu.matrix.torch,gpu.matrix.torch'
qr.solve(a,b)
## S4 method for signature 'list,ANY'
qr.solve(a,b)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>gpu.matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y,b</code></td>
<td>
<p>a <code>gpu.matrix</code> corresponding to the right-hand side of equations <code>ax=b</code> or <code>ax=y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qr</code></td>
<td>
<p>a list resulting from the application of the function <code>qr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>The same as in 'base' function <code>qr.Q</code>, and <code>qr.X</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dvec</code></td>
<td>
<p>The same as in 'base' function <code>qr.Q</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>a <code>gpu.matrix</code> corresponding to the left-hand side of equations <code>ax=b</code> or <code>ax=y</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>qr</code> internally calls the corresponding function of the library torch or tensorflow (depending on the type of input gpu.matrix-class).
</p>
<p>The QR decomposition can be used to solve the equation <code>Ax=b</code> for a given matrix A, and a vector of observations b. In this context, the functions <code>qr.coef</code>, and <code>qr.resid</code> return the coefficients, and residuals values. Moreover, the functions <code>qr.qy</code>, and <code>qr.qty</code> returns <code>Q %*% y</code> and <code>Q %*% t(y)</code>.
Note that if parameter <code>complete</code> is TRUE then an arbitrary orthogonal completion of the <b>X</b> and <b>Q</b> matrix or wheter the <b>R</b> matrix is to be completed by binding zero-value rows beneath the square upper triangle.
</p>
<p>The function <code>solve.qr</code> solves the system of equations <code>Ax=b</code> via the QR decomposition. This function internally calls the corresponding function of the library torch or tensorflow (depending on the type of input gpu.matrix-class).
</p>
<p>If the input gpu.matrix-class object(s) are stored on the GPU, then the operations will be performed on the GPU. See <code>gpu.matrix</code>.
</p>


<h3>Value</h3>

<p>The function <code>qr</code> returns a list with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>The corresponding complete matrix <code>Q</code> resulting from the application of the QR decomposition to <code>a</code>. It is a gpu.matrix-class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The corresponding complete matrix <code>R</code> resulting from the application of the QR decomposition to <code>a</code>. It is a gpu.matrix-class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The matrix <code>a</code>. It is a gpu.matrix-class object.</p>
</td>
</tr>
</table>
<p>Please note that the output returned by this function is different from the 'base' function <code>qr</code>, which returns an object of the 'qr' class.
</p>
<p>After performing a QR decomposition on a matrix A, given the resulting object, the functions <code>qr.X</code>, <code>qr.Q</code>, and <code>qr.R</code> return the original matrix A, the matrix Q, and the matrix R respectively. The returned matrices are gpu.matrix-class objects.
</p>
<p>The functions <code>qr.coef</code> and <code>qr.resid</code> return the coefficients and residuals when fitting the equation <code>Ax=b</code>. In this context, the  functions <code>qr.qy</code>, and <code>qr.qty</code> returns <code>Q %*% y</code> and <code>Q %*% t(y)</code>. The resulting vectors are objects of the class gpu.matrix.
</p>
<p>The function <code>qr.solve</code> returns a gpu.matrix-class object containing the coefficients of the solution of the system of equations <code>Ax=b</code> by QR decomposition.
</p>


<h3>See Also</h3>

<p>See <code>qr</code>, <code>linalg_qr</code>, <code>torch_triangular_solve</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
## overdetermined system
A &lt;- gpu.matrix(runif(12),nrow =  4)
b &lt;- gpu.matrix(rnorm(4),ncol=1)
qr.solve(a = A, b)
qr_gpu &lt;- qr(A)
qr.solve(a=qr_gpu,b)
qr.coef(qr = qr_gpu,b)
qr.resid(qr = qr_gpu,b)
qr.qty(qr = qr_gpu,b)
qr.qy(qr = qr_gpu,b)
qr.X(qr = qr_gpu,complete = T)
qr.Q(qr = qr_gpu,complete = T)
qr.R(qr = qr_gpu,complete = T)


## underdetermined system
A &lt;- gpu.matrix(runif(12),nrow =  3)
b &lt;- gpu.matrix(rnorm(3),ncol=1)
qr.solve(a = A, b)
qr_gpu &lt;- qr(A)
qr.solve(a=qr_gpu,b)
qr.coef(qr = qr_gpu,b)
qr.resid(qr = qr_gpu,b)
qr.qty(qr = qr_gpu,b)
qr.qy(qr = qr_gpu,b)
qr.X(qr = qr_gpu,complete = T)
qr.Q(qr = qr_gpu,complete = T)
qr.R(qr = qr_gpu,complete = T)

## End(Not run)

</code></pre>


</div>