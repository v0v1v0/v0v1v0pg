<div class="container">

<table style="width: 100%;"><tr>
<td>read.myacc.csv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Read custom csv files with accelerometer data
</h2>

<h3>Description</h3>

<p>Loads csv files with accelerometer data and standardises 
the output format (incl. unit of measurement, timestamp format,
header format, and column locations) to make the data compatible
with other GGIR functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  read.myacc.csv(rmc.file=c(), rmc.nrow=Inf, rmc.skip = c(), rmc.dec=".",
                          rmc.firstrow.acc = c(), rmc.firstrow.header=c(),
                          rmc.header.length = c(),
                          rmc.col.acc = 1:3, rmc.col.temp = c(), 
                          rmc.col.time=c(),
                          rmc.unit.acc = "g", rmc.unit.temp = "C", 
                          rmc.unit.time = "POSIX",
                          rmc.format.time = "%Y-%m-%d %H:%M:%OS",
                          rmc.bitrate = c(), rmc.dynamic_range = c(), 
                          rmc.unsignedbit = TRUE,
                          rmc.origin = "1970-01-01",
                          rmc.desiredtz = NULL,
                          rmc.configtz = NULL,
                          rmc.sf = c(),
                          rmc.headername.sf = c(),
                          rmc.headername.sn = c(),
                          rmc.headername.recordingid = c(),
                          rmc.header.structure = c(),
                          rmc.check4timegaps = FALSE,
                          rmc.col.wear = c(),
                          rmc.doresample = FALSE,
                          rmc.scalefactor.acc = 1,
                          interpolationType=1, 
                          PreviousLastValue = c(0, 0, 1),
                          PreviousLastTime = NULL,
                          desiredtz = NULL,
                          configtz = NULL,
                          header = NULL)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rmc.file</code></td>
<td>

<p>Filename of file to be read if it is in the working directory, or full path to the file otherwise.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.nrow</code></td>
<td>

<p>Number of rows to read, same as nrow argument in read.csv and nrows in fread. The whole file is read by default (i.e., rmc.nrow = Inf).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.skip</code></td>
<td>

<p>Number of rows to skip, same as skip argument in read.csv and in fread.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.dec</code></td>
<td>

<p>Decimal used for numbers, same as skip argument in read.csv and in fread.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.firstrow.acc</code></td>
<td>

<p>First row (number) of the acceleration data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.firstrow.header</code></td>
<td>

<p>First row (number) of the header. Leave blank if the file does not have
a header.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.header.length</code></td>
<td>

<p>If file has header, specify header length (numeric).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.col.acc</code></td>
<td>

<p>Vector with three column (numbers) in which the acceleration signals
are stored
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.col.temp</code></td>
<td>

<p>Scalar with column (number) in which the temperature is stored.
Leave in default setting if no temperature is avaible. The temperature
will be used by g.calibrate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.col.time</code></td>
<td>

<p>Scalar with column (number) in which the timestamps are stored.
Leave in default setting if timestamps are not stored. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.unit.acc</code></td>
<td>

<p>Character with unit of acceleration values: "g", "mg", or "bit"
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.unit.temp</code></td>
<td>

<p>Character with unit of temperature values: (K)elvin, (C)elsius, or (F)ahrenheit
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.unit.time</code></td>
<td>

<p>Character with unit of timestamps: "POSIX",
"UNIXsec" (seconds since origin, see argument rmc.origin), "character", or
"ActivPAL" (exotic timestamp format only used in the ActivPAL
activity monitor).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.format.time</code></td>
<td>

<p>Character string giving a date-time format as used by strptime. Only used for rmc.unit.time: character and POSIX.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.bitrate</code></td>
<td>

<p>Numeric: If unit of acceleration is a bit then provide bit rate, e.g. 12 bit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.dynamic_range</code></td>
<td>

<p>Numeric, if unit of acceleration is a bit then provide dynamic range deviation
in g from zero, e.g. +/-6g would mean this argument needs to be 6. If you give this
argument a character value the code will search the file header for elements with
a name equal to the character value and use the corresponding numeric value
next to it as dynamic range.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.unsignedbit</code></td>
<td>

<p>Boolean, if unsignedbit = TRUE means that bits are only positive numbers.
if unsignedbit = FALSE then bits are both positive and negative.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.origin</code></td>
<td>

<p>Origin of time when unit of time is UNIXsec, e.g. 1970-1-1
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.desiredtz</code></td>
<td>

<p>Deprecated, please see <code>desiredtz</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.configtz</code></td>
<td>

<p>Deprecated, please see <code>configtz</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.sf</code></td>
<td>

<p>Sample rate in Hertz, if this is stored in the file header then that will be used
instead.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.headername.sf</code></td>
<td>

<p>If file has a header: Row name (character) under which the sample
frequency can be found.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.headername.sn</code></td>
<td>

<p>If file has a header: Row name (character) under which the
serial number can be found.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.headername.recordingid</code></td>
<td>

<p>If file has a header: Row name (character) under which the
recording ID can be found.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.header.structure</code></td>
<td>

<p>Character used to split the header name from the header
value, e.g. ":" or " "
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.check4timegaps</code></td>
<td>

<p>Boolean to indicate whether gaps in time should be imputed with zeros.
Some sensing equipment provides accelerometer with gaps in time. The rest of 
GGIR is not designed for this, by setting this argument to TRUE the the gaps
in time will be filled with zeros.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.col.wear</code></td>
<td>

<p>If external wear detection outcome is stored as part of the data then this can be used by GGIR.
This argument specifies the column in which the wear detection (Boolean) is stored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.doresample</code></td>
<td>

<p>Boolean to indicate whether to resample the data based on the available timestamps and extracted 
sample rate from the file header
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmc.scalefactor.acc</code></td>
<td>

<p>Numeric value (default 1) to scale the acceleration signals via multiplication.
For example, if data is provided in m/s2 then by setting this to 1/9.81
we would derive gravitational units.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolationType</code></td>
<td>

<p>Integer to indicate type of interpolation to be used when resampling time series (mainly relevant for Axivity sensors), 1=linear, 2=nearest neighbour.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PreviousLastValue</code></td>
<td>

<p>Automatically identified last value in previous chunk of data read.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PreviousLastTime</code></td>
<td>

<p>Automatically identified last timestamp in previous chunk of data read.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>desiredtz</code></td>
<td>

<p>Timezone in which device was worn.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>configtz</code></td>
<td>

<p>Timezone in which device was configured. If equal to desiredtz you can leave
this in its default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>

<p>Header information that was extracted the previous time this file was read,
to be re-used instead of being extracted again.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To use this function in the context of GGIR use all arguments from this function,
except rmc.file, rmc.nrow, and  rmc.skip as input for function GGIR or g.part1 and also specify argument rmc.noise, which is not part of this function but needed to tell GGIR what noise level to expect in the data. The rmc.noise is taken from the params_rawdata object if not explicitly specified by user.
</p>


<h3>Value</h3>

<p>List with objects data holding the time series of acceleration, and
header if it was available in the orignal file.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  # create test files: No header, with temperature, with time
  N = 30
  sf = 30
  x = Sys.time()+((0:(N-1))/sf)
  timestamps = as.POSIXlt(x, origin="1970-1-1", tz = "Europe/London")
  mydata = data.frame(x = rnorm(N), time = timestamps, y = rnorm(N), z = rnorm(N),
            temp = rnorm(N) + 20)
  testfile = "testcsv1.csv"
  write.csv(mydata, file= testfile, row.names = FALSE)
  loadedData = read.myacc.csv(rmc.file=testfile, rmc.nrow=20, rmc.dec=".",
                      rmc.firstrow.acc = 1, rmc.firstrow.header=c(),
                      desiredtz = "",
                      rmc.col.acc = c(1,3,4), rmc.col.temp = 5, rmc.col.time=2,
                      rmc.unit.acc = "g", rmc.unit.temp = "C", rmc.origin = "1970-01-01")
  if (file.exists(testfile)) file.remove(testfile)
  
</code></pre>


</div>