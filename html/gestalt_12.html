<div class="container">

<table style="width: 100%;"><tr>
<td>posure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variable Composite Functions</h2>

<h3>Description</h3>

<p><code>posure()</code> enables you to create <em>efficient</em> variable (i.e., parameterized)
composite functions.
</p>
<p>For instance, say you have a composite function such as
</p>
<div class="sourceCode"><pre>  function(..., b = 2, n) {
    (sample %&gt;&gt;&gt;% log(base = b) %&gt;&gt;&gt;% rep(n))(...)
  }

  # Alternatively, expressed with the magrittr %&gt;%:
  function(..., b = 2, n) {
    sample(...) %&gt;% log(base = b) %&gt;% rep(n)
  }
</pre></div>
<p>which varies according to the values of <code>b</code> and <code>n</code>.  You can express this
more succinctly with <code>posure()</code>, by dropping the placeholder argument
(‘<code>...</code>’):
</p>
<div class="sourceCode"><pre>  posure(b = 2, n ~ {
    sample %&gt;&gt;&gt;% log(base = b) %&gt;&gt;&gt;% rep(n)
  })
</pre></div>
<p>This creates a function with same formals and return values.
</p>
<p>But the <code>posure()</code> version is more efficient because it creates the composite
function just <em>once</em>, rather than anew with each function call. Morever, it
is robuster than the functionally equivalent construction with the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
because <code>posure()</code> validates the constituent functions (see
‘Examples’).
</p>


<h3>Usage</h3>

<pre><code class="language-R">posure(..., ..env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Function declaration whose body must be a function composition
expressed using <code>%&gt;&gt;&gt;%</code>. Quasiquotation is
supported. The syntax is that of <code>fn()</code> (see ‘Function
Declarations’) except that declaring ‘<code>...</code>’ among <code>...</code> is
ambiguous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>..env</code></td>
<td>
<p>Environment in which to create the function. (You should rarely
need to set this.)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>posure()</code> <a href="https://en.wikipedia.org/wiki/Currying">curries</a> composite
functions. However, the main significance of <code>posure()</code> is its efficiency,
which is achieved via non-standard scoping semantics (transparent to the
caller). <code>posure()</code> creates the given composite function once. When the
resulting variable composite function is called, its dependencies are
dynamically bound to its localized <em>lexical</em> scope, for fast lookup, then
removed when the function exits. Thus a <strong>posure</strong> is a (parameterized)
closure that is <em>partially dynamically scoped</em>. (This
portmanteau is due to <a href="https://github.com/henryaj">Henry Stanley</a>.)
</p>


<h3>Value</h3>

<p>Function with formals
<code style="white-space: pre;">⁠function (..., &lt;composite_function_dependencies&gt;)⁠</code>, where
<code style="white-space: pre;">⁠&lt;composite_function_dependencies&gt;⁠</code> stands for the formals captured by the
dots of <code>posure()</code>. In particular, a call of the form
</p>
<div class="sourceCode"><pre>  posure(a, b = value ~ f(a, b) %&gt;&gt;&gt;% g(a, b))
</pre></div>
<p>produces a function with the same formals and return values as
</p>
<div class="sourceCode"><pre>  function(..., a, b = value) {
    (f(a, b) %&gt;&gt;&gt;% g(a, b))(...)
  }
</pre></div>


<h3>See Also</h3>

<p><code>%&gt;&gt;&gt;%</code>, <code>fn()</code>, <code>partial()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">foo &lt;- posure(b = 2, n ~ {
  sample %&gt;&gt;&gt;% log(base = b) %&gt;&gt;&gt;% rep(n)
})

# A posure is a composite function with dependencies:
foo

set.seed(1)
foo(2^(1:10), size = 2, n = 3)
#&gt; [1] 3 4 3 4 3 4

set.seed(1)
rep(log(sample(2^(1:10), size = 2), base = 2), 3)
#&gt; [1] 3 4 3 4 3 4

# However, a 'posure()' does the composition upfront, so it is faster
# than the equivalent function defined using the magrittr pipe:

library(magrittr)  # Provides the pipe %&gt;%

foo_pipe &lt;- function(..., b = 2, n) {
  sample(...) %&gt;% log(base = b) %&gt;% rep(n)
}

set.seed(1)
foo_pipe(2^(1:10), size = 2, n = 3)
#&gt; [1] 3 4 3 4 3 4

# Moreover, posures are safer than functions defined using the pipe,
# because '%&gt;&gt;&gt;%' validates constituent functions:
try(posure(b = 2, n ~ log(Base = b) %&gt;&gt;&gt;% rep(n)))
# Error: unused argument (Base = b)

try(posure(b = 2 ~ my_sample %&gt;&gt;&gt;% log(base = b)))
# Error: object 'my_sample' not found

</code></pre>


</div>