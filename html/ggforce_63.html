<div class="container">

<table style="width: 100%;"><tr>
<td>geom_mark_hull</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Annotate areas with hulls</h2>

<h3>Description</h3>

<p>This geom lets you annotate sets of points via hulls. While convex hulls are
most common due to their clear definition, they can lead to large areas
covered that does not contain points. Due to this <code>geom_mark_hull</code> uses
concaveman which lets you adjust concavity of the resulting hull. The hull is
calculated at draw time, and can thus change as you resize the plot. In order
to clearly contain all points, and for aesthetic purpose the resulting hull
is expanded 5mm and rounded on the corners. This can be adjusted with the
<code>expand</code> and <code>radius</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_mark_hull(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  expand = unit(5, "mm"),
  radius = unit(2.5, "mm"),
  concavity = 2,
  label.margin = margin(2, 2, 2, 2, "mm"),
  label.width = NULL,
  label.minwidth = unit(50, "mm"),
  label.hjust = 0,
  label.fontsize = 12,
  label.family = "",
  label.lineheight = 1,
  label.fontface = c("bold", "plain"),
  label.fill = "white",
  label.colour = "black",
  label.buffer = unit(10, "mm"),
  con.colour = "black",
  con.size = 0.5,
  con.type = "elbow",
  con.linetype = 1,
  con.border = "one",
  con.cap = unit(3, "mm"),
  con.arrow = NULL,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>concavity</code></td>
<td>
<p>A measure of the concavity of the hull. <code>1</code> is very concave
while it approaches convex as it grows. Defaults to <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.margin</code></td>
<td>
<p>The margin around the annotation boxes, given by a call
to <code>ggplot2::margin()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.width</code></td>
<td>
<p>A fixed width for the label. Set to <code>NULL</code> to let the text
or <code>label.minwidth</code> decide.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.minwidth</code></td>
<td>
<p>The minimum width to provide for the description. If
the size of the label exceeds this, the description is allowed to fill as
much as the label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.hjust</code></td>
<td>
<p>The horizontal justification for the annotation. If it
contains two elements the first will be used for the label and the second for
the description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fontsize</code></td>
<td>
<p>The size of the text for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.family</code></td>
<td>
<p>The font family used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.lineheight</code></td>
<td>
<p>The height of a line as a multipler of the fontsize.
If it contains two elements the first will be used for the label and the
second for the description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fontface</code></td>
<td>
<p>The font face used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fill</code></td>
<td>
<p>The fill colour for the annotation box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.colour</code></td>
<td>
<p>The text colour for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.buffer</code></td>
<td>
<p>The size of the region around the mark where labels
cannot be placed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.colour</code></td>
<td>
<p>The colour for the line connecting the annotation to the
mark.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.size</code></td>
<td>
<p>The width of the connector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.type</code></td>
<td>
<p>The type of the connector. Either <code>"elbow"</code>, <code>"straight"</code>, or
<code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.linetype</code></td>
<td>
<p>The linetype of the connector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.border</code></td>
<td>
<p>The bordertype of the connector. Either <code>"one"</code> (to draw a
line on the horizontal side closest to the mark), <code>"all"</code> (to draw a border
on all sides), or <code>"none"</code> (not going to explain that one).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.cap</code></td>
<td>
<p>The distance before the mark that the line should stop at.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>con.arrow</code></td>
<td>
<p>An arrow specification for the connection using
<code>grid::arrow()</code> for the end pointing towards the mark.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td>
</tr>
</table>
<h3>Aesthetics</h3>

<p><code>geom_mark_hull</code> understand the following aesthetics (required aesthetics are
in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li>
<p> x0 <em>(used to anchor the label)</em>
</p>
</li>
<li>
<p> y0 <em>(used to anchor the label)</em>
</p>
</li>
<li>
<p> filter
</p>
</li>
<li>
<p> label
</p>
</li>
<li>
<p> description
</p>
</li>
<li>
<p> color
</p>
</li>
<li>
<p> fill
</p>
</li>
<li>
<p> group
</p>
</li>
<li>
<p> size
</p>
</li>
<li>
<p> linetype
</p>
</li>
<li>
<p> alpha
</p>
</li>
</ul>
<h3>Annotation</h3>

<p>All <code style="white-space: pre;">⁠geom_mark_*⁠</code> allow you to put descriptive textboxes connected to the
mark on the plot, using the <code>label</code> and <code>description</code> aesthetics. The
textboxes are automatically placed close to the mark, but without obscuring
any of the datapoints in the layer. The placement is dynamic so if you resize
the plot you'll see that the annotation might move around as areas become big
enough or too small to fit the annotation. If there's not enough space for
the annotation without overlapping data it will not get drawn. In these cases
try resizing the plot, change the size of the annotation, or decrease the
buffer region around the marks.
</p>


<h3>Filtering</h3>

<p>Often marks are used to draw attention to, or annotate specific features of
the plot and it is thus not desirable to have marks around everything. While
it is possible to simply pre-filter the data used for the mark layer, the
<code style="white-space: pre;">⁠geom_mark_*⁠</code> geoms also comes with a dedicated <code>filter</code> aesthetic that, if
set, will remove all rows where it evalutates to <code>FALSE</code>. There are
multiple benefits of using this instead of prefiltering. First, you don't
have to change your data source, making your code more adaptable for
exploration. Second, the data removed by the filter aesthetic is remembered
by the geom, and any annotation will take care not to overlap with the
removed data.
</p>


<h3>See Also</h3>

<p>Other mark geoms: 
<code>geom_mark_circle()</code>,
<code>geom_mark_ellipse()</code>,
<code>geom_mark_rect()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## requires the concaveman packages
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, filter = Species != 'versicolor')) +
  geom_point()

# Adjusting the concavity lets you change the shape of the hull
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, filter = Species != 'versicolor'),
    concavity = 1
  ) +
  geom_point()

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, filter = Species != 'versicolor'),
    concavity = 10
  ) +
  geom_point()

# Add annotation
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species)) +
  geom_point()

# Long descriptions are automatically wrapped to fit into the width
iris$desc &lt;- c(
  'A super Iris - and it knows it',
  'Pretty mediocre Iris, but give it a couple of years and it might surprise you',
  "You'll never guess what this Iris does every Sunday"
)[iris$Species]

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species, description = desc,
                     filter = Species == 'setosa')) +
  geom_point()

# Change the buffer size to move labels farther away (or closer) from the
# marks
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species),
                 label.buffer = unit(40, 'mm')) +
  geom_point()

# The connector is capped a bit before it reaches the mark, but this can be
# controlled
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species),
                 con.cap = 0) +
  geom_point()
</code></pre>


</div>