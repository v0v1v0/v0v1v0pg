<div class="container">

<table style="width: 100%;"><tr>
<td>GNE.fpeq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fixed point equation reformulation of the GNE problem.</h2>

<h3>Description</h3>

<p>Fixed point equation reformulation via the NI function of the GNE problem.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GNE.fpeq(init, dimx, obj, argobj, grobj, arggrobj, 
	heobj, argheobj, joint, argjoint, jacjoint, argjacjoint, 
	method = "default", problem = c("NIR", "VIR"), 
	merit = c("NI", "VI", "FP"), order.method=1, control.outer=list(), 
	control.inner=list(), silent=TRUE, param=list(), stepfunc, argstep, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Initial values for the parameters to be optimized over: <code class="reqn">z=(x, lambda, mu)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>objective function (to be minimized), see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argobj</code></td>
<td>
<p>a list of additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p>joint function (<code class="reqn">h(x)&lt;=0</code>), see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jacjoint</code></td>
<td>
<p>Jacobian of the joint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argjacjoint</code></td>
<td>
<p>a list of additional arguments of the Jacobian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>either <code>"pure"</code>, <code>"UR"</code>, <code>"vH"</code>, <code>"RRE"</code>, <code>"MPE"</code>, 
<code>"SqRRE"</code> or <code>"SqMPE"</code> method, see details. <code>"default"</code> 
corresponds to <code>"MPE"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>problem</code></td>
<td>
<p>either <code>"NIR"</code>, <code>"VIP"</code>, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merit</code></td>
<td>
<p>either <code>"NI"</code>, <code>"VI"</code>, <code>"FP"</code>, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order.method</code></td>
<td>
<p>the order of the extrapolation method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.outer</code></td>
<td>
<p>a list with control parameters for the fixed point algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.inner</code></td>
<td>
<p>a list with control parameters for the fixed point function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>a logical to show some traces.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>a list of parameters for the computation of the fixed point function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepfunc</code></td>
<td>
<p>the step function, only needed when <code>method="UR"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argstep</code></td>
<td>
<p>additional arguments for the step function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to the optimization routine. 
NOT to the functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions in argument must respect the following template:
</p>

<ul>
<li>
<p><code>obj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code> 
and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>grobj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>heobj</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>joint</code> must have arguments the current iterate <code>z</code>
and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>jacjoint</code> must have arguments the current iterate <code>z</code>,
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
</ul>
<p>The fixed point approach consists in solving equation <code class="reqn">y(x)=x</code>.
</p>

<dl>
<dt>(a) Crude or pure fixed point method:</dt>
<dd>
<p>It simply consists in iterations <code class="reqn">x_{n+1} = y(x_n)</code>.</p>
</dd>
<dt>(b) Polynomial methods:</dt>
<dd>

<dl>
<dt>- relaxation algorithm (linear extrapolation):</dt>
<dd>
<p>The next iterate is computed as </p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = (1-\alpha_n) x_n + \alpha_n y(x_n).</code>
</p>

<p>The step <code class="reqn">\alpha_n</code> can be computed in different ways: constant, decreasing
serie or a line search method. In the literature of game theory, the decreasing serie
refers to the method of Ursayev and Rubinstein (<code>method="UR"</code>) while the line search
method refers to the method of von Heusinger (<code>method="vH"</code>). Note that the constant
step can be done using the UR method.</p>
</dd>
<dt>- RRE and MPE method:</dt>
<dd>
<p>Reduced Rank Extrapolation and Minimal Polynomial Extrapolation 
methods are polynomial extrapolation methods, where the monomials are functional 
“powers” of the y function, i.e. function composition of y. Of order 1, RRE and MPE
consists of </p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = x_n + t_n (y(x_n) - x_n),</code>
</p>
 
<p>where <code class="reqn">t_n</code> equals to
<code class="reqn">&lt;v_n, r_n&gt; / &lt;v_n, v_n&gt;</code> for RRE1 and <code class="reqn">&lt;r_n, r_n&gt; / &lt;v_n, r_n&gt;</code> for MPE1, where
<code class="reqn">r_n =y(x_n) - x_n </code> and <code class="reqn">v_n = y(y(x_n)) - 2y(x_n) + x_n</code>. 
To use RRE/MPE methods, set <code>method = "RRE"</code> or <code>method = "MPE"</code>.</p>
</dd>	
<dt>- squaring method:</dt>
<dd>
<p>It consists in using an extrapolation method (such as RRE and MPE)
after two iteration of the linear extrapolation, i.e. 
</p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = x_n -2 t_n r_n + t_n^2 v_n.</code>
</p>
<p> The squared version of RRE/MPE methods are
available via setting <code>method = "SqRRE"</code> or <code>method = "SqMPE"</code>.</p>
</dd>	
</dl>
</dd>
<dt>(c) Epsilon algorithms:</dt>
<dd>
<p>Not implemented.</p>
</dd>
</dl>
<p>For details on fixed point methods, see Varadhan &amp; Roland (2004).
</p>
<p>The <code>control.outer</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt>
<code>merit="FP"</code> and <code>method="pure"</code>
</dt>
<dd>
<p>see <code>fpiter</code>.
the default parameters are <code>list(tol=1e-6, maxiter=100, trace=TRUE)</code>.
</p>
</dd>
<dt>
<code>merit="FP"</code> and <code>method!="pure"</code>
</dt>
<dd>
<p>see <code>squarem</code>.
the default parameters are <code>list(tol=1e-6, maxiter=100, trace=TRUE)</code>.
</p>
</dd>
<dt><code>merit!="FP"</code></dt>
<dd>
<p>parameters are 
</p>

<dl>
<dt><code>tol</code></dt>
<dd>
<p>The absolute convergence tolerance. Default to 1e-6.</p>
</dd>
<dt><code>maxit</code></dt>
<dd>
<p>The maximum number of iterations. Default to 100.</p>
</dd>
<dt><code>echo</code></dt>
<dd>
<p>A logical or an integer (0, 1, 2, 3) to print traces. 
Default to <code>FALSE</code>, i.e. 0.</p>
</dd>
<dt><code>sigma, beta</code></dt>
<dd>
<p>parameters for von Heusinger algorithm. 
Default to 9/10 and 1/2 respectively.</p>
</dd>
</dl>
</dd>
</dl>
<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt><code>par</code></dt>
<dd>
<p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>The value of the merit function.</p>
</dd>
<dt><code>outer.counts</code></dt>
<dd>
<p>A two-element integer vector giving the number of 
calls to fixed-point and merit functions respectively.</p>
</dd>					
<dt><code>outer.iter</code></dt>
<dd>
<p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt>
<dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt>
<dd>
<p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>4</code></dt>
<dd>
<p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>100</code></dt>
<dd>
<p>an error in the execution.</p>
</dd>
</dl>
</dd>
<dt><code>inner.iter</code></dt>
<dd>
<p>The iteration number when 
computing the fixed-point function.</p>
</dd>	
<dt><code>inner.counts</code></dt>
<dd>
<p>A two-element integer 
vector giving the number of calls to the gap function and its gradient 
when computing the fixed-point function.</p>
</dd>			
<dt><code>message</code></dt>
<dd>
<p>a string describing the termination code</p>
</dd>	
</dl>
<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>A. von Heusinger (2009),
<em>Numerical Methods for the Solution of the Generalized Nash Equilibrium Problem</em>,
Ph. D. Thesis.
</p>
<p>A. von Heusinger and C. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>S. Uryasev and R.Y. Rubinstein (1994),
<em>On relaxation algorithms in computation of noncooperative equilibria</em>, 
IEEE Transactions on Automatic Control.
</p>
<p>R. Varadhan and C. Roland (2004),
<em>Squared Extrapolation Methods (SQUAREM): A New Class of Simple and Efficient Numerical 
Schemes for Accelerating the Convergence of the EM Algorithm</em>,
Johns Hopkins University, Dept. of Biostatistics Working Papers.
</p>


<h3>See Also</h3>

<p>See <code>GNE.ceq</code>, <code>GNE.minpb</code> and <code>GNE.nseq</code> 
for other approaches.
</p>


</div>