<div class="container">

<table style="width: 100%;"><tr>
<td>cv.gamlr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Cross Validation for gamlr</h2>

<h3>Description</h3>

<p>Cross validation for gamma lasso penalty selection. </p>


<h3>Usage</h3>

<pre><code class="language-R">cv.gamlr(x, y, nfold=5, foldid=NULL, verb=FALSE, cl=NULL, ...)
## S3 method for class 'cv.gamlr'
plot(x, select=TRUE, df=TRUE, ...)
## S3 method for class 'cv.gamlr'
coef(object, select=c("1se","min"), ...)
## S3 method for class 'cv.gamlr'
predict(object, newdata, select=c("1se","min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> Covariates; see <code>gamlr</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> Response; see <code>gamlr</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfold</code></td>
<td>
<p> The number of cross validation folds. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p> An optional length-n vector of fold memberships for each observation.  If specified, this dictates <code>nfold</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p> Whether to print progress through folds. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>possible <code>parallel</code> library cluster.  If this is not-<code>NULL</code>, the CV folds are executed in parallel.  This copies the data <code>nfold</code> times, so make sure you have the memory space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Arguments to <code>gamlr</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> A gamlr object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p> New <code>x</code> data for prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p> In prediction and coefficient extraction, 
select which "best" model to return: 
<code>select="min"</code> is that with minimum average OOS deviance,
and  <code>select="1se"</code> is that whose average OOS deviance is
no more than 1 standard error away from the minimum. In <code>plot</code>, whether to draw these selections.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p> Whether to add to the plot degrees of freedom along the top axis.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> Fits a <code>gamlr</code> regression to the full dataset, and then performs <code>nfold</code> 
cross validation to evaluate out-of-sample (OOS)
performance  for different penalty weights.
</p>
<p><code>plot.cv.gamlr</code> can be used to plot the results: it 
shows mean OOS deviance with 1se error bars.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gamlr</code></td>
<td>
<p> The full-data fitted <code>gamlr</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfold</code></td>
<td>
<p> The number of CV folds. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p> The length-n vector of fold memberships. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvm</code></td>
<td>
<p> Mean OOS deviance by <code>gamlr\$lambda</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvs</code></td>
<td>
<p> The standard errors on <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seg.min</code></td>
<td>
<p> The index of minimum <code>cvm</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seg.1se</code></td>
<td>
<p> The index of <code>1se</code> <code>cvm</code> (see details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p> Penalty at minimum <code>cvm</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p> Penalty at <code>1se</code> <code>cvm</code>. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matt Taddy <a href="mailto:mataddy@gmail.com">mataddy@gmail.com</a>
</p>


<h3>References</h3>

<p>Taddy (2017 JCGS), One-Step Estimator Paths for Concave Regularization, http://arxiv.org/abs/1308.5623</p>


<h3>See Also</h3>

<p>gamlr, hockey</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 100
p &lt;- 100

xvar &lt;- matrix(ncol=p,nrow=p)
for(i in 1:p) for(j in i:p) xvar[i,j] &lt;- 0.5^{abs(i-j)}
x &lt;- matrix(rnorm(p*n), nrow=n)%*%chol(xvar)
beta &lt;- matrix( (-1)^(1:p)*exp(-(1:p)/10) )
mu = x%*%beta
y &lt;- mu + rnorm(n,sd=sd(as.vector(mu))/2)

## fit with gamma=1 concavity
cvfit &lt;- cv.gamlr(x, y, gamma=1, verb=TRUE)

coef(cvfit)[1:3,] # 1se default
coef(cvfit, select="min")[1:3,] # min OOS deviance

predict(cvfit, x[1:2,], select="min")
predict(cvfit$gamlr, x[1:2,], select=cvfit$seg.min)

par(mfrow=c(1,2))
plot(cvfit)
plot(cvfit$gamlr)

</code></pre>


</div>