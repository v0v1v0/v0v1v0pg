<div class="container">

<table style="width: 100%;"><tr>
<td>SICM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulated integrated conditional moment test statistic</h2>

<h3>Description</h3>

<p>This class inherits from TestStatistic and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is given in Bierens &amp; Wang
(2012) doi: <a href="https://doi.org/10.1017/S0266466611000168">10.1017/S0266466611000168</a> and defined by
</p>
<p style="text-align: center;"><code class="reqn">\hat{T}_n^{(s)}(c) = \frac{1}{(2c)^{p+1}} \int_{[-c,c]^p}
  \int_{-c}^c \left|\frac{1}{\sqrt{n}} \sum_{j=1}^n \Big(\exp(i \tau Y_j) -
  \exp(i \tau \tilde{Y}_j)\Big) \exp(i \xi^T X_j)\right|^2 d\tau d\xi </code>
</p>



<h3>Super class</h3>

<p><code>gofreg::TestStatistic</code> -&gt; <code>SICM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SICM-new"><code>SICM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SICM-calc_stat"><code>SICM$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-SICM-clone"><code>SICM$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href="../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc"><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href="../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy"><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href="../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value"><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href="../../gofreg/html/TestStatistic.html#method-TestStatistic-plot"><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href="../../gofreg/html/TestStatistic.html#method-TestStatistic-print"><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul></details><hr>
<a id="method-SICM-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize an instance of class SICM.
</p>


<h5>Usage</h5>

<div class="r"><pre>SICM$new(
  c,
  transx = function(values) {
     tvals &lt;- atan(scale(values))
     tvals[,
    apply(values, 2, sd) == 0] &lt;- 0
     return(tvals)
 },
  transy = function(values, data) {
     array(atan(scale(values, center = mean(data$y),
    scale = sd(data$y))))
 }
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c</code></dt>
<dd>
<p>chosen value for integral boundaries (see Bierens &amp; Wang (2012))</p>
</dd>
<dt><code>transx</code></dt>
<dd>
<p><code style="white-space: pre;">⁠function(values)⁠</code> used to transform x-values to be
standardized and bounded; default is standardization by subtracting the
mean and dividing by the standard deviation and then applying arctan</p>
</dd>
<dt><code>transy</code></dt>
<dd>
<p><code style="white-space: pre;">⁠function(values, data)⁠</code> used to transform y-values to be
standardized and bounded (same method is used for simulated y-values);
default is standardization by subtracting the mean and dividing by the
standard deviation and then applying arctan</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>a new instance of the class
</p>


<hr>
<a id="method-SICM-calc_stat"></a>



<h4>Method <code>calc_stat()</code>
</h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>SICM$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt>
<dd>
<p>ParamRegrModel to test for</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-SICM-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SICM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R"># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts &lt;- SICM$new(c = 5)
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts2 &lt;- SICM$new(c = 5)
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>


</div>