<div class="container">

<table style="width: 100%;"><tr>
<td>Legendre</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Legendre functions</h2>

<h3>Description</h3>

<p>Legendre functions as per the Gnu Scientific Library reference manual
section 7.24, and AMS-55, chapter 8.  These functions are declared in
header file <code>gsl_sf_legendre.h</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">legendre_P1(x, give=FALSE, strict=TRUE)
legendre_P2(x, give=FALSE, strict=TRUE)
legendre_P3(x, give=FALSE, strict=TRUE)
legendre_Pl(l, x, give=FALSE, strict=TRUE)
legendre_Pl_array(lmax, x, give=FALSE, strict=TRUE)
legendre_Q0(x, give=FALSE, strict=TRUE)
legendre_Q1(x, give=FALSE, strict=TRUE)
legendre_Ql(l, x, give=FALSE, strict=TRUE)
legendre_array_n(lmax)
legendre_array_index(l,m)
legendre_check_args(x,lmax,norm,csphase)
legendre_array(x, lmax, norm=1, csphase= -1)
legendre_deriv_array(x, lmax, norm=1, csphase= -1)
legendre_deriv_alt_array(x, lmax, norm=1, csphase= -1)
legendre_deriv2_array(x, lmax, norm=1, csphase= -1)
legendre_deriv2_alt_array(x, lmax, norm=1, csphase= -1)
legendre_Plm(l, m, x, give=FALSE, strict=TRUE)
legendre_sphPlm(l, m, x, give=FALSE, strict=TRUE)
conicalP_half(lambda, x, give=FALSE, strict=TRUE)  
conicalP_mhalf(lambda, x, give=FALSE, strict=TRUE)  
conicalP_0(lambda, x, give=FALSE, strict=TRUE)  
conicalP_1(lambda, x, give=FALSE, strict=TRUE)  
conicalP_sph_reg(l, lambda, x, give=FALSE, strict=TRUE)  
conicalP_cyl_reg(m, lambda, x, give=FALSE, strict=TRUE)
legendre_H3d_0(lambda, eta, give=FALSE, strict=TRUE)
legendre_H3d_1(lambda, eta, give=FALSE, strict=TRUE)
legendre_H3d(l, lambda, eta, give=FALSE, strict=TRUE)
legendre_H3d_array(lmax, lambda, eta, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>eta,lambda,x</code></td>
<td>
<p>input: real values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l,m,lmax</code></td>
<td>
<p>input: integer values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csphase,norm</code></td>
<td>
<p>Options for use with <code>legendre_array()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
return just the answers, and <code>TRUE</code> meaning to return a status
vector as well</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if nonzero status is returned by the <abbr><span class="acronym">GSL</span></abbr> function (<code>FALSE</code>
means to return the value: use with caution)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class="language-R"> theta &lt;- seq(from=0,to=pi/2,len=100)
 plot(theta,legendre_P1(cos(theta)),type="l",ylim=c(-0.5,1), main="Figure 8.1, p338")
 abline(1,0)
 lines(theta,legendre_P2(cos(theta)),type="l")
 lines(theta,legendre_P3(cos(theta)),type="l")

x &lt;- seq(from=0,to=1,len=600)
plot(x, legendre_Plm(3,1,x), type="l",lty=3,main="Figure 8.2, p338: note sign error")
lines(x,legendre_Plm(2,1,x), type="l",lty=2)
lines(x,legendre_Plm(1,1,x), type="l",lty=1)
abline(0,0)


plot(x,legendre_Ql(0,x),xlim=c(0,1), ylim=c(-1,1.5), type="l",lty=1,
main="Figure 8.4, p339")
lines(x,legendre_Ql(1,x),lty=2)
lines(x,legendre_Ql(2,x),lty=3)
lines(x,legendre_Ql(3,x),lty=4)
abline(0,0)

#table 8.1 of A&amp;S:
t(legendre_Pl_array(10, seq(from=0,to=1,by=0.01))[1+c(2,3,9,10),])

#table 8.3:
f &lt;- function(n){legendre_Ql(n, seq(from=0,to=1,by=0.01))}
sapply(c(0,1,2,3,9,10),f)


# Some checks for the legendre_array() series:

# P_6^1(0.3):
legendre_array(0.3,7)[7,2]         # MMA:  LegendreP[6,1,0.3]; note off-by-one issue

# d/dx  P_8^5(x) @ x=0.2:
legendre_deriv_array(0.2,8)[9,6]   # MMA: D[LegendreP[8,5,x],x] /. {x -&gt; 0.2}


# alternative derivatives:
 legendre_deriv_alt_array(0.4,8)[9,6]  # D[LegendreP[8,5,Cos[x]],x] /. x -&gt; ArcCos[0.4] 



</code></pre>


</div>