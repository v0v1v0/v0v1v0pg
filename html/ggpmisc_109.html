<div class="container">

<table style="width: 100%;"><tr>
<td>stat_quant_band</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicted band from quantile regression fits</h2>

<h3>Description</h3>

<p>Predicted values are computed and, by default, plotted as a band plus an
optional line within. <code>stat_quant_band()</code> supports the use of both
<code>x</code> and <code>y</code> as explanatory variable in the model formula.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_quant_band(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  fm.values = FALSE,
  n = 80,
  method = "rq",
  method.args = list(),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>numeric vector Two or three values in 0..1 indicating the
quantiles at the  edges of the band and optionally a line within the band.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fm.values</code></td>
<td>
<p>logical Add n as a column to returned data? ('FALSE' by
default.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function or character If character, "rq", "rqss" or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>). If a
function different to <code>rq()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, <code>tau</code> and <code>method</code>
and return a model fit object of class <code>rq</code>, <code>rqs</code> or
<code>rqss</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either "x" or "y" controlling the default for
<code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This statistic is similar to <code>stat_quant_line</code> but plots the
quantiles differently with the band representing a region between two
quantiles, while in <code>stat_quant_line()</code> the bands plotted when
<code>se = TRUE</code> represent confidence intervals for the fitted quantile
lines.
</p>
<p><code>geom_smooth</code>, which is used by default, treats each
axis differently and thus is dependent on orientation. If no argument is
passed to <code>formula</code>, it defaults to <code>y ~ x</code> but <code>x ~y</code> is also
accepted, and equivalent to <code>y ~ x</code> plus <code>orientation = "y"</code>.
Package 'ggpmisc' does not define a new geometry matching this statistic as
it is enough for the statistic to return suitable 'x' and 'y' values.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values for three quantiles as <code>y</code>,
<code>ymin</code> and <code>ymax</code>, plus <code>x</code>.
</p>


<h3>Aesthetics</h3>

<p><code>stat_quant_eq</code> expects <code>x</code> and <code>y</code>,
aesthetics to be used in the <code>formula</code> rather than the names of the
variables mapped to them. If present, the variable mapped to the
<code>weight</code> aesthetics is passed as argument to parameter <code>weights</code>
of the fitting function. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics recognized by the geometry
(<code>"geom_smooth"</code> is the default) are obeyed and grouping
respected.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for quantile regression: 
<code>stat_quant_eq()</code>,
<code>stat_quant_line()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band()

# If you need the fitting to be done along the y-axis set the orientation
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(orientation = "y")

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = x ~ poly(y, 3))

# Instead of rq() we can use rqss() to fit an additive model:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(method = "rqss",
                  formula = y ~ qss(x))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(method = "rqss",
                  formula = x ~ qss(y, constraint = "D"))

# Regressions are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  stat_quant_band(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = y ~ poly(x, 2)) +
  facet_wrap(~drv)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(linetype = "dashed", color = "darkred", fill = "red")

ggplot(mpg, aes(displ, hwy)) +
  stat_quant_band(color = NA, alpha = 1) +
  geom_point()

ggplot(mpg, aes(displ, hwy)) +
  stat_quant_band(quantiles = c(0, 0.1, 0.2)) +
  geom_point()

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_band(geom = "debug")

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_band(geom = "debug", fm.values = TRUE)

</code></pre>


</div>