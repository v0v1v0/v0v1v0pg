<div class="container">

<table style="width: 100%;"><tr>
<td>method_kde_1d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Univariate kernel density HDR estimator</h2>

<h3>Description</h3>

<p>Function used to specify univariate kernel density estimator
for <code>get_hdr_1d()</code> and layer functions (e.g. <code>geom_hdr_rug()</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">method_kde_1d(
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  weights = NULL,
  window = kernel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>the smoothing bandwidth to be used.  The kernels are scaled
such that this is the standard deviation of the smoothing kernel.
(Note this differs from the reference books cited below, and from S-PLUS.)
</p>
<p><code>bw</code> can also be a character string giving a rule to choose the
bandwidth.  See <code>bw.nrd</code>. <br> The default,
<code>"nrd0"</code>, has remained the default for historical and
compatibility reasons, rather than as a general recommendation,
where e.g., <code>"SJ"</code> would rather fit, see also Venables and
Ripley (2002).
</p>
<p>The specified (or computed) value of <code>bw</code> is multiplied by
<code>adjust</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>.
This makes it easy to specify values like ‘half the default’
bandwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel, window</code></td>
<td>
<p>a character string giving the smoothing kernel
to be used. This must partially match one of <code>"gaussian"</code>,
<code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code> or <code>"optcosine"</code>, with default
<code>"gaussian"</code>, and may be abbreviated to a unique prefix (single
letter).
</p>
<p><code>"cosine"</code> is smoother than <code>"optcosine"</code>, which is the
usual ‘cosine’ kernel in the literature and almost MSE-efficient.
However, <code>"cosine"</code> is the version used by S.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>numeric vector of non-negative observation weights,
hence of same length as <code>x</code>. The default <code>NULL</code> is
equivalent to <code>weights = rep(1/nx, nx)</code> where <code>nx</code> is the
length of (the finite entries of) <code>x[]</code>.  If <code>na.rm = TRUE</code>
and there are <code>NA</code>'s in <code>x</code>, they <em>and</em> the
corresponding weights are removed before computations.  In that case,
when the original weights have summed to one, they are re-scaled to
keep doing so.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For more details on the use and implementation of the <code style="white-space: pre;">⁠method_*_1d()⁠</code> functions,
see <code>vignette("method", "ggdensity")</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">df &lt;- data.frame(x = rnorm(1e3, sd = 3))

ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_kde_1d()) +
  geom_density()

# Details of the KDE can be adjusted with arguments to `method_kde_1d()`
ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_kde_1d(adjust = 1/5)) +
  geom_density(adjust = 1/5)

ggplot(df, aes(x)) +
  geom_hdr_rug(method = method_kde_1d(kernel = "triangular")) +
  geom_density(kernel = "triangular")

# Can also be used with `get_hdr_1d()` for numerical summary of HDRs
res &lt;- get_hdr_1d(df$x, method = method_kde_1d())
str(res)

</code></pre>


</div>