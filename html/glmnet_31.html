<div class="container">

<table style="width: 100%;"><tr>
<td>coxnet.deviance</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute deviance for Cox model</h2>

<h3>Description</h3>

<p>Compute the deviance (-2 log partial likelihood) for Cox model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coxnet.deviance(
  pred = NULL,
  y,
  x = NULL,
  offset = NULL,
  weights = NULL,
  std.weights = TRUE,
  beta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>Fit vector or matrix (usually from glmnet at a particular
lambda or a sequence of lambdas).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Survival response variable, must be a <code>Surv</code> or
<code>stratifySurv</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Optional <code>x</code> matrix, to be supplied if <code>pred = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Optional offset vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights (default is all equal to 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.weights</code></td>
<td>
<p>If TRUE (default), observation weights are standardized
to sum to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Optional coefficient vector/matrix, to be supplied if
<code>pred = NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the deviance for a single set of predictions, or for a matrix
of predictions. The user can either supply the predictions
directly through the <code>pred</code> option, or by supplying the <code>x</code> matrix
and <code>beta</code> coefficients. Uses the Breslow approach to ties.
</p>
<p>The function first checks if <code>pred</code> is passed: if so, it is used as
the predictions. If <code>pred</code> is not passed but <code>x</code> and <code>beta</code>
are passed, then these values are used to compute the predictions. If
neither <code>x</code> nor <code>beta</code> are passed, then the predictions are all
taken to be 0.
</p>
<p><code>coxnet.deviance()</code> is a wrapper: it calls the appropriate internal
routine based on whether the response is right-censored data or
(start, stop] survival data.
</p>


<h3>Value</h3>

<p>A vector of deviances, one for each column of predictions.
</p>


<h3>See Also</h3>

<p><code>coxgrad</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
eta &lt;- rnorm(10)
time &lt;- runif(10, min = 1, max = 10)
d &lt;- ifelse(rnorm(10) &gt; 0, 1, 0)
y &lt;- survival::Surv(time, d)
coxnet.deviance(pred = eta, y = y)

# if pred not provided, it is set to zero vector
coxnet.deviance(y = y)

# example with x and beta
x &lt;- matrix(rnorm(10 * 3), nrow = 10)
beta &lt;- matrix(1:3, ncol = 1)
coxnet.deviance(y = y, x = x, beta = beta)

# example with (start, stop] data
y2 &lt;- survival::Surv(time, time + runif(10), d)
coxnet.deviance(pred = eta, y = y2)

# example with strata
y2 &lt;- stratifySurv(y, rep(1:2, length.out = 10))
coxnet.deviance(pred = eta, y = y2)

</code></pre>


</div>