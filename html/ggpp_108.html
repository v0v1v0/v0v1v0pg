<div class="container">

<table style="width: 100%;"><tr>
<td>stat_functions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Draw functions as curves</h2>

<h3>Description</h3>

<p><code>stat_functions()</code> computes values from functions and returns new data
containing numeric vectors for <code>x</code> and <code>y</code>. As function definitions
are passed through <code>data</code> this statistic follows the grammar of graphics in
its behaviour.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_functions(
  mapping = NULL,
  data = NULL,
  n = 101,
  geom = "line",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code> or <code>aes_</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset. Useful if the function curve is to be
overlaid on other layers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer Number of points to interpolate along the x axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use on this layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code> values should be stripped
before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes it if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This statistic can be used to plot values computed by functions. As
it follows the grammar of graphics, grouping and facets are supported. In
this it differs from <code>geom_function</code> which behaves
like a plot annotation.
</p>
<p>Aesthetics <code>xmin</code> and <code>xmax</code> should be mapped to numeric values
defining the range of the vector to be created and passed as argument to
the function to compute the <code>y</code> values, and returned as <code>x</code> in
data. <code>n</code> is the length of this <code>x</code> vector.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Computed variables</h3>

<p>Data frame with <code>n</code> rows or a multiple of
this, one for each
row in <code>data</code>. </p>

<dl>
<dt>x</dt>
<dd>
<p>numeric vector</p>
</dd>
<dt>y</dt>
<dd>
<p>numeric vactor</p>
</dd>
<dt>idx</dt>
<dd>
<p>integer vector, with values corresponding to rows in the input
<code>data</code>, i.e., for each function</p>
</dd>
</dl>
<p>As shown in one example below <code>geom_debug</code> can be
used to print the computed values returned by any statistic. The output
shown includes also values mapped to aesthetics.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# one function

df1 &lt;- data.frame(min = 0, max = pi, fun = I(list(sin)))

ggplot(df1, aes(xmin = min, xmax = max, y = fun)) +
  stat_functions()

ggplot(df1, aes(xmin = min, xmax = max, y = fun)) +
  stat_functions(geom = "point", n = 20)

# two functions

df2 &lt;- data.frame(min = -pi, max = pi,
                  fun = I(list(sin, cos)), name = c("sin", "cos"))

# each function must be in a separate group for correct plotting of lines

ggplot(df2, aes(xmin = min, xmax = max, y = fun, group = after_stat(idx))) +
  stat_functions()

ggplot(df2, aes(xmin = min, xmax = max, y = fun, colour = name)) +
  stat_functions()

ggplot(df2, aes(xmin = min, xmax = max, y = fun)) +
  stat_functions() +
  facet_grid(~ name)

# two curves with same function

df3 &lt;- data.frame(min = c(-pi, 0),
                  max = c(0,pi),
                  fun = I(list(sin, sin)),
                  name = c("negative", "positive"))

ggplot(df3, aes(xmin = min, xmax = max, y = fun, colour = name)) +
  stat_functions()

# We use geom_debug() to see the computed values

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(df1, aes(xmin = min, xmax = max, y = fun)) +
    stat_functions(geom = "debug")

}

</code></pre>


</div>