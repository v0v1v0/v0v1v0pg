<div class="container">

<table style="width: 100%;"><tr>
<td>make_domain</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates a list of elements that defines the domain for a multivariate distribution.</h2>

<h3>Description</h3>

<p>Creates a list of elements that define the domain for a multivariate distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_domain(type, p, lefts = NULL, rights = NULL, ineqs = NULL, rule = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A string, the domain type. Currently support <code>"R"</code>, <code>"R+"</code>, <code>"uniform"</code>, <code>"polynomial"</code>, <code>"simplex"</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>An integer, the dimension of the domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lefts</code></td>
<td>
<p>Optional, required if <code>type == "uniform"</code> and must have the same length as <code>rights</code>. A non-empty vector of numbers (may contain <code>-Inf</code>), the left endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rights</code></td>
<td>
<p>Optional, required if <code>type == "uniform"</code> and must have the same length as <code>lefts</code>. A non-empty vector of numbers (may contain <code>Inf</code>), the right endpoints of a domain defined as a union of intervals. It is required that <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ineqs</code></td>
<td>
<p>Optional, required if <code>type == "polynomial"</code>. A list of lists, each sublist representing an inequality that defines the domain. Each sublist must contain fields <code>abs</code> (logical) and <code>nonnegative</code> (logical), and in addition either a single <code>expression</code> (string), or all of the following: <code>uniform</code> (logical), <code>larger</code> (logical), <code>power_numers</code> (1 or <code>p</code> integers), <code>power_denoms</code> (1 or <code>p</code> integers), <code>const</code> (a number), <code>coeffs</code> (1 or <code>p</code> numbers).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>Optional, required if <code>type == "polynomial" &amp;&amp; length(ineqs) &gt; 1</code>. A string containing inequality numbers, spaces, parentheses, '&amp;' and '|' only. Used to indicate the logic operation on how to combine the domains defined by each inequality, i.e. "(1 &amp; 2 &amp;&amp; 3) || 4 | 5". Chained operations not separated by parentheses are only allowed for the same type of operation ('&amp;'/'|'), i.e. "1 &amp; 2 | 3" is not allowed; it should be either "(1 &amp; 2) | 3" or "1 &amp; (2 | 3)".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following types of domains are supported:
</p>

<dl>
<dt><code>"R"</code></dt>
<dd>
<p>The entire <code>p</code>-dimensional real space. Equivalent to <code>"uniform"</code> type with <code>lefts=-Inf</code> and <code>rights=Inf</code>.</p>
</dd>
<dt><code>"R+"</code></dt>
<dd>
<p>The non-negative orthant of the <code>p</code>-dimensional real space. Equivalent to <code>"uniform"</code> type with <code>lefts=0</code> and <code>rights=Inf</code>.</p>
</dd>
<dt><code>"uniform"</code></dt>
<dd>
<p>A union of finitely many disjoint intervals as a uniform domain for all components. The left endpoints should be specified through <code>lefts</code> and the right endpoints through <code>rights</code>. The intervals must be disjoint and strictly increasing, i.e. <code>lefts[i] &lt;= rights[i] &lt;= lefts[j]</code> for any <code>i &lt; j</code>. E.g. <code>lefts=c(0, 10)</code> and <code>rights=c(5, Inf)</code> represents the domain ([0,5]v[10,+Inf])^p.</p>
</dd>
<dt><code>"simplex"</code></dt>
<dd>
<p>The standard <code>p-1</code>-simplex with all components positive and sum to 1, i.e. <code>sum(x) == 1</code> and <code>x &gt; 0</code>.</p>
</dd>
<dt><code>"polynomial"</code></dt>
<dd>
<p>A finite intersection/union of domains defined by comparing a constant to a polynomial with at most one term in each component and no interaction terms (e.g. <code>x1^3+x1^2&gt;1</code> or <code>x1*x2&gt;1</code> not supported). The following is supported: <code>{x1^2 + 2*x2^(3/2) &gt; 1} &amp;&amp; ({3.14*x1 - 0.7*x3^3 &lt; 1} || {-exp(3*x2) + 3.7*log(x3) + 2.4*x4^(-3/2)})</code>.</p>
</dd>
</dl>
<p>To specify a polynomial-type domain, one should define the <code>ineqs</code>, and in case of more than one inequality, the logical <code>rule</code> to combine the domains defined by each inequality.
</p>
<dl>
<dt><code>rule</code></dt>
<dd>
<p>A logical rule in infix notation, e.g. <code>"(1 &amp;&amp; 2 &amp;&amp; 3) || (4 &amp;&amp; 5) || 6"</code>, where the numbers represent the inequality numbers starting from 1. <code>"&amp;&amp;"</code> and <code>"&amp;"</code> are not differentiated, and similarly for <code>"||"</code> and <code>"|"</code>. Chained operations are only allowed for the same operation (<code>"&amp;"</code> or <code>"|"</code>), so instead of <code>"1 &amp;&amp; 2 || 3"</code> one should write either <code>"(1 &amp;&amp; 2) || 3"</code> or <code>"1 &amp;&amp; (2 || 3)"</code> to avoid ambiguity.</p>
</dd>
<dt><code>ineqs</code></dt>
<dd>
<p>A list of lists, each sublist represents one inequality, and must contain the following fields:
</p>

<dl>
<dt><code>abs</code></dt>
<dd>
<p>A logical, indicates whether one should evaluate the polynomial in <code>abs(x)</code> instead of <code>x</code> (e.g. <code>"sum(x) &gt; 1"</code> with <code>abs == TRUE</code> is interpreted as <code>sum(abs(x)) &gt; 1</code>).</p>
</dd>
<dt><code>nonnegative</code></dt>
<dd>
<p>A logical, indicates whether the domain of this inequality should be restricted to the non-negative orthant.</p>
</dd>
</dl>
<p>In addition, one must in addition specify either a single string <code>"expression"</code> (highly recommended, detailed below), or all of the following fields (discouraged usage):
</p>

<dl>
<dt><code>uniform</code></dt>
<dd>
<p>A logical, indicates whether the inequality should be uniformly applied to all components (e.g. <code>"x&gt;1"</code> -&gt; <code>"x1&gt;1 &amp;&amp; ... &amp;&amp; xp&gt;1"</code>).</p>
</dd>
<dt><code>larger</code></dt>
<dd>
<p>A logical, indicates whether the polynomial should be larger or smaller than the constant (e.g. <code>TRUE</code> for <code>x1 + ... + xp &gt; C</code>, and <code>FALSE</code> for <code>x1 + ... + xp &lt; C</code>).</p>
</dd>
<dt><code>const</code></dt>
<dd>
<p>A number, the constant the polynomial should be compared to  (e.g. <code>2.3</code> for <code>x1 + ... + xp &gt; 2.3</code>).</p>
</dd>
<dt><code>power_numers</code></dt>
<dd>
<p>A single integer or a vector of <code>p</code> integers. <code>x[i]</code> will be raised to the power of <code>power_numers[i] / power_denoms[i]</code> (or without subscript if a singer integer). Note that <code>x^(0/0)</code> is interpreted as <code>log(x)</code>, and <code>x^(n/0)</code> as <code>exp(n*x)</code> for <code>n</code> non-zero. For a negative <code>x</code>, <code>x^(a/b)</code> is defined as <code>(-1)^a*|x|^(a/b)</code> if <code>b</code> is odd, or <code>NaN</code> otherwise. (Example: <code>c(2,3,5,0,-2)</code> for <code>x1^2+2*x2^(3/2)+3*x3^(5/3)+4*log(x4)+5*exp(-2*x)&gt;1</code>).</p>
</dd>
<dt><code>power_denoms</code></dt>
<dd>
<p>A single integer or a vector of <code>p</code> integers.  (Example: <code>c(1,2,3,0,0)</code> for <code>x1^2+2*x2^(3/2)+3*x3^(5/3)+4*log(x4)+5*exp(-2*x)&gt;1</code>).</p>
</dd>
<dt><code>coeffs</code></dt>
<dd>
<p>Required if <code>uniform == FALSE</code>. A vector of <code>p</code> doubles, where <code>coeffs[i]</code> is the coefficient on <code>x[i]</code> in the inequality.</p>
</dd>
</dl>
<p>The user is recommended to use a single <code>expression</code> for ease and to avoid potential errors. The user may safely skip the explanations and directly look at the examples to get a better understanding.<br></p>
<p>The expression should have the form <code>"POLYNOMIAL SIGN CONST"</code>, where <code>"SIGN"</code> is one of <code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;"</code>, <code>"&gt;="</code>, and <code>"CONST"</code> is a single number (scientific notation allowed).<br></p>
<p><code>"POLYNOMIAL"</code> must be (1) a single term (see below) in <code>"x"</code> with no coefficient (e.g. <code>"x^(2/3)"</code>, <code>"exp(3x)"</code>), or (2) such a term surrounded by <code>"sum()"</code> (e.g. <code>"sum(x^(2/3))"</code>, <code>"sum(exp(3x))"</code>), or (3) a sum of such terms in <code>"x1"</code> through <code>"xp"</code> (one term max for each component) with or without coefficients, separated by the plus or the minus sign (e.g. <br><code>"2.3x1^(2/3)-3.4exp(x2)+x3^(-3/5)"</code>).<br></p>
<p>For (1) and (2), the term must be in one of the following forms: <code>"x"</code>, <code>"x^2"</code>, <code>"x^(-2)"</code>, <code>"x^(2/3)"</code>, <code>"x^(-2/3)"</code>, <code>"log(x)"</code>, <code>"exp(x)"</code>, <code>"exp(2x)"</code>, <code>"exp(2*x)"</code>, <code>"exp(-3x)"</code>, where the <code>2</code> and <code>3</code> can be changed to any other non-zero integers.<br>
For (3), each term should be as above but in <code>"x1"</code>, ..., <code>"xp"</code> instead of <code>"x"</code>, following an optional double number and optionally a <code>"*"</code> sign.<br></p>
<p>Examples: For <code>p=10</code>, <br>
(1) <code>"x^2 &gt; 2"</code> defines the domain <code>abs(x1) &gt; sqrt(2) &amp;&amp; ... &amp;&amp; abs(x10) &gt; sqrt(2)</code>.<br>
(2) <code>"sum(x^2) &gt; 2"</code> defines the domain <code>x1^2 + ... + x10^2 &gt; 2</code>.<br>
(3) <code>"2.3x3^(2/3)-3.4x4+x5^(-3/5)+3.7*x6^(-4)-1.9*log(x7)+1.3e5*exp(-3x8)}\cr
          \code{-2*exp(x9)+0.5exp(2*x10) &lt;= 2"</code> defines a domain using a polynomial in <code>x3</code> through <code>x10</code>, and <code>x1</code> and <code>x2</code> are thus allowed to vary freely.<br></p>
<p>Note that <code>"&gt;"</code> and <code>"&gt;="</code> are not differentiated, and so are <code>"&lt;"</code> and <code>"&lt;="</code>.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>A list containing the elements that define the domain.
For all types of domains, the following are returned.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A string, same as the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>An integer, same as the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_deemed</code></td>
<td>
<p>An integer, equal to <code>p-1</code> if <code>type == "simplex"</code> or <code>p</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checked</code></td>
<td>
<p>A logical, <code>TRUE</code>. Used in other functions to test whether a list is returned by this function.</p>
</td>
</tr>
</table>
<p>In addition,
</p>

<ul>
<li>
<p>For <code>type == "simplex"</code>, returns in addition
</p>

<dl>
<dt><code>simplex_tol</code></dt>
<dd>
<p>Tolerance used for simplex domains. Defaults to <code>1e-10</code>.</p>
</dd>
</dl>
</li>
<li>
<p>For <code>type == "uniform"</code>, returns in addition
</p>

<dl>
<dt><code>lefts</code></dt>
<dd>
<p>A non-empty vector of numbers, same as the input.</p>
</dd>
<dt><code>rights</code></dt>
<dd>
<p>A non-empty vector of numbers, same as the input.</p>
</dd>
<dt><code>left_inf</code></dt>
<dd>
<p>A logical, indicates whether <code>lefts[1]</code> is <code>-Inf</code>.</p>
</dd>
<dt><code>right_inf</code></dt>
<dd>
<p>A logical, indicates whether <code>rights[length(rights)]</code> is <code>Inf</code>.</p>
</dd>
</dl>
</li>
<li>
<p>For <code>type == "polynomial"</code>, returns in addition
</p>

<dl>
<dt><code>rule</code></dt>
<dd>
<p>A string, same as the input if provided and valid; if not provided and <code>length(ineqs) == 1</code>, set to <code>"1"</code> by default.</p>
</dd>
<dt><code>postfix_rule</code></dt>
<dd>
<p>A string, <code>rule</code> in postfix notation (reverse Polish notation) containing numbers, <code>" "</code>, <code>"&amp;"</code> and <code>"|"</code> only.</p>
</dd>
<dt><code>ineqs</code></dt>
<dd>
<p>A list of lists, each sublist representing one inequality containing the following fields:
</p>

<dl>
<dt><code>uniform</code></dt>
<dd>
<p>A logical, indicates whether the inequality should be uniformly applied to all components (e.g. <code>"x&gt;1"</code> -&gt; <code>"x1&gt;1 &amp;&amp; ... &amp;&amp; xp&gt;1"</code>).</p>
</dd>
<dt><code>larger</code></dt>
<dd>
<p>A logical, indicates whether the polynomial should be larger or smaller than the constant (e.g. <code>TRUE</code> for <code>x1 + ... + xp &gt; C</code>, and <code>FALSE</code> for <code>x1 + ... + xp &lt; C</code>).</p>
</dd>
<dt><code>const</code></dt>
<dd>
<p>A number, the constant the polynomial should be compared to  (e.g. <code>2.3</code> for <code>x1 + ... + xp &gt; 2.3</code>).</p>
</dd>
<dt><code>abs</code></dt>
<dd>
<p>A logical, indicates whether one should evaluate the polynomial in <code>abs(x)</code> instead of <code>x</code>.</p>
</dd>
<dt><code>nonnegative</code></dt>
<dd>
<p>A logical, indicates whether the domain of this inequality should be restricted to the non-negative orthant.</p>
</dd>
<dt><code>power_numers</code></dt>
<dd>
<p>A single integer or a vector of <code>p</code> integers. <code>x[i]</code> will be raised to the power of <code>power_numers[i] / power_denoms[i]</code> (or without subscript if a singer integer). Note that <code>x^(0/0)</code> is interpreted as <code>log(x)</code>, and <code>x^(n/0)</code> as <code>exp(n*x)</code> for <code>n</code> non-zero. For a negative <code>x</code>, <code>x^(a/b)</code> is defined as <code>(-1)^a*|x|^(a/b)</code> if <code>b</code> is odd, or <code>NaN</code> otherwise.</p>
</dd>
<dt><code>power_denoms</code></dt>
<dd>
<p>A single integer or a vector of <code>p</code> integers.</p>
</dd>
<dt><code>coeffs</code></dt>
<dd>
<p><code>NULL</code> if <code>uniform == TRUE</code>. A vector of <code>p</code> doubles, where <code>coeffs[i]</code> is the coefficient on <code>x[i]</code> in the inequality</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">p &lt;- 30
# The 30-dimensional real space R^30
domain &lt;- make_domain("R", p=p)

# The non-negative orthant of the 30-dimensional real space, R+^30
domain &lt;- make_domain("R+", p=p)

# x such that sum(x^2) &gt; 10 &amp;&amp; sum(x^(1/3)) &gt; 10 with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list("expression"="sum(x^2)&gt;10", abs=FALSE, nonnegative=FALSE),
                      list("expression"="sum(x^(1/3))&gt;10", abs=FALSE, nonnegative=FALSE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list(uniform=FALSE, power_numers=2, power_denoms=1, const=10, coeffs=1,
                 larger=1, abs=FALSE, nonnegative=FALSE),
                 list(uniform=FALSE, power_numers=1, power_denoms=3, const=10, coeffs=1,
                 larger=1, abs=FALSE, nonnegative=FALSE)))


# ([0, 1] v [2,3]) ^ p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))

# x such that {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list(uniform=FALSE, power_numers=1, power_denoms=1, const=1,
                 coeffs=c(1,rep(0,p-1)), larger=1, abs=FALSE, nonnegative=TRUE),
                 list(uniform=FALSE, power_numers=1, power_denoms=1, const=1,
                 coeffs=c(0,1,rep(0,p-2)), larger=0, abs=FALSE, nonnegative=TRUE),
                 list(uniform=TRUE, power_numers=1, power_denoms=0, const=1.3,
                 larger=1, abs=FALSE, nonnegative=FALSE)))


# x in R_+^p such that {sum(log(x))&lt;2 || (x1^(2/3)-1.3x2^(-3)&lt;1 &amp;&amp; exp(x1)+2.3*x2&gt;2)}
domain &lt;- make_domain("polynomial", p=p, rule="1 || (2 &amp;&amp; 3)",
       ineqs=list(list("expression"="sum(log(x))&lt;2", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x1^(2/3)-1.3x2^(-3)&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x1)+2.3*x2^2&gt;2", abs=FALSE, nonnegative=TRUE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2",
       ineqs=list(list(uniform=FALSE, power_numers=0, power_denoms=0, const=2,
                 coeffs=1, larger=0, abs=FALSE, nonnegative=TRUE),
                 list(uniform=FALSE, power_numers=c(2,-3,rep(1,p-2)), power_denoms=c(3,rep(1,p-1)),
                 const=1, coeffs=c(1.0,-1.3,rep(0,p-2)), larger=0, abs=FALSE, nonnegative=TRUE),
                 list(uniform=FALSE, power_numers=c(1,2,rep(1,p-2)), power_denoms=c(0,rep(1,p-1)),
                 const=2, coeffs=c(1,2.3,rep(0,p-2)), larger=1, abs=FALSE, nonnegative=TRUE)))


# x in R_+^p such that {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
# Alternatively
domain2 &lt;- make_domain("polynomial", p=p,
       ineqs=list(list(uniform=FALSE, power_numers=1, power_denoms=1, const=1,
                 coeffs=1:p, larger=0, abs=FALSE, nonnegative=TRUE)))


# The (p-1)-simplex
domain &lt;- make_domain("simplex", p=p)

# The l-1 ball {sum(|x|) &lt; 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"="sum(x)&lt;1", abs=TRUE, nonnegative=FALSE)))
</code></pre>


</div>