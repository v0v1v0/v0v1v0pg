<div class="container">

<table style="width: 100%;"><tr>
<td>data_color</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform data cell colorization</h2>

<h3>Description</h3>

<p>It's possible to add color to data cells according to their values with
<code>data_color()</code> There is a multitude of ways to perform data cell
colorizing here:
</p>

<ul>
<li>
<p> targeting: we can constrain which columns and rows should receive the
colorization treatment (through the <code>columns</code> and <code>rows</code> arguments)
</p>
</li>
<li>
<p> direction: ordinarily we perform coloring in a column-wise fashion but
there is the option to color data cells in a row-wise manner (this is
controlled by the <code>direction</code> argument)
</p>
</li>
<li>
<p> coloring method: <code>data_color()</code> automatically computes colors based on the
column type but you can choose a specific methodology (e.g., with bins or
quantiles) and the function will generate colors accordingly; the <code>method</code>
argument controls this through keywords and other arguments act as inputs to
specific methods
</p>
</li>
<li>
<p> coloring function: a custom function can be supplied to the <code>fn</code> argument
for finer control over color evaluation with data; the <code style="white-space: pre;">⁠scales::col_*()⁠</code>
color mapping functions can be used here or any function you might want to define
</p>
</li>
<li>
<p> color palettes: with <code>palette</code> we could supply a vector of colors, a
<strong>virdis</strong> or <strong>RColorBrewer</strong> palette name, or, a palette from the
<strong>paletteer</strong> package
</p>
</li>
<li>
<p> value domain: we can either opt to have the range of values define the
domain, or, specify one explicitly with the <code>domain</code> argument
</p>
</li>
<li>
<p> indirect color application: it's possible to compute colors from one column
and apply them to one or more different columns; we can even perform a
color mapping from multiple source columns to the same multiple of target
columns
</p>
</li>
<li>
<p> color application: with the <code>apply_to</code> argument, there's an option for
whether to apply the cell-specific colors to the cell background or the cell
text
</p>
</li>
<li>
<p> text autocoloring: if colorizing the cell background, <code>data_color()</code> will
automatically recolor the foreground text to provide the best contrast (can
be deactivated with <code>autocolor_text = FALSE</code>)
</p>
</li>
</ul>
<p><code>data_color()</code> won't fail with the default options used, but
that won't typically provide you the type of colorization you really need.
You can however safely iterate through a collection of different options
without running into too many errors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">data_color(
  data,
  columns = everything(),
  rows = everything(),
  direction = c("column", "row"),
  target_columns = NULL,
  method = c("auto", "numeric", "bin", "quantile", "factor"),
  palette = NULL,
  domain = NULL,
  bins = 8,
  quantiles = 4,
  levels = NULL,
  ordered = FALSE,
  na_color = NULL,
  alpha = NULL,
  reverse = FALSE,
  fn = NULL,
  apply_to = c("fill", "text"),
  autocolor_text = TRUE,
  contrast_algo = c("apca", "wcag"),
  colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><em>The gt table data object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;gt_tbl&gt;⁠</code> // <strong>required</strong>
</p>
<p>This is the <strong>gt</strong> table object that is commonly created through use of the
<code>gt()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns to target</em>
</p>
<p><code>&lt;column-targeting expression&gt;</code> // <em>default:</em> <code>everything()</code>
</p>
<p>The columns to which cell data color operations are constrained. Can either
be a series of column names provided in <code>c()</code>, a vector of column indices,
or a select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p><em>Rows to target</em>
</p>
<p><code>&lt;row-targeting expression&gt;</code> // <em>default:</em> <code>everything()</code>
</p>
<p>In conjunction with <code>columns</code>, we can specify which of their rows should
form a constraint for cell data color operations. The default
<code>everything()</code> results in all rows in <code>columns</code> being formatted.
Alternatively, we can supply a vector of row IDs within <code>c()</code>, a vector of
row indices, or a select helper function (e.g. <code>starts_with()</code>,
<code>ends_with()</code>, <code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>).
We can also use expressions to filter down to the rows we need
(e.g., <code style="white-space: pre;">⁠[colname_1] &gt; 100 &amp; [colname_2] &lt; 50⁠</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p><em>Color computation direction</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[column|row]⁠</code> // <em>default:</em> <code>"column"</code>
</p>
<p>Should the color computations be performed column-wise or row-wise? By
default this is set with the <code>"column"</code> keyword and colors will be applied
down columns. The alternative option with the <code>"row"</code> keyword ensures that
the color mapping works across rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target_columns</code></td>
<td>
<p><em>Indirect columns to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;row-targeting expression&gt;⁠</code> // <em>default:</em> <code>NULL</code> <code>optional</code>
</p>
<p>For indirect column coloring treatments, we can supply the columns that
will receive the styling. The necessary precondition is that we must use
<code>direction = "column"</code>. If <code>columns</code> resolves to a single column then we
may use one or more columns in <code>target_columns</code>. If on the other hand
<code>columns</code> resolves to multiple columns, then <code>target_columns</code> must resolve
to the same multiple.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><em>Color computation method</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[auto|numeric|bin|quantile|factor]⁠</code> // <em>default:</em> <code>"auto"</code>
</p>
<p>A method for computing color based on the data within body cells. Can be
<code>"auto"</code> (the default), <code>"numeric"</code>, <code>"bin"</code>, <code>"quantile"</code>, or <code>"factor"</code>.
The <code>"auto"</code> method will automatically choose the <code>"numeric"</code> method for
numerical input data or the <code>"factor"</code> method for any non-numeric inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>palette</code></td>
<td>
<p><em>Color palette</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A vector of color names, a color class that can be cast to a vector of
color names, the name of an <strong>RColorBrewer</strong> palette, the name of a
<strong>viridis</strong> palette, or a discrete palette accessible from the
<strong>paletteer</strong> package using the <code style="white-space: pre;">⁠&lt;package&gt;::&lt;palette&gt;⁠</code> syntax (e.g.,
<code>"wesanderson::IsleofDogs1"</code>). If providing a vector of colors as a
palette, each color value provided must either be a color name (Only R/X11
color names or CSS 3.0 color names) or a hexadecimal string in the form of
<code>"#RRGGBB"</code> or <code>"#RRGGBBAA"</code>. If nothing is provided here, the default R
color palette is used (i.e., the colors from <code>palette()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p><em>Value domain</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;numeric|integer|character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The possible values that can be mapped. For the <code>"numeric"</code> and <code>"bin"</code>
methods, this can be a numeric range specified with a length of two vector.
Representative numeric data is needed for the <code>"quantile"</code> method and
categorical data must be used for the <code>"factor"</code> method. If <code>NULL</code> (the
default value), the values in each column or row (depending on <code>direction</code>)
value will represent the domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bins</code></td>
<td>
<p><em>Specification of bin number</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;numeric|integer&gt;⁠</code> // <em>default:</em> <code>8</code>
</p>
<p>For <code>method = "bin"</code> this can either be a numeric vector of two or more
unique cut points, or, a single numeric value (greater than or equal to
<code>2</code>) giving the number of intervals into which the domain values are to be
cut. By default, this is <code>8</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p><em>Specification of quantile number</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;numeric|integer&gt;⁠</code> // <em>default:</em> <code>4</code>
</p>
<p>For <code>method = "quantile"</code> this is the number of equal-size quantiles to
use. By default, this is set to <code>4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p><em>Specification of factor levels</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>For <code>method = "factor"</code> this allows for an alternate way of specifying
levels. If anything is provided here then any value supplied to <code>domain</code>
will be ignored. This should be a character vector of unique values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p><em>Use an ordered factor</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>For <code>method = "factor"</code>, setting this to <code>TRUE</code> means that the vector
supplied to <code>domain</code> will be treated as being in the correct order if that
vector needs to be coerced to a factor. By default, this is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_color</code></td>
<td>
<p><em>Default color for <code>NA</code> values</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The color to use for missing values. By default (with <code>na_color = NULL</code>),
the color gray (<code>"#808080"</code>) will be used. This option has no effect if
providing a color-mapping function to <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p><em>Transparency value</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;numeric|integer&gt;(0&gt;=val&gt;=1)⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional, fixed alpha transparency value that will be applied to all
color palette values (regardless of whether a color palette was directly
supplied in <code>palette</code> or generated through a color mapping function via
<code>fn</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p><em>Reverse order of computed colors</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the colors computed operate in the reverse order? If <code>TRUE</code> then
colors that normally change from red to blue will change in the opposite
direction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p><em>Color-mapping function</em>
</p>
<p><code>function</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>A color-mapping function. The function should be able to take a vector of
data values as input and return an equal-length vector of color values. The
<code style="white-space: pre;">⁠scales::col_*()⁠</code> functions (i.e.,<code>scales::col_numeric()</code>,
<code>scales::col_bin()</code>, and <code>scales::col_factor()</code>) can be invoked here with
options, as those functions themselves return a color-mapping function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apply_to</code></td>
<td>
<p><em>How to apply color</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[fill|text]⁠</code> // <em>default:</em> <code>"fill"</code>
</p>
<p>Which style element should the colors be applied to? Options include the
cell background (the default, given as <code>"fill"</code>) or the cell text
(<code>"text"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autocolor_text</code></td>
<td>
<p><em>Automatically recolor text</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>An option to let <strong>gt</strong> modify the coloring of text within cells undergoing
background coloring. This will result in better text-to-background color
contrast. By default, this is set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast_algo</code></td>
<td>
<p><em>Color contrast algorithm choice</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[apca|wcag]⁠</code> // <em>default:</em> <code>"apca"</code>
</p>
<p>The color contrast algorithm to use when <code>autocolor_text = TRUE</code>. By
default this is <code>"apca"</code> (Accessible Perceptual Contrast Algorithm) and the
alternative to this is <code>"wcag"</code> (Web Content Accessibility Guidelines).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colors</code></td>
<td>
<p><em>Deprecated Color mapping function</em>
</p>
<p><code>function</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>This argument is deprecated. Use the <code>fn</code> argument instead to provide a
<strong>scales</strong>-based color-mapping function. If providing a palette, use the
<code>palette</code> argument.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>gt_tbl</code>.
</p>


<h3>Color computation methods</h3>

<p><code>data_color()</code> offers four distinct methods for computing color
based on cell data values. They are set by the <code>method</code> argument and the
options go by the keywords <code>"numeric"</code>, <code>"bin"</code>, <code>"quantile"</code>, and
<code>"factor"</code>. There are other arguments in <code>data_color()</code> that variously
support these methods (e.g., <code>bins</code> for the <code>"bin"</code> method, etc.). Here we'll
go through each method, providing a short explanation of what each one does
and which options are available.
</p>


<h4><code>"numeric"</code></h4>

<p>The <code>"numeric"</code> method provides a simple linear mapping from continuous
numeric data to an interpolated <code>palette</code>. Internally, this uses
<code>scales::col_numeric()</code>. This method is suited for numeric data cell
values and can make use of a supplied <code>domain</code> value, in the form of a
two-element numeric vector describing the range of values, if provided.
</p>



<h4><code>"bin"</code></h4>

<p>The <code>"bin"</code> method provides a mapping of continuous numeric data to
value-based bins. Internally, this uses <code>scales::col_bin()</code> which itself
uses <code>base::cut()</code>. As with the <code>"numeric"</code> method, <code>"bin"</code> is meant for
numeric data cell values. The use of a <code>domain</code> value is supported with this
method. The <code>bins</code> argument in <code>data_color()</code> is specific to this method,
offering the ability to: (1) specify the number of bins, or (2) provide a
vector of cut points.
</p>



<h4><code>"quantile"</code></h4>

<p>The <code>"quantile"</code> method provides a mapping of continuous numeric data to
quantiles. Internally, this uses <code>scales::col_quantile()</code> which itself uses
<code>stats::quantile()</code>. Input data cell values should be numeric, as with the
<code>"numeric"</code> and <code>"bin"</code> methods. A numeric <code>domain</code> value is supported with
this method. The <code>quantiles</code> argument in <code>data_color()</code> controls the number
of equal-size quantiles to use.
</p>



<h4><code>"factor"</code></h4>

<p>The <code>"factor"</code> method provides a mapping of factors to colors. With discrete
palettes, color interpolation is used when the number of factors does not
match the number of colors in the palette. Internally, this uses
<code>scales::col_factor()</code>. Input data cell values can be of any type
(i.e., factor, character, numeric values, and more are supported). The
optional input to <code>domain</code> should take the form of categorical data. The
<code>levels</code> and <code>ordered</code> arguments in <code>data_color()</code> support this method.
</p>



<h3>Color palette access from <strong>RColorBrewer</strong> and <strong>viridis</strong>
</h3>

<p>All palettes from the <strong>RColorBrewer</strong> package and select palettes from
<strong>viridis</strong> can be accessed by providing the palette name in <code>palette</code>.
<strong>RColorBrewer</strong> has 35 available palettes:</p>

<table>
<tr>
<td style="text-align: left;">
    </td>
<td style="text-align: left;"> Palette Name </td>
<td style="text-align: left;"> Colors </td>
<td style="text-align: left;"> Category </td>
<td style="text-align: left;"> Colorblind Friendly </td>
</tr>
<tr>
<td style="text-align: left;">
   1 </td>
<td style="text-align: left;"> <code>"BrBG"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   2 </td>
<td style="text-align: left;"> <code>"PiYG"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   3 </td>
<td style="text-align: left;"> <code>"PRGn"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   4 </td>
<td style="text-align: left;"> <code>"PuOr"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   5 </td>
<td style="text-align: left;"> <code>"RdBu"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   6 </td>
<td style="text-align: left;"> <code>"RdYlBu"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   7 </td>
<td style="text-align: left;"> <code>"RdGy"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   8 </td>
<td style="text-align: left;"> <code>"RdYlGn"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   9 </td>
<td style="text-align: left;"> <code>"Spectral"</code> </td>
<td style="text-align: left;"> 11 </td>
<td style="text-align: left;"> Diverging </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   10 </td>
<td style="text-align: left;"> <code>"Dark2"</code> </td>
<td style="text-align: left;"> 8 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   11 </td>
<td style="text-align: left;"> <code>"Paired"</code> </td>
<td style="text-align: left;"> 12 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   12 </td>
<td style="text-align: left;"> <code>"Set1"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   13 </td>
<td style="text-align: left;"> <code>"Set2"</code> </td>
<td style="text-align: left;"> 8 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   14 </td>
<td style="text-align: left;"> <code>"Set3"</code> </td>
<td style="text-align: left;"> 12 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   15 </td>
<td style="text-align: left;"> <code>"Accent"</code> </td>
<td style="text-align: left;"> 8 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   16 </td>
<td style="text-align: left;"> <code>"Pastel1"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   17 </td>
<td style="text-align: left;"> <code>"Pastel2"</code> </td>
<td style="text-align: left;"> 8 </td>
<td style="text-align: left;"> Qualitative </td>
<td style="text-align: left;"> No </td>
</tr>
<tr>
<td style="text-align: left;">
   18 </td>
<td style="text-align: left;"> <code>"Blues"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   19 </td>
<td style="text-align: left;"> <code>"BuGn"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   20 </td>
<td style="text-align: left;"> <code>"BuPu"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   21 </td>
<td style="text-align: left;"> <code>"GnBu"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   22 </td>
<td style="text-align: left;"> <code>"Greens"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   23 </td>
<td style="text-align: left;"> <code>"Greys"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   24 </td>
<td style="text-align: left;"> <code>"Oranges"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   25 </td>
<td style="text-align: left;"> <code>"OrRd"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   26 </td>
<td style="text-align: left;"> <code>"PuBu"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   27 </td>
<td style="text-align: left;"> <code>"PuBuGn"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   28 </td>
<td style="text-align: left;"> <code>"PuRd"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   29 </td>
<td style="text-align: left;"> <code>"Purples"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   30 </td>
<td style="text-align: left;"> <code>"RdPu"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   31 </td>
<td style="text-align: left;"> <code>"Reds"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   32 </td>
<td style="text-align: left;"> <code>"YlGn"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   33 </td>
<td style="text-align: left;"> <code>"YlGnBu"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   34 </td>
<td style="text-align: left;"> <code>"YlOrBr"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
   35 </td>
<td style="text-align: left;"> <code>"YlOrRd"</code> </td>
<td style="text-align: left;"> 9 </td>
<td style="text-align: left;"> Sequential </td>
<td style="text-align: left;"> Yes </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>We can access four colorblind-friendly palettes from <strong>viridis</strong>:
<code>"viridis"</code>, <code>"magma"</code>, <code>"plasma"</code>, and <code>"inferno"</code>. Simply provide any one
of those names to <code>palette</code>.
</p>


<h3>Color palette access from <strong>paletteer</strong>
</h3>

<p>Choosing the right color palette can often be difficult because it's both
hard to discover suitable palettes and then obtain the vector of colors. To
make this process easier we can elect to use the <strong>paletteer</strong> package,
which makes a wide range of palettes from various R packages readily
available. The <code>info_paletteer()</code> information table allows us to easily
inspect all of the discrete color palettes available in <strong>paletteer</strong>. We
only then need to specify the palette and associated package using the
<code style="white-space: pre;">⁠&lt;package&gt;::&lt;palette&gt;⁠</code> syntax (e.g., <code>"tvthemes::Stannis"</code>) for
the <code>palette</code> argument.
</p>
<p>A requirement for using <strong>paletteer</strong> in this way is that the package must be
installed (<strong>gt</strong> doesn't import <strong>paletteer</strong> currently). This can be easily
done with <code>install.packages("paletteer")</code>. Not having this package installed
with result in an error when using the <code style="white-space: pre;">⁠&lt;package&gt;::&lt;palette&gt;⁠</code> syntax in
<code>palette</code>.
</p>


<h3>Foreground text and background fill</h3>

<p>By default, <strong>gt</strong> will choose the ideal text color (for maximal contrast)
when colorizing the background of data cells. This option can be disabled by
setting <code>autocolor_text</code> to <code>FALSE</code>. The <code>contrast_algo</code> argument lets us
choose between two color contrast algorithms: <code>"apca"</code> (<em>Accessible
Perceptual Contrast Algorithm</em>, the default algo) and <code>"wcag"</code> (<em>Web Content
Accessibility Guidelines</em>).
</p>


<h3>Examples</h3>

<p><code>data_color()</code> can be used without any supplied arguments to
colorize a <strong>gt</strong> table. Let's do this with the <code>exibble</code> dataset:
</p>
<div class="sourceCode r"><pre>exibble |&gt;
  gt() |&gt;
  data_color()
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_1.png" alt="This image of a table was generated from the first code example in the `data_color()` help file." style="width:100%;"><p>What's happened is that <code>data_color()</code> applies background colors to all cells
of every column with the default palette in R (accessed through <code>palette()</code>).
The default method for applying color is <code>"auto"</code>, where numeric values will
use the <code>"numeric"</code> method and character or factor values will use the
<code>"factor"</code> method. The text color undergoes an automatic modification that
maximizes contrast (since <code>autocolor_text</code> is <code>TRUE</code> by default).
</p>
<p>You can use any of the available <code>method</code> keywords and <strong>gt</strong> will only apply
color to the compatible values. Let's use the <code>"numeric"</code> method and supply
<code>palette</code> values of <code>"red"</code> and <code>"green"</code>.
</p>
<div class="sourceCode r"><pre>exibble |&gt;
  gt() |&gt;
  data_color(
    method = "numeric",
    palette = c("red", "green")
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_2.png" alt="This image of a table was generated from the second code example in the `data_color()` help file." style="width:100%;"><p>With those options in place we see that only the numeric columns <code>num</code> and
<code>currency</code> received color treatments. Moreover, the palette colors were
mapped to the lower and upper limits of the data in each column; interpolated
colors were used for the values in between the numeric limits of the two
columns.
</p>
<p>We can constrain the cells to which coloring will be applied with the
<code>columns</code> and <code>rows</code> arguments. Further to this, we can manually set the
limits of the data with the <code>domain</code> argument (which is preferable in most
cases). Here, the domain will be set as <code>domain = c(0, 50)</code>.
</p>
<div class="sourceCode r"><pre>exibble |&gt;
  gt() |&gt;
  data_color(
    columns = currency,
    rows = currency &lt; 50,
    method = "numeric",
    palette = c("red", "green"),
    domain = c(0, 50)
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_3.png" alt="This image of a table was generated from the third code example in the `data_color()` help file." style="width:100%;"><p>We can use any of the palettes available in the <strong>RColorBrewer</strong> and
<strong>viridis</strong> packages. Let's make a new <strong>gt</strong> table from a subset of the
<code>countrypops</code> dataset. Then, through <code>data_color()</code>, we'll apply coloring
to the <code>population</code> column with the <code>"numeric"</code> method, use a domain between
2.5 and 3.4 million, and specify <code>palette = "viridis"</code>.
</p>
<div class="sourceCode r"><pre>countrypops |&gt;
  dplyr::select(-contains("code")) |&gt;
  dplyr::filter(
    country_name == "Bangladesh",
    year %in% 2012:2021
  ) |&gt;
  gt() |&gt;
  data_color(
    columns = population,
    method = "numeric",
    palette = "viridis",
    domain = c(150E6, 170E6),
    reverse = TRUE
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_4.png" alt="This image of a table was generated from the fourth code example in the `data_color()` help file." style="width:100%;"><p>We can alternatively use the <code>fn</code> argument for supplying the <strong>scales</strong>-based
function <code>scales::col_numeric()</code>. That function call will itself return a
function (which is what the <code>fn</code> argument actually requires) that takes a
vector of numeric values and returns color values. Here is an alternate
version of the code that returns the same table as in the previous example.
</p>
<div class="sourceCode r"><pre>countrypops |&gt;
  dplyr::select(-contains("code")) |&gt;
  dplyr::filter(
    country_name == "Bangladesh",
    year %in% 2012:2021
  ) |&gt;
  gt() |&gt;
  data_color(
    columns = population,
    fn = scales::col_numeric(
      palette = "viridis",
      domain = c(150E6, 170E6),
      reverse = TRUE
    )
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_4.png" alt="This image of a table was generated from the fourth code example in the `data_color()` help file." style="width:100%;"><p>Using your own function in <code>fn</code> can be very useful if you want to make use of
specialized arguments in the <code style="white-space: pre;">⁠scales::col_*()⁠</code> functions. You could even
supply your own specialized function for performing complex colorizing
treatments!
</p>
<p><code>data_color()</code> has a way to apply colorization indirectly to
other columns. That is, you can apply colors to a column different from the
one used to generate those specific colors. The trick is to use the
<code>target_columns</code> argument. Let's do this with a more complete
<code>countrypops</code>-based table example.
</p>
<div class="sourceCode r"><pre>countrypops |&gt;
  dplyr::filter(country_code_3 %in% c("FRA", "GBR")) |&gt;
  dplyr::filter(year %% 10 == 0) |&gt;
  dplyr::select(-contains("code")) |&gt;
  dplyr::mutate(color = "") |&gt;
  gt(groupname_col = "country_name") |&gt;
  fmt_integer(columns = population) |&gt;
  data_color(
    columns = population,
    target_columns = color,
    method = "numeric",
    palette = "viridis",
    domain = c(4E7, 7E7)
  ) |&gt;
  cols_label(
    year = "",
    population = "Population",
    color = ""
  ) |&gt;
  opt_vertical_padding(scale = 0.65)
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_5.png" alt="This image of a table was generated from the fifth code example in the `data_color()` help file." style="width:100%;"><p>When specifying a single column in <code>columns</code> we can use as many
<code>target_columns</code> values as we want. Let's make another <code>countrypops</code>-based
table where we map the generated colors from the <code>year</code> column to all columns
in the table. This time, the <code>palette</code> used is <code>"inferno"</code> (also from the
<strong>viridis</strong> package).
</p>
<div class="sourceCode r"><pre>countrypops |&gt;
  dplyr::filter(country_code_3 %in% c("FRA", "GBR", "ITA")) |&gt;
  dplyr::select(-contains("code")) |&gt;
  dplyr::filter(year %% 5 == 0) |&gt;
  tidyr::pivot_wider(
    names_from = "country_name",
    values_from = "population"
  ) |&gt;
  gt() |&gt;
  fmt_integer(columns = c(everything(), -year)) |&gt;
  cols_width(
    year ~ px(80),
    everything() ~ px(160)
  ) |&gt;
  opt_all_caps() |&gt;
  opt_vertical_padding(scale = 0.75) |&gt;
  opt_horizontal_padding(scale = 3) |&gt;
  data_color(
    columns = year,
    target_columns = everything(),
    palette = "inferno"
  ) |&gt;
  tab_options(
    table_body.hlines.style = "none",
    column_labels.border.top.color = "black",
    column_labels.border.bottom.color = "black",
    table_body.border.bottom.color = "black"
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_6.png" alt="This image of a table was generated from the sixth code example in the `data_color()` help file." style="width:100%;"><p>Now, it's time to use <code>pizzaplace</code> to create a <strong>gt</strong> table. The color
palette to be used is the <code>"ggsci::red_material"</code> one (it's in the <strong>ggsci</strong>
R package but also obtainable from the <strong>paletteer</strong> package).
Colorization will be applied to the to the <code>sold</code> and <code>income</code> columns. We
don't have to specify those in <code>columns</code> because those are the only columns
in the table. Also, the <code>domain</code> is not set here. We'll use the bounds of the
available data in each column.
</p>
<div class="sourceCode r"><pre>pizzaplace |&gt;
  dplyr::group_by(type, size) |&gt;
  dplyr::summarize(
    sold = dplyr::n(),
    income = sum(price),
    .groups = "drop_last"
  ) |&gt;
  dplyr::group_by(type) |&gt;
  dplyr::mutate(f_sold = sold / sum(sold)) |&gt;
  dplyr::mutate(size = factor(
    size, levels = c("S", "M", "L", "XL", "XXL"))
  ) |&gt;
  dplyr::arrange(type, size) |&gt;
  gt(
    rowname_col = "size",
    groupname_col = "type"
  ) |&gt;
  fmt_percent(
    columns = f_sold,
    decimals = 1
  ) |&gt;
  cols_merge(
    columns = c(size, f_sold),
    pattern = "{1} ({2})"
  ) |&gt;
  cols_align(align = "left", columns = stub()) |&gt;
  data_color(
    method = "numeric",
    palette = "ggsci::red_material"
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_7.png" alt="This image of a table was generated from the seventh code example in the `data_color()` help file." style="width:100%;"><p>Colorization can occur in a row-wise manner. The key to making that happen is
by using <code>direction = "row"</code>. Let's use the <code>sza</code> dataset to make a <strong>gt</strong>
table. Then, color will be applied to values across each 'month' of data in
that table. This is useful when not setting a <code>domain</code> as the bounds of each
row will be captured, coloring each cell with values relative to the range.
The <code>palette</code> is <code>"PuOr"</code> from the <strong>RColorBrewer</strong> package (only the name
here is required).
</p>
<div class="sourceCode r"><pre>sza |&gt;
  dplyr::filter(latitude == 20 &amp; tst &lt;= "1200") |&gt;
  dplyr::select(-latitude) |&gt;
  dplyr::filter(!is.na(sza)) |&gt;
  tidyr::spread(key = "tst", value = sza) |&gt;
  gt(rowname_col = "month") |&gt;
  sub_missing(missing_text = "") |&gt;
  data_color(
    direction = "row",
    palette = "PuOr",
    na_color = "white"
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_8.png" alt="This image of a table was generated from the eighth code example in the `data_color()` help file." style="width:100%;"><p>Notice that <code>na_color = "white"</code> was used, and this avoids the appearance of
gray cells for the missing values (we also removed the <code>"NA"</code> text with
<code>sub_missing()</code>, opting for empty strings).
</p>


<h3>Function ID</h3>

<p>3-36
</p>


<h3>Function Introduced</h3>

<p><code>v0.2.0.5</code> (March 31, 2020)
</p>


<h3>See Also</h3>

<p>Other data formatting functions: 
<code>fmt()</code>,
<code>fmt_auto()</code>,
<code>fmt_bins()</code>,
<code>fmt_bytes()</code>,
<code>fmt_chem()</code>,
<code>fmt_country()</code>,
<code>fmt_currency()</code>,
<code>fmt_date()</code>,
<code>fmt_datetime()</code>,
<code>fmt_duration()</code>,
<code>fmt_email()</code>,
<code>fmt_engineering()</code>,
<code>fmt_flag()</code>,
<code>fmt_fraction()</code>,
<code>fmt_icon()</code>,
<code>fmt_image()</code>,
<code>fmt_index()</code>,
<code>fmt_integer()</code>,
<code>fmt_markdown()</code>,
<code>fmt_number()</code>,
<code>fmt_partsper()</code>,
<code>fmt_passthrough()</code>,
<code>fmt_percent()</code>,
<code>fmt_roman()</code>,
<code>fmt_scientific()</code>,
<code>fmt_spelled_num()</code>,
<code>fmt_tf()</code>,
<code>fmt_time()</code>,
<code>fmt_units()</code>,
<code>fmt_url()</code>,
<code>sub_large_vals()</code>,
<code>sub_missing()</code>,
<code>sub_small_vals()</code>,
<code>sub_values()</code>,
<code>sub_zero()</code>
</p>


</div>