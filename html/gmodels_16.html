<div class="container">

<table style="width: 100%;"><tr>
<td>fast.prcomp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Efficient computation of principal components and singular value
decompositions.</h2>

<h3>Description</h3>

<p>The standard <code>stats::prcomp()</code> and <code>svd()</code> function are
very inefficient for wide matrixes. <code>fast.prcomp</code> and <code>fast.svd</code>
are modified versions which are efficient even for matrixes that are very
wide.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fast.prcomp(x, retx = TRUE, center = TRUE, scale. = FALSE, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retx</code></td>
<td>
<p>a logical value indicating whether the rotated variables
should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>a logical value indicating whether the variables
should be shifted to be zero centered. Alternately, a vector of
length equal the number of columns of <code>x</code> can be supplied.
The value is passed to <code>scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.</code></td>
<td>
<p>a logical value indicating whether the variables should
be scaled to have unit variance before the analysis takes
place.  The default is <code>FALSE</code> for consistency with S, but
in general scaling is advisable.  Alternatively, a vector of length
equal the number of columns of <code>x</code> can be supplied.  The
value is passed to <code>scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a value indicating the magnitude below which components
should be omitted. (Components are omitted if their
standard deviations are less than or equal to <code>tol</code> times the
standard deviation of the first component.)  With the default null
setting, no components are omitted (unless <code>rank.</code> is specified
less than <code>min(dim(x))</code>.).  Other settings for tol could be
<code>tol = 0</code> or <code>tol = sqrt(.Machine$double.eps)</code>, which
would omit essentially constant components.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current implementation of the function <code>svd()</code> in S-Plus and R
is much slower when operating on a matrix with a large number of columns
than on the transpose of this matrix, which has a large number of rows. As a
consequence, <code>stats::prcomp()</code>, which uses <code>svd()</code>, is
also very slow when applied to matrixes with a large number of rows.
</p>
<p>The simple solution is to use <code>La.svd()</code> instead of
<code>svd()</code>.  A suitable patch to <code>stats::prcomp()</code> has been
submitted.  In the mean time, the function <code>fast.prcomp</code> has been
provided as a short-term work-around.
</p>

<dl>
<dt>list("fast.prcomp")</dt>
<dd>
<p>is a modified versiom of
<code>stats::prcomp()</code> that calls <code>La.svd()</code> instead of
<code>svd()</code> </p>
</dd>
<dt>list("fast.svd")</dt>
<dd>
<p>is simply a wrapper around
<code>La.svd()</code>.  </p>
</dd>
</dl>
<h3>Value</h3>

<p>See the documetation for <code>stats::prcomp()</code> or
<code>svd()</code> .
</p>


<h3>Author(s)</h3>

<p>Modifications by Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code>stats::prcomp()</code>, <code>base::svd()</code>, <code>base::La.svd()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

  # create test matrix
  set.seed(4943546)
  nr &lt;- 50
  nc &lt;- 2000
  x  &lt;- matrix( rnorm( nr*nc), nrow=nr, ncol=nc )
  tx &lt;- t(x)

  # SVD directly on matrix is SLOW:
  system.time( val.x &lt;- svd(x)$u )

  # SVD on t(matrix) is FAST:
  system.time( val.tx &lt;- svd(tx)$v )

  # and the results are equivalent:
  max( abs(val.x) - abs(val.tx) )

  # Time gap dissapears using fast.svd:
  system.time( val.x &lt;- fast.svd(x)$u )
  system.time( val.tx &lt;- fast.svd(tx)$v )
  max( abs(val.x) - abs(val.tx) )


  library(stats)

  # prcomp directly on matrix is SLOW:
  system.time( pr.x &lt;- prcomp(x) )

  # prcomp.fast is much faster
  system.time( fast.pr.x &lt;- fast.prcomp(x) )

  # and the results are equivalent
  max( pr.x$sdev - fast.pr.x$sdev )
  max( abs(pr.x$rotation[,1:49]) - abs(fast.pr.x$rotation[,1:49]) )
  max( abs(pr.x$x) - abs(fast.pr.x$x)  )

  # (except for the last and least significant component):
  max( abs(pr.x$rotation[,50]) - abs(fast.pr.x$rotation[,50]) )

</code></pre>


</div>