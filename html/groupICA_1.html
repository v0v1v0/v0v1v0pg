<div class="container">

<table style="width: 100%;"><tr>
<td>groupICA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>groupICA</h2>

<h3>Description</h3>

<p>Estimates the unmixing and confounded sources of the groupICA model
X=A(S+H).
</p>


<h3>Usage</h3>

<pre><code class="language-R">groupICA(X, group_index = NA, partition_index = NA, n_components = NA,
  n_components_uwedge = NA, rank_components = FALSE,
  pairing = "complement", groupsize = 1, partitionsize = NA,
  max_iter = 1000, tol = 1e-12, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>data matrix. Each column corresponds to one predictor
variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_index</code></td>
<td>
<p>vector coding to which group each sample
belongs, with length(<code>group_index</code>)=nrow(<code>X</code>). If no
group index is provided a rigid grid with <code>groupsize</code>
samples per group is used (which defaults to all samples if
<code>groupsize</code> was not set).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partition_index</code></td>
<td>
<p>vector coding to which partition each
sample belongs, with
length(<code>partition_index</code>)=nrow(<code>X</code>). If no partition
index is provided a rigid grid with <code>partitionsize</code> samples
per partition is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_components</code></td>
<td>
<p>number of components to extract. If NA is
passed, the same number of components as the input has
dimensions is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_components_uwedge</code></td>
<td>
<p>number of components to extract during
uwedge approximate joint diagonalization of the matrices. If NA
is passed, the same number of components as the input has
dimensions is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank_components</code></td>
<td>
<p>boolean, optional. When TRUE, the
components will be ordered in decreasing stability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pairing</code></td>
<td>
<p>either 'complement' or 'allpairs'. If 'allpairs'
the difference matrices are computed for all pairs of partition
covariance matrices, while if 'complement' a one-vs-complement
scheme is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupsize</code></td>
<td>
<p>int, optional. Approximate number of samples in
each group when using a rigid grid as groups. If NA is passed,
all samples will be in one group unless group_index is passed
during fitting in which case the provided group index is used
(the latter is the advised and preferred way).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partitionsize</code></td>
<td>
<p>int, optional. Approxiate number of samples
in each partition when using a rigid grid as partition. If NA is
passed, a (hopefully sane) default is used, again, unless
partition_index is passed during fitting in which case the
provided partition index is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>int, optional. Maximum number of iterations for
the uwedge approximate joint diagonalisation during fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>float, optional. Tolerance for terminating the uwedge
approximate joint diagonalisation during fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>boolean whether to supress status outputs.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For further details see the references.
</p>


<h3>Value</h3>

<p>object of class 'GroupICA' consisting of the following
elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>the unmixing matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coverged</code></td>
<td>
<p>boolean indicating whether the approximate joint
diagonalisation converged due to tol.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_iter</code></td>
<td>
<p>number of iterations of the approximate joint
diagonalisation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanoffdiag</code></td>
<td>
<p>mean absolute value of the off-diagonal values
of the to be jointly diagonalised matrices, i.e., a proxy of the
approximate joint diagonalisation objective function.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Niklas Pfister and Sebastian Weichwald
</p>


<h3>References</h3>

<p>Pfister, N., S. Weichwald, P. Bühlmann and B. Schölkopf (2017).
GroupICA: Independent Component Analysis for grouped data.
ArXiv e-prints (arXiv:1806.01094).
</p>
<p>Project website (https://sweichwald.de/groupICA/)
</p>


<h3>See Also</h3>

<p>The function <code>uwedge</code> allows to perform to
perform an approximate joint matrix diagonalization.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example
set.seed(1)

# Generate data from a block-wise variance model
d &lt;- 2
m &lt;- 10
n &lt;- 5000
group_index &lt;- rep(c(1,2), each=n)
partition_index &lt;- rep(rep(1:m, each=n/m), 2)
S &lt;- matrix(NA, 2*n, d)
H &lt;- matrix(NA, 2*n, d)
for(i in unique(group_index)){
  varH &lt;- abs(rnorm(d))/4
  H[group_index==i, ] &lt;- matrix(rnorm(d*n)*rep(varH, each=n), n, d)
  for(j in unique(partition_index[group_index==i])){
    varS &lt;- abs(rnorm(d))
    index &lt;- partition_index==j &amp; group_index==i
    S[index,] &lt;- matrix(rnorm(d*n/m)*rep(varS, each=n/m),
                                                     n/m, d)
  }
}
A &lt;- matrix(rnorm(d^2), d, d)
A &lt;- A%*%t(A)
X &lt;- t(A%*%t(S+H))

# Apply groupICA
res &lt;- groupICA(X, group_index, partition_index, rank_components=TRUE)

# Compare results
par(mfrow=c(2,2))
plot((S+H)[,1], type="l", main="true source 1", ylab="S+H")
plot(res$Shat[,1], type="l", main="estimated source 1", ylab="Shat")
plot((S+H)[,2], type="l", main="true source 2", ylab="S+H")
plot(res$Shat[,2], type="l", main="estimated source 2", ylab="Shat")
cor(res$Shat, S+H)
</code></pre>


</div>