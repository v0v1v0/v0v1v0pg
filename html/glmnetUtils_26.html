<div class="container">

<table style="width: 100%;"><tr>
<td>cva.glmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Do elastic net cross-validation for alpha and lambda simultaneously</h2>

<h3>Description</h3>

<p>Do elastic net cross-validation for alpha and lambda simultaneously
</p>


<h3>Usage</h3>

<pre><code class="language-R">cva.glmnet(x, ...)

## Default S3 method:
cva.glmnet(
  x,
  y,
  alpha = seq(0, 1, len = 11)^3,
  nfolds = 10,
  foldid = sample(rep(seq_len(nfolds), length = nrow(x))),
  ...,
  outerParallel = NULL,
  checkInnerParallel = TRUE
)

## S3 method for class 'formula'
cva.glmnet(
  formula,
  data,
  ...,
  weights = NULL,
  offset = NULL,
  subset = NULL,
  na.action = getOption("na.action"),
  drop.unused.levels = FALSE,
  xlev = NULL,
  sparse = FALSE,
  use.model.frame = FALSE
)

## S3 method for class 'cva.glmnet'
predict(
  object,
  newx,
  alpha,
  which = match(TRUE, abs(object$alpha - alpha) &lt; 1e-08),
  ...
)

## S3 method for class 'cva.glmnet.formula'
predict(
  object,
  newdata,
  alpha,
  which = match(TRUE, abs(object$alpha - alpha) &lt; 1e-08),
  na.action = na.pass,
  ...
)

## S3 method for class 'cva.glmnet'
coef(
  object,
  alpha,
  which = match(TRUE, abs(object$alpha - alpha) &lt; 1e-08),
  ...
)

## S3 method for class 'cva.glmnet.formula'
print(x, ...)

## S3 method for class 'cva.glmnet'
plot(x, ..., legend.x = xlim[1], legend.y = xlim[2], log.x = TRUE)

minlossplot(x, ...)

## S3 method for class 'cva.glmnet'
minlossplot(x, ..., cv.type = c("1se", "min"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A matrix of predictor variables; or for the plotting methods, an object returned by <code>cva.glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to lower-level functions. In the case of <code>cva.glmnet</code>, these arguments are passed to <code>cv.glmnet</code>; for <code>predict</code> and <code>coef</code>, they are passed to <code>predict.cv.glmnet</code>; and for <code>plot</code> and <code>minlossplot</code>, to <code>plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A response vector or matrix (for a multinomial response).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A vector of alpha values for which to do cross-validation. The default is a sequence of 11 values more closely spaced around alpha = 0. For the <code>predict</code> and <code>coef</code> methods, the specific value of alpha for which to return predictions/regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>The number of cross-validation folds to use. Defaults to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>Vector of fold IDs for cross-validation. See glmnet::cv.glmnet.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outerParallel</code></td>
<td>
<p>Method of parallelising the outer loop over alpha. See 'Details' below. If <code>NULL</code>, the loop is run sequentially.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkInnerParallel</code></td>
<td>
<p>If the outer loop is run in parallel, check that the inner loop over lambda will not be in contention for cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A model formula; interaction terms are allowed and will be expanded per the usual rules for linear models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or matrix containing the variables in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>An optional vector of case weights to be used in the fitting process. If missing, defaults to an unweighted fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>An optional vector of offsets, an <em>a priori</em> known component to be included in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying the subset of observations to be used to fit the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function which indicates what should happen when the data contains missing values. For the <code>predict</code> method, <code>na.action = na.pass</code> will predict missing values with <code>NA</code>; <code>na.omit</code> or <code>na.exclude</code> will drop them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.unused.levels</code></td>
<td>
<p>Should factors have unused levels dropped? Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlev</code></td>
<td>
<p>A named list of character vectors giving the full set of levels to be assumed for each factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>Should the model matrix be in sparse format? This can save memory when dealing with many factor variables, each with many levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.model.frame</code></td>
<td>
<p>Should the base model.frame function be used when constructing the model matrix? This is the standard method that most R modelling functions use, but has some disadvantages. The default is to avoid <code>model.frame</code> and construct the model matrix term-by-term; see discussion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>For the <code>predict</code> and <code>coef</code> methods, an object returned by <code>cva.glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newx</code></td>
<td>
<p>For the <code>predict</code> method, a matrix of predictor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>An alternative way of specifying alpha; the index number of the desired value within the alpha vector. If both <code>which</code> and <code>alpha</code> are supplied, the former takes precedence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>For the <code>predict</code> and <code>coef</code> methods, a data frame containing the observations for which to calculate predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.x, legend.y</code></td>
<td>
<p>Location for the legend. Defaults to the top-left corner of the plot. Set either of these to NULL to omit the legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.x</code></td>
<td>
<p>Whether to plot the X-axis (lambda) on the log scale. Defaults to TRUE, which for most lambda sequences produces a more reasonable looking plot. If your lambda sequence includes zero, set this to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.type</code></td>
<td>
<p>For <code>minlossplot</code>, which cross-validated loss value to plot for each value of alpha. This can be either <code>"min"</code> which is the minimum loss, or <code>"1se"</code> which is the highest loss within 1 standard error of the minimum. The default is <code>"1se"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>cva.glmnet</code> function does simultaneous cross-validation for both the alpha and lambda parameters in an elastic net model. The procedure is as outlined in the documentation for glmnet::cv.glmnet: it creates a vector <code>foldid</code> allocating the observations into folds, and then calls <code>cv.glmnet</code> in a loop over different values of alpha, but the same values of <code>foldid</code> each time.
</p>
<p>Optionally this loop over alpha can be parallelised; currently, <code>cva.glmnet</code> knows about two methods of doing so:
</p>

<ul>
<li>
<p> Via parLapply in the parallel package. To use this, set <code>outerParallel</code> to a valid cluster object created by makeCluster.
</p>
</li>
<li>
<p> Via <code>rxExec</code> as supplied by Microsoft R Server's RevoScaleR package. To use this, set <code>outerParallel</code> to a valid compute context created by <code>RxComputeContext</code>, or a character string specifying such a context.
</p>
</li>
</ul>
<p>If the outer loop is run in parallel, <code>cva.glmnet</code> can check if the inner loop (over lambda) is also set to run in parallel, and disable this if it would lead to contention for cores. This is done if it is likely that the parallelisation is local on a multicore machine, ie if <code>outerParallel</code> is a <code>SOCKcluster</code> object running on <code>"localhost"</code>, or if the RevoScaleR compute context is local parallel.
</p>
<p>There are two ways in which the matrix of predictors can be generated. The default, with <code>use.model.frame = FALSE</code>, is to process the additive terms in the formula independently. With wide datasets, this is much faster and more memory-efficient than the standard R approach which uses the <code>model.frame</code> and <code>model.matrix</code> functions. However, the resulting model object is not exactly the same as if the standard approach had been used; in particular, it lacks a bona fide terms object. If you require interoperability with other packages that assume the standard model object structure, set <code>use.model.frame = TRUE</code>. See discussion for more information on this topic.
</p>
<p>The <code>predict</code> method computes predictions for a specific alpha value given a <code>cva.glmnet</code> object. It looks up the supplied alpha (possibly supplied indirectly via the <code>which</code> argument) in the object's stored <code>alpha</code> vector, and calls <code>glmnet:::predict.cv.glmnet</code> on the corresponding <code>cv.glmnet</code> fit. All the arguments to that function are (or should be) supported.
</p>
<p>The <code>coef</code> method is similar, returning the coefficients for the selected alpha value via <code>glmnet:::coef.cv.glmnet</code>.
</p>
<p>The plot method for <code>cva.glmnet</code> objects plots the average cross-validated loss by lambda, for each value of alpha. Each line represents one <code>cv.glmnet</code> fit, corresponding to one value of alpha. Note that the specific lambda values can vary substantially by alpha.
</p>
<p>The <code>minlossplot</code> function gives the best (lowest) cross-validated loss for each value of alpha.
</p>


<h3>Value</h3>

<p>For <code>cva.glmnet.default</code>, an object of class <code>cva.glmnet</code>. This is a list containing the following:
</p>

<ul>
<li> <p><code>alpha</code> The vector of alpha values
</p>
</li>
<li> <p><code>nfolds</code> The number of folds
</p>
</li>
<li> <p><code>modlist</code> A list of <code>cv.glmnet</code> objects, containing the cross-validation results for each value of alpha
</p>
</li>
</ul>
<p>The function <code>cva.glmnet.formula</code> adds a few more components to the above, to facilitate working with formulas.
</p>
<p>For the <code>predict</code> method, a vector or matrix of predicted values.
</p>
<p>For the <code>coef</code> method, a vector of regularised regression coefficients.
</p>


<h3>See Also</h3>

<p>glmnet::cv.glmnet
</p>
<p>glmnet::predict.cv.glmnet, glmnet::coef.cv.glmnet
</p>
<p>cva.glmnet, glmnet::cv.glmnet, plot
</p>


<h3>Examples</h3>

<pre><code class="language-R">cva &lt;- cva.glmnet(mpg ~ ., data=mtcars)
predict(cva, mtcars, alpha=1)

## Not run: 

# Leukemia example dataset from Trevor Hastie's website
download.file("https://web.stanford.edu/~hastie/glmnet/glmnetData/Leukemia.RData",
              "Leukemia.RData")
load("Leukemia.Rdata")
leuk &lt;- do.call(data.frame, Leukemia)
leuk.cva &lt;- cva.glmnet(y ~ ., leuk, family="binomial")
leuk.pred &lt;- predict(leuk.cva, leuk, which=6)

## End(Not run)
</code></pre>


</div>