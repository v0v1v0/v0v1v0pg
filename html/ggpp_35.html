<div class="container">

<table style="width: 100%;"><tr>
<td>geom_grob</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inset graphical objects</h2>

<h3>Description</h3>

<p><code>geom_grob</code> and <code>geom_grob_npc</code> add Grobs as insets to the ggplot
using syntax similar to that of <code>geom_text</code>,
<code>geom_text_s</code> and <code>geom_text_npc</code>.
In most respects they behave as any other ggplot geometry: they add a layer
containing one or more grobs and grouping and faceting works as usual. The
most common use of <code>geom_grob</code> is to add data labels that are graphical
objects rather than text. <code>geom_grob_npc</code> is used to add grobs
as annotations to plots, but contrary to layer function <code>annotate()</code>,
<code>geom_grob_npc</code> is data driven and respects grouping and facets,
thus plot insets can differ among panels. Of these two geoms only
<code>geom_grob</code> supports the plotting of segments, as
<code>geom_grob_npc</code> uses a coordinate system that is unrelated
to data units and data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_grob(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "segment",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "segment",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_grob_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nudge_x, nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.colour, default.color</code></td>
<td>
<p>A colour definition to use for elements not targeted by
the colour aesthetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colour.target, color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"box"</code> and <code>"segment"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>box.padding, point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code>arrow</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You can modify the size of insets with the <code>vp.width</code> and
<code>vp.height</code> aesthetics. These can take a number between 0 (smallest
possible inset) and 1 (whole plotting area width or height). The default
value for for both of these aesthetics is 1/5. Thus, in contrast to
<code>geom_text</code>, <code>geom_label</code>,
<code>geom_text_s</code> and <code>geom_label_s</code> the size of the
insets remains the same relative to the size of the plotting area
irrespective of the size the plot is rendered at. The aspect ratio of
insets is preserved and size is adjusted until the whole inset fits within
the viewport.
</p>
<p>By default <code>geom_grob</code> uses <code>position_nudge_center</code> and
justification <code>"position"</code>, while <code>geom_grob_npc</code> uses
<code>position_nudge</code> and justification <code>"inward"</code>. In
contrast to <code>position_nudge</code>,
<code>position_nudge_center</code> and all other position functions
defined in packages 'ggpp' keep the original coordinates thus allowing the
plotting of connecting segments and arrows.
</p>
<p>This <code>geom_grob</code> and <code>geom_grob_npc</code> require the use tibbles as
argument for <code>data</code>, as the grobs should be stored as a list of
graphics objects ("grob") to be mapped to the <code>label</code> aesthetic.
</p>
<p>The <code>x</code> and <code>y</code> aesthetics determine the position of the whole
inset grob, similarly to that of a text label, justification is interpreted
as indicating the position of the grob with respect to its <em>x</em> and
<em>y</em> coordinates in the data, and <code>angle</code> is used to rotate the
grob as a whole.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Plot boundaries and clipping</h3>

<p>The "width" and "height" of an inset
as for a text element are 0, so stacking and dodging inset plots will not
work by default, and axis limits are not automatically expanded to include
all inset plots. Obviously, insets do have height and width, but they are
physical units, not data units. The amount of space they occupy on the main
plot is not constant in data units of the base plot: when you modify scale
limits, inset plots stay the same size relative to the physical size of the
base plot.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code>position_nudge_keep</code>,
<code>position_dodge_keep</code>, <code>position_jitter_keep</code>,
<code>position_nudge_center</code>, <code>position_nudge_line</code>,
<code>position_nudge_to</code>, <code>position_dodgenudge</code>,
<code>position_jitternudge</code>, and <code>position_stacknudge</code>
for examples and details of their use.
</p>


<h3>Note</h3>

<p>The insets are stored nested within the main ggplot object and
contain their own copy of the data, and are rendered as grid grobs as normal
ggplots at the time the main ggplot is rendered. They can have different
themes.
</p>
<p>Use <code>annotate</code> as redefined in 'ggpp' when adding insets
as annotations (automatically available unless 'ggpp' is not attached).
<code>annotate</code> cannot be used with the <code>npcx</code> and
<code>npcy</code> pseudo-aesthetics.
</p>


<h3>References</h3>

<p>The idea of implementing a <code>geom_custom()</code> for grobs has
been discussed as an issue at
<a href="https://github.com/tidyverse/ggplot2/issues/1399">https://github.com/tidyverse/ggplot2/issues/1399</a>.
</p>


<h3>See Also</h3>

<p><code>grid-package</code>, <code>geom_text</code>,
and other documentation of package 'ggplot2'.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(tibble)
df &lt;- tibble(x = 2, y = 15, grob = list(grid::circleGrob(r = 0.2)))

# without nudging no segments are drawn
ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob))

# with nudging segments are drawn
ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob),
            nudge_x = 0.5,
            colour = "red",
            hjust = 0.5,
            vjust = 0.5)

ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob),
            nudge_x = 0.5,
            colour = "red",
            colour.target = "none",
            hjust = 0.5,
            vjust = 0.5)

# with nudging plotting of segments can be disabled
ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob),
            add.segments = FALSE,
            nudge_x = 0.5,
            hjust = 0.5,
            vjust = 0.5)

</code></pre>


</div>