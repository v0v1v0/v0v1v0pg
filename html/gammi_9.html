<div class="container">

<table style="width: 100%;"><tr>
<td>spline.basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Spectral Spline Basis
</h2>

<h3>Description</h3>

<p>Generate a spectral spline basis matrix for a nominal, ordinal, or polynomial smoothing spline.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spline.basis(x, df = NULL, knots = NULL, m = NULL, intercept = FALSE, 
             Boundary.knots = NULL, warn.outside = TRUE, 
             periodic = FALSE, xlev = levels(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>the predictor vector of length <code>n</code>. Can be a factor, integer, or numeric, see Note.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>

<p>the degrees of freedom, i.e., number of knots to place at quantiles of <code>x</code>. Defaults to 10 but ignored if <code>knots</code> are provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>

<p>the breakpoints (knots) defining the spline. If <code>knots</code> are provided, the <code>df</code> is defined as <code>length(unique(c(knots, Boundary.knots)))</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>the derivative penalty order: 0 = ordinal spline, 1 = linear spline, 2 = cubic spline, 3 = quintic spline
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>should an intercept be included in the basis?  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots</code></td>
<td>

<p>the boundary points for spline basis. Defaults to <code>range(x)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.outside</code></td>
<td>

<p>if <code>TRUE</code>, a warning is provided when <code>x</code> values are outside of the <code>Boundary.knots</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>periodic</code></td>
<td>

<p>should the spline basis functions be constrained to be periodic with respect to the <code>Boundary.knots</code>?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlev</code></td>
<td>

<p>levels of <code>x</code> (only applicable if <code>x</code> is a <code>factor</code>)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a reproduction of the <code>rk</code> function in the <b>grpnet</b> package (Helwig, 2024b). 
</p>
<p>Given a vector of function realizations <code class="reqn">f</code>, suppose that <code class="reqn">f = X \beta</code>, where <code class="reqn">X</code> is the (unregularized) spline basis and <code class="reqn">\beta</code> is the coefficient vector. Let <code class="reqn">Q</code> denote the postive semi-definite penalty matrix, such that <code class="reqn">\beta^\top Q \beta</code> defines the roughness penalty for the spline. See Helwig (2017) for the form of <code class="reqn">X</code> and <code class="reqn">Q</code> for the various types of splines.
</p>
<p>Consider the spectral parameterization of the form <code class="reqn">f = Z \alpha</code> where
</p>
<p style="text-align: center;"><code class="reqn">Z = X Q^{-1/2}</code>
</p>

<p>is the regularized spline basis (that is returned by this function), and <code class="reqn">\alpha = Q^{1/2} \beta</code> are the reparameterized coefficients. Note that <code class="reqn">X \beta = Z \alpha</code> and <code class="reqn">\beta^\top Q \beta = \alpha^\top \alpha</code>, so the spectral parameterization absorbs the penalty into the coefficients (see Helwig, 2021, 2024).
</p>
<p>Syntax of this function is designed to mimic the syntax of the <code>bs</code> function.
</p>


<h3>Value</h3>

<p>Returns a basis function matrix of dimension <code>n</code> by <code>df</code> (plus 1 if an <code>intercept</code> is included) with the following attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>df </code></td>
<td>
<p>degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots </code></td>
<td>
<p>knots for spline basis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m </code></td>
<td>
<p>derivative penalty order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept </code></td>
<td>
<p>was an intercept included?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Boundary.knots </code></td>
<td>
<p>boundary points of <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>periodic </code></td>
<td>
<p>is the basis periodic?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlev </code></td>
<td>
<p>factor levels (if applicable)</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The (default) type of spline basis depends on the <code>class</code> of the input <code>x</code> object:
</p>
<p>* If <code>x</code> is an unordered factor, then a nominal spline basis is used
</p>
<p>* If <code>x</code> is an ordered factor (and <code>m = NULL</code>), then an ordinal spline basis is used
</p>
<p>* If <code>x</code> is an integer or numeric (and <code>m = NULL</code>), then a cubic spline basis is used
</p>
<p>Note that you can override the default behavior by specifying the <code>m</code> argument.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2021). Spectrally sparse nonparametric regression via elastic net regularized smoothers. <em>Journal of Computational and Graphical Statistics, 30</em>(1), 182-191. <a href="https://doi.org/10.1080/10618600.2020.1806855">doi:10.1080/10618600.2020.1806855</a>
</p>
<p>Helwig, N. E. (2024a). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>
<p>Helwig, N. E. (2024b). grpnet: Group Elastic Net Regularized GLMs and GAMs. R package version 0.4. <a href="https://doi.org/10.32614/CRAN.package.grpnet">doi:10.32614/CRAN.package.grpnet</a>
</p>


<h3>See Also</h3>

<p><code>spline.model.matrix</code> for building model matrices using tensor products of spline bases
</p>


<h3>Examples</h3>

<pre><code class="language-R">######***######   NOMINAL SPLINE BASIS   ######***######

x &lt;- as.factor(LETTERS[1:5])
basis &lt;- spline.basis(x)
plot(1:5, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(1:5, basis[,j], col = j)
}


######***######   ORDINAL SPLINE BASIS   ######***######

x &lt;- as.ordered(LETTERS[1:5])
basis &lt;- spline.basis(x)
plot(1:5, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(1:5, basis[,j], col = j)
}


######***######   LINEAR SPLINE BASIS   ######***######

x &lt;- seq(0, 1, length.out = 101)
basis &lt;- spline.basis(x, df = 5, m = 1)
plot(x, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(x, basis[,j], col = j)
}


######***######   CUBIC SPLINE BASIS   ######***######

x &lt;- seq(0, 1, length.out = 101)
basis &lt;- spline.basis(x, df = 5)
basis &lt;- scale(basis)  # for visualization only!
plot(x, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(x, basis[,j], col = j)
}


######***######   QUINTIC SPLINE BASIS   ######***######

x &lt;- seq(0, 1, length.out = 101)
basis &lt;- spline.basis(x, df = 5, m = 3)
basis &lt;- scale(basis)  # for visualization only!
plot(x, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(x, basis[,j], col = j)
}
</code></pre>


</div>