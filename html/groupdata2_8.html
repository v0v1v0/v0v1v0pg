<div class="container">

<table style="width: 100%;"><tr>
<td>collapse_groups_by</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Collapse groups balanced by a single attribute</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Collapses a set of groups into a smaller set of groups.
</p>
<p>Balance the new groups by:
</p>

<ul>
<li>
<p> The <strong>number of rows</strong> with <code>collapse_groups_by_size()</code>
</p>
</li>
<li> <p><strong>Numerical columns</strong> with <code>collapse_groups_by_numeric()</code>
</p>
</li>
<li>
<p> One or more levels of <strong>categorical columns</strong> with <code>collapse_groups_by_levels()</code>
</p>
</li>
<li>
<p> Level counts in <strong>ID columns</strong> with <code>collapse_groups_by_ids()</code>
</p>
</li>
<li> <p><strong>Any combination</strong> of these with <code>collapse_groups()</code>
</p>
</li>
</ul>
<p>These functions wrap <code>collapse_groups()</code>
to provide a simpler interface. To balance more than one of the attributes at a time
and/or create multiple new unique grouping columns at once, use
<code>collapse_groups()</code> directly.
</p>
<p>While, <em>on average</em>, the balancing work better than without, this is
<strong>not guaranteed on every run</strong>. <code>`auto_tune`</code> (enabled by default) can yield
a much better overall balance than without in most contexts. This generates a larger set
of group columns using all combinations of the balancing columns and selects the
most balanced group column(s). This is slower and can be speeded up by enabling
parallelization (see <code>`parallel`</code>).
</p>
<p><strong>Tip</strong>: When speed is more important than balancing, disable <code>`auto_tune`</code>.
</p>
<p><strong>Tip</strong>: Check the balances of the new groups with
<code>summarize_balances()</code> and
<code>ranked_balances()</code>.
</p>
<p><strong>Note</strong>: The categorical and ID balancing algorithms are different to those
in <code>fold()</code> and
<code>partition()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">collapse_groups_by_size(
  data,
  n,
  group_cols,
  auto_tune = TRUE,
  method = "balance",
  col_name = ".coll_groups",
  parallel = FALSE,
  verbose = FALSE
)

collapse_groups_by_numeric(
  data,
  n,
  group_cols,
  num_cols,
  balance_size = FALSE,
  auto_tune = TRUE,
  method = "balance",
  group_aggregation_fn = mean,
  col_name = ".coll_groups",
  parallel = FALSE,
  verbose = FALSE
)

collapse_groups_by_levels(
  data,
  n,
  group_cols,
  cat_cols,
  cat_levels = NULL,
  balance_size = FALSE,
  auto_tune = TRUE,
  method = "balance",
  col_name = ".coll_groups",
  parallel = FALSE,
  verbose = FALSE
)

collapse_groups_by_ids(
  data,
  n,
  group_cols,
  id_cols,
  balance_size = FALSE,
  auto_tune = TRUE,
  method = "balance",
  col_name = ".coll_groups",
  parallel = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code>. Can be <em>grouped</em>, in which case
the function is applied group-wise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of new groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_cols</code></td>
<td>
<p>Names of factors in <code>`data`</code> for identifying the <em>existing</em> groups
that should be collapsed.
</p>
<p>Multiple names are treated as in <code>dplyr::group_by()</code>
(i.e., a hierarchy of groups), where each leaf group within each parent group is
considered a unique group to be collapsed.
Parent groups are not considered during collapsing, why leaf groups from different
parent groups can be collapsed together.
</p>
<p><strong>Note</strong>: Do not confuse these group columns with potential columns that <code>`data`</code> is grouped by.
<code>`group_cols`</code> identifies the groups to be collapsed. When <code>`data`</code> is
grouped with <code>dplyr::group_by()</code>, the function is
applied separately to each of those subsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto_tune</code></td>
<td>
<p>Whether to create a larger set of collapsed group columns
from all combinations of the balancing dimensions and select the
overall most balanced group column(s).
</p>
<p>This tends to create much more balanced collapsed group columns.
</p>
<p>Can be slow, why we recommend enabling parallelization (see <code>`parallel`</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>"balance"</code>, <code>"ascending"</code>, or <code>"descending"</code>.
</p>

<ul>
<li> <p><code>"balance"</code> balances the attribute between the groups.
</p>
</li>
<li> <p><code>"ascending"</code> orders by the attribute and groups from the lowest to highest value.
</p>
</li>
<li> <p><code>"descending"</code> orders by the attribute and groups from the highest to lowest value.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_name</code></td>
<td>
<p>Name of the new group column. When creating multiple new group columns
(<code>`num_new_group_cols`&gt;1</code>), this is the prefix for the names, which will
be suffixed with an underscore and a number (_1, _2, _3, etc.).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Whether to parallelize the group column comparisons
when <code>`auto_tune`</code> is enabled.
</p>
<p>Requires a registered parallel backend.
Like <code>doParallel::registerDoParallel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print information about the process.
May make the function slightly slower.
</p>
<p>N.B. Currently only used during auto-tuning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_cols</code></td>
<td>
<p>Names of numerical columns to balance between groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance_size</code></td>
<td>
<p>Whether to balance the size of the collapsed groups. (logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_aggregation_fn</code></td>
<td>
<p>Function for aggregating values in the <code>`num_cols`</code> columns
for each group in <code>`group_cols`</code>.
</p>
<p>Default is <code>mean()</code>, where the average value(s) are balanced across the new groups.
</p>
<p>When using <code>sum()</code>, the groups will have similar sums across the new groups.
</p>
<p><strong>N.B.</strong> Only used when <code>`num_cols`</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cat_cols</code></td>
<td>
<p>Names of categorical columns to balance the average frequency
of one or more levels of.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cat_levels</code></td>
<td>
<p>Names of the levels in the <code>`cat_cols`</code> columns to balance the average frequencies
of. When <code>`NULL`</code> (default), all levels are balanced.
Can be weights indicating the balancing importance of each level (within each column).
</p>
<p>The weights are automatically scaled to sum to <code>1</code>.
</p>
<p>Can be <code>".minority"</code> or <code>".majority"</code>, in which case the minority/majority level
are found and used.
</p>


<h4>When <code>`cat_cols`</code> has single column name:</h4>

<p>Either a <code>vector</code> with level names or a named <code>numeric vector</code> with weights:
</p>
<p>E.g. <code>c("dog", "pidgeon", "mouse")</code> or <code>c("dog" = 5, "pidgeon" = 1, "mouse" = 3)</code>
</p>



<h4>When <code>`cat_cols`</code> has multiple column names:</h4>

<p>A named <code>list</code> with <code>vector</code>s for each column name in <code>`cat_cols`</code>.
When not providing a <code>vector</code> for a <code>`cat_cols`</code>
column, all levels are balanced in that column.
</p>
<p>E.g. <code>list("col1" = c("dog" = 5, "pidgeon" = 1, "mouse" = 3),
 "col2" = c("hydrated", "dehydrated"))</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_cols</code></td>
<td>
<p>Names of factor columns with IDs to balance the counts of between groups.
</p>
<p>E.g. useful to get a similar number of participants in each group.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See details in <code>collapse_groups()</code>.
</p>


<h3>Value</h3>

<p><code>`data`</code> with a new grouping factor column.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other grouping functions: 
<code>all_groups_identical()</code>,
<code>collapse_groups()</code>,
<code>fold()</code>,
<code>group_factor()</code>,
<code>group()</code>,
<code>partition()</code>,
<code>splt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Attach packages
library(groupdata2)
library(dplyr)

# Set seed
if (requireNamespace("xpectr", quietly = TRUE)){
  xpectr::set_test_seed(42)
}

# Create data frame
df &lt;- data.frame(
  "participant" = factor(rep(1:20, 3)),
  "age" = rep(sample(c(1:100), 20), 3),
  "answer" = factor(sample(c("a", "b", "c", "d"), 60, replace = TRUE)),
  "score" = sample(c(1:100), 20 * 3)
)
df &lt;- df %&gt;% dplyr::arrange(participant)
df$session &lt;- rep(c("1", "2", "3"), 20)

# Sample rows to get unequal sizes per participant
df &lt;- dplyr::sample_n(df, size = 53)

# Create the initial groups (to be collapsed)
df &lt;- fold(
  data = df,
  k = 8,
  method = "n_dist",
  id_col = "participant"
)

# Ungroup the data frame
# Otherwise `collapse_groups*()` would be
# applied to each fold separately!
df &lt;- dplyr::ungroup(df)

# When `auto_tune` is enabled for larger datasets
# we recommend enabling parallelization
# This can be done with:
# library(doParallel)
# doParallel::registerDoParallel(7) # use 7 cores

## Not run: 

# Collapse to 3 groups with size balancing
# Creates new `.coll_groups` column
df_coll &lt;- collapse_groups_by_size(
  data = df,
  n = 3,
  group_cols = ".folds"
)

# Check balances
(coll_summary &lt;- summarize_balances(
  data = df_coll,
  group_cols = ".coll_groups"
))

# Get ranked balances
# This is most useful when having created multiple
# new group columns with `collapse_groups()`
# The scores are standard deviations across groups
ranked_balances(coll_summary)

# Collapse to 3 groups with *categorical* balancing
df_coll &lt;- collapse_groups_by_levels(
  data = df,
  n = 3,
  group_cols = ".folds",
  cat_cols = "answer"
)

# Check balances
(coll_summary &lt;- summarize_balances(
  data = df_coll,
  group_cols = ".coll_groups",
  cat_cols = 'answer'
))

# Collapse to 3 groups with *numerical* balancing
# Also balance size to get similar sums
# as well as means
df_coll &lt;- collapse_groups_by_numeric(
  data = df,
  n = 3,
  group_cols = ".folds",
  num_cols = "score",
  balance_size = TRUE
)

# Check balances
(coll_summary &lt;- summarize_balances(
  data = df_coll,
  group_cols = ".coll_groups",
  num_cols = 'score'
))

# Collapse to 3 groups with *ID* balancing
# This should give us a similar number of IDs per group
df_coll &lt;- collapse_groups_by_ids(
  data = df,
  n = 3,
  group_cols = ".folds",
  id_cols = "participant"
)

# Check balances
(coll_summary &lt;- summarize_balances(
  data = df_coll,
  group_cols = ".coll_groups",
  id_cols = 'participant'
))

# Collapse to 3 groups with balancing of ALL attributes
# We create 5 new grouping factors and compare them
# The latter is in-general a good strategy even if you
# only need a single collapsed grouping factor
# as you can choose your preferred balances
# based on the summary
# NOTE: This is slow (up to a few minutes)
# consider enabling parallelization
df_coll &lt;- collapse_groups(
  data = df,
  n = 3,
  num_new_group_cols = 5,
  group_cols = ".folds",
  cat_cols = "answer",
  num_cols = 'score',
  id_cols = "participant",
  auto_tune = TRUE   # Disabled by default in `collapse_groups()`
  # parallel = TRUE  # Add comma above and uncomment
)

# Check balances
(coll_summary &lt;- summarize_balances(
  data = df_coll,
  group_cols = paste0(".coll_groups_", 1:5),
  cat_cols = "answer",
  num_cols = 'score',
  id_cols = 'participant'
))

# Compare the new grouping columns
# The lowest across-group standard deviation
# is the most balanced
ranked_balances(coll_summary)


## End(Not run)

</code></pre>


</div>