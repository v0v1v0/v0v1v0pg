<div class="container">

<table style="width: 100%;"><tr>
<td>gsi.DS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Workhorse function for direct sampling</h2>

<h3>Description</h3>

<p>This function implements in R the direct sampling algorithm
</p>


<h3>Usage</h3>

<pre><code class="language-R">gsi.DS(
  n,
  f,
  t,
  n_realiz,
  dim_TI,
  dim_SimGrid,
  TI_input,
  SimGrid_input,
  ivars_TI = 3:ncol(TI_input),
  SimGrid_mask = ncol(SimGrid_input),
  invertMask = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>size of the conditioning data event (integer)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>fraction of the training image to scan (numeric between 0 and 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>maximal acceptable discrepance between conditioning data event and TI event (numeric between 0 and 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_realiz</code></td>
<td>
<p>number of simulations desired</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim_TI</code></td>
<td>
<p>dimensions of the grid of the training image (ie. either <code class="reqn">(n_x, n_y)</code>
for dimension <code class="reqn">k=2</code> or <code class="reqn">(n_x, n_y, n_z)</code> for dimension <code class="reqn">k=3</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim_SimGrid</code></td>
<td>
<p>dimensions of the simulation grid (ie. either <code class="reqn">(m_x, m_y)</code> or
<code class="reqn">(m_x, m_y, m_z)</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TI_input</code></td>
<td>
<p>training image, as a matrix of <code class="reqn">(n_x\cdot n_y\cdot n_z, k+D)</code>
elements; WITH NAMED COLUMNS and including spatial coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SimGrid_input</code></td>
<td>
<p>simulation grid with conditioning data, as a matrix of
<code class="reqn">(m_x\cdot m_y\cdot m_z, k+D)</code> elements; with same columns as <code>TI_input</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ivars_TI</code></td>
<td>
<p>which colnames of <code>TI_input</code> and <code>SimGrid_input</code> identify variables to consider in the data event</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SimGrid_mask</code></td>
<td>
<p>either a logical vector of length <code class="reqn">m_x\cdot m_y\cdot m_z</code>, or else a column name of <code>SimGrid_input</code>
giving a logical column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invertMask</code></td>
<td>
<p>logical, does <code>SimGrid_mask</code> identify with TRUE the data OUTSIDE the simulation area?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>sp::SpatialPixelsDataFrame()</code> or  <code>sp::SpatialGridDataFrame()</code>, depending on whether the whole
grid is simulated. The '@data' slot of these objects contains a <code>DataFrameStack()</code> with the stacking dimension
running through the realisations. It is safer to use this functionality through the interface
<code>make.gmCompositionalMPSSpatialModel()</code>, then request a direct simulation with <code>DSpars()</code> and
finally run it with predict_gmSpatialModel.
</p>


<h3>Author(s)</h3>

<p>Hassan Talebi (copyright holder), Raimon Tolosana-Delgado
</p>


<h3>Examples</h3>

<pre><code class="language-R">## training image:
x = 1:10
y = 1:7
xy_TI = expand.grid(x=x, y=y)
TI_input = cbind(xy_TI, t(apply(xy_TI, 1, function(x) c(sum(x), abs(x[2]-x[1]))+rnorm(2, sd=0.01))))
colnames(TI_input) = c("x", "y", "V1", "V2")
o1 = image_cokriged(TI_input, ivar="V1")
o2 = image_cokriged(TI_input, ivar="V2")
## simulation grid:
SimGrid = TI_input
SimGrid$mask = with(SimGrid, x==1 | x==10 | y==1 | y==7)
tk = SimGrid$mask
tk[sample(70, 50)] = TRUE 
SimGrid[tk,3:4]=NA
image_cokriged(SimGrid, ivar="V1", breaks=o1$breaks, col=o1$col)
image_cokriged(SimGrid, ivar="V2", breaks=o2$breaks, col=o2$col)
image_cokriged(SimGrid, ivar="mask", breaks=c(-0.0001, 0.5, 1.001))
## Not run: 
res = gsi.DS(n=5, f=0.75, t=0.05, n_realiz=2, dim_TI=c(10,7),  dim_SimGrid=c(10,7), 
       TI_input=as.matrix(TI_input), SimGrid_input=as.matrix(SimGrid), 
       ivars_TI = c("V1", "V2"), SimGrid_mask="mask", invertMask=TRUE)
image_cokriged(cbind(xy_TI, getStackElement(res,1)), ivar="V1", breaks=o1$breaks, col=o1$col)
image_cokriged(cbind(xy_TI, getStackElement(res,2)), ivar="V1", breaks=o1$breaks, col=o1$col)
image_cokriged(cbind(xy_TI, getStackElement(res,1)), ivar="V2", breaks=o2$breaks, col=o2$col)
image_cokriged(cbind(xy_TI, getStackElement(res,2)), ivar="V2", breaks=o2$breaks, col=o2$col)

## End(Not run)
</code></pre>


</div>