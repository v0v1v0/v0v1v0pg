<div class="container">

<table style="width: 100%;"><tr>
<td>ch1.solutions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution code for Chapter 1: Linear Models</h2>

<h3>Description</h3>

<p>R code for Chapter 1 exercise solutions.</p>


<h3>Author(s)</h3>

<p>Simon Wood &lt;simon@r-project.org&gt;
</p>
<p>Maintainer: Simon Wood &lt;simon@r-project.org&gt;
</p>


<h3>References</h3>

<p>Wood, S.N. (2017) <em>Generalized Additive Models: An Introduction with R</em>, CRC
</p>


<h3>See Also</h3>

<p><code>mgcv</code>, <code>ch1</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(gamair); library(mgcv)

## Q.8 Rubber
## a)
library(MASS)
m1 &lt;- lm(loss~hard+tens+I(hard*tens)+I(hard^2)+I(tens^2)+
I(hard^2*tens)+I(tens^2*hard)+I(tens^3)+I(hard^3),Rubber)
plot(m1)    ## residuals OK
summary(m1) ## p-values =&gt; drop I(tens^2*hard)
m2 &lt;- update(m1,.~.-I(tens^2*hard))
summary(m2)
m3 &lt;- update(m2,.~.-hard)
summary(m3)
m4 &lt;- update(m3,.~.-1)
summary(m4)
m5 &lt;- update(m4,.~.-I(hard^2))
summary(m5) ## p-values =&gt; keep all remaining
plot(m5)    ## residuals OK

## b)
AIC(m1,m2,m3,m4,m5)
m6 &lt;- step(m1)

## c)
m &lt;- 40;attach(Rubber)
mt &lt;- seq(min(tens),max(tens),length=m)
mh &lt;- seq(min(hard),max(hard),length=m)
lp &lt;- predict(m6,data.frame(hard=rep(mh,rep(m,m)),
                            tens=rep(mt,m)))
contour(mt,mh,matrix(lp,m,m),xlab="tens",ylab="hard")
points(tens,hard)
detach(Rubber)

## Q.9 warpbreaks
wm &lt;- lm(breaks~wool*tension,warpbreaks)
par(mfrow=c(2,2))
plot(wm)    # residuals OK
anova(wm)
## ... so there is evidence for a wool:tension interaction.
par(mfrow=c(1,1))
with(warpbreaks,interaction.plot(tension,wool,breaks))

## Q.10 cars
## a)
cm1 &lt;- lm(dist ~ speed + I(speed^2),cars)
summary(cm1)
## Intercept has very high p-value, so drop it
cm2 &lt;- lm(dist ~ speed + I(speed^2)-1,cars)
summary(cm2)
## both terms now significant, but try the alternative of
## dropping `speed'
cm3 &lt;- lm(dist ~ I(speed^2),cars)
AIC(cm1,cm2,cm3)
plot(cm2)
# Clearly cm2, with speed and speed squared terms, is to be preferred,
# but note that variance seems to be increasing with mean a little:
# perhaps a GLM, better?

## b)
# In seconds, the answer is obtained as follows..
b &lt;- coef(cm2)
5280/(b[1]*60^2)
# This is a long time, but would have a rather wide associated confidence
# interval.

## Q.11 QR
# The following is a version of the function that you should end up with.

fitlm &lt;- function(y,X)
{ qrx &lt;- qr(X)                ## get QR decomposition
  y &lt;- qr.qty(qrx,y)          ## form Q'y efficiently
  R &lt;- qr.R(qrx)              ## extract R
  p &lt;- ncol(R);n &lt;- length(y) ## get dimensions
  f &lt;- y[1:p]; r &lt;- y[(p+1):n]## partition Q'y
  beta &lt;- backsolve(R,f)      ## parameter estimates (a)
  sig2 &lt;- sum(r^2)/(n-p)      ## resid variance estimate (c)
  Ri &lt;- backsolve(R,diag(ncol(R))) ## inverse of R matrix
  Vb &lt;- Ri%*%t(Ri)*sig2       ## covariance matrix
  se &lt;- diag(Vb)^.5           ## standard errors (c)
  F.ratio &lt;- f^2/sig2         ## sequential F-ratios
  seq.p.val &lt;- 1-pf(F.ratio,1,n-p) ## seq. p-values (e)
  list(beta=beta,se=se,sig2=sig2,seq.p.val=seq.p.val,df=n-p)
} ## fitlm

# The following code uses the function to answer some of the question parts.

## get example X ...
X &lt;- model.matrix(dist ~ speed + I(speed^2),cars)
cm &lt;- fitlm(cars$dist,X) # used fitting function
cm$beta;cm$se            # print estimates and s.e.s (a,c)
cm1&lt;-lm(dist ~ speed + I(speed^2),cars) # equiv. lm call
summary(cm1)             # check estimates and s.e.s (b,c)
t.ratio &lt;- cm$beta/cm$se # form t-ratios
p.val &lt;- pt(-abs(t.ratio),df=cm$df)*2
p.val                    # print evaluated p-values (d)
## print sequential ANOVA p-values, and check them (e)
cm$seq.p.val
anova(cm1)

## Q.12 InsectSprays
X &lt;- model.matrix(~spray-1,InsectSprays)
X &lt;- cbind(rep(1,nrow(X)),X)   # redundant model matrix
C &lt;- matrix(c(0,rep(1,6)),1,7) # constraints
qrc &lt;- qr(t(C))                # QR decomp. of C'
## use fact that Q=[D:Z] and XQ = (Q'X')' to form XZ ...
XZ &lt;- t(qr.qty(qrc,t(X)))[,2:7]
m1 &lt;- lm(InsectSprays$count~XZ-1) # fit model
bz &lt;- coef(m1) # estimates in constrained parameterization
## form b = Z b_z, using fact that Q=[D:Z], again
b &lt;- c(0,bz)
b &lt;- qr.qy(qrc,b)
sum(b[2:7])

## Q.13 trees
## a)
EV.func &lt;- function(b,g,h)
{ mu &lt;- b[1]*g^b[2]*h^b[3]
  J &lt;- cbind(g^b[2]*h^b[3],mu*log(g),mu*log(h))
  list(mu=mu,J=J)
}

## b)
attach(trees)
b &lt;- c(.002,2,1);b.old &lt;- 100*b+100
while (sum(abs(b-b.old))&gt;1e-7*sum(abs(b.old))) {
   EV &lt;- EV.func(b,Girth,Height)
   z &lt;- (Volume-EV$mu) + EV$J%*%b
   b.old &lt;- b
   b &lt;- coef(lm(z~EV$J-1))
}
b

## c)
sig2 &lt;- sum((Volume - EV$mu)^2)/(nrow(trees)-3)
Vb &lt;- solve(t(EV$J)%*%EV$J)*sig2
se &lt;- diag(Vb)^.5;se

</code></pre>


</div>