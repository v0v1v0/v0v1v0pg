<div class="container">

<table style="width: 100%;"><tr>
<td>ff.rotationsDF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rotations</h2>

<h3>Description</h3>

<p>Optimize factor loading rotation objective.
</p>


<h3>Usage</h3>

<pre><code class="language-R">	ff.bentler(L)
	ff.cf(L, kappa=0)
	ff.cubimax(L)
	ff.entropy(L)
	ff.geomin(L, delta=0.01)
	ff.infomax(L) 
	ff.oblimax(L)
	ff.pst(L, W=NULL, Target=NULL)
	ff.quartimax(L)
	ff.quartimin(L)
	ff.simplimax(L, k=nrow(L))
	ff.fss(L, kij=2)
	ff.target(L, Target=NULL) 
	ff.varimax(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a factor loading matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>constant added to Lambda^2 in objective calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Target</code></td>
<td>
<p>rotation target for objective calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>weighting of each element in target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of close to zero loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kij</code></td>
<td>
<p>minimum additional number of forced simple structure loadings in a pair of factors.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are used to optimize a rotation objective. The name need to be included
in a call to <code>GPForth.df</code> or <code>GPFoblq</code>. Calling the functions itself computes the values
but no rotation is performed.
</p>
<p>Functions listed here are all exported through NAMESPACE, and primarily serve as examples 
for programming new rotation methods.  New rotation methods can be programmed with a name
<code>ff.newmethod</code>. The inputs are the matrix L, and optionally any additional arguments. The
output should be a list with elements 
</p>

<table>
<tr>
<td style="text-align: left;">
  <code>f</code>       </td>
<td style="text-align: left;"> the value of the criterion at L.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>Method</code>  </td>
<td style="text-align: left;"> a string indicating the criterion.</td>
</tr>
<tr>
<td style="text-align: left;">         
  </td>
</tr>
</table>
<p>Please note that the function value <code>f</code> has to be minimized. If the rotation criterion
is supposed to maximize, then use the negative of the criterion to miniize. 
Functions which are available are 
</p>

<table>
<tr>
<td style="text-align: left;">
<code>ff.bentler</code>   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.cf</code>		   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.cubimax</code>   </td>
<td style="text-align: left;"> orthogonal    </td>
<td style="text-align: left;">  	</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.entropy</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  minimum entropy			</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.fss</code> 	   </td>
<td style="text-align: left;"> orthogonal or oblique	   </td>
<td style="text-align: left;">  Forced Simple Structure (see Vignette)   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.geomin</code>    </td>
<td style="text-align: left;"> orthogonal or oblique  </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.infomax</code>   </td>
<td style="text-align: left;"> orthogonal or oblique   </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.oblimax</code>   </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.pst</code>	   </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.quartimax</code> </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 					</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.quartimin</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.simplimax</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.target</code>    </td>
<td style="text-align: left;"> orthogonal or oblique </td>
<td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
<td style="text-align: left;">
<code>ff.varimax</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 					</td>
</tr>
<tr>
<td style="text-align: left;">
 </td>
</tr>
</table>
<p>The argument <code>kappa</code> parameterizes the family for the Crawford-Ferguson 
method. If <code>m</code> is the number of factors and <code>p</code> is the number of 
items then <code>kappa</code> values having special names are <code>0=</code>Quartimax, 
<code>1/p=</code>Varimax, <code>m/(2*p)=</code>Equamax, <code>(m-1)/(p+m-2)=</code>Parsimax, <code>1=</code>Factor parsimony.
</p>
<p>For the argument <code>kij</code> for Forced Simple Structure see <code>rotationsDF</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>criterion function value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich</p>


<h3>References</h3>

<p>Jennrich, R.I. (2004) Derivative free gradient projection algorithms for rotation,
Psychometrika: <b>69</b>(3), 475â€“480.
</p>


<h3>See Also</h3>

<p><code>GPForth.df</code>, 
<code>GPFoblq.df</code>, 
<code>fssQ.df</code>,
<code>fssT.df</code>,
<code>cubimax.df</code>,
<code>rotationsDF</code>,
<code>factanal</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">  data("Harman", package="GPArotation")
  qHarman  &lt;- GPForth.df(Harman8, Tmat=diag(2), method="quartimax")
  
  # define a new function as ff.newname for use with factanal
  ff.expomax &lt;- function(L)
  {
    f &lt;- -sum(diag(expm1(abs(L))))
    list(f = f, Method = "DF-Expomax")
  }
  GPForth.df(Harman8, method ="expomax")

  expomax.df &lt;- function(L, Tmat = diag(ncol(L)), normalize = FALSE, eps = 1e-5, maxit = 1000){
   GPForth.df(L, Tmat=Tmat, method = "expomax", normalize = normalize, eps= eps, maxit = maxit)	
  }
  expomax.df(Harman8, normalize = TRUE)
  factanal(factors = 2, covmat = ability.cov, rotation = "expomax.df", 
      control = list(rotate =c(normalize = TRUE)))
 </code></pre>


</div>