<div class="container">

<table style="width: 100%;"><tr>
<td>condBiCopSim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation from a Conditional Bivariate Copula</h2>

<h3>Description</h3>

<p>Simulates from a conditional bivariate copula, where each copula parameter
takes a different value, depending on the calibration
function and covariates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">condBiCopSim(family, calib.fnc, X, par2 = 0, return.par = TRUE, tau = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>family A copula family:
<code>1</code> Gaussian,
<code>2</code> Student t,
<code>3</code> Clayton,
<code>4</code> Gumbel,
<code>5</code> Frank,
<code>13</code> Survival Clayton,
<code>14</code> Survival Gumbel,
<code>23</code> Rotated (90 degrees) Clayton,
<code>24</code> Rotated (90 degrees) Gumbel,
<code>33</code> Rotated (270 degrees) Clayton and
<code>34</code> Rotated (270 degrees) Gumbel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calib.fnc</code></td>
<td>
<p>A calibration function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A vector (if <code>calib.fnc</code> takes a single argument) or matrix
(if <code>calib.fnc</code> takes multiple arguments) of covariates values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par2</code></td>
<td>
<p>The second copula parameter (for the Student t), default
<code>par2 = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.par</code></td>
<td>
<p>Should the parameter (and calibration function) be returned
as well (default <code>return.par = TRUE</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Should the calibration function (and the model) be specified for
the copula parameter or Kendall's tau (default <code>tau = TRUE</code>)?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>return.par = TRUE</code>, then the function returns a list with:
</p>

<ul>
<li> <p><code>data</code>, a matrix with two columns containing the simulated data,
</p>
</li>
<li> <p><code>par</code>, a vector containing the values of the copula parameter,
</p>
</li>
<li>
<p> and <code>eta</code>, a vector containing the values of the
calibration function.
</p>
</li>
</ul>
<p>If <code>return.par = FALSE</code>, then the function simply returns <code>data</code>,
a matrix with two columns containing the simulated data.
</p>


<h3>See Also</h3>

<p><code>gamBiCopFit</code> and <code>gamBiCopSimulate</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Gaussian copula family)
n &lt;- 2e2
rho &lt;- 0.5
fam &lt;- 1


## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## Display the calibration surface
par(mfrow = c(1, 3), pty = "s", mar = c(1, 1, 4, 1))
u &lt;- seq(0, 1, length.out = 100)
sel &lt;- matrix(c(1, 1, 2, 2, 3, 3), ncol = 2)
jet.colors &lt;- colorRamp(c(
  "#00007F", "blue", "#007FFF", "cyan", "#7FFF7F",
  "yellow", "#FF7F00", "red", "#7F0000"
))
jet &lt;- function(x) rgb(jet.colors(exp(x / 3) / (1 + exp(x / 3))),
    maxColorValue = 255
  )
for (k in 1:3) {
  tmp &lt;- outer(u, u, function(x, y)
    eta0 + calib.surf[[sel[k, 1]]](x) + calib.surf[[sel[k, 2]]](y))
  persp(u, u, tmp,
    border = NA, theta = 60, phi = 30, zlab = "",
    col = matrix(jet(tmp), nrow = 100),
    xlab = paste("X", sel[k, 1], sep = ""),
    ylab = paste("X", sel[k, 2], sep = ""),
    main = paste("eta0+f", sel[k, 1],
      "(X", sel[k, 1], ") +f", sel[k, 2],
      "(X", sel[k, 2], ")",
      sep = ""
    )
  )
}

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Display the data
dev.off()
plot(data[, "u1"], data[, "u2"], xlab = "U1", ylab = "U2")
</code></pre>


</div>