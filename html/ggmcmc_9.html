<div class="container">

<table style="width: 100%;"><tr>
<td>ggs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Import MCMC samples into a ggs object than can be used by all ggs_* graphical functions.</h2>

<h3>Description</h3>

<p>This function manages MCMC samples from different sources (JAGS, MCMCpack, STAN -both via rstan and via csv files-) and converts them into a data frame tibble. The resulting data frame has four columns (Iteration, Chain, Parameter, value) and six attributes (nChains, nParameters, nIterations, nBurnin, nThin and description). The ggs object returned is then used as the input of the ggs_* functions to actually plot the different convergence diagnostics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ggs(
  S,
  family = NA,
  description = NA,
  burnin = TRUE,
  par_labels = NA,
  sort = TRUE,
  keep_original_order = FALSE,
  splitting = FALSE,
  inc_warmup = FALSE,
  stan_include_auxiliar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Either a <code>mcmc.list</code> object with samples from JAGS, a <code>mcmc</code> object with samples from MCMCpack, a <code>stanreg</code> object with samples from rstanarm, a <code>brmsfit</code> object with samples from brms, a <code>stanfit</code> object with samples from rstan, or a list with the filenames of <code>csv</code> files generated by stan outside rstan (where the order of the files is assumed to be the order of the chains). ggmcmc guesses what is the original object and tries to import it accordingly. rstan is not expected to be in CRAN soon, and so coda::mcmc is used to extract stan samples instead of the more canonical rstan::extract.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Name of the family of parameters to process, as given by a character vector or a regular expression. A family of parameters is considered to be any group of parameters with the same name but different numerical value between square brackets (as beta[1], beta[2], etc).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>Character vector giving a short descriptive text that identifies the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Logical or numerical value. When logical and TRUE (the default), the number of samples in the burnin period will be taken into account, if it can be guessed by the extracting process. Otherwise, iterations will start counting from 1. If a numerical vector is given, the user then supplies the length of the burnin period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_labels</code></td>
<td>
<p>data frame with two colums. One named "Parameter" with the same names of the parameters of the model. Another named "Label" with the label of the parameter. When missing, the names passed to the model are used for representation. When there is no correspondence between a Parameter and a Label, the original name of the parameter is used. The order of the levels of the original Parameter does not change.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>Logical. When TRUE (the default), parameters are sorted first by family name and then by numerical value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_original_order</code></td>
<td>
<p>Logical. When TRUE, parameters are sorted using the original order provided by the source software. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitting</code></td>
<td>
<p>Logical. When TRUE, use the approach suggested by Gelman, Carlin, Stern, Dunson, Vehtari and Rubin (2014) Bayesian Data Analysis. 3rd edition. This implies splitting the sequences (original chains) in half, and treat each half as a different Chain, therefore effectively doubling the number of chains. In this case, the first half of Chain 1 is still Chain 1 , but the second half is turned into Chain 2, and the first half of Chain 2 into Chain 3, and so on. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inc_warmup</code></td>
<td>
<p>Logical. When dealing with stanfit objects from rstan, logical value whether the warmup samples are included. Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stan_include_auxiliar</code></td>
<td>
<p>Logical value to include "lp__" parameter in rstan, and "lp__", "treedepth__" and "stepsize__" in stan running without rstan. Defaults to FALSE.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>D A data frame tibble with the data arranged and ready to be used by the rest of the <code>ggmcmc</code> functions. The data frame has four columns, namely: Iteration, Chain, Parameter and value, and six attributes: nChains, nParameters, nIterations, nBurnin, nThin and description. A data frame tibble is a wrapper to a local data frame, behaves like a data frame and its advantage is related to printing, which is compact. For more details, see <code>as_tibble()</code> in package <code>dplyr</code>.
</p>


<h3>References</h3>

<p>Fernández-i-Marín, Xavier (2016) ggmcmc: Analysis of MCMC Samples and Bayesian Inference. Journal of Statistical Software, 70(9), 1-20. doi:10.18637/jss.v070.i09
</p>
<p>Gelman, Carlin, Stern, Dunson, Vehtari and Rubin (2014) Bayesian Data Analysis. 3rd edition. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Assign 'S' to be a data frame suitable for \code{ggmcmc} functions from
# a coda object called s
data(linear)
S &lt;- ggs(s)        # s is a coda object

# Get samples from 'beta' parameters only
S &lt;- ggs(s, family = "beta")
</code></pre>


</div>