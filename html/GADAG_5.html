<div class="container">

<table style="width: 100%;"><tr>
<td>GADAG_Run</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run GADAG</h2>

<h3>Description</h3>

<p>Function to run GADAG, an algorithm that aims at inferring large sparse directed acyclic graphs
based on an observation sample X, by minimizing the penalized negative log-likelihood with a convex program embedded in a genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GADAG_Run(X, lambda, threshold = 0.1, GADAG.control = list(n.gen = 100,
  tol.Shannon = 1e-06, max.eval = 10000, pop.size = 10, p.xo = 0.25, p.mut =
  0.05), grad.control = list(tol.obj.inner = 1e-06, max.ite.inner = 50),
  ncores = 1, print.level = 0, return.level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Design matrix, with samples (n) in rows and variables (p) in columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Parameter of penalization (&gt;0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>Thresholding value for the estimated edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GADAG.control</code></td>
<td>
<p>A list containing parameters for controlling GADAG (termination conditions and inherent parameters of the Genetic Algortihm).
Some parameters (n.gen, max.eval and pop.size) are particularly critical for reducing the computational time.
</p>

<ul>
<li>
<p><code>n.gen</code> maximal number of population generations (&gt;0),
</p>
</li>
<li>
<p><code>pop.size</code> initial population size for the genetic algorithm (&gt;0),
</p>
</li>
<li>
<p><code>max.eval</code> overall maximal number of calls of the evaluation function (&gt;0, should be of the order of <code>n.gen</code>*<code>pop.size</code>),
</p>
</li>
<li>
<p><code>tol.Shannon</code> threshold for the Shannon entropy (&gt;0),
</p>
</li>
<li>
<p><code>p.xo</code> crossover probability of the genetic algorithm (between 0 and 1),
</p>
</li>
<li>
<p><code>p.mut</code> mutation probability of the genetic algorithm (between 0 and 1).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad.control</code></td>
<td>
<p>A list containing the parameters for controlling the inner optimization, i.e. the gradient descent.
</p>

<ul>
<li>
<p><code>tol.obj.inner</code> tolerance (&gt;0),
</p>
</li>
<li>
<p><code>max.ite.inner</code> maximum number of iterations (&gt;0).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of cores (&gt;0, depending on your computer).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>0 no print, 1 some info on the genetic algorithm behaviour are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.level</code></td>
<td>
<p>0 only best solution is returned, 1 evolution of the current best solution and statistics on the population fitness values are also returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function returns as a primary output <code>G.best</code>, the adjacency matrix of the inferred graph. This matrix is computed thanks
to its decomposition (<code>P.best</code>, <code>T.best</code>).
</p>
<p>The values of the inputs <code>n.gen</code>, <code>max.eval</code> and <code>pop.size</code> largely influence the algorithm inference capability,
but also its computational cost. As a rule-of-thumb, we recommend setting <code>pop.size</code> between 1 to 10 times the number of nodes,
and <code>n.gen</code> between 10 to 100 times <code>pop.size</code>. <code>tol.Shannon</code> may be decreased in case of premature stop. The other
parameters should only be modified with care.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li>
<p><code>f.best</code> Best fitness value.
</p>
</li>
<li>
<p><code>P.best</code> Best node order (vector of length p).
</p>
</li>
<li>
<p><code>T.best</code> Corresponding best edges values (vector of length p).
</p>
</li>
<li>
<p><code>G.best</code> Best graph (matrix form).
</p>
</li>
<li>
<p><code>f.best.evol</code> Evolution of the best fitness value across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>P.best.evol</code> Evolution of the best node order across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>T.best.evol</code> Evolution of the best edges values across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>fmin.evol</code> Evolution of the minimal fitness value of the population across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>fmean.evol</code> Evolution of the averaged fitness value of the population across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>fp10.evol</code> Evolution of the quantiles of the fitness value across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>fp90.evol</code> Evolution of the quantiles of the fitness value across the iterations (if return.level=1).
</p>
</li>
<li>
<p><code>Shannon.evol</code> Evolution of the Shannon entropy of the population across the iterations (if return.level=1).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Magali Champion, Victor Picheny and Matthieu Vignes
</p>


<h3>See Also</h3>

<p><code>GADAG</code>, <code>GADAG_Run</code>, <code>GADAG_Analyze</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"> #############################################################
 # Loading toy data
 #############################################################
 data(toy_data)
 # toy_data is a list of two matrices corresponding to a "star"
 # DAG (node 1 activates all other nodes):
 # - toy_data$X is a 100x10 design matrix
 # - toy_data$G is the 10x10 adjacency matrix (ground trough)

 #############################################################
 # Running GADAG
 #############################################################
 # Simple run, with only the penalty term specified
 GADAG_results &lt;- GADAG_Run(X=toy_data$X, lambda=0.1)
 print(GADAG_results$G.best) # optimal adjacency matrix graph

 # Expensive run with many evaluations if we refine the
 # termination conditions
 ## Not run: 
 n.gen &lt;- 1e10 # we allow a very large number of iterations
 tol.Shannon &lt;- 1e-10 # the entropy of Shannon of the population
                      # has to be very small
 pop.size &lt;- 5*ncol(toy_data$G) # this is usually a good
                                # population size
 max.eval &lt;- n.gen * pop.size # maximal number of nested
                              # evaluation
 GADAG_results &lt;- GADAG_Run(X=toy_data$X, lambda=0.1,
      GADAG.control=list(n.gen=n.gen, tol.Shannon=tol.Shannon,
                         pop.size = pop.size, max.eval=max.eval))
 print(GADAG_results$G.best) # optimal adjacency matrix graph
 
## End(Not run)

 # Expensive run if we also increase the population size
 ## Not run: 
 pop.size &lt;- 10*ncol(toy_data$G)
 GADAG_results &lt;- GADAG_Run(X=toy_data$X, lambda=0.1,
      GADAG.control=list(pop.size=pop.size))
 print(GADAG_results$G.best) # optimal adjacency matrix graph
 
## End(Not run)

 # You can have more information about the evolution of the
 # algorithm by turning return.level on
 ## Not run: 
 return.level &lt;- 1
 GADAG_results &lt;- GADAG_Run(X=toy_data$X, lambda=0.1, return.level = return.level)
 print(GADAG_results$f.best.evol) # this shows the evolution of the fitness
                                  # across the iterations
 
## End(Not run)
</code></pre>


</div>