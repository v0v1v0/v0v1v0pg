<div class="container">

<table style="width: 100%;"><tr>
<td>GrammaticalExhaustiveSearch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Exhaustive Search</h2>

<h3>Description</h3>

 
<p>Exhaustive Search within context-free grammar.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
GrammaticalExhaustiveSearch(grammar, evalFunc,
                max.depth = GrammarGetDepth(grammar),
                startSymb = GrammarStartSymbol(grammar),
                max.len = GrammarMaxSequenceLen(grammar, max.depth, startSymb),
                wrappings = 3,
                terminationCost = NA,
                monitorFunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>grammar</code></td>
<td>

<p>A <code>grammar</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalFunc</code></td>
<td>

<p>The evaluation function, taking an expression as its input
and returning the cost (i.e., the score) of the expression.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.depth</code></td>
<td>

<p>Maximum depth of recursion, in case of a cyclic grammar. 
By default it is limited to the number of production rules in the grammar.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.len</code></td>
<td>

<p>Maximum length of the sequences to search. 
By default it is determined by <code>max.depth</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrappings</code></td>
<td>

<p>The number of times the function is allowed to wrap around <code>inputString</code>
if non-terminal symbols are still remaining.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminationCost</code></td>
<td>

<p>Target cost. If an expression with this cost or less is found,
the algorithm terminates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitorFunc</code></td>
<td>

<p>A function that is called at each iteration. It can be used to monitor the search.
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p><code>GrammaticalExhaustiveSearch</code> performs an exhaustive search,
iterating through all possible expressions that can be generated by the <code>grammar</code>,
to find the expression that minimises <code>evalFunc</code>.
</p>
<p>The search terminates when all possible expressions are exhausted,
or when an expression with a cost less than <code>terminationCost</code> is discovered.
</p>
<p>If a <code>monitorFunc</code> is given, it is called for each expression, and it receives a 
list similar to the <code>GrammaticalExhaustiveSearch</code>'s return value with the information
availabe for that expression.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bestExpression</code></td>
<td>
<p>The Best expresssion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestSequence</code></td>
<td>
<p>Best expresssion's generating sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestCost</code></td>
<td>
<p>Best expresssion's cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numExpr</code></td>
<td>
<p>Number of evaluated expressions.</p>
</td>
</tr>
</table>
<p>In addition, the <code>monitorFunc</code> receives the following additional slots: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>currentExpression</code></td>
<td>
<p>The current expresssion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>currentSequence</code></td>
<td>
<p>Current expresssion's generating sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>currentCost</code></td>
<td>
<p>Current expresssion's cost.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>GrammarGetNextSequence</code>,
<code>GrammaticalEvolution</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("gramEvol")

ruleDef &lt;- list(expr = gsrule("&lt;var&gt;&lt;op&gt;&lt;var&gt;"),
                op   = gsrule("+", "-", "*"),
                var  = gsrule("A", "B"))

# Create a grammar object
grammarDef &lt;- CreateGrammar(ruleDef)         


# use exhaustive search to find the sequence for creating "B - A"
evalFunc &lt;- function(expr) {
  if (as.character(expr) == "B - A") {
    return(0) # Minimum error
  } else {
    return(1) # maximum error
  }
}

res &lt;- GrammaticalExhaustiveSearch(grammarDef, evalFunc, terminationCost = 0)

print(res)

</code></pre>


</div>