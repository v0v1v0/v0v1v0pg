<div class="container">

<table style="width: 100%;"><tr>
<td>sgplm1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized partial linear model</h2>

<h3>Description</h3>

<p>Fits a generalized partial linear model (based on smoothing spline)
using the (generalized) Speckman estimator or backfitting (in the
generalized case combined with local scoring) for two additive
component functions.
In contrast to <code>kgplm</code>, this function can be used
only for a 1-dimensional nonparametric function. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">sgplm1(x, t, y, spar, df=4, family, link,
       b.start=NULL, m.start=NULL, grid = NULL, offset = 0, 
       method = "speckman", weights = 1, weights.trim = 1, 
       weights.conv = 1, max.iter = 25, eps.conv = 1e-8,
       verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>n x p matrix, data for linear part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>n x 1 vector, responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>n x 1 matrix, data for nonparametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spar</code></td>
<td>
<p>scalar smoothing parameter, as in <code>smooth.spline</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>scalar equivalent number of degrees of freedom (trace of
the smoother matrix), as in <code>smooth.spline</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>text string, family of distributions (e.g.
"gaussian" or "bernoulli", see details for <code>glm.ll</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>text string, link function (depending on family,
see details for <code>glm.ll</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.start</code></td>
<td>
<p>p x 1 vector, start values for linear part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.start</code></td>
<td>
<p>n x 1 vector, start values for nonparametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>m x q matrix, where to calculate the nonparametric function (default = t)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>offset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>"speckman" or "backfit"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>binomial weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.trim</code></td>
<td>
<p>trimming weights for fitting the linear part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.conv</code></td>
<td>
<p>weights for convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximal number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.conv</code></td>
<td>
<p>convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print additional convergence information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters to be passed to <code>smooth.spline</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>p x 1 vector, linear coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.cov</code></td>
<td>
<p>p x p matrix, linear coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>n x 1 vector, nonparametric function estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.grid</code></td>
<td>
<p>m x 1 vector, nonparametric function estimate on grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>it</code></td>
<td>
<p>number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>approximate degrees of freedom (residuals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>
<p>Akaike's information criterion</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function is mainly implemented for comparison. It is not
really optimized for performance, however since it is spline-based, it
should be sufficiently fast. Nevertheless, there might be several
possibilities to improve for speed, in particular I guess that the
sorting that <code>smooth.spline</code> performs in every iteration
is slowing down the procedure quite a bit.
</p>


<h3>Author(s)</h3>

<p>Marlene Mueller</p>


<h3>References</h3>

<p>Mueller, M. (2001)
Estimation and testing in generalized partial linear models – A
comparative study. <em>Statistics and Computing,</em> 11:299–309.
</p>
<p>Hastie, T. and Tibshirani, R. (1990)
<em>Generalized Additive Models.</em> London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code>kgplm</code></p>


<h3>Examples</h3>

<pre><code class="language-R">  ## generate data
  n &lt;- 1000; b &lt;- c(1,-1); rho &lt;- 0.7
  mm &lt;- function(t){ 1.5*sin(pi*t) }
  x1 &lt;- runif(n,min=-1,max=1); u  &lt;- runif(n,min=-1,max=1)
  t  &lt;- runif(n,min=-1,max=1); x2 &lt;- round(mm(rho*t + (1-rho)*u))
  x  &lt;- cbind(x1,x2)
  y  &lt;- x %*% b + mm(t) + rnorm(n)

  ## fit partial linear model (PLM)
  k.plm &lt;- kgplm(x,t,y,h=0.35,family="gaussian",link="identity")
  s.plm &lt;- sgplm1(x,t,y,spar=0.95,family="gaussian",link="identity")

  o &lt;- order(t)
  ylim &lt;- range(c(mm(t[o]),k.plm$m,s.plm$m),na.rm=TRUE)
  plot(t[o],mm(t[o]),type="l",ylim=ylim)
  lines(t[o],k.plm$m[o], col="green")
  lines(t[o],s.plm$m[o], col="blue")
  rug(t); title("Kernel PLM vs. Spline PLM")

  ## fit partial linear probit model (GPLM)
  y &lt;- (y&gt;0)
  k.gplm &lt;- kgplm(x,t,y,h=0.35,family="bernoulli",link="probit")
  s.gplm &lt;- sgplm1(x,t,y,spar=0.95,family="bernoulli",link="probit")

  o &lt;- order(t)
  ylim &lt;- range(c(mm(t[o]),k.gplm$m,s.gplm$m),na.rm=TRUE)
  plot(t[o],mm(t[o]),type="l",ylim=ylim)
  lines(t[o],k.gplm$m[o], col="green")
  lines(t[o],s.gplm$m[o], col="blue")
  rug(t); title("Kernel GPLM vs. Spline GPLM (Probit)")
</code></pre>


</div>