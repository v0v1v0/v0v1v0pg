<div class="container">

<table style="width: 100%;"><tr>
<td>extended_mean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extended mean</h2>

<h3>Description</h3>

<p>Calculate a generalized logarithmic mean / extended mean.
</p>


<h3>Usage</h3>

<pre><code class="language-R">extended_mean(r, s)

generalized_logmean(r)

logmean(a, b, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r, s</code></td>
<td>
<p>A finite number giving the order of the generalized logarithmic
mean / extended mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a, b</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance used to determine if <code>a == b</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>extended_mean()</code> returns a function to compute the
component-wise extended mean of <code>a</code> and <code>b</code> of orders <code>r</code> and
<code>s</code>. See Bullen (2003, p. 393) for a definition. This is also called
the difference mean, Stolarsky mean, or extended mean-value mean.
</p>
<p>The function <code>generalized_logmean()</code> returns a function to compute the
component-wise generalized logarithmic mean of <code>a</code> and <code>b</code> of
order <code>r</code>. See Bullen (2003, p. 385) for a definition, or
<a href="https://en.wikipedia.org/wiki/Stolarsky_mean">https://en.wikipedia.org/wiki/Stolarsky_mean</a>. The generalized
logarithmic mean is a special case of the extended mean, corresponding to
<code>extended_mean(r, 1)()</code>, but is more commonly used for price indexes.
</p>
<p>The function <code>logmean()</code> returns the ordinary component-wise
logarithmic mean of <code>a</code> and <code>b</code>, and corresponds to
<code>generalized_logmean(1)()</code>.
</p>
<p>Both <code>a</code> and <code>b</code> should be strictly positive. This is not
enforced, but the results may not make sense when the generalized
logarithmic mean / extended mean is not defined. The usual recycling rules
apply when <code>a</code> and <code>b</code> are not the same length.
</p>
<p>By definition, the generalized logarithmic mean / extended mean of <code>a</code>
and <code>b</code> is <code>a</code> when <code>a == b</code>. The <code>tol</code> argument is used
to test equality by checking if <code>abs(a - b) &lt;= tol</code>. The default value
is the same as <code>all.equal()</code>. Setting <code>tol = 0</code>
tests for exact equality, but can give misleading results when <code>a</code> and
<code>b</code> are computed values. In some cases it's useful to multiply
<code>tol</code> by a scale factor, such as <code>max(abs(a), abs(b))</code>. This often
doesn't matter when making price indexes, however, as <code>a</code> and <code>b</code>
are usually around 1.
</p>


<h3>Value</h3>

<p><code>generalized_logmean()</code> and <code>extended_mean()</code> return a
function:
</p>
<pre>function(a, b, tol = .Machine$double.eps^0.5){...}</pre>
<p>This computes the component-wise generalized logarithmic mean of order
<code>r</code>, or the extended mean of orders <code>r</code> and <code>s</code>, of <code>a</code> and <code>b</code>.
</p>
<p><code>logmean()</code> returns a numeric vector, the same length as
<code>max(length(a), length(b))</code>, giving the component-wise logarithmic mean
of <code>a</code> and <code>b</code>.
</p>


<h3>Note</h3>

<p><code>generalized_logmean()</code> can be defined on the extended real line,
so that <code>r = -Inf / Inf</code> returns <code>pmin()</code>/<code>pmax()</code>, to agree with the
definition in, e.g., Bullen (2003). This is not implemented, and <code>r</code>
must be finite as in the original formulation by Stolarsky (1975).
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Bullen, P. S. (2003). <em>Handbook of Means and Their Inequalities</em>.
Springer Science+Business Media.
</p>
<p>Stolarsky, K. B. (1975). Generalizations of the Logarithmic Mean.
<em>Mathematics Magazine</em>, 48(2): 87-92.
</p>


<h3>See Also</h3>

<p><code>transmute_weights()</code> uses the extended mean to turn a generalized
mean of order <code class="reqn">r</code> into a generalized mean of order <code class="reqn">s</code>.
</p>
<p>Other means: 
<code>generalized_mean()</code>,
<code>lehmer_mean()</code>,
<code>nested_mean()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 8:5
y &lt;- 1:4

#---- Comparing logarithmic means and generalized means ----

# The arithmetic and geometric means are special cases of the
# generalized logarithmic mean

all.equal(generalized_logmean(2)(x, y), (x + y) / 2)
all.equal(generalized_logmean(-1)(x, y), sqrt(x * y))

# The logarithmic mean lies between the arithmetic and geometric means
# because the generalized logarithmic mean is increasing in r

all(logmean(x, y) &lt; (x + y) / 2) &amp;
  all(logmean(x, y) &gt; sqrt(x * y))

# The harmonic mean cannot be expressed as a logarithmic mean, but can
# be expressed as an extended mean

all.equal(extended_mean(-2, -1)(x, y), 2 / (1 / x + 1 / y))

# The quadratic mean is also a type of extended mean

all.equal(extended_mean(2, 4)(x, y), sqrt(x^2 / 2 + y^2 / 2))

# As are heronian and centroidal means

all.equal(
  extended_mean(0.5, 1.5)(x, y),
  (x + sqrt(x * y) + y) / 3
)
all.equal(
  extended_mean(2, 3)(x, y),
  2 / 3 * (x^2 + x * y + y^2) / (x + y)
)

#---- Approximating the logarithmic mean ----

# The logarithmic mean can be approximated as a convex combination of
# the arithmetic and geometric means that gives more weight to the
# geometric mean

approx1 &lt;- 1 / 3 * (x + y) / 2 + 2 / 3 * sqrt(x * y)
approx2 &lt;- ((x + y) / 2)^(1 / 3) * (sqrt(x * y))^(2 / 3)

approx1 - logmean(x, y) # always a positive approximation error
approx2 - logmean(x, y) # a negative approximation error

# A better approximation

correction &lt;- (log(x / y) / pi)^4 / 32
approx1 / (1 + correction) - logmean(x, y)

#---- Some identities ----

# A useful identity for turning an additive change into a proportionate
# change

all.equal(logmean(x, y) * log(x / y), x - y)

# Works for other orders, too

r &lt;- 2

all.equal(
  generalized_logmean(r)(x, y)^(r - 1) * (r * (x - y)),
  (x^r - y^r)
)

# Some other identities

all.equal(
  generalized_logmean(-2)(1, 2),
  (harmonic_mean(1:2) * geometric_mean(1:2)^2)^(1 / 3)
)

all.equal(
  generalized_logmean(0.5)(1, 2),
  (arithmetic_mean(1:2) + geometric_mean(1:2)) / 2
)

all.equal(
  logmean(1, 2),
  geometric_mean(1:2)^2 * logmean(1, 1 / 2)
)

#---- Integral representations of the logarithmic mean ----

logmean(2, 3)

integrate(function(t) 2^(1 - t) * 3^t, 0, 1)$value
1 / integrate(function(t) 1 / (2 * (1 - t) + 3 * t), 0, 1)$value

</code></pre>


</div>