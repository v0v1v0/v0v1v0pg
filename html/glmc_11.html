<div class="container">

<table style="width: 100%;"><tr>
<td>glmc.control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auxiliary for Controlling GLM Fitting with population level constraints.</h2>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code>glmc</code> fitting.
Typically only used when calling <code>glmc</code>.</p>


<h3>Usage</h3>

<pre><code class="language-R">glmc.control(epsilon.glm = 1e-8, maxit.glm= 100, trace.glm= FALSE, 
             trace.optim= 0, fnscale.optim=-1, parscale.optim = rep.int(1,1), 
             ndeps.optim = rep.int(0.001,1), maxit.optim = 100, 
             abstol.optim = -Inf, reltol.optim= sqrt(.Machine$double.eps), 
             alpha.optim = 1, beta.optim = 0.5, gamma.optim = 2, 
             REPORT.optim= 10, type.optim = 1, lmm.optim = 5, 
             factr.optim= 1e+07, pgtol.optim = 0, tmax.optim = 10, 
             temp.optim =10, maxit.weights = 25, gradtol.weights = 1e-07, 
             svdtol.weights = 1e-09, itertrace.weights = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>epsilon.glm</code></td>
<td>
<p>positive convergence tolerance <code class="reqn">epsilon</code>; the iterations converge when <code class="reqn">|dev - devold|/(|dev| + 0.1) &lt; epsilon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.glm</code></td>
<td>
<p>integer giving the maximal number of IWLS iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.glm</code></td>
<td>
<p>logical indicating if output should be produced for each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.optim</code></td>
<td>
<p>Non-negative integer. If positive, tracing information on the progress of the optimization is produced. Higher values may produce more tracing information: for method “L-BFGS-B” there are six levels of tracing. (To understand exactly what these do see the source code: higher levels give more detail.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fnscale.optim</code></td>
<td>
<p>A negative number determining the overall scaling to be applied to the value of fn and gr during optimization.  In <code>glmc</code> optimization is performed on <code class="reqn">fn(par)/(fnscale.optim)</code> if fnscale.optim is negative and on <code class="reqn">fn(par)/((-1)*fnscale.optim)</code> if fnscale.optim is positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parscale.optim</code></td>
<td>
<p>A vector of scaling values for the parameters. Optimization is performed on par/parscale and these should be comparable in the sense that a unit change in any element produces about a unit change in the scaled value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndeps.optim</code></td>
<td>
<p>A vector of step sizes for the finite-difference approximation to the gradient, on par/parscale scale. Defaults to 1e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.optim</code></td>
<td>
<p>The maximum number of iterations. Defaults to 100 for the derivative-based methods, and 500 for “Nelder-Mead”. For “SANN” maxit gives the total number of function evaluations. There is no other stopping criterion. Defaults to 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol.optim</code></td>
<td>
<p>The absolute convergence tolerance. Only useful for non-negative functions, as a tolerance for reaching zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol.optim</code></td>
<td>
<p>Relative convergence tolerance. The algorithm stops if it is unable to reduce the value by a factor of reltol * (abs(val) + reltol) at a step. Defaults to sqrt(.Machine\$double.eps), typically about 1e-8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.optim, beta.optim, gamma.optim</code></td>
<td>
<p>Scaling parameters for the “Nelder-Mead” method. alpha is the reflection factor (default 1.0), beta the contraction factor (0.5) and gamma the expansion factor (2.0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>REPORT.optim</code></td>
<td>
<p>The frequency of reports for the “BFGS” and “L-BFGS-B” methods if control\$trace is positive. Defaults to every 10 iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.optim</code></td>
<td>
<p>for the conjugate-gradients method. Takes value 1 for the Fletcher–Reeves update, 2 for Polak–Ribiere and 3 for Beale–Sorenson.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lmm.optim</code></td>
<td>
<p>is an integer giving the number of BFGS updates retained in the “L-BFGS-B” method, It defaults to 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factr.optim</code></td>
<td>
<p>controls the convergence of the “L-BFGS-B” method. Convergence occurs when the reduction in the objective is within this factor of the machine tolerance. Default is 1e7, that is a tolerance of about 1e-8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pgtol.optim</code></td>
<td>
<p>helps controls the convergence of the “L-BFGS-B” method. It is a tolerance on the projected gradient in the current search direction. This defaults to zero, when the check is suppressed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp.optim</code></td>
<td>
<p>controls the “SANN” method. It is the starting temperature for the cooling schedule. Defaults to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmax.optim</code></td>
<td>
<p>is the number of function evaluations at each temperature for the “SANN” method. Defaults to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit.weights</code></td>
<td>
<p>an optional integer to control iteration when solve constrained maximisation for the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradtol.weights</code></td>
<td>
<p>an optional real value for convergence test while calculating the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>svdtol.weights</code></td>
<td>
<p>an optional real value to detect singularity while solve equations. This is used to compute the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itertrace.weights</code></td>
<td>
<p>a logical value. If the iteration history when calculating the weights needs to be printed out.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with components 
</p>


</div>