<div class="container">

<table style="width: 100%;"><tr>
<td>forecast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Forecasting GLARMA time series
</h2>

<h3>Description</h3>

<p><code>forecast</code> is a generic function for forecasting time series or
time series models. The function invokes particular <em>methods</em> which
depend on the class of the first argument.
</p>
<p>Currently the only method provided by the package is for objects of
class <code>"glarma"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
forecast(object, ...)
## S3 method for class 'glarma'
forecast(object, n.ahead = 1, newdata = 0,
         newoffset = 0, newm = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class "glarma" obtained from a call to
<code>glarma</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ahead</code></td>
<td>
<p>The number of periods ahead to be forecast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>The model matrix <code class="reqn">X</code> comprising the values of the
predictors for the times for which the series is to be predicted.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newoffset</code></td>
<td>
<p>A vector containing the values of the offset for the
times for which the series is to be predicted.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newm</code></td>
<td>
<p>A vector containing the number of trials when forecasting
binomial or binary time series. Defaults to the binary case. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments for the call, currently unused.  </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Only one forecasting method is currently provided, for objects of
class "glarma". This produces an object of class "glarmaForecast".
</p>
<p>When forecasting one step ahead, the values in the matrix
<code>newdata</code> (and <code>offset</code> if there is an offset) in the GLARMA
model are used along with the regression coefficients in the model to
obtain the predicted value of <code class="reqn">\eta</code>, the regression
component of the state variable <code class="reqn">W</code>. The predicted value of the
ARMA component of the state variable is then added to this value to
give the predicted value of <code class="reqn">W</code>.
</p>
<p>When further predictions are required, since no data is available to
calculate the predicted value of the state variable, an observation is
generated from the predicted distribution and the methodology for one
step ahead is then used on this generated data. This process is
repeated until predictions are obtained for the required number of
time periods (specified by <code>n.ahead</code>). Note that the value of
<code>n.ahead</code> must equal the row dimension of <code>newdata</code> and if
they are specified, of <code>newoffset</code> and <code>newm</code>.
</p>
<p>For completeness a randomly generated value of the time series is
produced even for one step-ahead prediction.
</p>
<p>Note that the forecasted time series returned as the component
<code>fitted</code> is then a randomly generated sample path for the
predicted time series. If a sample of such paths is produced by
repeated calls to <code>forecast</code> then sample predicted distributions
can be obtained for the forecast series.
</p>
<p>In the case of binary or binomial time series in addition to values of
the predictors in the regression component of the state variable and
the values of any offset, the numbers of trials for the binomially
distributed future observations are required. This information should
be provided in the argument <code>newm</code>. If not, the number of trials
defaults to 1, which is the case of binary responses.
</p>


<h3>Value</h3>

<p><code>forecast</code> currently has no default method.
</p>
<p>When <code>object</code> is of class <code>"glarma"</code>, <code>forecast</code>
returns an object of class <code>"glarmaForecast"</code> with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>the forecast values of the regression component of the
state variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>the forecast values of the state variable <code class="reqn">W</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>the conditional mean <code class="reqn">\mu_t</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>the simulated series based on the fitted model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ahead</code></td>
<td>
<p>the number of steps ahead for which the forecasts were
requested in the call to <code>forecast</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>the model matrix <code class="reqn">X</code> comprising the values of the
predictors for the times for which the series is to be predicted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newoffset</code></td>
<td>
<p>the vector containing the values of the offset for
the times for which the series is to be predicted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newm</code></td>
<td>
<p>the vector giving the number of trials when forecasting
binomial or binary time series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the <code>"glarma"</code> object from the call to
<code>forecast</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>"William T.M. Dunsmuir" &lt;w.dunsmuir@unsw.edu.au&gt; and
"David J Scott" &lt;d.scott@auckland.ac.nz&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(zoo)
### Model number of deaths
data(DriverDeaths)
y &lt;- DriverDeaths[, "Deaths"]
X &lt;- as.matrix(DriverDeaths[, 2:5])
Population &lt;- DriverDeaths[, "Population"]

### Offset included
glarmamod &lt;- glarma(y, X, offset = log(Population/100000),
                    phiLags = c(12),
                    thetaLags = c(1),
                    type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
print(summary(glarmamod))

XT1 &lt;- matrix(X[72,], nrow = 1)
offsetT1 &lt;- log(Population/100000)[72]

mu &lt;- forecast(glarmamod, 1, XT1, offsetT1)$mu
print(mu)


### Save some values
allX &lt;- X
allFits &lt;- fitted(glarmamod)
ally &lt;- y

### Look at a succession of forecasts
### Using actual values in forecasts
forecasts &lt;- numeric(72)
for (i in (62:71)){
    y &lt;- DriverDeaths[1:i, "Deaths"]
    X &lt;- as.matrix(DriverDeaths[1:i, 2:5])
    Population &lt;- DriverDeaths[1:i, "Population"]

    ## Offset included
    glarmamod &lt;- glarma(y, X, offset = log(Population/100000),
                        phiLags = c(12),
                        thetaLags = c(1),
                        type = "Poi", method = "FS",
                        residuals = "Pearson", maxit = 100, grad = 1e-6)
    XT1 &lt;- matrix(allX[i + 1, ], nrow = 1)
    offsetT1 &lt;- log(DriverDeaths$Population[i + 1]/100000)
    mu &lt;- forecast(glarmamod, 1, XT1, offsetT1)$mu
    if (i == 62){
        forecasts[1:62] &lt;- fitted(glarmamod)
    }
    forecasts[i+1] &lt;- mu
}
par(mfrow = c(1,1))
forecasts &lt;- ts(forecasts[63:72], start = c(1985, 10), deltat = 1/12)
fitted &lt;- ts(allFits, start = c(1980, 8), deltat = 1/12)
obs &lt;- ts(DriverDeaths$Deaths, start = c(1980, 8), deltat = 1/12)
plot(obs, ylab = "Driver Deaths", lty = 2,
     main = "Single Vehicle Nighttime Driver Deaths in Utah")
points(obs)
lines(fitted, lwd = 2)
lines(forecasts, col = "red")
par(xpd = NA)
graph.param &lt;-
    legend("top",
           legend = c("observations",expression(estimated~mu[t]),
                      expression(predicted~mu[t])),
           ncol = 3,
           cex = 0.7,
           bty = "n", plot = FALSE)
legend(graph.param$rect$left,
       graph.param$rect$top + graph.param$rect$h,
       legend = c("observations", expression(estimated~mu[t]),
                  expression(predicted~mu[t])),
       col = c("black","black","red"),
       lwd = c(1,2,1), lty = c(2,1,1),
       pch = c(1, NA_integer_, NA_integer_),
       ncol = 3,
       cex = 0.7,
       bty = "n",
       text.font = 4)
par(xpd = FALSE)

### Generate a sample of Y values 2 steps ahead and examine the distribution
data(DriverDeaths)
y &lt;- DriverDeaths[, "Deaths"]
X &lt;- as.matrix(DriverDeaths[, 2:5])
Population &lt;- DriverDeaths[, "Population"]

### Fit the glarma model to the first 70 observations
glarmamod &lt;- glarma(y[1:70], X[1:70, ],
                    offset = log(Population/100000)[1:70],
                    phiLags = c(12),
                    thetaLags = c(1),
                    type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)

nObs &lt;- NROW(X)
n.ahead &lt;- 2
### Specify the X matrix and offset for the times where predictions
### are required
XT1 &lt;- as.matrix(X[(nObs - n.ahead + 1):nObs, ])
offsetT1 &lt;- log(Population/100000)[(nObs - n.ahead + 1):nObs]
nSims &lt;- 500
forecastY &lt;- matrix(ncol = n.ahead, nrow = nSims)
forecastMu &lt;- matrix(ncol = n.ahead, nrow = nSims)

### Generate sample predicted values
for(i in 1:nSims){
    temp &lt;-  forecast(glarmamod, n.ahead, XT1, offsetT1)
    forecastY[i, ] &lt;- temp$Y
    forecastMu[i, ] &lt;- temp$mu
}
### Examine distribution of sample of Y values n.ahead
table(forecastY[, 2])
par(mfrow = c(2,1))
barplot(table(forecastY[, 2]),
        main = "Barplot of Sample Y Values 2 Steps Ahead")
hist(forecastY[, 2], xlab = "Sample Y values",
     breaks=seq(0,max(forecastY[, 2])),
     main = "Histogram of Sample Y Values 2 Steps Ahead\nwith 0.025 and 0.975 Quantiles")
abline(v = quantile(forecastY[, 2], c(0.025, 0.975)), col = "red")

</code></pre>


</div>