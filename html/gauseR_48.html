<div class="container">

<table style="width: 100%;"><tr>
<td>lv_optim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Optimizer for Lotka-Volterra Interactions</h2>

<h3>Description</h3>

<p>Identifies optimal parameter values for a Lotka-Volterra interaction system.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lv_optim(
  pars,
  opt_data,
  parm_signs,
  standardize = TRUE,
  odefun = lv_interaction_log
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>A vector of parameter values in log space to be optimized.
Must include a logged starting abundance for each species, followed by the logged absolute values of the growth rates,
followed by the logged absolute value of the elements of the interaction matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_data</code></td>
<td>
<p>Abundance data for optimization. Must include one column labeled 'time' with time steps, and a column for each species abundance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm_signs</code></td>
<td>
<p>A vector that provides the desired sign of each parameter (i.e. -1 or 1).
If value is zero, then the term is held at zero (but should be left out of the pars vector).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>A logical, defaulting to TRUE - should error be calculated based on standardized values of
outputs? Allows for more equal weighting of observed variabels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>odefun</code></td>
<td>
<p>The function to use to simulate the ODE - defaults to lv_interaction_log</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>squared error between model fits for given parameter values, and observations
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# load data from competition experiment
data(gause_1934_book_f32)

# keep all data - no separate treatments exist for this experiment
predatorpreydata&lt;-gause_1934_book_f32

# get time-lagged observations for each species
prey_lagged&lt;-get_lag(x = predatorpreydata$Individuals_Prey, time = predatorpreydata$Day)
predator_lagged&lt;-get_lag(x = predatorpreydata$Individuals_Predator, time = predatorpreydata$Day)

# calculate per-capita growth rates
prey_dNNdt&lt;-percap_growth(x = prey_lagged$x, laggedx = prey_lagged$laggedx, dt = prey_lagged$dt)
predator_dNNdt&lt;-percap_growth(x = predator_lagged$x,
      laggedx = predator_lagged$laggedx, dt = predator_lagged$dt)

# fit linear models to dNNdt, based on average
# abundances between current and lagged time steps
prey_mod_dat&lt;-data.frame(prey_dNNdt=prey_dNNdt, prey=prey_lagged$laggedx,
      predator=predator_lagged$laggedx)
mod_prey&lt;-lm(prey_dNNdt~prey+predator, data=prey_mod_dat)

predator_mod_dat&lt;-data.frame(predator_dNNdt=predator_dNNdt,
      predator=predator_lagged$laggedx, prey=prey_lagged$laggedx)
mod_predator&lt;-lm(predator_dNNdt~predator+prey, data=predator_mod_dat)

# model summaries
summary(mod_prey)
summary(mod_predator)

# extract parameters
# growth rates
r1 &lt;- unname(coef(mod_prey)["(Intercept)"])
r2 &lt;- unname(coef(mod_predator)["(Intercept)"])

# self-limitation
a11 &lt;- unname(coef(mod_prey)["prey"])
a22 &lt;- unname(coef(mod_predator)["predator"])

# effect of Pa on Pc
a12 &lt;- unname(coef(mod_prey)["predator"])
# effect of Pc on Pa
a21 &lt;- unname(coef(mod_predator)["prey"])

# run ODE:
# make parameter vector:
parms &lt;- c(r1, r2, a11, a12, a21, a22)
initialN &lt;- c(4, 0.1)
out &lt;- deSolve::ode(y=initialN, times=seq(1, 17, length=100), func=lv_interaction, parms=parms)
matplot(out[,1], out[,-1], type="l",
        xlab="time", ylab="N", col=c("black","red"), lty=c(1,3), lwd=2, ylim=c(0, 60))
legend("topright", c("Pc", "Dn"), col=c(1,2), lwd=2, lty=c(1,3))

# now, plot in points from data
points(predatorpreydata$Day, predatorpreydata$Individuals_Predator , col=2)
points(predatorpreydata$Day, predatorpreydata$Individuals_Prey, col=1)

# uh-oh - This is a bad fit. This suggests that our linear model
# approximation isn't very good. Instead, we should try optimizing
# directly using the ode solver

# Re-run using an optimizer
# Data for the optimizer:
# Must have a column with time steps labeled 'time', and
# columns for each species in the community.
opt_data&lt;-data.frame(time=predatorpreydata$Day, Prey=predatorpreydata$Individuals_Prey,
    Predator=predatorpreydata$Individuals_Predator)

# Save the signs of the parameters -
# optimizer works in log space, so these
# must be specified separately
parm_signs&lt;-sign(parms)

# parameter vector for optimizer -
# must be a vector with, first, the
# starting abundances in log space,
# and second, the parameter values,
# again in log space
pars&lt;-c(log(initialN), log(abs(parms)))

# run optimizer
optout&lt;-optim(par = pars, fn = lv_optim, hessian = TRUE,
             opt_data=opt_data, parm_signs=parm_signs)

# extract parameter vector:
parms &lt;- exp(optout$par[-c(1:2)])*parm_signs
initialN &lt;- exp(optout$par[1:2])

out &lt;- deSolve::ode(y=initialN, times=seq(1, 17, length=100), func=lv_interaction, parms=parms)
matplot(out[,1], out[,-1], type="l",
        xlab="time", ylab="N", col=c("black","red"), lty=c(1,3), lwd=2, ylim=c(0, 60))
legend("topright", c("Pc", "Dn"), col=c(1,2), lwd=2, lty=c(1,3))

# now, plot in points from data
points(predatorpreydata$Day, predatorpreydata$Individuals_Predator , col=2)
points(predatorpreydata$Day, predatorpreydata$Individuals_Prey, col=1)

# get rough estimate of confidence intervals
fisher_info&lt;-solve(-optout$hessian)
optout$par_sd&lt;-sqrt(abs(diag(fisher_info)))

parm_signs_sp&lt;-c(rep(1, ncol(opt_data)-1), parm_signs)
parameter_intervals&lt;-data.frame(lower_sd=exp(optout$par-optout$par_sd)*parm_signs_sp,
                                mu=exp(optout$par)*parm_signs_sp,
                                upper_sd=exp(optout$par+optout$par_sd)*parm_signs_sp)

rownames(parameter_intervals)&lt;-c("prey", "predator", "r1", "r2", "a11", "a12", "a21", "a22")
parameter_intervals
</code></pre>


</div>