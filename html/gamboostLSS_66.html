<div class="container">

<table style="width: 100%;"><tr>
<td>methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Methods for mboostLSS
</h2>

<h3>Description</h3>

<p>Methods for GAMLSS models fitted by boosting algorithms.
</p>


<h3>Usage</h3>

<pre><code class="language-R">### print model
## S3 method for class 'mboostLSS'
print(x, ...)

### summarize model
## S3 method for class 'mboostLSS'
summary(object, ...)

### extract coefficients
## S3 method for class 'glmboostLSS'
coef(object, which = NULL,
     aggregate = c("sum", "cumsum", "none"),
     off2int = FALSE, parameter = names(object), ...)
## S3 method for class 'mboostLSS'
coef(object, which = NULL,
     aggregate = c("sum", "cumsum", "none"),
     parameter = names(object), ...)

### plot partial effects
## S3 method for class 'glmboostLSS'
plot(x, main = names(x), parameter = names(x),
     off2int = FALSE, ...)
## S3 method for class 'gamboostLSS'
plot(x, main = names(x), parameter = names(x), ...)

### extract and plot marginal prediction intervals
predint(x, which, pi = 0.9, newdata = NULL, ...)
PI(x, which, pi = 0.9, newdata = NULL, ...)
## S3 method for class 'predint'
plot(x, main = "Marginal Prediction Interval(s)",
     xlab = NULL, ylab = NULL, lty = c("solid", "dashed"),
     lcol = c("black", "black"), log = "", ...)

### extract mstop
## S3 method for class 'mboostLSS'
mstop(object, parameter = names(object), ...)
## S3 method for class 'oobag'
mstop(object, parameter = names(object), ...)
## S3 method for class 'cvriskLSS'
mstop(object, parameter = NULL, ...)

### set mstop
## S3 method for class 'mboostLSS'
x[i, return = TRUE, ...]

### extract risk
## S3 method for class 'mboostLSS'
risk(object, merge = FALSE, parameter = names(object), ...)

### extract selected base-learners
## S3 method for class 'mboostLSS'
selected(object, merge = FALSE, parameter = names(object), ...)

### extract fitted values
## S3 method for class 'mboostLSS'
fitted(object, parameter = names(object), ...)

### make predictions
## S3 method for class 'mboostLSS'
predict(object, newdata = NULL,
        type = c("link", "response", "class"), which = NULL,
        aggregate = c("sum", "cumsum", "none"),
        parameter = names(object), ...)

### update weights of the fitted model
## S3 method for class 'mboostLSS'
update(object, weights, oobweights = NULL,
       risk = NULL, trace = NULL, mstop = NULL, ...)

### extract model weights
## S3 method for class 'mboostLSS'
model.weights(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p> an object of the appropriate class (see usage). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p> a subset of base-learners to take into account when computing
predictions or coefficients. If <code>which</code> is given
(as an integer vector or characters corresponding
to base-learners), a list or matrix is returned. In <code>plot_PI</code>
the argument <code>which</code> must be specified and it must be given as
a character string containing the name of the variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p> a character specifying how to aggregate predictions
or coefficients of single base-learners. The default
returns the prediction or coefficient for the final number of
boosting iterations. <code>"cumsum"</code> returns a
matrix with the predictions for all iterations
simultaneously (in columns). <code>"none"</code> returns a
list with matrices where the <code class="reqn">j</code>th columns of the
respective matrix contains the predictions
of the base-learner of the <code class="reqn">j</code>th boosting
iteration (and zero if the base-learner is not
selected in this iteration).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p> This can be either a vector of indices or a vector
of parameter names which should be processed. See expamles for
details. Per default all distribution parameters of the GAMLSS family are
returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>off2int</code></td>
<td>
<p> logical indicating whether the offset should be
added to the intercept (if there is any) or if the offset is
neglected for plotting (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p> logical. Should the risk vectors of the single
components be merged to one risk vector for the model in total? Per
default (<code>merge = FALSE</code>) a (named) list of risk vectors is
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p> integer. Index specifying the model to extract. If <code>i</code>
is smaller than the initial <code>mstop</code>, a subset is used.
If <code>i</code> is larger than the initial <code>mstop</code>,
additional boosting steps are performed until step <code>i</code>
is reached. One can specify a scalar, a (possibly named) vector or a
(possibly named) list with separate values  for each component. See
the details section of <code>mboostLSS</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return</code></td>
<td>
<p> a logical indicating whether the changed object is
returned. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p> a title for the plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab</code></td>
<td>
<p> x- and y axis labels for the plots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi</code></td>
<td>
<p> the level(s) of the prediction interval(s); Per default a
90% prediction interval is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p> (vector) of line types to be used for plotting the
prediction intervals. The vector should contain <code>length(pi) +
    1</code> elements. If less elements are specified, the last element is
recycled. The first value <code>lty[1]</code> is used for the marginal
median, the second value <code>lty[2]</code> is used for the <code>pi[1]</code>
prediction interval, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcol</code></td>
<td>
<p> (vector) of (line) colors to be used for plotting the
prediction intervals. The vector should contain <code>length(pi) +
    1</code> elements. If less elements are specified, the last element is
recycled. The first value <code>lcol[1]</code> is used for the marginal
median, the second value <code>lcol[2]</code> is used for the <code>pi[1]</code>
prediction interval, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p> a character string which determines if and if so which
axis should be logarithmic. See <code>plot.default</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p> optional; A data frame in which to look for variables with
which to predict or with which to plot the marginal prediction intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> the type of prediction required.  The default is on the scale
of the predictors; the alternative <code>"response"</code> is on
the scale of the response variable.  Thus for a
binomial model the default predictions are on the log-odds scale
(probabilities on logit scale) and <code>type = "response"</code> gives
the predicted probabilities.  The <code>"class"</code> option returns
predicted classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>a numeric vector of weights for the model
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oobweights</code></td>
<td>

<p>an additional vector of out-of-bag weights (used internally
by <code>cvrisk</code>. For details see there.).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>

<p>a character indicating how the empirical risk should be
computed for each boosting iteration. Per default <code>risk</code> is set
to the risk type specified for model fitting via
<code>boost_control</code>. For details and alternatives see there.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>a logical triggering printout of status information during the
fitting process.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mstop</code></td>
<td>

<p>number of boosting iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Further arguments to the functions.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions can be used to extract details from fitted models. For
a tutorial with worked examples see Hofner et al. (2016).
</p>
<p><code>print</code> shows a dense representation of the model fit.
</p>
<p>The function <code>coef</code> extracts the regression coefficients of
linear predictors fitted using the <code>glmboostLSS</code> function or
additive predictors fitted using <code>gamboostLSS</code>. Per default,
only coefficients of selected base-learners are returned for all
distribution parameters. However, any desired coefficient can be
extracted using the <code>which</code> argument. Furhtermore, one can
extract only coefficients for a single distribution parameter via the
<code>parameter</code> argument (see examples for details).
</p>
<p>Analogical, the function <code>plot</code> per default displays the
coefficient paths for the complete GAMLSS but can be restricted to
single distribution parameters or covariates (or subsets) using the
<code>parameter</code> or <code>which</code> arguments, respectively.
</p>
<p>The function <code>predint</code> (or <code>PI</code> which is just an alias)
computes marginal prediction intervals and returns a data frame with
the predictors used for the marginal prediction interval, the computed
median prediction and the marginal prediction intervals. A plot
function (<code>plot.predint</code>) for the resulting object exists. Note
that marginal predictions from AFT models (i.e., families
<code>LogLogLSS</code>, <code>LogNormalLSS</code>, and
<code>WeibullLSS</code>) represent the predicted “true”
survival time and not the observed survival time which is possible
subject to censoring. Hence, comparing observed survival times with
the marginal prediction interval is only sensible for uncensored
observations.
</p>
<p>The <code>predict</code> function can be used for predictions for the
distribution parameters depending on new observations whereas
<code>fitted</code> extracts the regression fits for the observations in the
learning sample. For <code>predict</code>, <code>newdata</code> can be specified
– otherwise the fitted values are returned. If <code>which</code> is
specified, marginal effects of the corresponding base-learner(s) are
returned. The argument <code>type</code> can be used to make predictions on
the scale of the link (i.e., the linear predictor X * beta), the
<code>response</code> (i.e. h(X * beta), where h is the response function)
or the <code>class</code> (in case of classification).
</p>
<p>The function <code>update</code> updates models fit with <span class="pkg">gamboostLSS</span>
and is primarily used within <code>cvrisk</code>. It
updates the weights and refits the model to the altered data.
Furthermore, the type of <code>risk</code>, the <code>trace</code> and the number
of boosting iterations <code>mstop</code> can be modified.
</p>
<p>The function <code>model.weights</code> is a generic version of the same
function provided by package <span class="pkg">stats</span>, which is required to make
<code>model.weights</code> work with <code>mboostLSS</code> models.
</p>


<h3>Warning</h3>

<p>The <code>[.mboostLSS</code> function changes the original object, i.e.,
<code>LSSmodel[10]</code> changes <code>LSSmodel</code> directly!
</p>


<h3>References</h3>

<p>B. Hofner, A. Mayr, M. Schmid (2016). gamboostLSS: An R Package for
Model Building and Variable Selection in the GAMLSS Framework.
Journal of Statistical Software, 74(1), 1-31.
</p>
<p>Available as <code>vignette("gamboostLSS_Tutorial")</code>.
</p>
<p>Mayr, A., Fenske, N., Hofner, B., Kneib, T. and Schmid, M. (2012):
Generalized additive models for location, scale and shape for
high-dimensional data - a flexible approach based on boosting. Journal
of the Royal Statistical Society, Series C (Applied Statistics) 61(3):
403-427.
</p>
<p>Buehlmann, P. and Hothorn, T. (2007), Boosting algorithms:
regularization, prediction and model fitting. Statistical Science,
22(4), 477–505.
</p>
<p>Rigby, R. A. and D. M. Stasinopoulos (2005). Generalized additive models
for location, scale and shape (with discussion). Journal of the Royal
Statistical Society, Series C (Applied Statistics), 54, 507-554.
</p>


<h3>See Also</h3>

<p><code>glmboostLSS</code>, <code>gamboostLSS</code> and
<code>blackboostLSS</code> for fitting of GAMLSS.
</p>
<p>Available distributions (families) are documented here:
<code>Families</code>.
</p>
<p>See <code>methods</code> in the <code>mboost</code> package for the
corresponding methods for <code>mboost</code> objects.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### generate data
set.seed(1907)
x1 &lt;- rnorm(1000)
x2 &lt;- rnorm(1000)
x3 &lt;- rnorm(1000)
x4 &lt;- rnorm(1000)
x5 &lt;- rnorm(1000)
x6 &lt;- rnorm(1000)
mu    &lt;- exp(1.5 + x1^2 +0.5 * x2 - 3 * sin(x3) -1 * x4)
sigma &lt;- exp(-0.2 * x4 +0.2 * x5 +0.4 * x6)
y &lt;- numeric(1000)
for( i in 1:1000)
    y[i] &lt;- rnbinom(1, size = sigma[i], mu = mu[i])
dat &lt;- data.frame(x1, x2, x3, x4, x5, x6, y)

### fit a model
model &lt;- gamboostLSS(y ~ ., families = NBinomialLSS(), data = dat,
                     control = boost_control(mstop = 100))

### Do not test the following line per default on CRAN as it takes some time to run:
### use a model with more iterations for a better fit
mstop(model) &lt;- 400

### extract coefficients
coef(model)

### only for distribution parameter mu
coef(model, parameter = "mu")

### only for covariate x1
coef(model, which = "x1")


### plot complete model
par(mfrow = c(4, 3))
plot(model)
### plot first parameter only
par(mfrow = c(2, 3))
plot(model, parameter = "mu")
### now plot only effect of x3 of both parameters
par(mfrow = c(1, 2))
plot(model, which = "x3")
### first component second parameter (sigma)
par(mfrow = c(1, 1))
plot(model, which = 1, parameter = 2)

### Do not test the following code per default on CRAN as it takes some time to run:
### plot marginal prediction interval
pi &lt;- predint(model, pi = 0.9, which = "x1")
pi &lt;- predint(model, pi = c(0.8, 0.9), which = "x1")
plot(pi, log = "y")  # warning as some y values are below 0
## here it would be better to plot x1 against
## sqrt(y) and sqrt(pi)

### set model to mstop = 300 (one-dimensional)
mstop(model) &lt;- 300
### END (don't test automatically)


par(mfrow = c(2, 2))
plot(risk(model, parameter = "mu")[[1]])
plot(risk(model, parameter = "sigma")[[1]])

### Do not test the following code per default on CRAN as it takes some time to run:
### get back to orignal fit
mstop(model) &lt;- 400
plot(risk(model, parameter = "mu")[[1]])
plot(risk(model, parameter = "sigma")[[1]])

### use different mstop values for the components
mstop(model) &lt;- c(100, 200)
## same as
  mstop(model) &lt;- c(mu = 100, sigma = 200)
## or
  mstop(model) &lt;- list(mu = 100, sigma = 200)
## or
  mstop(model) &lt;- list(100, 200)

plot(risk(model, parameter = "mu")[[1]])
plot(risk(model, parameter = "sigma")[[1]])
### END (don't test automatically)

</code></pre>


</div>