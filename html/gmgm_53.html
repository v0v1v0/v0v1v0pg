<div class="container">

<table style="width: 100%;"><tr>
<td>struct_em</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Learn the structure and the parameters of a Gaussian mixture graphical model
with incomplete data</h2>

<h3>Description</h3>

<p>This function learns the structure and the parameters of a Gaussian mixture
graphical model with incomplete data using the structural EM algorithm. At
each iteration, the parametric EM algorithm is performed to complete the data
and update the parameters (E step). The completed data are then used to
update the structure (M step), and so on. Each iteration is guaranteed to
increase the scoring function until convergence to a local maximum (Koller
and Friedman, 2009). In practice, due to the sampling process inherent in
particle-based inference, it may happen that the monotonic increase no longer
occurs when approaching the local maximum, resulting in an earlier
termination of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">struct_em(
  gmgm,
  data,
  nodes = structure(gmgm)$nodes,
  arcs_cand = tibble(lag = 0),
  col_seq = NULL,
  score = "bic",
  n_part = 1000,
  max_part_sim = 1e+06,
  min_ess = 1,
  max_iter_sem = 5,
  max_iter_pem = 5,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gmgm</code></td>
<td>
<p>An object of class <code>gmbn</code> (non-temporal) or <code>gmdbn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the data used for learning. Its columns
must explicitly be named after nodes of <code>gmgm</code> and can contain missing
values (columns with no value can be removed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>A character vector containing the nodes whose local conditional
models are learned (by default all the nodes of <code>gmgm</code>). If <code>gmgm</code>
is a <code>gmdbn</code> object, the same nodes are learned for each of its
<code>gmbn</code> elements. This constraint can be overcome by passing a list of
character vectors named after some of these elements (<code>b_1</code>, ...) and
containing learned nodes specific to them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcs_cand</code></td>
<td>
<p>A data frame containing the candidate arcs for addition or
removal (by default all possible non-temporal arcs). The column <code>from</code>
describes the start node, the column <code>to</code> the end node and the column
<code>lag</code> the time lag between them. Missing values in <code>from</code> or
<code>to</code> are interpreted as "all possible nodes", which allows to quickly
define large set of arcs that share common attributes. Missing values in
<code>lag</code> are replaced by 0. If <code>gmgm</code> is a <code>gmdbn</code> object, the
same candidate arcs are used for each of its <code>gmbn</code> elements. This
constraint can be overcome by passing a list of data frames named after some
of these elements (<code>b_1</code>, ...) and containing candidate arcs specific
to them. If arcs already in <code>gmgm</code> are not candidates, they cannot be
removed. Therefore, setting <code>arcs_cand</code> to <code>NULL</code> is equivalent to
learning only the mixture structure (and the parameters) of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_seq</code></td>
<td>
<p>A character vector containing the column names of <code>data</code>
that describe the observation sequence. If <code>NULL</code> (the default), all the
observations belong to a single sequence. If <code>gmgm</code> is a <code>gmdbn</code>
object, the observations of a same sequence must be ordered such that the
<code class="reqn">t</code>th one is related to time slice <code class="reqn">t</code> (note that the sequences can
have different lengths). If <code>gmgm</code> is a <code>gmbn</code> object, this
argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>A character string (<code>"aic"</code>, <code>"bic"</code> or
<code>"loglik"</code>) corresponding to the scoring function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_part</code></td>
<td>
<p>A positive integer corresponding to the number of particles
generated for each observation (if <code>gmgm</code> is a <code>gmbn</code> object) or
observation sequence (if <code>gmgm</code> is a <code>gmdbn</code> object) during
inference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_part_sim</code></td>
<td>
<p>An integer greater than or equal to <code>n_part</code>
corresponding to the maximum number of particles that can be processed
simultaneously during inference. This argument is used to prevent memory
overflow, dividing <code>data</code> into smaller subsets that are handle
sequentially.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_ess</code></td>
<td>
<p>A numeric value in [0, 1] corresponding to the minimum ESS
(expressed as a proportion of <code>n_part</code>) under which the renewal step of
sequential importance resampling is performed. If <code>1</code> (the default),
this step is performed at each time slice. If <code>gmgm</code> is a <code>gmbn</code>
object, this argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_sem</code></td>
<td>
<p>A non-negative integer corresponding to the maximum
number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_pem</code></td>
<td>
<p>A non-negative integer corresponding to the maximum
number of iterations of the parametric EM algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value indicating whether iterations in progress
are displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to function <code>stepwise</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>gmgm</code></td>
<td>
<p>The final <code>gmbn</code> or <code>gmdbn</code> object (with the highest
score).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame (tibble) containing the complete data used to learn
the final <code>gmbn</code> or <code>gmdbn</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seq_score</code></td>
<td>
<p>A numeric matrix containing the sequence of scores measured
after the E and M steps of each iteration.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Koller, D. and Friedman, N. (2009). <em>Probabilistic Graphical Models:
Principles and Techniques</em>. The MIT Press.
</p>


<h3>See Also</h3>

<p><code>param_em</code>, <code>param_learn</code>,
<code>struct_learn</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(0)
data(data_body)
data_1 &lt;- data_body
data_1$GENDER[sample.int(2148, 430)] &lt;- NA
data_1$AGE[sample.int(2148, 430)] &lt;- NA
data_1$HEIGHT[sample.int(2148, 430)] &lt;- NA
data_1$WEIGHT[sample.int(2148, 430)] &lt;- NA
data_1$FAT[sample.int(2148, 430)] &lt;- NA
data_1$WAIST[sample.int(2148, 430)] &lt;- NA
data_1$GLYCO[sample.int(2148, 430)] &lt;- NA
gmbn_1 &lt;- add_nodes(NULL,
                    c("AGE", "FAT", "GENDER", "GLYCO", "HEIGHT", "WAIST",
                      "WEIGHT"))
arcs_cand_1 &lt;- data.frame(from = c("AGE", "GENDER", "HEIGHT", "WEIGHT", NA,
                                   "AGE", "GENDER", "AGE", "FAT", "GENDER",
                                   "HEIGHT", "WEIGHT", "AGE", "GENDER",
                                   "HEIGHT"),
                          to = c("FAT", "FAT", "FAT", "FAT", "GLYCO", "HEIGHT",
                                 "HEIGHT", "WAIST", "WAIST", "WAIST", "WAIST",
                                 "WAIST", "WEIGHT", "WEIGHT", "WEIGHT"))
res_learn_1 &lt;- struct_em(gmbn_1, data_1, arcs_cand = arcs_cand_1,
                         verbose = TRUE, max_comp = 3)

set.seed(0)
data(data_air)
data_2 &lt;- data_air
data_2$NO2[sample.int(7680, 1536)] &lt;- NA
data_2$O3[sample.int(7680, 1536)] &lt;- NA
data_2$TEMP[sample.int(7680, 1536)] &lt;- NA
data_2$WIND[sample.int(7680, 1536)] &lt;- NA
gmdbn_1 &lt;- gmdbn(b_2 = add_nodes(NULL, c("NO2", "O3", "TEMP", "WIND")),
                 b_13 = add_nodes(NULL, c("NO2", "O3", "TEMP", "WIND")))
arcs_cand_2 &lt;- data.frame(from = c("NO2", "NO2", "NO2", "O3", "TEMP", "TEMP",
                                   "WIND", "WIND"),
                          to = c("NO2", "O3", "O3", "O3", NA, NA, NA, NA),
                          lag = c(1, 0, 1, 1, 0, 1, 0, 1))
res_learn_2 &lt;- struct_em(gmdbn_1, data_2, arcs_cand = arcs_cand_2,
                         col_seq = "DATE", verbose = TRUE, max_comp = 3)

</code></pre>


</div>