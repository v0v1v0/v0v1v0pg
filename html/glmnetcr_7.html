<div class="container">

<table style="width: 100%;"><tr>
<td>glmnetcr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a Penalized Constrained Continuation Ratio Model Using Lasso or Elasticnet Regularization Via 'glmnet'</h2>

<h3>Description</h3>

<p>Fit a constrained continuation ratio model via penalized maximum likelihood.  The
regularization path is computed for the lasso or elasticnet penalty at a grid
of values for the regularization parameter lambda. Can deal with all
shapes of data, including very large sparse data matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmnetcr(x, y, method = "backward", weights = NULL, offset = NULL, alpha = 1,
nlambda = 100, lambda.min.ratio = NULL, lambda = NULL, standardize = TRUE,
thresh = 1e-04,  exclude = NULL, penalty.factor = NULL, maxit = 100,
dfmax = nvars + 1, pmax = min(dfmax * 2 + 20, nvars),
type.logistic = c("Newton","modified.Newton"),
trace.it = 0 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>input data, of dimension nobs x nvars; each row is an observation vector. Can be in sparse column format (class <code>"dgCMatrix"</code> as in package <code>Matrix</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>ordinal response variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>select between fitting a backward (default) versus a forward continuation ratio model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>observation weights. Can be total counts if responses are proportion matrices. Default is 1 for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>

<p>A vector of length <code>nobs</code> that is included in the linear predictor (a <code>nobs x nc</code> matrix for the <code>"multinomial"</code> family). Useful for the <code>"poisson"</code> family (e.g. log of exposure time), or for refining a model by starting at a current fit. Default is <code>NULL</code>. If supplied, then values must also be supplied to the <code>predict.glmnet.cr</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>The elasticnet mixing parameter, with
<code class="reqn">0&lt;\alpha\le 1</code>. The penalty is defined
as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>
 <p><code>alpha=1</code>
is the lasso penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>

<p>The number of <code>lambda</code> values - default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>

<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero). The default depends on the
sample size <code>nobs</code> relative to the number of variables
<code>nvars</code>. If <code>nobs &gt; nvars</code>, the default is <code>0.0001</code>,
close to zero.  If <code>nobs &lt; nvars</code>, the default is <code>0.01</code>.
A very small value of
<code>lambda.min.ratio</code> will lead to a saturated fit in the <code>nobs &lt;
  nvars</code> case. This is undefined for
<code>"binomial"</code> and <code>"multinomial"</code> models, and <code>glmnet</code>
will exit gracefully when the percentage deviance explained is almost
1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A user supplied <code>lambda</code> sequence. Typical usage
is to have the
program compute its own <code>lambda</code> sequence based on
<code>nlambda</code> and <code>lambda.min.ratio</code>. Supplying a value of
<code>lambda</code> overrides this. WARNING: use with care. Do not supply
a single value for <code>lambda</code> (for predictions after CV use <code>predict()</code>
instead).  Supply instead
a decreasing sequence of <code>lambda</code> values. <code>glmnet</code> relies
on its warms starts for speed, and its often faster to fit a whole
path than compute a single fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>

<p>Logical flag for variable standardization, prior to
fitting the model sequence. The coefficients are always returned on
the original scale. Default is <code>standardize=TRUE</code>.
If variables are in the same units already, you might not wish to standardize.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each inner
coordinate-descent loop continues until the maximum change in the
objective after any coefficient update is less than <code>thresh</code>
times the null deviance. Defaults value is <code>1E-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>

<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
(next item).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>

<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies <code>lambda</code> to allow
differential shrinkage. Can be 0 for some variables, which implies
no shrinkage, and that variable is always included in the
model. Default is 1 for all variables (and implicitly infinity for
variables listed in <code>exclude</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of outer-loop iterations for
<code>"binomial"</code> or <code>"multinomial"</code> families. Default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfmax</code></td>
<td>
<p>Limit the maximum number of variables in the model. Useful for very large <code>nvars</code>, if a partial path is desired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmax</code></td>
<td>
<p>Limit the maximum number of variables ever to be nonzero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.logistic</code></td>
<td>
<p>If <code>"Newton"</code> then the exact hessian is used (default), while <code>"modified.Newton"</code> uses an upper-bound on the hessian, and can be faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is displayed; useful for big models that take a long time to fit.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by coordinate
descent. This is a lasso or elasticnet regularization path
for fitting the generalized linear regression
paths, by maximizing the appropriate penalized log-likelihood. Sometimes the sequence is truncated before <code>nlambda</code>
values of <code>lambda</code> have been used, because of instabilities in
the inverse link functions near a saturated fit. This function invokes <code>glmnet(...,family="binomial")</code>
which fits a traditional logistic regression model for the
log-odds. The
penalties take care of redundancies.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>a <code>nvars x
      length(lambda)</code> matrix of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev</code></td>
<td>
<p>The fraction of (null) deviance explained (for <code>"elnet"</code>, this
is the R-square). The deviance calculations incorporate weights if
present in the model. The deviance is defined to be -2*(loglike_sat -
loglike), where loglike_sat is the log-likelihood for the saturated
model (a model with a free parameter per observation). Hence dev.fraction=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to
be  -2*(loglike_sat -loglike(Null)); The NULL model refers to the
intercept model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of
<code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfmat</code></td>
<td>
<p>Appliable for <code>"multnet"</code> only so does not apply to the CR model. A matrix consisting of the
number of nonzero coefficients per class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>dimension of coefficient matrix (ices)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>total passes over the data summed over all lambda
values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>a logical variable indicating whether an offset was included in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors (largely for internal debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>returns the original data matrix. Useful for <code>predict</code> and <code>fitted</code> functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>returns the original ordinal response. Useful for <code>predict</code> and <code>fitted</code> functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>returns the continuation ratio method (forward or backward). Useful for <code>predict</code> and <code>fitted</code> functions</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function depends heavily upon the <code>glmnet</code> function in the <span class="pkg">glmnet</span> package written by Jerome Friedman, Trevor Hastie and Rob Tibshirani
</p>


<h3>Author(s)</h3>

<p>Kellie J. Archer, <a href="mailto:archer.43@osu.edu">archer.43@osu.edu</a></p>


<h3>See Also</h3>

<p>See Also as <code>glmnet</code>, <code>select.glmnetcr</code>, <code>fitted.glmnetcr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(diabetes)

x &lt;- diabetes[, 2:dim(diabetes)[2]]

y &lt;- diabetes$y

glmnet.fit &lt;- glmnetcr(x, y)

fitted(glmnet.fit, s = select.glmnetcr(glmnet.fit))
</code></pre>


</div>