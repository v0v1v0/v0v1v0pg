<div class="container">

<table style="width: 100%;"><tr>
<td>maternGmrfPrec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Precision matrix for a Matern spatial correlation</h2>

<h3>Description</h3>

<p>Produces the precision matrix for a Gaussian random field on a regular square lattice, using a Markov random field approximation. 
</p>


<h3>Usage</h3>

<pre><code class="language-R"> 
maternGmrfPrec(N, ...)
## S3 method for class 'dgCMatrix'
maternGmrfPrec(N, 
	param=c(variance=1, range=1, shape=1, cellSize=1),
  adjustEdges=FALSE,...) 
## Default S3 method:
maternGmrfPrec(N, Ny=N, 	
  param=c(variance=1, range=1, shape=1, cellSize=1),
  adjustEdges=FALSE, ...)
NNmat(N, Ny=N, nearest=3, adjustEdges=FALSE)
## S3 method for class 'SpatRaster'
NNmat(N, Ny=N, nearest=3, adjustEdges=FALSE)
## Default S3 method:
NNmat(N, Ny=N, nearest=3, adjustEdges=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Number of grid cells in the x direction, or a matrix denoting nearest neighbours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ny</code></td>
<td>
<p>Grid cells in the y direction, defaults to <code>N</code> for a square grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>Vector of model parameters, with named elements: <code>scale</code>,
scale parameter for the correlation function; <code>prec</code>, precision parameter; <code>shape</code>, 
Matern differentiability parameter (0, 1, or 2); and <code>cellSize</code>, the size of the grid cells.  Optionally, 
<code>variance</code> and <code>range</code> can be given in place of <code>prec</code> and <code>scale</code>, when the former 
are present and the latter are missing the reciprocal of the former are taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjustEdges</code></td>
<td>
<p>If <code>TRUE</code>, adjust the precision matrix so it does not implicitly assume 
the field takes values of zero outside the specified region.  Defaults to <code>FALSE</code>.  Can be a character string specifying the parameters to use for the correction, such as <code>'optimal'</code> or <code>'optimalShape'</code>, with <code>TRUE</code> equivalent to <code>'theo'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nearest</code></td>
<td>
<p>Number of nearest neighbours to compute</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>maternGmrfPrec.dsCMatrix</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The numbering of cells
is consistent with the <code>terra</code> package.  Cell 1 is the top left cell, with cell 2 being the cell to the right and numbering
continuing row-wise.
</p>
<p>The 
nearest neighbour matrix <code>N</code> has: <code>N[i,j]=1</code> if <code>i=j</code>; 
takes a value 2 if <code>i</code> and <code>j</code> are first ‘rook’ neighbours; 
3 if they are first ‘bishop’ neighbours; 4 if they are second ‘rook’ neighbours; 5 
if ‘knight’ neighbours; and 6 if third ‘rook’ neighbours.
</p>
<pre>
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]    0    0    0    6    0    0    0
[2,]    0    0    5    4    5    0    0
[3,]    0    5    3    2    3    5    0
[4,]    6    4    2    1    2    4    6
[5,]    0    5    3    2    3    5    0
[6,]    0    0    5    4    5    0    0
[7,]    0    0    0    6    0    0    0
</pre>


<h3>Value</h3>

<p>A sparse matrix <code>dsCMatrix-class</code> object, containing a precision matrix for a 
Gaussian random field or (from the <code>NNmat</code> function)  a matrix denoting neighbours.  
</p>


<h3>Examples</h3>

<pre><code class="language-R"># produces the matrix above
	matrix(NNmat(11, 11, nearest=5)[,11*5+6],11, 11)

	params=c(range = 3,	shape=2, variance=5^2)
	
	myGrid = squareRaster(ext(0,20,0,10), 40)
		
	# precision matrix without adjusting for edge effects
	precMat =maternGmrfPrec(N=myGrid, param=params) 
	
	attributes(precMat)$info$precisionEntries
	
	midcell = cellFromRowCol(myGrid, 
		round(nrow(myGrid)/2), round(ncol(myGrid)/2)) # the middle cell
	edgeCell = cellFromRowCol(myGrid, 5,5)# cell near corner

# show precision of middle cell 
	precMid=matrix(precMat[,midcell], 
		nrow(myGrid), ncol(myGrid), byrow=TRUE)

	precMid[round(nrow(precMid)/2) + seq(-5, 5), 
		round(ncol(precMid)/2) + seq(-3, 3)]

	# and with the adjustment
	precMatCorr =maternGmrfPrec(
		N = myGrid, param=params, 
		adjustEdges=TRUE) 

	

# variance matrices
	varMat = Matrix::solve(precMat)
	varMatCorr = Matrix::solve(precMatCorr)

# compare covariance matrix to the matern
	xseq = seq(-ymax(myGrid), ymax(myGrid), len=1000)/1.5
	plot(xseq, matern(xseq, param=params),
	 type = 'l',ylab='cov', xlab='dist',
	 ylim=c(0, params["variance"]*1.1),
	 main="matern v gmrf")

	# middle cell
	varMid=matrix(varMat[,midcell], 
		nrow(myGrid), ncol(myGrid), byrow=TRUE)
	varMidCorr=matrix(varMatCorr[,midcell], 
		nrow(myGrid), ncol(myGrid), byrow=TRUE)
	xseqMid = yFromRow(myGrid) - yFromCell(myGrid, midcell)	
	points(xseqMid, varMid[,colFromCell(myGrid, midcell)], 
		col='red')
	points(xseqMid, varMidCorr[,colFromCell(myGrid, midcell)],
		 col='blue', cex=0.5)

	# edge cells
	varEdge=matrix(varMat[,edgeCell], 
	  nrow(myGrid), ncol(myGrid), byrow=TRUE)
	varEdgeCorr = matrix(varMatCorr[,edgeCell], 
	  nrow(myGrid), ncol(myGrid), byrow=TRUE)
	xseqEdge = yFromRow(myGrid) - yFromCell(myGrid, edgeCell)
	points(xseqEdge, 
		varEdge[,colFromCell(myGrid, edgeCell)], 
		pch=3,col='red')
	points(xseqEdge, 
	  varEdgeCorr[,colFromCell(myGrid, edgeCell)], 
	  pch=3, col='blue')
	
	legend("topright", lty=c(1, NA, NA, NA, NA), 
	  pch=c(NA, 1, 3, 16, 16),
		col=c('black','black','black','red','blue'),
		legend=c('matern', 'middle','edge','unadj', 'adj')
		)


	# construct matern variance matrix

	myraster = attributes(precMat)$raster
	covMatMatern = matern(myraster, param=params)
 
 	prodUncor = crossprod(covMatMatern, precMat)
 	prodCor = crossprod(covMatMatern, precMatCorr)

 	quantile(Matrix::diag(prodUncor),na.rm=TRUE)
 	quantile(Matrix::diag(prodCor),na.rm=TRUE)
 	
 	quantile(prodUncor[lower.tri(prodUncor,diag=FALSE)],na.rm=TRUE)	
 	quantile(prodCor[lower.tri(prodCor,diag=FALSE)],na.rm=TRUE)	

 	


</code></pre>


</div>