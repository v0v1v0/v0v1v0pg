<div class="container">

<table style="width: 100%;"><tr>
<td>geom_label_npc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Text with Normalised Parent Coordinates</h2>

<h3>Description</h3>

<p><code>geom_text_npc()</code> adds text directly to the plot.
<code>geom_label_npc()</code> draws a rectangle behind the text, making it easier
to read. The difference is that <code>x</code> and <code>y</code> mappings are expected
to be given in <code>npc</code> graphic units, using pseudo-aesthetics. Their
intended use is to add annotations to a plot.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_label_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  label.size = 0.25,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_text_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific data set - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parse</code></td>
<td>
<p>If TRUE, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nudge_x, nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size.unit</code></td>
<td>
<p>How the 'size' aesthetic is interpreted: as millimetres
('"mm"', default), points ('"pt"'), centimetres ('"cm"'), inches ('"in"'),
or picas ('"pc"').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_overlap</code></td>
<td>
<p>If 'TRUE', text that overlaps previous text in the same
layer will not be plotted.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These geoms are identical to 'ggplot2'
<code>geom_text</code> and <code>geom_label</code>
except that they interpret <code>npcx</code> and <code>npcy</code> positions in
<code>npc</code> units. They translate <code>npcx</code> and <code>npcy</code> coordinates
using a pseudo-aesthetic with a fixed scale, the translation is done
separately for each plot panel. All aesthetics other than <em>x</em> and
<em>y</em> and grouping work as in normal geoms. These include
<code>linetype</code> and <code>angle</code> in <code>geom_label_npc()</code>.
</p>


<h3>Alignment</h3>

<p>With textual positions and groups a shift is added to
successive labels to avoid overlaps. The shift is based on grouping,
however unused levels are not dropped. In plots with faceting, if not
all groups appear in each panel, there will be blank spaces in between
labels. To solve this pass numeric values for the npc coordinates of each
label instead of character strings.
</p>
<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Plot boundaries and clipping</h3>

<p>Note that when you change the scale
limits for <em>x</em> and/or <em>y</em> of a plot, text labels stay the same
size, as determined by the <code>size</code> aesthetic, given in millimetres. The
actual size as seen in the plotted output is decided during the rendering
of the plot to a graphics device. Limits are expanded only to include the
anchor point of the labels because the "width" and "height" of a text
element are 0 (as seen by ggplot2). Text labels do have height and width,
but in grid units, not data units.
</p>


<h3>See Also</h3>

<p><code>geom_text</code> and
<code>geom_label</code> for additional details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
df &lt;- data.frame(
  x = c(0, 0, 1, 1, 0.5),
  x.chr = c("left", "left", "right", "right", "center"),
  y = c(0, 1, 0, 1, 0.5),
  y.chr = c("bottom", "top", "bottom", "top", "middle"),
  text = c("bottom-left", "top-left", "bottom-right", "top-right", "center-middle")
)

ggplot(df) +
  geom_text_npc(aes(npcx = x, npcy = y, label = text))

ggplot(df) +
  geom_text_npc(aes(npcx = x.chr, npcy = y.chr, label = text))

ggplot(df) +
  geom_text_npc(aes(npcx = x.chr, npcy = y.chr, label = text),
                angle = 90)

ggplot(data = mtcars, mapping = aes(wt, mpg)) +
  geom_point() +
  geom_text_npc(data = df, aes(npcx = x, npcy = y, label = text))

ggplot(data = mtcars, mapping = aes(wt, mpg)) +
  geom_point() +
  geom_text_npc(data = df, aes(npcx = x, npcy = y, label = text)) +
  expand_limits(y = 40, x = 6)

ggplot(data = mtcars) +
  geom_point(mapping = aes(wt, mpg)) +
  geom_label_npc(data = df, aes(npcx = x, npcy = y, label = text))

ggplot(data = mtcars) +
  geom_point(mapping = aes(wt, mpg)) +
  geom_label_npc(data = df, aes(npcx = x.chr, npcy = y.chr, label = text),
                 angle = 90) # ignored by ggplot2 &lt; 3.5.0

</code></pre>


</div>