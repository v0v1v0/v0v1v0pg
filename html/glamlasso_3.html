<div class="container">

<table style="width: 100%;"><tr>
<td>glamlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Penalization in Large Scale Generalized Linear Array Models</h2>

<h3>Description</h3>

<p>Efficient design matrix free procedure for fitting large scale penalized  2 or 3-dimensional
generalized linear array models (GLAM). It is also possible to fit an additional non-tensor structured component 
- e.g an intercept - however this can reduce the computational efficiency of the procedure substantially. 
Currently the LASSO penalty and the SCAD penalty are both implemented. Furthermore,
the Gaussian model with identity link,  the Binomial model with logit link, the Poisson model
with log link and the Gamma model with log link is currently implemented. The underlying algorithm combines gradient descent and proximal gradient (gdpg algorithm), see  <cite>Lund et al., 2017</cite>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glamlasso(X, 
          Y, 
          Z = NULL,
          family = "gaussian",
          penalty = "lasso",
          intercept = FALSE,
          weights = NULL,
          betainit = NULL,
          alphainit = NULL,
          nlambda = 100,
          lambdaminratio = 1e-04,
          lambda = NULL,
          penaltyfactor = NULL,
          penaltyfactoralpha = NULL,
          reltolinner = 1e-07,
          reltolouter = 1e-04,
          maxiter = 15000,
          steps = 1,
          maxiterinner = 3000,
          maxiterouter = 25,
          btinnermax = 100,
          btoutermax = 100,
          iwls = "exact",
          nu = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A list containing the tensor components (2 or 3) of the tensor design matrix.
These are  matrices of sizes <code class="reqn">n_i   \times p_i</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The response values, an array of size <code class="reqn">n_1 \times\cdots\times n_d</code>. For option 
<code>family = "binomial"</code> this array must contain the proportion of successes and the 
number of trials is then specified as <code>weights</code> (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The non tensor structrured part of the design matrix. A matrix of size <code class="reqn">n_1 \cdots n_d\times q</code>. 
Is set to <code>NULL</code> as default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A string specifying the model family (essentially the response distribution). Possible values 
are <code>"gaussian", "binomial", "poisson", "gamma"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>A string specifying the penalty. Possible values 
are <code>"lasso", "scad"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Logical variable indicating if the model includes an intercept. 
When <code>intercept = TRUE</code> the first coulmn in the non-tensor design component <code>Z</code> is all 1s.
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights, an array of size <code class="reqn">n_1 \times \cdots \times n_d</code>. For option 
<code>family = "binomial"</code> this array must contain the number of trials and must be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betainit</code></td>
<td>
<p>The initial parameter values. Default is NULL in which case all parameters are initialized at zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphainit</code></td>
<td>
<p>A <code class="reqn">q\times 1</code> vector containing the initial parameter values for the non-tensor parameter. 
Default is NULL in which case all parameters are initialized at 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaminratio</code></td>
<td>
<p>The smallest value for <code>lambda</code>, given as a fraction of 
<code class="reqn">\lambda_{max}</code>; the (data derived) smallest value for which all coefficients are zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The sequence of penalty parameters for the regularization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penaltyfactor</code></td>
<td>
<p>An array of size <code class="reqn">p_1 \times \cdots \times p_d</code>. Is multiplied 
with each element in <code>lambda</code> to allow differential shrinkage on the coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penaltyfactoralpha</code></td>
<td>
<p>A <code class="reqn">q \times 1</code> vector multiplied with each element in <code>lambda</code> to allow differential 
shrinkage on the non-tensor coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltolinner</code></td>
<td>
<p>The convergence tolerance for the inner loop</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltolouter</code></td>
<td>
<p>The convergence tolerance for the outer loop.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of inner iterations allowed for each <code>lambda</code>
value, when  summing over all outer iterations for said <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>The number of steps used in the multi-step adaptive lasso algorithm for non-convex penalties. Automatically set to 1 when <code>penalty = "lasso"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiterinner</code></td>
<td>
<p>The maximum number of inner iterations allowed for each outer iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiterouter</code></td>
<td>
<p>The maximum number of outer iterations allowed for each lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>btinnermax</code></td>
<td>
<p>Maximum number of backtracking steps allowed in each inner iteration. Default is <code>btinnermax = 100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>btoutermax</code></td>
<td>
<p>Maximum number of backtracking steps allowed in each outer iteration. Default is <code>btoutermax = 100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iwls</code></td>
<td>
<p>A string indicating whether to use the exact iwls weight matrix or use a kronecker structured approximation to it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>A number between 0 and 1 that controls the step size <code class="reqn">\delta</code> in the proximal algorithm (inner loop) by 
scaling the upper bound <code class="reqn">\hat{L}_h</code> on the Lipschitz constant <code class="reqn">L_h</code> (see <cite>Lund et al., 2017</cite>). 
For <code>nu = 1</code> backtracking never occurs and the proximal step size is always <code class="reqn">\delta = 1 / \hat{L}_h</code>. 
For <code>nu = 0</code> backtracking always occurs and the proximal step size is initially <code class="reqn">\delta = 1</code>. 
For <code>0 &lt; nu &lt; 1</code> the proximal step size is initially <code class="reqn">\delta = 1/(\nu\hat{L}_h)</code> and backtracking 
is only employed if the objective function does not decrease. A <code>nu</code> close  to 0 gives large step 
sizes and presumably more backtracking in the inner loop. The default is <code>nu = 1</code> and the option is only 
used if <code>iwls = "exact"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider a (two component) generalized linear model (GLM) 
</p>
<p style="text-align: center;"><code class="reqn">g(\mu) = X\beta  + Z\alpha =: \eta.</code>
</p>

<p>Here <code class="reqn">g</code> is a link function, <code class="reqn">\mu</code> is a <code class="reqn">n\times 1</code> vector 
containing the mean of the response variable  <code class="reqn">Y</code>, <code class="reqn">Z</code> is a 
<code class="reqn">n\times q</code> matrix and  <code class="reqn">X</code> a <code class="reqn">n\times p</code> matrix  with tensor structure 
</p>
<p style="text-align: center;"><code class="reqn">X =  X_d\otimes\cdots\otimes X_1,</code>
</p>

<p>where <code class="reqn">X_1,\ldots,X_d</code> are the marginal <code class="reqn">n_i\times p_i</code> design 
matrices (tensor factors) such that <code class="reqn">p = p_1\cdots p_d</code> and  
<code class="reqn">n=n_1\cdots n_d</code>. Then <code class="reqn">\beta</code> is the <code class="reqn">p\times 1</code> parameter associated 
with the tensor component <code class="reqn">X</code> and <code class="reqn">\alpha</code> the <code class="reqn">q\times 1</code> 
parameter associated with the non-tensor component <code class="reqn">Z</code>, e.g. the intercept. 
</p>
<p>Using the generalized linear array model (GLAM) framework the model equation is
</p>
<p style="text-align: center;"><code class="reqn">g(\mu) = \textrm{vec}(\rho(X_d,\rho(X_{d-1},\ldots,\rho(X_1,B)))) + Z\alpha ,</code>
</p>

<p>where <code class="reqn">\rho</code> is the so called rotated <code class="reqn">H</code>-transform and <code class="reqn">B</code> is the
array version of <code class="reqn">\beta</code>. See <cite>Currie et al., 2006</cite> for more details.
</p>
<p>The  log-likelihood is a function of  <code class="reqn">\theta  :=(\beta,\alpha)</code> through 
the linear predictor <code class="reqn">\eta</code> i.e. <code class="reqn">\theta \mapsto l(\eta(\theta))</code>.
In the usual exponential family framework this can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">l(\eta(\theta )) = \sum_{i = 1}^n a_i \frac{y_i \vartheta(\eta_i(\theta)) - b(\vartheta(\eta_i(\theta  )))}{\psi}+c(y_i,\psi)</code>
</p>
 
<p>where <code class="reqn">\vartheta</code>, the canonical parameter map,  is linked to the  linear
predictor via the identity <code class="reqn">\eta(\theta) = g(b'(\vartheta))</code> with <code class="reqn">b</code>
the cumulant function. Here <code class="reqn">a_i \ge 0, i = 1,\ldots,n</code> are observation
weights and <code class="reqn">\psi</code> is the dispersion parameter.
</p>
<p>For <code class="reqn">d = 3</code> or <code class="reqn">d = 2</code>, using only the marginal matrices <code class="reqn">X_1,X_2,\ldots</code>, 
the function <code>glamlasso</code> solves the penalized estimation problem 
</p>
<p style="text-align: center;"><code class="reqn">\min_{\theta} -l(\eta(\theta)) + \lambda J (\theta),</code>
</p>
 
<p>for <code class="reqn">J</code> either the LASSO or SCAD penalty function,  in the GLAM setup for 
a sequence of penalty parameters <code class="reqn">\lambda&gt;0</code>. The underlying algorithm is 
based on an outer gradient descent loop and an inner proximal gradient based 
loop. We note that if <code class="reqn">J</code> is not convex, as with the SCAD penalty, we use
the multiple step adaptive lasso procedure to loop over the inner proximal 
algorithm, see <cite>Lund et al., 2017</cite> for more details.
</p>
<p>Note that the package is optimized towards solving the estimation problem, 
for <code class="reqn">\alpha = 0</code>. For <code class="reqn">\alpha \neq 0</code> the user incurs a  potentially 
substantial computational cost. Especially it is not advisable to inlcude a 
very large non-tensor component  in the model (large <code class="reqn">q</code>) and even  
adding an intecept to the model (<code class="reqn">q=1</code>) will result in a reduction of 
computational efficiency.
</p>


<h3>Value</h3>

<p>An object with S3 Class 'glamlasso'. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>A string indicating the GLAM dimension (<code class="reqn">d = 2, 3</code>), the model 
family and the penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code class="reqn">p_1\cdots p_d \times</code> <code>nlambda</code> matrix containing the 
estimates of the parameters for the tensor structured part of the model 
(<code>beta</code>) for  each <code>lambda</code>-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A <code class="reqn">q \times</code> <code>nlambda</code> matrix containing the estimates 
of the parameters for the non tensor structured part of the model <code>alpha</code> 
for each <code>lambda</code>-value. If <code>intercept = TRUE</code> the first row 
contains the intercept estimate for each <code>lambda</code>-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A vector containing the sequence of penalty values used in the 
estimation procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimcoef</code></td>
<td>
<p>A vector giving the dimension of the model coefficient array 
<code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimobs</code></td>
<td>
<p>A vector giving the dimension of the observation (response) 
array <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Iter</code></td>
<td>
<p>A list with 4 items:  
<code>bt_iter_inner</code>  is total number of backtracking steps performed in the 
inner loop, <code>bt_enter_inner</code> is the number of times the backtracking is 
initiated in  the inner loop, <code>bt_iter_outer</code> is total number of 
backtracking steps performed in the  outer loop, and <code>iter_mat</code> is a 
<code>nlambda</code> <code class="reqn">\times</code> <code>maxiterouter</code> matrix containing the  number 
of inner iterations for each <code>lambda</code> value and each outer iteration and  
<code>iter</code> is total number of iterations i.e. <code>sum(Iter)</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Adam Lund
</p>
<p>Maintainer: Adam Lund, <a href="mailto:adam.lund@math.ku.dk">adam.lund@math.ku.dk</a>
</p>


<h3>References</h3>

<p>Lund, A., M. Vincent, and N. R. Hansen (2017). Penalized estimation in 
large-scale generalized linear array models. 
<em>Journal of Computational and Graphical Statistics</em>, 26, 3, 709-724.  url = https://doi.org/10.1080/10618600.2017.1279548.
</p>
<p>Currie, I. D., M. Durban, and P. H. C. Eilers (2006). Generalized linear
array models with applications to multidimensional smoothing. 
<em>Journal of the Royal Statistical Society. Series B</em>. 68, 259-280. url = http://dx.doi.org/10.1111/j.1467-9868.2006.00543.x.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##size of example 
n1 &lt;- 65; n2 &lt;- 26; n3 &lt;- 13; p1 &lt;- 12; p2 &lt;- 6; p3 &lt;- 4

##marginal design matrices (tensor components)
X1 &lt;- matrix(rnorm(n1 * p1), n1, p1) 
X2 &lt;- matrix(rnorm(n2 * p2), n2, p2) 
X3 &lt;- matrix(rnorm(n3 * p3), n3, p3) 
X &lt;- list(X1, X2, X3)

##############gaussian example 
Beta &lt;- array(rnorm(p1 * p2 * p3) * rbinom(p1 * p2 * p3, 1, 0.1), c(p1 , p2, p3))
Mu &lt;- RH(X3, RH(X2, RH(X1, Beta)))
Y &lt;- array(rnorm(n1 * n2 * n3, Mu), c(n1, n2, n3))

system.time(fit &lt;- glamlasso(X, Y))

modelno &lt;- length(fit$lambda)
plot(c(Beta), type = "h", ylim = range(Beta, fit$coef[, modelno]))
points(c(Beta))
lines(fit$coef[ , modelno], col = "red", type = "h")

###with non tensor design component Z
q &lt;- 5
alpha &lt;- matrix(rnorm(q)) * rbinom(q, 1, 0.5)
Z &lt;- matrix(rnorm(n1 * n2 * n3 * q), n1 * n2 *n3, q) 
Y &lt;- array(rnorm(n1 * n2 * n3, Mu + array(Z %*% alpha, c(n1, n2, n3))), c(n1, n2, n3))
system.time(fit &lt;- glamlasso(X, Y, Z))

modelno &lt;- length(fit$lambda)
oldmfrow &lt;- par()$mfrow
par(mfrow = c(1, 2))
plot(c(Beta), type = "l", ylim = range(Beta, fit$coef[, modelno]))
points(c(Beta))
lines(fit$coef[ , modelno], col = "red")
plot(c(alpha), type = "h", ylim = range(Beta, fit$alpha[, modelno]))
points(c(alpha))
lines(fit$alpha[ , modelno], col = "red", type = "h")
par(mfrow = oldmfrow)

################ poisson example
Beta &lt;- array(rnorm(p1 * p2 * p3, 0, 0.1) * rbinom(p1 * p2 * p3, 1, 0.1), c(p1 , p2, p3))
Mu &lt;- RH(X3, RH(X2, RH(X1, Beta)))
Y &lt;- array(rpois(n1 * n2 * n3, exp(Mu)), dim = c(n1, n2, n3))
system.time(fit &lt;- glamlasso(X, Y, family = "poisson", nu = 0.1))

modelno &lt;- length(fit$lambda)
plot(c(Beta), type = "h", ylim = range(Beta, fit$coef[, modelno]))
points(c(Beta))
lines(fit$coef[ , modelno], col = "red", type = "h")

###with non tensor design component Z
q &lt;- 5
alpha &lt;- matrix(rnorm(q)) * rbinom(q, 1, 0.5)
Z &lt;- matrix(rnorm(n1 * n2 * n3 * q), n1 * n2 *n3, q) 
Y &lt;- array(rpois(n1 * n2 * n3, exp(Mu + array(Z %*% alpha, c(n1, n2, n3)))), dim = c(n1, n2, n3))
system.time(fit &lt;- glamlasso(X, Y, Z, family = "poisson", nu = 0.1))

modelno &lt;- length(fit$lambda)
oldmfrow &lt;- par()$mfrow
par(mfrow = c(1, 2))
plot(c(Beta), type = "l", ylim = range(Beta, fit$coef[, modelno]))
points(c(Beta))
lines(fit$coef[ , modelno], col = "red")
plot(c(alpha), type = "h", ylim = range(Beta, fit$alpha[, modelno]))
points(c(alpha))
lines(fit$alpha[ , modelno], col = "red", type = "h")
par(mfrow = oldmfrow)

</code></pre>


</div>