<div class="container">

<table style="width: 100%;"><tr>
<td>select_parameters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Select parameters for a clustering algorithm</h2>

<h3>Description</h3>

<p>Function to select the parameters for a clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">select_parameters(
  algo,
  data,
  k,
  m,
  alpha = NA,
  beta = NA,
  nblistw = NULL,
  lag_method = "mean",
  window = NULL,
  spconsist = TRUE,
  classidx = TRUE,
  nrep = 30,
  indices = NULL,
  standardize = TRUE,
  robust = FALSE,
  noise_cluster = FALSE,
  delta = NA,
  maxiter = 500,
  tol = 0.01,
  seed = NULL,
  init = "random",
  verbose = TRUE
)

selectParameters(
  algo,
  data,
  k,
  m,
  alpha = NA,
  beta = NA,
  nblistw = NULL,
  lag_method = "mean",
  window = NULL,
  spconsist = TRUE,
  classidx = TRUE,
  nrep = 30,
  indices = NULL,
  standardize = TRUE,
  robust = FALSE,
  noise_cluster = FALSE,
  delta = NA,
  maxiter = 500,
  tol = 0.01,
  seed = NULL,
  init = "random",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>A string indicating which method to use (FCM, GFCM, SFCM, SGFCM)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A dataframe with numeric columns or a list of rasters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>A sequence of values for k to test (&gt;=2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A sequence of values for m to test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A sequence of values for alpha to test (NULL if not required)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A sequence of values for beta to test (NULL if not required)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nblistw</code></td>
<td>
<p>A list of list.w objects describing the neighbours typically
produced by the spdep package (NULL if not required)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag_method</code></td>
<td>
<p>A string indicating if a classical lag must be used
("mean") or if a weighted median must be used ("median"). Both can be
tested by specifying a vector : c("mean","median"). When working with rasters,
the string must be parsable to a function like mean, min, max, sum, etc. and will
be applied to all the pixels values in the window designated by the parameter window
and weighted according to the values of this matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>A list of windows to use to calculate neighbouring values if
rasters are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spconsist</code></td>
<td>
<p>A boolean indicating if the spatial consistency must be
calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classidx</code></td>
<td>
<p>A boolean indicating if the quality of classification
indices must be calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>An integer indicating the number of permutation to do to simulate
the random distribution of the spatial inconsistency. Only used if spconsist
is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indices</code></td>
<td>
<p>A character vector with the names of the indices to calculate, to
evaluate clustering quality. default is :c("Silhouette.index", "Partition.entropy",
"Partition.coeff", "XieBeni.index", "FukuyamaSugeno.index", "Explained.inertia").
Other available indices are : "DaviesBoulin.index", "CalinskiHarabasz.index",
"GD43.index", "GD53.index" and "Negentropy.index".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>A boolean to specify if the variable must be centered and
reduce (default = True)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>A boolean indicating if the "robust" version of the algorithm must be used (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_cluster</code></td>
<td>
<p>A boolean indicatong if a noise cluster must be added to the solution (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>A float giving the distance of the noise cluster to each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>An integer for the maximum number of iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance criterion used in the evaluateMatrices function for
convergence assessment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An integer used for random number generation. It ensures that the
start centers will be the same if the same integer is selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A string indicating how the initial centers must be selected. "random"
indicates that random observations are used as centers. "kpp" use a distance based method
resulting in more dispersed centers at the beginning. Both of them are heuristic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A boolean indicating if a progressbar should be displayed</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A dataframe with indicators assessing the quality of classifications
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(LyonIris)
AnalysisFields &lt;-c("Lden","NO2","PM25","VegHautPrt","Pct0_14","Pct_65","Pct_Img",
"TxChom1564","Pct_brevet","NivVieMed")
dataset &lt;- sf::st_drop_geometry(LyonIris[AnalysisFields])
queen &lt;- spdep::poly2nb(LyonIris,queen=TRUE)
Wqueen &lt;- spdep::nb2listw(queen,style="W")
#set spconsist to TRUE to calculate the spatial consistency indicator
#FALSE here to reduce the time during package check
values &lt;- select_parameters(algo = "SFCM", dataset, k = 5, m = seq(2,3,0.1),
    alpha = seq(0,2,0.1), nblistw = Wqueen, spconsist=FALSE)


data(LyonIris)
AnalysisFields &lt;-c("Lden","NO2","PM25","VegHautPrt","Pct0_14","Pct_65","Pct_Img",
"TxChom1564","Pct_brevet","NivVieMed")
dataset &lt;- sf::st_drop_geometry(LyonIris[AnalysisFields])
queen &lt;- spdep::poly2nb(LyonIris,queen=TRUE)
Wqueen &lt;- spdep::nb2listw(queen,style="W")
#set spconsist to TRUE to calculate the spatial consistency indicator
#FALSE here to reduce the time during package check
values &lt;- selectParameters(algo = "SFCM", dataset, k = 5, m = seq(2,3,0.1),
    alpha = seq(0,2,0.1), nblistw = Wqueen, spconsist=FALSE)

</code></pre>


</div>