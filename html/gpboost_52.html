<div class="container">

<table style="width: 100%;"><tr>
<td>predict.gpb.Booster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction function for <code>gpb.Booster</code> objects</h2>

<h3>Description</h3>

<p>Prediction function for <code>gpb.Booster</code> objects
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'gpb.Booster'
predict(object, data, start_iteration = NULL,
  num_iteration = NULL, pred_latent = FALSE, predleaf = FALSE,
  predcontrib = FALSE, header = FALSE, reshape = FALSE,
  group_data_pred = NULL, group_rand_coef_data_pred = NULL,
  gp_coords_pred = NULL, gp_rand_coef_data_pred = NULL,
  cluster_ids_pred = NULL, predict_cov_mat = FALSE, predict_var = FALSE,
  cov_pars = NULL, ignore_gp_model = FALSE, rawscore = NULL,
  vecchia_pred_type = NULL, num_neighbors_pred = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object of class <code>gpb.Booster</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>matrix</code> object, a <code>dgCMatrix</code> object or a character representing a filename</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_iteration</code></td>
<td>
<p>int or NULL, optional (default=NULL)
Start index of the iteration to predict.
If NULL or &lt;= 0, starts from the first iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_iteration</code></td>
<td>
<p>int or NULL, optional (default=NULL)
Limit number of iterations in the prediction.
If NULL, if the best iteration exists and start_iteration is NULL or &lt;= 0, the
best iteration is used; otherwise, all iterations from start_iteration are used.
If &lt;= 0, all iterations from start_iteration are used (no limits).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred_latent</code></td>
<td>
<p>If TRUE latent variables, both fixed effects (tree-ensemble) 
and random effects (<code>gp_model</code>) are predicted. Otherwise, the response variable 
(label) is predicted. Depending on how the argument 'pred_latent' is set,
different values are returned from this function; see the 'Value' section for more details. 
If there is no <code>gp_model</code>, this argument corresponds to 'raw_score' in LightGBM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predleaf</code></td>
<td>
<p>whether predict leaf index instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predcontrib</code></td>
<td>
<p>return per-feature contributions for each record.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>
<p>only used for prediction for text file. True if text file has header</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reshape</code></td>
<td>
<p>whether to reshape the vector of predictions to a matrix form when there are several
prediction outputs per case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_data_pred</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with elements being group levels 
for which predictions are made (if there are grouped random effects in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_rand_coef_data_pred</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with covariate data 
for grouped random coefficients (if there are some in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_coords_pred</code></td>
<td>
<p>A <code>matrix</code> with prediction coordinates (=features) for 
Gaussian process (if there is a GP in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_rand_coef_data_pred</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with covariate data for 
Gaussian process random coefficients (if there are some in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_ids_pred</code></td>
<td>
<p>A <code>vector</code> with elements indicating the realizations of 
random effects / Gaussian processes for which predictions are made 
(set to NULL if you have not specified this when creating the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict_cov_mat</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, the (posterior) 
predictive covariance is calculated in addition to the (posterior) predictive mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict_var</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, the (posterior) 
predictive variances are calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_pars</code></td>
<td>
<p>A <code>vector</code> containing covariance parameters which are used if the 
<code>gp_model</code> has not been trained or if predictions should be made for other 
parameters than the trained ones</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_gp_model</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, predictions are only made for the tree ensemble part
and the <code>gp_model</code> is ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rawscore</code></td>
<td>
<p>This is discontinued. Use the renamed equivalent argument 
<code>pred_latent</code> instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_pred_type</code></td>
<td>
<p>A <code>string</code> specifying the type of Vecchia approximation used for making predictions.
This is discontinued here. Use the function 'set_prediction_data' to specify this</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_neighbors_pred</code></td>
<td>
<p>an <code>integer</code> specifying the number of neighbors for making predictions.
This is discontinued here. Use the function 'set_prediction_data' to specify this</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional named arguments passed to the <code>predict()</code> method of
the <code>gpb.Booster</code> object passed to <code>object</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>either a list with vectors or a single vector / matrix depending on 
whether there is a <code>gp_model</code> or not
If there is a <code>gp_model</code>, the result dict contains the following entries.
1. If <code>pred_latent</code> is TRUE, the dict contains the following 3 entries:
- result["fixed_effect"] are the predictions from the tree-ensemble.
- result["random_effect_mean"] are the predicted means of the <code>gp_model</code>.
- result["random_effect_cov"] are the predicted covariances or variances of the <code>gp_model</code>
(only if 'predict_var' or 'predict_cov' is TRUE).
2. If <code>pred_latent</code> is FALSE, the dict contains the following 2 entries:
- result["response_mean"] are the predicted means of the response variable (Label) taking into account
both the fixed effects (tree-ensemble) and the random effects (<code>gp_model</code>)
- result["response_var"] are the predicted  covariances or variances of the response variable
(only if 'predict_var' or 'predict_cov' is TRUE)
If there is no <code>gp_model</code> or <code>predcontrib</code> or <code>ignore_gp_model</code> 
are TRUE, the result contains predictions from the tree-booster only.
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist, authors of the LightGBM R package
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# See https://github.com/fabsig/GPBoost/tree/master/R-package for more examples


library(gpboost)
data(GPBoost_data, package = "gpboost")

#--------------------Combine tree-boosting and grouped random effects model----------------
# Create random effects model
gp_model &lt;- GPModel(group_data = group_data[,1], likelihood = "gaussian")
# The default optimizer for covariance parameters (hyperparameters) is 
# Nesterov-accelerated gradient descent.
# This can be changed to, e.g., Nelder-Mead as follows:
# re_params &lt;- list(optimizer_cov = "nelder_mead")
# gp_model$set_optim_params(params=re_params)
# Use trace = TRUE to monitor convergence:
# re_params &lt;- list(trace = TRUE)
# gp_model$set_optim_params(params=re_params)

# Train model
bst &lt;- gpboost(data = X, label = y, gp_model = gp_model, nrounds = 16,
               learning_rate = 0.05, max_depth = 6, min_data_in_leaf = 5,
               verbose = 0)
# Estimated random effects model
summary(gp_model)

# Make predictions
# Predict latent variables
pred &lt;- predict(bst, data = X_test, group_data_pred = group_data_test[,1],
                predict_var = TRUE, pred_latent = TRUE)
pred$random_effect_mean # Predicted latent random effects mean
pred$random_effect_cov # Predicted random effects variances
pred$fixed_effect # Predicted fixed effects from tree ensemble
# Predict response variable
pred_resp &lt;- predict(bst, data = X_test, group_data_pred = group_data_test[,1],
                     predict_var = TRUE, pred_latent = FALSE)
pred_resp$response_mean # Predicted response mean
# For Gaussian data: pred$random_effect_mean + pred$fixed_effect = pred_resp$response_mean
pred$random_effect_mean + pred$fixed_effect - pred_resp$response_mean

#--------------------Combine tree-boosting and Gaussian process model----------------
# Create Gaussian process model
gp_model &lt;- GPModel(gp_coords = coords, cov_function = "exponential",
                    likelihood = "gaussian")
# Train model
bst &lt;- gpboost(data = X, label = y, gp_model = gp_model, nrounds = 8,
               learning_rate = 0.1, max_depth = 6, min_data_in_leaf = 5,
               verbose = 0)
# Estimated random effects model
summary(gp_model)
# Make predictions
pred &lt;- predict(bst, data = X_test, gp_coords_pred = coords_test,
                predict_var = TRUE, pred_latent = TRUE)
pred$random_effect_mean # Predicted latent random effects mean
pred$random_effect_cov # Predicted random effects variances
pred$fixed_effect # Predicted fixed effects from tree ensemble
# Predict response variable
pred_resp &lt;- predict(bst, data = X_test, gp_coords_pred = coords_test,
                     predict_var = TRUE, pred_latent = FALSE)
pred_resp$response_mean # Predicted response mean

</code></pre>


</div>