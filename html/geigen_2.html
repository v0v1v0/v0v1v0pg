<div class="container">

<table style="width: 100%;"><tr>
<td>geigen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Eigenvalues</h2>

<h3>Description</h3>

<p>Computes generalized eigenvalues and eigenvectors of a pair of matrices.</p>


<h3>Usage</h3>

<pre><code class="language-R">geigen(A, B, symmetric, only.values=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>left hand side matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>right hand side matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>if <code>TRUE</code>, both matrices are assumed to be symmetric (or Hermitian if complex)
and only their lower triangle (diagonal included) is used.
If <code>symmetric</code> is not specified, the matrices are inspected for symmetry.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.values</code></td>
<td>
<p>if <code>TRUE</code> only eigenvalues are computed otherwise both eigenvalues and eigenvctors are
returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the argument <code>symmetric</code> is missing, the function
will try to determine if the matrices are symmetric with the function <code>isSymmetric</code> from
the <span class="pkg">base</span> package. It is faster to specify the argument.
</p>
<p>Both matrices must be square.
This function provides the solution to the generalized eigenvalue problem defined by
</p>
<p style="text-align: center;"><code class="reqn">A x = \lambda Bx</code>
</p>

<p>If either one of the matrices is complex the other matrix is coerced to be complex.
</p>
<p>If the matrices are symmetric then the matrix <code>B</code> must be positive definite; if it is not
an error message will be issued.
If the matrix <code>B</code> is known to be symmetric but not positive definite then the argument
<code>symmetric</code> should be set to <code>FALSE</code> explicitly.
</p>
<p>If the matrix <code>B</code> is not positive definite when it should be an
error message of the form
</p>
<p><code>    Leading minor of order ... of B is not positive definite</code>
</p>
<p>will be issued. In that case set the argument <code>symmetric</code> to <code>FALSE</code> if not set and try again.
</p>
<p>For general matrices the generalized eigenvalues <code class="reqn">\lambda</code>
are calculated as the ratio <code class="reqn">\alpha / \beta</code>
where <code class="reqn">\beta</code> may be zero or very small leading
to non finite or very large values for the eigenvalues.
Therefore the values for <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are also included in the return value
of the function.
When both matrices are complex (or coerced to be so) the generalized eigenvalues,
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are complex.
When both matrices are numeric <code class="reqn">\alpha</code> may be numeric or complex and
<code class="reqn">\beta</code> is numeric.
</p>
<p>When both matrices are symmetric (or Hermitian) the generalized eigenvalues are numeric and
no components <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are available.</p>


<h3>Value</h3>

<p>A list containing components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>a vector containing the <code class="reqn">n</code> generalized eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectors</code></td>
<td>
<p>an <code class="reqn">n\times n</code> matrix containing the generalized eigenvectors or NULL
if <code>only.values</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the numerator of the generalized eigenvalues and may be NULL if not applicable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>the denominator of the generalized eigenvalues and may be NULL if not applicable.</p>
</td>
</tr>
</table>
<h3>Source</h3>

<p><code>geigen</code> uses the LAPACK routines <code>DGGEV</code>,
<code>DSYGV</code>, <code>ZHEGV</code> and <code>ZGGEV</code>.
LAPACK is from <a href="http://www.netlib.org/lapack">http://www.netlib.org/lapack</a>.
The complex routines used by the package come from LAPACK 3.8.0.
</p>


<h3>References</h3>

<p>Anderson. E. and ten others (1999)
<em>LAPACK Users' Guide</em>.  Third Edition.  SIAM.<br>
Available on-line at
<a href="http://www.netlib.org/lapack/lug/lapack_lug.html">http://www.netlib.org/lapack/lug/lapack_lug.html</a>.
See the section <em>Generalized Eigenvalue and Singular Value Problems</em>
(<a href="http://www.netlib.org/lapack/lug/node33.html">http://www.netlib.org/lapack/lug/node33.html</a>).
</p>


<h3>See Also</h3>

<p><code>eigen</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">A &lt;- matrix(c(14, 10, 12,
              10, 12, 13,
              12, 13, 14), nrow=3, byrow=TRUE)

B &lt;- matrix(c(48, 17, 26,
              17, 33, 32,
              26, 32, 34), nrow=3, byrow=TRUE)

z1 &lt;- geigen(A, B, symmetric=FALSE, only.values=TRUE)
z2 &lt;- geigen(A, B, symmetric=FALSE, only.values=FALSE )
z2

# geigen(A, B)
z1 &lt;- geigen(A, B, only.values=TRUE)
z2 &lt;- geigen(A, B, only.values=FALSE)
z1;z2

A.c &lt;- A + 1i
B.c &lt;- B + 1i

A[upper.tri(A)] &lt;- A[upper.tri(A)] + 1i
A[lower.tri(A)] &lt;- Conj(t(A[upper.tri(A)]))

B[upper.tri(B)] &lt;- B[upper.tri(B)] + 1i
B[lower.tri(B)] &lt;- Conj(t(B[upper.tri(B)]))

isSymmetric(A)
isSymmetric(B)

z1 &lt;- geigen(A, B, only.values=TRUE)
z2 &lt;- geigen(A, B, only.values=FALSE)
z1;z2
</code></pre>


</div>