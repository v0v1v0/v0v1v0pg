<div class="container">

<table style="width: 100%;"><tr>
<td>gclm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>l1 penalized loss estimation for GCLM</h2>

<h3>Description</h3>

<p>Estimates a sparse continuous time Lyapunov
parametrization of a covariance matrix using a lasso
(L1) penalty.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gclm(
  Sigma,
  B = -0.5 * diag(ncol(Sigma)),
  C = rep(1, ncol(Sigma)),
  C0 = rep(1, ncol(Sigma)),
  loss = "loglik",
  eps = 0.01,
  alpha = 0.5,
  maxIter = 100,
  lambda = 0,
  lambdac = 0,
  job = 0
)

gclm.path(
  Sigma,
  lambdas = NULL,
  B = -0.5 * diag(ncol(Sigma)),
  C = rep(1, ncol(Sigma)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>initial B matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>diagonal of initial C matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C0</code></td>
<td>
<p>diagonal of penalization matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>one of "loglik" (default) or "frobenius"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>convergence threshold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>parameter line search</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>penalization coefficient for B</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdac</code></td>
<td>
<p>penalization coefficient for C</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>job</code></td>
<td>
<p>integer 0,1,10 or 11</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>sequence of lambda</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>gclm</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gclm</code> performs proximal gradient descent for the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">argmin L(\Sigma(B,C)) + \lambda \rho(B) + \lambda_C ||C - C0||_F^2</code>
</p>

<p>subject to <code class="reqn">B</code> stable and <code class="reqn">C</code> diagonal, where <code class="reqn">\rho(B)</code> is the l1 norm
of the off-diagonal element of <code class="reqn">B</code>.
</p>
<p><code>gclm.path</code> simply calls iteratively <code>gclm</code>
with different <code>lambda</code> values. Warm start is used, that
is in the i-th call to <code>gclm</code> the <code>B</code> and <code>C</code>
matrices are initialized as the one obtained in the (i-1)th
call.
</p>


<h3>Value</h3>

<p>for <code>gclm</code>: a list with the result of the optimization
</p>
<p>for <code>gclm.path</code>: a list of the same length of
<code>lambdas</code> with the results of the optimization for
the different <code>lambda</code> values
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(rnorm(50*20),ncol=20)
S &lt;- cov(x)

## l1 penalized log-likelihood
res &lt;- gclm(S, eps = 0, lambda = 0.1, lambdac = 0.01)

## l1 penalized log-likelihood with fixed C
res &lt;- gclm(S, eps = 0, lambda = 0.1, lambdac = -1)

## l1 penalized frobenius loss
res &lt;- gclm(S, eps = 0, lambda = 0.1, loss = "frobenius")
</code></pre>


</div>