<div class="container">

<table style="width: 100%;"><tr>
<td>coef.garchx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extraction functions for 'garchx' objects</h2>

<h3>Description</h3>

<p>Extraction functions for objects of class 'garchx'</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'garchx'
coef(object, ...)
  ## S3 method for class 'garchx'
fitted(object, as.zoo = TRUE, ...)
  ## S3 method for class 'garchx'
logLik(object, ...)
  ## S3 method for class 'garchx'
nobs(object, ...)
  ## S3 method for class 'garchx'
predict(object, n.ahead = 10, newxreg = NULL,
    newindex = NULL, n.sim = NULL, verbose = FALSE, ...)
  ## S3 method for class 'garchx'
print(x, ...)
  ## S3 method for class 'garchx'
quantile(x, probs=0.025, names = TRUE, type = 7, as.zoo = TRUE, ...)
  ## S3 method for class 'garchx'
residuals(object, as.zoo = TRUE, ...)
  ## S3 method for class 'garchx'
toLatex(object, digits = 4, ...)
  ## S3 method for class 'garchx'
vcov(object, vcov.type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class 'garchx'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class 'garchx'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.zoo</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the returned result is of class <code>zoo</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ahead</code></td>
<td>
<p><code>integer</code> that determines how many steps ahead predictions should be generated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newxreg</code></td>
<td>
<p><code>vector</code> or <code>matrix</code> with the out-of-sample regressor values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newindex</code></td>
<td>
<p><code>zoo</code>-index for the out-of-sample predictions. If <code>NULL</code> (default), then <code>1:n.ahead</code> is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p><code>NULL</code> or an <code>integer</code>, the number of simulations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, then the simulations - in addition to the predictions - are returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p><code>vector</code> of probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p><code>logical</code>, whether to return names or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><code>integer</code> that determines the algorithm used to compute the quantile, see <code>quantile</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p><code>integer</code>, the number of digits in the printed LaTeX code</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov.type</code></td>
<td>
<p><code>NULL</code> or a <code>character</code> that is (partially) matched to <code>"ordinary"</code> or <code>"robust"</code>. The robust coefficient-covariance is that of Francq and Thieu (2018).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coef:</code></td>
<td>
<p>numeric vector containing parameter estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted:</code></td>
<td>
<p>fitted conditional variance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLik:</code></td>
<td>
<p>log-likelihood (normal density)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs:</code></td>
<td>
<p>the number of observations used in the estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict:</code></td>
<td>
<p>a <code>vector</code> with the predictions (<code>verbose=FALSE</code>), or a <code>matrix</code> with both the predictions and the simulations (<code>verbose=TRUE</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print:</code></td>
<td>
<p>print of the estimation results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantile:</code></td>
<td>
<p>the fitted quantiles, i.e. the conditional standard deviation times the empirical quantile of the standardised innovations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals:</code></td>
<td>
<p>standardised residuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov:</code></td>
<td>
<p>coefficient variance-covariance matrix</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a>
</p>


<h3>References</h3>

<p>Christian Francq and Le Quien Thieu (2018): 'QML inference for volatility models with covariates', Econometric Theory, doi:10.1017/S0266466617000512
</p>


<h3>See Also</h3>

<p><code>garchx</code>, <code>garchxSim</code>, <code>zoo</code></p>


<h3>Examples</h3>

<pre><code class="language-R">##simulate from a garch(1,1):
set.seed(123)
y &lt;- garchxSim(1000)

##estimate garch(1,1) model:
mymod &lt;- garchx(y)

##print estimation results:
print(mymod)

##extract coefficients:
coef(mymod)

##extract and store conditional variances:
sigma2hat &lt;- fitted(mymod)

##extract log-likelihood:
logLik(mymod)

##extract and store standardised residuals:
etahat &lt;- residuals(mymod)

##extract coefficient variance-covariance matrix:
vcov(mymod)

##generate predictions:
predict(mymod)

</code></pre>


</div>