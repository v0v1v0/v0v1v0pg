<div class="container">

<table style="width: 100%;"><tr>
<td>summary.gips</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summarizing the gips object</h2>

<h3>Description</h3>

<p><code>summary</code> method for <code>gips</code> class.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'gips'
summary(object, ...)

## S3 method for class 'summary.gips'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>gips</code>. Usually, a result of a <code>find_MAP()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>summary.gips</code> to be printed</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function <code>summary.gips()</code> computes and returns a list of summary
statistics of the given <code>gips</code> object. Those are:
</p>

<ul>
<li>
<p> For unoptimized <code>gips</code> object:
</p>

<ol>
<li> <p><code>optimized</code> - <code>FALSE</code>.
</p>
</li>
<li> <p><code>start_permutation</code> - the permutation this <code>gips</code> represents.
</p>
</li>
<li> <p><code>start_permutation_log_posteriori</code> - the log of the a posteriori
value the start permutation has.
</p>
</li>
<li> <p><code>times_more_likely_than_id</code> - how many more likely
the <code>start_permutation</code> is over the identity permutation, <code style="white-space: pre;">⁠()⁠</code>.
It can be less than 1, meaning the identity permutation
is more likely. Remember that this number can big and
overflow to <code>Inf</code> or small and underflow to 0.
</p>
</li>
<li> <p><code>n0</code> - the minimum number of observations needed for
the covariance matrix's maximum likelihood estimator
(corresponding to a MAP) to exist. See <strong><code class="reqn">C\sigma</code> and <code>n0</code></strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>.
</p>
</li>
<li> <p><code>S_matrix</code> - the underlying matrix.
This matrix will be used in calculations of
the posteriori value in <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code>number_of_observations</code> - the number of observations that
were observed for the <code>S_matrix</code> to be calculated.
This value will be used in calculations of
the posteriori value in <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code>was_mean_estimated</code> - given by the user while creating the <code>gips</code> object:
</p>

<ul>
<li> <p><code>TRUE</code> means the <code>S</code> parameter was the output of <code>stats::cov()</code> function;
</p>
</li>
<li> <p><code>FALSE</code> means the <code>S</code> parameter was calculated with
<code>S = t(X) %*% X / number_of_observations</code>.
</p>
</li>
</ul>
</li>
<li> <p><code>delta</code>, <code>D_matrix</code> - the hyperparameters of the Bayesian method.
See the <strong>Hyperparameters</strong> section of <code>gips()</code> documentation.
</p>
</li>
<li> <p><code>AIC</code>, <code>BIC</code> - output of <code>AIC.gips()</code> and <code>BIC.gips()</code> functions.
</p>
</li>
<li> <p><code>n_parameters</code> - number of free parameters in the covariance matrix.
</p>
</li>
</ol>
</li>
<li>
<p> For optimized <code>gips</code> object:
</p>

<ol>
<li> <p><code>optimized</code> - <code>TRUE</code>.
</p>
</li>
<li> <p><code>found_permutation</code> - the permutation this <code>gips</code> represents.
The visited permutation with the biggest a posteriori value.
</p>
</li>
<li> <p><code>found_permutation_log_posteriori</code> - the log of the a posteriori
value the found permutation has.
</p>
</li>
<li> <p><code>start_permutation</code> - the original permutation this <code>gips</code>
represented before optimization. It is the first visited permutation.
</p>
</li>
<li> <p><code>start_permutation_log_posteriori</code> - the log of the a posteriori
value the start permutation has.
</p>
</li>
<li> <p><code>times_more_likely_than_start</code> - how many more likely
the <code>found_permutation</code> is over the <code>start_permutation</code>.
It cannot be a number less than 1.
Remember that this number can big and overflow to <code>Inf</code>.
</p>
</li>
<li> <p><code>n0</code> - the minimal number of observations needed for the existence of
the maximum likelihood estimator (corresponding to a MAP) of
the covariance matrix (see <strong><code class="reqn">C\sigma</code> and <code>n0</code></strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
</p>
</li>
<li> <p><code>S_matrix</code> - the underlying matrix.
This matrix will be used in calculations of
the posteriori value in <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code>number_of_observations</code> - the number of observations that
were observed for the <code>S_matrix</code> to be calculated.
This value will be used in calculations of
the posteriori value in <code>log_posteriori_of_gips()</code>.
</p>
</li>
<li> <p><code>was_mean_estimated</code> - given by the user while creating the <code>gips</code> object:
</p>

<ul>
<li> <p><code>TRUE</code> means the <code>S</code> parameter was output of the <code>stats::cov()</code> function;
</p>
</li>
<li> <p><code>FALSE</code> means the <code>S</code> parameter was calculated with
<code>S = t(X) %*% X / number_of_observations</code>.
</p>
</li>
</ul>
</li>
<li> <p><code>delta</code>, <code>D_matrix</code> - the hyperparameters of the Bayesian method.
See the <strong>Hyperparameters</strong> section of <code>gips()</code> documentation.
</p>
</li>
<li> <p><code>AIC</code>, <code>BIC</code> - output of <code>AIC.gips()</code> and <code>BIC.gips()</code> functions.
</p>
</li>
<li> <p><code>n_parameters</code> - number of free parameters in the covariance matrix.
</p>
</li>
<li> <p><code>optimization_algorithm_used</code> - all used optimization algorithms
in order (one could start optimization with "MH", and then
do an "HC").
</p>
</li>
<li> <p><code>did_converge</code> - a boolean, did the last used algorithm converge.
</p>
</li>
<li> <p><code>number_of_log_posteriori_calls</code> - how many times was
the <code>log_posteriori_of_gips()</code> function called during
the optimization.
</p>
</li>
<li> <p><code>whole_optimization_time</code> - how long was the optimization process;
the sum of all optimization times (when there were multiple).
</p>
</li>
<li> <p><code>log_posteriori_calls_after_best</code> - how many times was
the <code>log_posteriori_of_gips()</code> function called after
the <code>found_permutation</code>; in other words, how long ago
could the optimization be stopped and have the same result.
If this value is small, consider running <code>find_MAP()</code>
again with <code>optimizer = "continue"</code>.
For <code>optimizer = "BF"</code>, it is <code>NULL</code>.
</p>
</li>
<li> <p><code>acceptance_rate</code> - only interesting for <code>optimizer = "MH"</code>.
How often was the algorithm accepting the change of permutation
in an iteration.
</p>
</li>
</ol>
</li>
</ul>
<p>The function <code>print.summary.gips()</code> returns an invisible <code>NULL</code>.
</p>


<h3>Methods (by generic)</h3>


<ul><li> <p><code>print(summary.gips)</code>: Printing method for class <code>summary.gips</code>.
Prints every interesting information in a form pleasant for humans.
</p>
</li></ul>
<h3>See Also</h3>


<ul>
<li> <p><code>find_MAP()</code> - Usually, the <code>summary.gips()</code>
is called on the output of <code>find_MAP()</code>.
</p>
</li>
<li> <p><code>log_posteriori_of_gips()</code> - Calculate
the likelihood of a permutation.
</p>
</li>
<li> <p><code>AIC.gips()</code>, <code>BIC.gips()</code> - Calculate
Akaike's or Bayesian Information Criterion
</p>
</li>
<li> <p><code>project_matrix()</code> - Project the known
matrix on the found permutations space.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">require("MASS") # for mvrnorm()

perm_size &lt;- 6
mu &lt;- runif(6, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.4, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.4, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6, 0.4,
    0.4, 0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.4, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.4, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5,6)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)

g_map &lt;- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "Metropolis_Hastings")
unclass(summary(g_map))

g_map2 &lt;- find_MAP(g, max_iter = 10, show_progress_bar = FALSE, optimizer = "hill_climbing")
summary(g_map2)
# ================================================================================
S &lt;- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE)
g &lt;- gips(S, 10)
print(summary(g))
</code></pre>


</div>