<div class="container">

<table style="width: 100%;"><tr>
<td>uwedge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>uwedge</h2>

<h3>Description</h3>

<p>Performs an approximate joint matrix diagonalization on a list of
matrices. More precisely, for a list of matrices Rx the algorithm
finds a matrix V such that for all i V Rx[i] t(V) is approximately
diagonal.
</p>


<h3>Usage</h3>

<pre><code class="language-R">uwedge(Rx, init = NA, rm_x0 = TRUE, return_diag = FALSE, tol = 1e-10,
  max_iter = 1000, n_components = NA, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Rx</code></td>
<td>
<p>list of matrices to be diagaonlized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>matrix used in first step of initialization. If NA a
default based on PCA is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rm_x0</code></td>
<td>
<p>boolean whether to also diagonalize first matrix in
<code>Rx</code> or only use it for scaling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_diag</code></td>
<td>
<p>boolean. Specifies whether to return the list
of diagonalized matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>float, optional. Tolerance for terminating the
iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>int, optional. Maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_components</code></td>
<td>
<p>number of components to extract. If NA is
passed, all components are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>boolean whether to supress status outputs.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For further details see the references.
</p>


<h3>Value</h3>

<p>object of class 'uwedge' consisting of the following
elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>joint diagonalizing matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rxdiag</code></td>
<td>
<p>list of diagonalized matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>boolean specifying whether the algorithm
converged for the given <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>number of iterations of the approximate joint
diagonalisation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanoffdiag</code></td>
<td>
<p>mean absolute value of the off-diagonal values
of the to be jointly diagonalised matrices, i.e., a proxy of the
approximate joint diagonalisation objective function.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Niklas Pfister and Sebastian Weichwald
</p>


<h3>References</h3>

<p>Pfister, N., S. Weichwald, P. Bühlmann and B. Schölkopf (2017).
GroupICA: Independent Component Analysis for grouped data.
ArXiv e-prints (arXiv:1806.01094).
</p>
<p>Tichavsky, P. and Yeredor, A. (2009).
Fast Approximate Joint Diagonalization Incorporating Weight Matrices.
IEEE Transactions on Signal Processing.
</p>


<h3>See Also</h3>

<p>The function <code>groupICA</code> uses <code>uwedge</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example
set.seed(1)

# Generate data 20 matrix that can be jointly diagonalized
d &lt;- 10
A &lt;- matrix(rnorm(d*d), d, d)
A &lt;- A%*%t(A)
Rx &lt;- lapply(1:20, function(x) A %*% diag(rnorm(d)) %*% t(A))

# Perform approximate joint diagonalization
ptm &lt;- proc.time()
res &lt;- uwedge(Rx,
              rm_x0=FALSE,
              return_diag=TRUE,
              max_iter=1000)
print(proc.time()-ptm)

# Average value of offdiagonal elements:
print(res$meanoffdiag)
</code></pre>


</div>