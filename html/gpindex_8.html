<div class="container">

<table style="width: 100%;"><tr>
<td>back_period</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Offset a vector prices or quantities</h2>

<h3>Description</h3>

<p>For each product, compute either the position of the previous period (back
period), or the position of the first period (base period). Useful when price
information is stored in a table.
</p>


<h3>Usage</h3>

<pre><code class="language-R">back_period(period, product = gl(1, length(period)), match_first = TRUE)

base_period(period, product = gl(1, length(period)), match_first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the time period for each transaction. The ordering of time periods
follows the levels of <code>period</code> to agree with
<code>cut()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>product</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the product identifier for each transaction. The default is to assume
that all transactions are for the same product.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match_first</code></td>
<td>
<p>Should products in the first period match with
themselves (the default)?</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Both functions return a numeric vector of indices for the back/base periods.
With <code>back_period()</code>, for all periods after the first, the resulting vector
gives the location of the corresponding product in the previous period.
With <code>base_period()</code>, the resulting vector gives the location of the
corresponding product in the first period. The locations are unchanged for
the first time period if <code>match_first = TRUE</code>, <code>NA</code> otherwise.
</p>


<h3>Note</h3>

<p>By definition, there must be at most one transaction for each product
in each time period to determine a back/base period. If multiple transactions
correspond to a period-product pair, then the back/base period at a point in
time is always the first position for that product in the previous period.
</p>


<h3>See Also</h3>

<p>outliers for common methods to detect outliers for price relatives.
</p>
<p><code>rs_pairs</code> in the <span class="pkg">rsmatrix</span> package for making sales pairs.
</p>


<h3>Examples</h3>

<pre><code class="language-R">df &lt;- data.frame(
  price = 1:6,
  product = factor(c("a", "b")),
  period = factor(c(1, 1, 2, 2, 3, 3))
)

with(df, back_period(period, product))

# Make period-over-period price relatives

with(df, price / price[back_period(period, product)])

# Make fixed-base price relatives

with(df, price / price[base_period(period, product)])

# Change the base period with relevel()

with(df, price / price[base_period(relevel(period, "2"), product)])

# Warning is given if the same product has multiple prices
# at any point in time

with(df, back_period(period))

</code></pre>


</div>