<div class="container">

<table style="width: 100%;"><tr>
<td>GrammaticalEvolution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Grammatical Evolution</h2>

<h3>Description</h3>

<p>Evolves an expression using a context-free grammar
to minimize a given cost function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GrammaticalEvolution(grammarDef, evalFunc, 
              numExpr = 1, 
              max.depth = GrammarGetDepth(grammarDef),
              startSymb = GrammarStartSymbol(grammarDef),
              seqLen = GrammarMaxSequenceLen(grammarDef, max.depth, startSymb),
              wrappings = 3, 
              suggestions = NULL,
              optimizer = c("auto", "es", "ga"),
              popSize = "auto", newPerGen = "auto", elitism = 2,
              mutationChance = NA,
              iterations = "auto",
              terminationCost = NA,
              monitorFunc = NULL,
              disable.warnings=FALSE,
              plapply = lapply, ...)

## S3 method for class 'GrammaticalEvolution'
print(x, ..., show.genome = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>grammarDef</code></td>
<td>

<p>A <code>grammar</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evalFunc</code></td>
<td>

<p>The cost function, taking a string or a collection of strings
containing the expression(s) as its input
and returning the cost of the expression(s).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numExpr</code></td>
<td>

<p>Number of expressions generated and given to <code>evalFunc</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.depth</code></td>
<td>

<p>Maximum depth of search in case of a cyclic grammar. 
By default it is limited to the number of production rules in the grammar.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startSymb</code></td>
<td>

<p>The symbol where the generation of a new expression should start.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seqLen</code></td>
<td>

<p>Length of integer vector used to create the expression.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrappings</code></td>
<td>

<p>Number of wrappings in case the length of chromosome is not enough for conversion to an expression.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suggestions</code></td>
<td>

<p>Suggested chromosomes to be added to the initial population pool. if <code>optimizer</code> parameter is set to <code>"es"</code>, 
only a single chromosome (as a numeric vector) is acceptable. For <code>"ga"</code> mode, a list of numeric vectors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>

<p>The evolutionary optimizer. <code>"es"</code> uses evolution strategy as in <code>EvolutionStrategy.int</code>
and <code>"ga"</code> uses genetic algorithm as in <code>GeneticAlg.int</code>. 
<code>"auto"</code> chooses evolution strategy when <code>numExpr = 1</code>, and genetic algorithm otherwise.
If <code>"auto"</code> is used, <code>popSize</code> and <code>iterations</code> are tweaked based on the grammar as well.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popSize</code></td>
<td>

<p>Population size in the evolutionary optimizer. By default, 8 for ES and 48 for GA.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newPerGen</code></td>
<td>

<p>Number of randomly generated individuals in evolution strategy.
If â€œauto", it is set to 25% of population of grammar if it is not recursive,
otherwise to all of it.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elitism</code></td>
<td>

<p>Number of top ranking chromosomes that are directly transfered to the next generation without
going through evolutionary operations, used in genetic algorithm optimizer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>

<p>Number of maximum iterations in the evolutionary optimizer. By default, 1000 for <code>"es"</code>
optimizer and 200 for <code>"ga"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terminationCost</code></td>
<td>

<p>Target cost. If a sequence with this cost or less is found,
the algorithm terminates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutationChance</code></td>
<td>

<p>Mutation chance in the evolutionary optimizer. It must be between 0 and 1.
By default it is set to <code>1/(1+chromosome size))</code> for genetic algorithm and
<code>10/(1+chromosome size))</code> for evolution strategy.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monitorFunc</code></td>
<td>

<p>A function that is called at each generation. It can be used to monitor evolution of population.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>disable.warnings</code></td>
<td>

<p>If <code>TRUE</code>, suppresses any warnings generated while evaulating <code>evalFunc</code>s.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plapply</code></td>
<td>

<p><code>lapply</code> function used for mapping chromosomes to the cost function.
See details for parallelization tips.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional parameters are passed to <code>GeneticAlg.int</code> or <code>EvolutionStrategy.int</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Grammatical Evolution results.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.genome</code></td>
<td>

<p>Prints the numeric value of genome if TRUE.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs an evolutionary search over the grammar, better known as Grammatical Evolution.
It evolves integer sequences and converts them to a collection containing
<code>numExpr</code> expression. These expressions can be evaluated using <code>eval</code> function.
The <code>evalFunc</code> receives these expressions and must return a numeric value.
The goal of optimization would be to find a chromosome which minimizes this function.
</p>
<p>Two evolutionary optimizers are supported: Genetic algorithm and evolution strategy,
which are set by the <code>optimizer</code> parameter.
</p>
<p>Only valid (i.e., terminal) expressions are passed to <code>evalFunc</code>,
and it is guaranteed that <code>evalFunc</code> receives at least one expression.
</p>
<p>If the grammar contains recursive elements, it is advisable that <code>chromosomeLen</code> is 
defined manually, as in such cases the possible search space grows explosively
with the recursion. The evolutionary algorithm automatically removes
the recursive chromosomes from the population by imposing a penalty for
chromosomes creating expressions with non-terminal elements.
</p>
<p><code>monitorFunc</code> receives a list similar to the <code>GrammaticalEvolution</code>'s return value.
</p>


<h3>Value</h3>

<p>The results of <code>GeneticAlg.int</code> or <code>EvolutionStrategy.int</code> with an additional item:
</p>
<table><tr style="vertical-align: top;">
<td><code>best$expressions</code></td>
<td>
<p>Expression(s) with the best cost.</p>
</td>
</tr></table>
<h3>See Also</h3>

<p><code>CreateGrammar</code>, 
<code>GeneticAlg.int</code>,
<code>EvolutionStrategy.int</code>,
<code>EvalExpressions</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Grammar Definition
ruleDef &lt;- list(expr     = gsrule("&lt;der.expr&gt;&lt;op&gt;&lt;der.expr&gt;"),
                der.expr = grule(func(var), var),
                func     = grule(log, exp, sin, cos),
                op       = gsrule("+", "-", "*"),
                var      = grule(A, B, n),
                n        = grule(1, 2, 3, 4))

# Creating the grammar object
grammarDef &lt;- CreateGrammar(ruleDef)

# cost function
evalFunc &lt;- function(expr) {
  # expr: a string containing a symbolic expression
  # returns: Symbolic regression Error
  A &lt;- 1:6
  B &lt;- c(2, 5, 8, 3, 4, 1)
  
  result &lt;- eval(as.expression(expr))
  
  X &lt;- log(A) * B
  err &lt;- sum((result - X)^2)
  
  return(err)
}

# invoke grammatical evolution (with default parameters)
ge &lt;- GrammaticalEvolution(grammarDef, evalFunc, terminationCost = 0.001)

# print results
print(ge, sequence = TRUE)
</code></pre>


</div>