<div class="container">

<table style="width: 100%;"><tr>
<td>fun.auto.bimodal.ml</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Fitting mixture of generalied lambda distribtions to data using maximum 
likelihood estimation via the EM algorithm </h2>

<h3>Description</h3>

<p>This function will fit mixture of generalised lambda distributions to dataset. 
It is restricted to two generalised lambda distributions. The method of fitting 
is maximum likelihood via EM algorithm. It is a two step optimization procedure, 
each unimodal part of the bimodal distribution is modelled using the maximum 
likelihood method or the starship method (FMKL GLD only), these initial values 
are the used to maximise the likelihood  for the entire bimodal distribution 
using the EM algorithm. It fits mixture of the form p*(f1)+(1-p)*(f2) where f1 
and f2 are pdfs of the generalised lambda distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fun.auto.bimodal.ml(data, per.of.mix = 0.01, clustering.m = clara, 
init1.sel = "rprs", init2.sel = "rprs", init1=c(-1.5, 1.5), init2=c(-1.5, 1.5), 
leap1=3, leap2=3,fun1="runif.sobol",fun2="runif.sobol",no=10000, max.it=5000,
optim.further="Y") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> A numerical vector representing the dataset. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>per.of.mix</code></td>
<td>
<p> Level of mix between two parts of the distribution, 
usually 1-2% of cross mix is sufficient. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustering.m</code></td>
<td>
<p> Clustering method used in classifying the dataset into 
two parts. Valid arguments include clara, fanny and pam from the cluster 
library. Default is clara. Or a logical vector specifying how data should
be split. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init1.sel</code></td>
<td>
<p> This can be <code>"rprs"</code>, <code>"rmfmkl"</code> or <code>"star"</code>, 
the initial method used to fit the first distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init2.sel</code></td>
<td>
<p> This can be <code>"rprs"</code>, <code>"rmfmkl"</code> or <code>"star"</code>, 
the initial method used to fit the second distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init1</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the first generalised 
lambda distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init2</code></td>
<td>
<p> Inititial values lambda3 and lambda4 for the second generalised 
lambda distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap1</code></td>
<td>
<p> See scrambling argument in <code>fun.gen.qrn</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun1</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap2</code></td>
<td>
<p> See scrambling argument in <code>fun.gen.qrn</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun2</code></td>
<td>
<p> A character string of either  <code>"runif.sobol"</code> (default), <code>"runif.sobol.owen"</code>, 
<code>"runif.halton"</code> or <code>"QUnif"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no</code></td>
<td>
<p> Number of initial random values to find the best initial values 
for optimisation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.it</code></td>
<td>
<p> Maximum number of iterations for numerical optimisation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.further</code></td>
<td>
<p>Whether to optimise the function further using full 
maximum likelihood method, recommended setting is "Y"</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The initial values that work well for RPRS are <code>c(-1.5,1.5)</code> and for RMFMKL 
are <code>c(-0.25,1.5)</code>. For scrambling, if <code>1</code>, <code>2</code> or <code>3</code> the 
sequence is scrambled otherwise not. If <code>1</code>, Owen type type of scrambling 
is applied, if <code>2</code>, Faure-Tezuka type of scrambling, is applied, and if 
<code>3</code>, both Owen+Faure-Tezuka type of scrambling is applied. The <code>star</code> 
method uses the same initial values as <code>rmfmkl</code> since it uses the FMKL 
generalised lambda distribution. Nelder-Simplex algorithm is used in the 
numerical optimization. <code>rprs</code> stands for revised percentile method for 
RS generalised lambda distribution and "rmfmkl" stands for revised method of 
moment for FMKL generalised lambda distribution. These acronyms represents the 
initial optimization algorithm used to get a reasonable set of initial values 
for the subsequent optimization procedues.
This function is an improvement from Su (2007) in Journal of Statistical 
Software.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p> The best set of parameters found, the first four corresponds to the 
first distribution fit, the second four corresponds to the second distribution 
fit, the last value correspond to p for the first distribution fit. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p> The value of -ML for the paramters obtained. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p> A two-element integer vector giving the number of calls to 
<code>fn</code> and <code>gr</code> respectively. This excludes those calls needed to 
compute the Hessian, if requested, and any calls to <code>fn</code> to compute a 
finite-difference approximation to the gradient. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
 <p><code>0</code> indicates successful convergence, <code>1</code> 
indicates the iteration limit <code>maxit</code> had been reached, <code>10</code> indicates 
degeneracy of the Nelder-Mead simplex. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p> A character string giving any additional information returned by 
the optimizer, or <code>NULL</code>. </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p> If the number of observations is small, 
<code>rprs</code> can sometimes fail as the percentiles may not exist for this data. 
Also, if the initial values do not span a valid generalised lambda distribution, 
try another set of initial values. </p>


<h3>Author(s)</h3>

<p> Steve Su </p>


<h3>References</h3>

 
<p>Bratley P. and Fox B.L. (1988) Algorithm 659: Implementing Sobol's quasi random 
sequence generator, ACM Transactions on Mathematical Software 14, 88-100.
</p>
<p>Joe S. and Kuo F.Y. (1998) Remark on Algorithm 659: Implementing Sobol's quasi 
random Sequence Generator.
</p>
<p>Nelder, J. A. and Mead, R. (1965) A simplex algorithm for function minimization. 
Computer Journal *7*, 308-313.
</p>
<p>Su (2007). Fitting Single and Mixture of Generalized Lambda Distributions to 
Data via Discretized and Maximum Likelihood Methods: GLDEX in R. 
Journal of Statistical Software: *21* 9.
</p>


<h3>See Also</h3>

 <p><code>fun.auto.bimodal.pml</code>, <code>fun.plot.fit.bm</code>, 
<code>fun.diag.ks.g.bimodal</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">

# Fitting faithful data from the dataset library, with the clara clustering 
# regime. The first distribution is RS and the second distribution is fmkl. 
# The percentage of data mix is 1%.

fun.auto.bimodal.ml(faithful[,1],per.of.mix=0.01,clustering.m=clara,
init1.sel="rprs",init2.sel="rmfmkl",init1=c(-1.5,1,5),init2=c(-0.25,1.5),
leap1=3,leap2=3)


</code></pre>


</div>