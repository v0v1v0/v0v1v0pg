<div class="container">

<table style="width: 100%;"><tr>
<td>geo_midpoint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Point of Equidistance to Up to Three Longitude, Latitude Points</h2>

<h3>Description</h3>

<p>Generates a latitude and longitude point that is equidistant to up to three latitude and longitude points
</p>


<h3>Usage</h3>

<pre><code class="language-R">geo_midpoint(coordinate_matrix, alternative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coordinate_matrix</code></td>
<td>
<p>A matrix of latitude and longitude columns and up to three rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>Whether to use alternative line creation method. Could be needed when nearly inverse angles cause intersections to be ambiguous.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a vector of length 2 containing a latitude and longitude point.
</p>


<h3>Author(s)</h3>

<p>Shant Sukljian
</p>


<h3>See Also</h3>

<p><code>geo_sed</code> <code>geo_point_dist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Load required packages
require(mapview)
require(sp)

# Create sample geo dataset
sample_coord &lt;-
   matrix(
        c(
            sample(327131680:419648450, 3) / 10000000,
            sample(-1147301410:-1241938690, 3) / 10000000
        ),
        ncol = 2
    )

# Generate circumcenter and radius
gmp &lt;- geo_midpoint(sample_coord)

# Find distance to circumcenter
radius &lt;- geo_point_dist(rbind(sample_coord[1, ], gmp))

# Create 80 sided polygon based on gmp's center and radius
gmp_poly &lt;- geo_surround_poly(gmp, radius, 80)

# Join all the points into a single matrix
bound_poly &lt;- rbind(sample_coord, as.vector(gmp), gmp_poly)

# Create SpacialPoints object and pass to mapview for visualization
mapview(
    SpatialPoints(
        bound_poly[,c(2, 1)],
        proj4string = CRS("+proj=longlat +datum=WGS84")
    )
)


</code></pre>


</div>