<div class="container">

<table style="width: 100%;"><tr>
<td>parse_ast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parse AST</h2>

<h3>Description</h3>

<p>This is a helper function for Scalars.  Given a particular kind and a resolve
function, it produces a function that will only parse values of a particular
kind.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_ast(kind, resolve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>kind</code></td>
<td>
<p>single character name of a class to parse</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolve</code></td>
<td>
<p>function to parse the value if the kind is correct</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Typically, <code>kind</code> is the same as the class of the Scalar.  When making a
new Scalar, parse_ast defaults to use the name of the scalar and the scalar's
parse value function.
</p>
<p>This function should only need to be used when defining a schema in
<code>gqlr_schema()</code>
</p>


<h3>Value</h3>

<p>function that takes <code>obj</code> and <code>schema</code> that will only parse
the value if the <code>kind</code> is inherited in the <code>obj</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">parse_date_value &lt;- function(obj, schema) {
  as.Date(obj)
}
parse_ast("Date", parse_date_value)

# Example from Int scalar
parse_int &lt;- function(value, ...) {
  MAX_INT &lt;-  2147483647
  MIN_INT &lt;- -2147483648
  num &lt;- suppressWarnings(as.integer(value))
  if (!is.na(num)) {
    if (num &lt;= MAX_INT &amp;&amp; num &gt;= MIN_INT) {
      return(num)
    }
  }
  return(NULL)
}
parse_ast("IntValue", parse_int)
</code></pre>


</div>