<div class="container">

<table style="width: 100%;"><tr>
<td>computeQs_from_segments</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>return the admixture fractions of sampled individuals</h2>

<h3>Description</h3>

<p>This operates on the output of segregate to add up the lengths
of all the segments segregated to different individuals to
thus compute the admixture fractions of each sampled
individual.
</p>


<h3>Usage</h3>

<pre><code class="language-R">computeQs_from_segments(S, check_total_length = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>the tibble output from <code>segregate</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_total_length</code></td>
<td>
<p>TRUE means it checks the total
genome length in each individual to make sure it checks out.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This function returns a tibble with the following columns:
</p>

<ul>
<li> <p><code>gpp</code>: the genomic simulation pedigree within which the individual sample was
simulated.
</p>
</li>
<li> <p><code>index</code>: the index which gives which instance of the GSP the sample is from
</p>
</li>
<li> <p><code>ped_sample_id</code>: the id number of that the sampled individual had in the
genomic simulation pedigree.
</p>
</li>
<li> <p><code>samp_index</code>: the index of the sample taken.  Some individuals in some
genomic simulation pedigrees can produce more than one sample. This number
tells you which sample it is.
</p>
</li>
<li> <p><code>pop_origin</code>: the "pedigree" population of origin of the segments that contributed
to the <code>group_length</code>.  These are
the simple "A", "B", "C", etc. designations given in the genomic simulation
pedigree.
</p>
</li>
<li> <p><code>group_origin</code>: Which group of samples the segments contributing to
the <code>group_length</code> originated from.  These are the groups of samples
that were mapped onto the simple pedigree <code>pop_origin</code>s by the reppop
request.
</p>
</li>
<li> <p><code>group_length</code>: the total length of segments from this group in this individual
in this reppop index from this gpp (in bases).
</p>
</li>
<li> <p><code>tot_length</code>: the total number of bases from all origins carried by this
individual.
</p>
</li>
<li> <p><code>admixture_fraction</code>: the fraction of all bases in the simulated individual
that originate from the group in <code>group_origin</code>.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">#### Get output from segregate to use as input ####
# We construct an example here where we will request segregation
# down a GSP with two F1s and F1B backcrosses between two hypothetical
# populations, A and B.
gsp_f1f1b &lt;- create_GSP("A", "B", F1 = TRUE, F1B = TRUE)

# We will imagine that in our marker data there are three groups
# labelled "grp1", "grp2", and "grp3", and we want to create the F1Bs with backcrossing
# only to grp3.
reppop &lt;- tibble::tibble(
  index = as.integer(c(1, 1, 2, 2)),
  pop = c("A", "B", "A", "B"),
  group = c("grp3", "grp1", "grp3", "grp2")
)

# combine those into a request
request &lt;- tibble::tibble(
  gpp = list(gsp_f1f1b),
  reppop = list(reppop)
)

# now run it through segregate()
set.seed(5)  # just for reproducibility in example...
simSegs &lt;- segregate(request, RecRates)

#### Now we can run those through computeQs_from_segments() ####
Qs &lt;- computeQs_from_segments(simSegs)

Qs
</code></pre>


</div>