<div class="container">

<table style="width: 100%;"><tr>
<td>pso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Particle Swarm Optimization</h2>

<h3>Description</h3>

<p>This function allows to use particle swarm algorithm for
numeric global optimization of real-valued functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pso(
  fn,
  gr = NULL,
  lower,
  upper,
  pop.n = 40,
  pop.initial = NULL,
  pop.method = "uniform",
  nh.method = "random",
  nh.par = 3,
  nh.adaptive = TRUE,
  velocity.method = "hypersphere",
  velocity.par = list(w = 1/(2 * log(2)), c1 = 0.5 + log(2), c2 = 0.5 + log(2)),
  hybrid.method = "rank",
  hybrid.par = 2,
  hybrid.prob = 0,
  hybrid.opt.par = NULL,
  hybrid.n = 1,
  constr.method = NULL,
  constr.par = NULL,
  random.order = TRUE,
  maxiter = 100,
  is.max = TRUE,
  info = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>function to be maximized i.e. fitness function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>gradient of the <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>lower bound of the search space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>upper bound of the search space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop.n</code></td>
<td>
<p>integer representing the size of the population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop.initial</code></td>
<td>
<p>numeric matrix which rows are particles to be
included into the initial population. Numeric vector will be coerced to
single row matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop.method</code></td>
<td>
<p>the algorithm to be applied for a creation of 
the initial population. See 'Details' for additional information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nh.method</code></td>
<td>
<p>string representing the method (topology) to be used for
the creation of neighbourhoods. See 'Details' for additional information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nh.par</code></td>
<td>
<p>parameters of the topology algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nh.adaptive</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then neighbourhoods
change every time when the best known (to the swarm) fitnesses value have
not increased. Neighbourhoods are updated according to the topology
defined via <code>nh.method</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>velocity.method</code></td>
<td>
<p>string representing the method to be used for
the update of velocities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>velocity.par</code></td>
<td>
<p>parameters of the velocity formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid.method</code></td>
<td>
<p>hybrids selection algorithm i.e. mechanism 
determining which particles should be subject to local optimization.
See 'Details' for additional information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid.par</code></td>
<td>
<p>parameters of the hybridization algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid.prob</code></td>
<td>
<p>probability of generating the hybrids each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid.opt.par</code></td>
<td>
<p>parameters of the local optimization function
to be used for hybridization algorithm (including <code>fn</code> and <code>gr</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hybrid.n</code></td>
<td>
<p>number of hybrids that appear if hybridization
should take place during the iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr.method</code></td>
<td>
<p>the algorithm to be applied for imposing constraints
on the particles. See 'Details' for additional information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr.par</code></td>
<td>
<p>parameters of the constraint algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.order</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then particles
related routine will be implemented in a random order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.max</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then fitness function
will be maximized. Otherwise it will be minimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) then some optimization related 
information will be printed each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters to be passed to 
<code>fn</code> and <code>gr</code> functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Default arguments have been set in accordance with SPSO 2011
algorithm proposed by M. Clerc (2012).
</p>
<p>To find information on particular methods available via
<code>pop.method</code>, <code>nh.method</code>, <code>velocity.method</code>,
<code>hybrid.method</code> and <code>constr.method</code>
arguments please see 'Details' section of 
<code>gena.population</code>, <code>pso.nh</code>,
<code>pso.velocity</code>, <code>gena.hybrid</code> 
and <code>gena.constr</code> correspondingly.
</p>
<p>It is possible to provide manually implemented functions for population
initialization, neighbourhoods creation, velocity updated, hybridization
and constraints in a similar way as for <code>gena</code>.
</p>
<p>By default function does not impose any constraints upon the parameters.
If <code>constr.method = "bounds"</code> then <code>lower</code> and <code>upper</code> 
constraints will be imposed. Lower bounds should be strictly smaller
then upper bounds.
</p>
<p>Currently the only available termination condition is <code>maxiter</code>. We
are going to provide some additional termination conditions during
future updates.
</p>
<p>Infinite values in <code>lower</code> and <code>upper</code> are substituted with
<code>-(.Machine$double.xmax * 0.9)</code> and <code>.Machine$double.xmax * 0.9</code>
correspondingly.
</p>
<p>By default if <code>gr</code> is provided then BFGS algorithm will be used inside
<code>optim</code> during hybridization.
Otherwise <code>Nelder-Mead</code> will be used. 
Manual values for <code>optim</code> arguments may be provided 
(as a list) through <code>hybrid.opt.par</code> argument.
</p>
<p>For more information on particle swarm optimization 
please see M. Clerc (2012).
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>pso</code> that is a list
containing the following elements:
</p>

<ul>
<li> <p><code>par</code> - particle (solution) with the highest fitness
(objective function) value.
</p>
</li>
<li> <p><code>value</code> - value of <code>fn</code> at <code>par</code>.
</p>
</li>
<li> <p><code>population</code> - matrix of particles (solutions) of the 
last iteration of the algorithm.
</p>
</li>
<li> <p><code>counts</code> - a two-element integer vector giving the number of
calls to <code>fn</code> and <code>gr</code> respectively.
</p>
</li>
<li> <p><code>is.max</code> - identical to <code>is.max</code> input argument.
</p>
</li>
<li> <p><code>fitness.history</code> - vector which i-th element is fitness
of the best particle in i-th iteration.
</p>
</li>
<li> <p><code>iter</code> - last iteration number.
</p>
</li>
</ul>
<h3>References</h3>

<p>M. Clerc (2012). 
Standard Particle Swarm Optimisation.
<em>HAL archieve</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Consider Ackley function

fn &lt;- function(par, a = 20, b = 0.2)
{
  val &lt;- a * exp(-b * sqrt(0.5 * (par[1] ^ 2 + par[2] ^ 2))) +
         exp(0.5 * (cos(2 * pi * par[1]) + cos(2 * pi * par[2]))) -
         exp(1) - a
  return(val)
}

# Maximize this function using particle swarm algorithm

set.seed(123)
lower &lt;- c(-5, -100)
upper &lt;- c(100, 5)
opt &lt;- pso(fn = fn, 
           lower = lower, upper = upper,
           a = 20, b = 0.2)
print(opt$par)


## Consider Bukin function number 6

fn &lt;- function(x, a = 20, b = 0.2)
{
  val &lt;- 100 * sqrt(abs(x[2] - 0.01 * x[1] ^ 2)) + 0.01 * abs(x[1] + 10)
  return(val)
}

# Minimize this function using initially provided
# position for one of the particles
set.seed(777)
lower &lt;- c(-15, -3)
upper &lt;- c(-5, 3)
opt &lt;- pso(fn = fn, 
           pop.init = c(8, 2),
           lower = lower, upper = upper,
           is.max = FALSE)
print(opt$par)

</code></pre>


</div>