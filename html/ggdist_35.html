<div class="container">

<table style="width: 100%;"><tr>
<td>density_bounded</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bounded density estimator using the reflection method</h2>

<h3>Description</h3>

<p>Bounded density estimator using the reflection method.
</p>
<p>Supports automatic partial function application.
</p>


<h3>Usage</h3>

<pre><code class="language-R">density_bounded(
  x,
  weights = NULL,
  n = 512,
  bandwidth = "dpi",
  adjust = 1,
  kernel = "gaussian",
  trim = FALSE,
  bounds = c(NA, NA),
  bounder = "cdf",
  adapt = 1,
  na.rm = FALSE,
  ...,
  range_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector containing a sample to compute a density estimate for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of weights to apply to <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>numeric: the number of grid points to evaluate the density estimator at.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>bandwidth of the density estimator. One of:
</p>

<ul>
<li>
<p> a numeric: the bandwidth, as the standard deviation of the kernel
</p>
</li>
<li>
<p> a function: a function taking <code>x</code> (the sample) and returning the bandwidth
</p>
</li>
<li>
<p> a string: the suffix of the name of a function starting with <code>"bandwidth_"</code> that
will be used to determine the bandwidth. See bandwidth for a list.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>numeric: the bandwidth for the density estimator is multiplied
by this value. See <code>stats::density()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>string: the smoothing kernel to be used. This must partially
match one of <code>"gaussian"</code>, <code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code>, or <code>"optcosine"</code>. See <code>stats::density()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>Should the density estimate be trimmed to the bounds of the data?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>length-2 vector of min and max bounds. If a bound is <code>NA</code>, then
that bound is estimated from the data using the method specified by <code>bounder</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounder</code></td>
<td>
<p>Method to use to find missing (<code>NA</code>) <code>bounds</code>. A function that
takes a numeric vector of values and returns a length-2 vector of the estimated
lower and upper bound of the distribution. Can also be a string giving the
suffix of the name of such a function that starts with <code>"bounder_"</code>. Useful
values include:
</p>

<ul>
<li> <p><code>"cdf"</code>: Use the CDF of the the minimum and maximum order statistics of the
sample to estimate the bounds. See <code>bounder_cdf()</code>.
</p>
</li>
<li> <p><code>"cooke"</code>: Use the method from Cooke (1979); i.e. method 2.3 from Loh (1984).
See <code>bounder_cooke()</code>.
</p>
</li>
<li> <p><code>"range"</code>: Use the range of <code>x</code> (i.e the <code>min</code> or <code>max</code>). See <code>bounder_range()</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>(<strong>very experimental</strong>) The name and interpretation of this argument
are subject to change without notice. Positive integer. If <code>adapt &gt; 1</code>, uses
an adaptive approach to calculate the density. First, uses the
adaptive bandwidth algorithm of Abramson (1982) to determine local (pointwise)
bandwidths, then groups these bandwidths into <code>adapt</code> groups, then calculates
and sums the densities from each group. You can set this to a very large number
(e.g. <code>Inf</code>) for a fully adaptive approach, but this will be very slow; typically
something around 100 yields nearly identical results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing (<code>NA</code>) values in <code>x</code> be removed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range_only</code></td>
<td>
<p>If <code>TRUE</code>, the range of the output of this density estimator
is computed and is returned in the <code style="white-space: pre;">⁠$x⁠</code> element of the result, and <code>c(NA, NA)</code>
is returned in <code style="white-space: pre;">⁠$y⁠</code>. This gives a faster way to determine the range of the output
than <code>density_XXX(n = 2)</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"density"</code>, mimicking the output format of
<code>stats::density()</code>, with the following components:
</p>

<ul>
<li> <p><code>x</code>: The grid of points at which the density was estimated.
</p>
</li>
<li> <p><code>y</code>: The estimated density values.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth.
</p>
</li>
<li> <p><code>n</code>: The sample size of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>call</code>: The call used to produce the result, as a quoted expression.
</p>
</li>
<li> <p><code>data.name</code>: The deparsed name of the <code>x</code> input argument.
</p>
</li>
<li> <p><code>has.na</code>: Always <code>FALSE</code> (for compatibility).
</p>
</li>
<li> <p><code>cdf</code>: Values of the (possibly weighted) empirical cumulative distribution
function at <code>x</code>. See <code>weighted_ecdf()</code>.
</p>
</li>
</ul>
<p>This allows existing methods for density objects, like <code>print()</code> and <code>plot()</code>, to work if desired.
This output format (and in particular, the <code>x</code> and <code>y</code> components) is also
the format expected by the <code>density</code> argument of the <code>stat_slabinterval()</code>
and the <code>smooth_</code> family of functions.
</p>


<h3>References</h3>

<p>Cooke, P. (1979). Statistical inference for bounds of random variables.
<em>Biometrika</em> 66(2), 367–374. <a href="https://doi.org/10.1093/biomet/66.2.367">doi:10.1093/biomet/66.2.367</a>.
</p>
<p>Loh, W. Y. (1984). Estimating an endpoint of a distribution with resampling
methods. <em>The Annals of Statistics</em> 12(4), 1543–1550. <a href="https://doi.org/10.1214/aos/1176346811">doi:10.1214/aos/1176346811</a>
</p>


<h3>See Also</h3>

<p>Other density estimators: 
<code>density_histogram()</code>,
<code>density_unbounded()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(distributional)
library(dplyr)
library(ggplot2)

# For compatibility with existing code, the return type of density_bounded()
# is the same as stats::density(), ...
set.seed(123)
x = rbeta(5000, 1, 3)
d = density_bounded(x)
d

# ... thus, while designed for use with the `density` argument of
# stat_slabinterval(), output from density_bounded() can also be used with
# base::plot():
plot(d)

# here we'll use the same data as above, but pick either density_bounded()
# or density_unbounded() (which is equivalent to stats::density()). Notice
# how the bounded density (green) is biased near the boundary of the support,
# while the unbounded density is not.
data.frame(x) %&gt;%
  ggplot() +
  stat_slab(
    aes(xdist = dist), data = data.frame(dist = dist_beta(1, 3)),
    alpha = 0.25
  ) +
  stat_slab(aes(x), density = "bounded", fill = NA, color = "#d95f02", alpha = 0.5) +
  stat_slab(aes(x), density = "unbounded", fill = NA, color = "#1b9e77", alpha = 0.5) +
  scale_thickness_shared() +
  theme_ggdist()

# We can also supply arguments to the density estimators by using their
# full function names instead of the string suffix; e.g. we can supply
# the exact bounds of c(0,1) rather than using the bounds of the data.
data.frame(x) %&gt;%
  ggplot() +
  stat_slab(
    aes(xdist = dist), data = data.frame(dist = dist_beta(1, 3)),
    alpha = 0.25
  ) +
  stat_slab(
    aes(x), fill = NA, color = "#d95f02", alpha = 0.5,
    density = density_bounded(bounds = c(0,1))
  ) +
  scale_thickness_shared() +
  theme_ggdist()
</code></pre>


</div>