<div class="container">

<table style="width: 100%;"><tr>
<td>gamlssML</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum Likelihood estimation of a simple GAMLSS model </h2>

<h3>Description</h3>

<p>The function <code>gamlssML()</code> fits  a <code>gamlss.family</code> distribution to single  data set  using a non linear maximisation algorithm in <code>R</code>.
This is relevant only when explanatory variables do not exist.
</p>
<p>The function <code>gamlssMLpred()</code> is similar to <code>gamlssML()</code> but it saves the <em>predictive</em> global deviance for the <code>newdata</code>.  The new data in <code>gamlssMLpred()</code> can be given with the arguments <code>newdata</code> or defining the factor  <code>rand</code>.  <code>rand</code> should be a binary factor <code>rand</code> splitting the original  data set into a training set (value 1)  and  a validation/test set (values 2), see
also <code>gamlssVGD</code></p>


<h3>Usage</h3>

<pre><code class="language-R">gamlssML(formula, family = NO, weights = NULL, mu.start = NULL, 
 sigma.start = NULL, nu.start = NULL, tau.start = NULL, 
 mu.fix = FALSE, sigma.fix = FALSE, nu.fix = FALSE, 
 tau.fix = FALSE, data, start.from = NULL, ...)

gamlssMLpred(response = NULL, data = NULL, family = NO, 
 rand = NULL, newdata = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula, response</code></td>
<td>

<p>a vector of data requiring the fit of a <code>gamlss.family</code> distribution or (only for the function <code>gamlssML</code>) a formula,  for example, <code>y~1</code>, with no explanatory variables because they are ignored).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
 <p><code>gamlss.family</code> object, which is used to define the distribution and the link functions of the various parameters. 
The distribution families supported by <code>gamlssML()</code> can be found in <code>gamlss.family</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> a vector of weights. 
Here weights can be used to weight out observations (like in <code>subset</code>) or for a weighted likelihood analysis where  the contribution of the observations to the likelihood differs according to <code>weights</code>. The length of <code>weights</code> must be the same as the number of observations in the data. By default, the weight is set to one. To set  weights to vector say <code>w</code> use <code>weights=w</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.start</code></td>
<td>
<p> a scalar of initial values for the location parameter <code>mu</code> e.g.  <code>mu.start=4</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.start</code></td>
<td>
<p>a scalar of initial values for the scale parameter <code>sigma</code> e.g. <code>sigma.start=1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.start</code></td>
<td>
<p>scalar of initial values for the parameter <code>nu</code> e.g. <code>nu.start=3</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.start</code></td>
<td>
<p>scalar of initial values for the parameter <code>tau</code> e.g. <code>tau.start=3</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.fix</code></td>
<td>
<p>whether the mu parameter should be kept fixed in the fitting processes e.g. <code>mu.fix=FALSE</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.fix</code></td>
<td>
<p>whether the sigma parameter should be kept fixed in the fitting processes e.g. <code>sigma.fix=FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.fix</code></td>
<td>
<p>whether the nu parameter should be kept fixed in the fitting processes e.g. <code>nu.fix=FALSE</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.fix</code></td>
<td>
<p>whether the tau parameter should be kept fixed in the fitting processes e.g. <code>tau.fix=FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing the variable <code>y</code>, e.g. <code>data=aids</code>. If this is missing, the variable should be on the search list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.from</code></td>
<td>
<p>a gamlss object to start from the fitting or vector of length as many parameters in the distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p>For <code>gamlssMLpred()</code> a factor with values 1 (for fitting) and 2 (for predicting).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>The prediction data  set (validation or test).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for extra arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p> The  function <code>gamlssML()</code> fits a <code>gamlss.family</code> distribution to a single data set is using a non linear maximisation.
in fact it uses the internal function <code>MLE()</code> which is a copy of the <code>mle()</code> function of package <code>stat4</code>.
The function <code>gamlssML()</code> could be for large data faster than the equivalent <code>gamlss()</code> function which is designed for regression type of models. 
</p>
<p>The  function <code>gamlssMLpred()</code> uses the  function  <code>gamlssML()</code>   to fit the model but then uses <code>predict.gamlssML()</code> to predict for new data and saves the the prediction i) deviance increments, ii) global deviance iii) residuals.   
</p>


<h3>Value</h3>

<p>Returns a <code>gamlssML</code> object which behaves like a <code>gamlss</code> fitted objected</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, Bob Rigby, Vlasis Voudouris and Majid Djennad 
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code>gamlss.family</code>, <code>gamlss</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#-------- negative binomial 1000 observations
y&lt;- rNBI(1000)
  system.time(m1&lt;-gamlss(y~1, family=NBI))
  system.time(m1a&lt;-gamlss(y~1, family=NBI, trace=FALSE))
system.time(m11&lt;-gamlssML(y, family=NBI))
AIC(m1,m1a,m11, k=0)
# neg. binomial   n=10000
 y&lt;- rNBI(10000)
 system.time(m1&lt;-gamlss(y~1, family=NBI))
 system.time(m1a&lt;-gamlss(y~1, family=NBI, trace=FALSE))
system.time(m11&lt;-gamlssML(y, family=NBI))
AIC(m1,m1a,m11, k=0)
# binomial type data 
data(aep)
m1 &lt;- gamlssML(aep$y, family=BB) # ok
m2 &lt;- gamlssML(y, data=aep, family=BB) # ok
m3 &lt;- gamlssML(y~1, data=aep, family=BB) # ok 
m4 &lt;- gamlssML(aep$y~1, family=BB) # ok
AIC(m1,m2,m3,m4)
## Not run: 
#-----------------------------------------------------------
# neg. binomial   n=10000
y&lt;- rNBI(10000)
rand &lt;- sample(2, length(y), replace=TRUE, prob=c(0.6,0.4))
table(rand)
   Y &lt;- subset(y, rand==1)
YVal &lt;- subset(y, rand==2) 
length(Y)
length(YVal) 
da1 &lt;- data.frame(y=y)
dim(da1)
da2 &lt;- data.frame(y=Y)
dim(da2)
danew &lt;- data.frame(y=YVal)
# using gamlssVGD to fit the models
g1 &lt;- gamlssVGD(y~1, rand=rand, family=NBI, data=da1)
g2 &lt;- gamlssVGD(y~1, family=NBI, data=da2, newdata=dan)
AIC(g1,g2)
VGD(g1,g2)
# using gamlssMLpred to fit the models
p1 &lt;- gamlssMLpred(y, rand=rand, family=NBI)
p2 &lt;- gamlssMLpred(Y, family=NBI, newdata=YVal)
# AIC and VGD should produce identical results
AIC(p1,p2,g1,g2)
VGD(p1,p2, g1,g2)
# the fitted residuals
wp(p1, ylim.all=1)
# the prediction residuals 
wp(resid=p1$residVal, ylim.all=.5)
#-------------------------------------------------------------
# chossing between distributions
p2&lt;-gamlssMLpred(y, rand=rand, family=PO)
p3&lt;-gamlssMLpred(y, rand=rand, family=PIG)
p4&lt;-gamlssMLpred(y, rand=rand, family=BNB)
AIC(p1, p2, p3, p4)
VGD(p1, p2, p3, p4)
#--------------------------------------------------

## End(Not run)
 </code></pre>


</div>