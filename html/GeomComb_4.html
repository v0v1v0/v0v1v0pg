<div class="container">

<table style="width: 100%;"><tr>
<td>comb_EIG1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Standard Eigenvector Forecast Combination</h2>

<h3>Description</h3>

<p>Computes forecast combination weights according to the standard eigenvector approach by Hsiao and Wan (2014) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class="language-R">comb_EIG1(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The standard eigenvector approach retrieves combination weights from the sample estimated mean squared prediction error matrix
as follows:
Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>, <code class="reqn">\Sigma</code> is the (positive definite)
mean squared prediction error matrix of <code class="reqn">\mathbf{f}_t</code> and <code class="reqn">\mathbf{e}</code> is an <code class="reqn">N \times 1</code> vector of <code class="reqn">(1, \ldots, 1)'</code>.
The <code class="reqn">N</code> positive eigenvalues are then arranged in increasing order <code class="reqn">(\Phi_1 = \Phi_{min}, \Phi_2, \ldots, \Phi_N)</code>, and <code class="reqn">\mathbf{w^j}</code>
is defined as the eigenvector corresponding to <code class="reqn">\Phi_j</code>. The combination weights <code class="reqn">\mathbf{w}^{EIG1} = (w_1, \ldots, w_N)'</code> are then
chosen corresponding to the minimum of <code class="reqn">\left(\frac{\Phi_1}{d_1^2}, \frac{\Phi_2}{d_2^2},\ldots,\frac{\Phi_N}{d_N^2}\right)</code>, denoted as <code class="reqn">\mathbf{w}^l</code>, where <code class="reqn">d_j = \mathbf{e}'\mathbf{w}^j</code>, as:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{w}^{EIG1} = \frac{1}{d_l} \mathbf{w}^l</code>
</p>

<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {\mathbf{f}_{t}}'\mathbf{w}^{EIG1}</code>
</p>

<p>The difference to extant methods that minimize the population mean squared prediction error (e.g., Newbold and Granger, 1974) is the normalization function. While
previous approaches optimize MSPE under the constraint of <code class="reqn">\mathbf{e}'\mathbf{w} = 1</code>, Hsiao and Wan (2014) show that this is dominated by
using <code class="reqn">\mathbf{w}'\mathbf{w} = 1</code> as constraint in the optimization problem.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294–309.
</p>
<p>Newbold, P., and Granger, C. W. J. (1974). Experience with Forecasting Univariate Time Series and the Combination of Forecasts.
<em>Journal of the Royal Statistical Society, Series A</em>, <b>137(2)</b>, 131–165.
</p>


<h3>See Also</h3>

<p><code>foreccomb</code>,
<code>plot.foreccomb_res</code>,
<code>summary.foreccomb_res</code>,
<code>comb_NG</code>,
<code>accuracy</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG1(data)

</code></pre>


</div>