<div class="container">

<table style="width: 100%;"><tr>
<td>gsl_nls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GSL Nonlinear Least Squares fitting</h2>

<h3>Description</h3>

<p>Determine the nonlinear least-squares estimates of the parameters of a
nonlinear model using the <code>gsl_multifit_nlinear</code> module present in
the GNU Scientific Library (GSL).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gsl_nls(fn, ...)

## S3 method for class 'formula'
gsl_nls(
  fn,
  data = parent.frame(),
  start,
  algorithm = c("lm", "lmaccel", "dogleg", "ddogleg", "subspace2D"),
  control = gsl_nls_control(),
  lower,
  upper,
  jac = NULL,
  fvv = NULL,
  trace = FALSE,
  subset,
  weights,
  na.action,
  model = FALSE,
  ...
)

## S3 method for class 'function'
gsl_nls(
  fn,
  y,
  start,
  algorithm = c("lm", "lmaccel", "dogleg", "ddogleg", "subspace2D"),
  control = gsl_nls_control(),
  lower,
  upper,
  jac = NULL,
  fvv = NULL,
  trace = FALSE,
  weights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>a nonlinear model defined either as a two-sided formula including variables and parameters,
or as a function returning a numeric vector, with first argument the vector of parameters to be estimated.
See the individual method descriptions below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables in <code>fn</code> if
defined as a formula. Can also be a list or an environment, but not a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric response vector if <code>fn</code> is defined as a function, equal in
length to the vector returned by evaluation of the function <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>a vector, list or matrix of initial parameter values or parameter ranges. <code>start</code> is only allowed to be missing
if <code>fn</code> is a <code>selfStart</code> model. The following choices are supported:
</p>

<ul>
<li>
<p> a named list or named vector of numeric starting values. If <code>start</code> has no missing values, a standard single-start optimization
is performed. If <code>start</code> contains missing values for one or more parameters, a multi-start algorithm (see ‘Details’) with
dynamic starting ranges for the undefined parameters and fixed starting values for the remaining parameters is executed.
If <code>start</code> is a named list or vector containing <em>only</em> missing values, the multi-start algorithm considers dynamically changing starting
ranges for all parameters. Note that there is no guarantee that the optimizing solution is a global minimum of the least-squares objective.
</p>
</li>
<li>
<p> a named list with starting parameter ranges in the form of length-2 numeric vectors. Can also be a (<code>2</code> by <code>p</code>) named matrix with as columns
the numeric starting ranges for the parameters. If <code>start</code> contains no missing values, a multi-start algorithm with fixed
starting ranges for the parameters is executed. Otherwise, if <code>start</code> contains infinities or missing values (e.g. <code>c(0, Inf)</code> or <code>c(NA, NA)</code>),
the multi-start algorithm considers dynamically changing starting ranges for the parameters with infinite and/or missing ranges.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character string specifying the algorithm to use. The following choices are supported:
</p>

<ul>
<li> <p><code>"lm"</code> Levenberg-Marquardt algorithm (default).
</p>
</li>
<li> <p><code>"lmaccel"</code> Levenberg-Marquardt algorithm with geodesic acceleration.
Stability is controlled by the <code>avmax</code> parameter in <code>control</code>, setting <code>avmax</code>
to zero is analogous to not using geodesic acceleration.
</p>
</li>
<li> <p><code>"dogleg"</code> Powell's dogleg algorithm.
</p>
</li>
<li> <p><code>"ddogleg"</code> Double dogleg algorithm, an improvement over <code>"dogleg"</code>
by including information about the Gauss-Newton step while the iteration is still
far from the minimum.
</p>
</li>
<li> <p><code>"subspace2D"</code> 2D generalization of the dogleg algorithm. This method
searches a larger subspace for a solution, it can converge more quickly than <code>"dogleg"</code>
on some problems.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>an optional list of control parameters to tune the least squares iterations and multistart algorithm.
See <code>gsl_nls_control</code> for the available control parameters and their default values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>a named list or named numeric vector of parameter lower bounds. If missing (default), the parameters are unconstrained from below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>a named list or named numeric vector of parameter upper bounds. If missing (default), the parameters are unconstrained from above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jac</code></td>
<td>
<p>either <code>NULL</code> (default) or a function returning the <code>n</code> by <code>p</code> dimensional Jacobian matrix of
the nonlinear model <code>fn</code>, where <code>n</code> is the number of observations and <code>p</code> the
number of parameters. If a function, the first argument must be the vector of parameters of length <code>p</code>.
If <code>NULL</code>, the Jacobian is computed internally using a finite difference approximations.
Can also be <code>TRUE</code>, in which case <code>jac</code> is derived symbolically with <code>deriv</code>,
this only works if <code>fn</code> is defined as a (non-selfstarting) formula. If <code>fn</code> is a <code>selfStart</code> model,
the Jacobian specified in the <code>"gradient"</code> attribute of the self-start model is used instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fvv</code></td>
<td>
<p>either <code>NULL</code> (default) or a function returning an <code>n</code> dimensional vector containing
the second directional derivatives of the nonlinear model <code>fn</code>, with <code>n</code> the number of observations.
This argument is only used if geodesic acceleration is enabled (<code>algorithm = "lmaccel"</code>).
If a function, the first argument must be the vector of parameters of length <code>p</code> and the second argument must be the velocity vector
also of length <code>p</code>. If <code>NULL</code>, the second directional derivative vector is computed internal
using a finite difference approximation. Can also be <code>TRUE</code>, in which case <code>fvv</code> is derived
symbolically with <code>deriv</code>, this only works if <code>fn</code> is defined as a (non-selfstarting) formula.
If the model function in <code>fn</code> also returns a <code>"hessian"</code> attribute (similar to the <code>"gradient"</code> attribute
in a <code>selfStart</code> model), this Hessian matrix is used to evaluate the second directional derivatives instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical value indicating if a trace of the iteration progress should be printed.
Default is <code>FALSE</code>. If <code>TRUE</code>, the residual (weighted) sum-of-squares and the current parameter estimates
are printed after each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.
This argument is only used if <code>fn</code> is defined as a formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional numeric vector of (fixed) weights. When present, the objective function is
weighted least squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The
default is set by the <code>na.action</code> setting of <code>options</code>, and is <code>na.fail</code> if that is unset.
The 'factory-fresh' default is <code>na.omit</code>. Value <code>na.exclude</code> can be useful.
This argument is only used if <code>fn</code> is defined as a formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the model frame is returned as part of the object. Defaults to <code>FALSE</code>.
This argument is only used if <code>fn</code> is defined as a formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to the calls of <code>fn</code>, <code>jac</code> and <code>fvv</code> if
defined as functions.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>fn</code> is a <code>formula</code> returns a list object of class <code>nls</code>.
If <code>fn</code> is a <code>function</code> returns a list object of class <code>gsl_nls</code>.
See the individual method descriptions for the structures of the returned lists and the generic functions
applicable to objects of both classes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gsl_nls(formula)</code>: If <code>fn</code> is a <code>formula</code>, the returned list object is of classes <code>gsl_nls</code> and <code>nls</code>.
Therefore, all generic functions applicable to objects of class <code>nls</code>, such as <code>anova</code>, <code>coef</code>, <code>confint</code>,
<code>deviance</code>, <code>df.residual</code>, <code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>nobs</code>, <code>predict</code>, <code>print</code>, <code>profile</code>,
<code>residuals</code>, <code>summary</code>, <code>vcov</code> and <code>weights</code> are also applicable to the returned list object.
In addition, a method <code>confintd</code> is available for inference of derived parameters.
</p>
</li>
<li> <p><code>gsl_nls(function)</code>: If <code>fn</code> is a <code>function</code>, the first argument must be the vector of parameters and
the function should return a numeric vector containing the nonlinear model evaluations at
the provided parameter and predictor or covariate vectors. In addition, the argument <code>y</code>
needs to contain the numeric vector of observed responses, equal in length to the numeric
vector returned by <code>fn</code>. The returned list object is (only) of class <code>gsl_nls</code>.
Although the returned object is not of class <code>nls</code>, the following generic functions remain
applicable for an object of class <code>gsl_nls</code>: <code>anova</code>, <code>coef</code>, <code>confint</code>, <code>deviance</code>,
<code>df.residual</code>, <code>fitted</code>, <code>formula</code>, <code>logLik</code>, <code>nobs</code>, <code>predict</code>, <code>print</code>,
<code>residuals</code>, <code>summary</code>, <code>vcov</code> and <code>weights</code>. In addition, a method <code>confintd</code>
is available for inference of derived parameters.
</p>
</li>
</ul>
<h3>Multi-start algorithm</h3>

<p>If <code>start</code> is a list or matrix of parameter ranges, or contains any missing values, a modified version of the multi-start algorithm described in
Hickernell and Yuan (1997) is applied. Note that the <code>start</code> parameter ranges are only used to bound the domain for the
starting values, i.e. the resulting parameter estimates are not constrained to lie within these bounds, use <code>lower</code> and/or <code>upper</code> for
this purpose instead. Quasi-random starting values are sampled in the unit hypercube from a Sobol sequence if <code>p &lt; 41</code> and from a Halton sequence (up to <code>p = 1229</code>) otherwise.
The initial starting values are scaled to the specified parameter ranges using an inverse (scaled) logistic function favoring starting values near the center of the
(scaled) domain. The trust region algorithm as specified by <code>algorithm</code> used for the inexpensive and expensive local search (see Algorithm 2.1 of Hickernell
and Yuan (1997)) are the same, only differing in the number of search iterations <code>mstart_p</code> versus <code>mstart_maxiter</code>, where
<code>mstart_p</code> is typically much smaller than <code>mstart_maxiter</code>. When a new stationary point is detected, the scaling step from the unit hypercube to
the starting value domain is updated using the diagonal of the estimated trust method's scaling matrix <code>D</code>, which improves optimization performance
especially when the parameters live on very different scales. The multi-start algorithm terminates when NSP (number of stationary points)
is larger than or equal to <code>mstart_minsp</code> and NWSP (number of worse stationary points) is larger than or equal to <code>mstart_r</code> times NSP,
or when the maximum number of major iterations <code>mstart_maxstart</code> is reached. After termination of the multi-start algorithm, a full
single-start optimization is executed starting from the best multi-start solution.
</p>


<h3>Missing starting values</h3>

<p>If <code>start</code> contains missing (or infinite) values, the multi-start algorithm is executed without fixed parameter ranges for the missing parameters.
The ranges for the missing parameters are initialized to the unit interval and dynamically increased or decreased in each major iteration
of the multi-start algorithm. The decision to increase or decrease a parameter range is driven by the minimum and maximum parameter values
attained by the first <code>mstart_q</code> inexpensive local searches ordered by their squared loss, which typically provide a decent indication of the
order of magnitude of the parameter range in which to search for the optimal solution. Note that this procedure is not expected to always
return a global minimum of the nonlinear least-squares objective. Especially when the objective function contains many local optima,
the algorithm may be unable to select parameter ranges that include the global minimizing solution. In this case, it may help to increase
the values of <code>mstart_n</code>, <code>mstart_r</code> or <code>mstart_minsp</code> to avoid early termination of the algorithm at the cost of
increased computational effort.
</p>


<h3>References</h3>

<p>M. Galassi et al., <em>GNU Scientific Library Reference Manual (3rd Ed.)</em>, ISBN 0954612078.
</p>
<p>Hickernell, F.J. and Yuan, Y. (1997) <em>“A simple multistart algorithm for global optimization”</em>, OR Transactions, Vol. 1 (2).
</p>


<h3>See Also</h3>

<p><code>nls</code>
</p>
<p><a href="https://www.gnu.org/software/gsl/doc/html/nls.html">https://www.gnu.org/software/gsl/doc/html/nls.html</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1: exponential model
# (https://www.gnu.org/software/gsl/doc/html/nls.html#exponential-fitting-example)

## data
set.seed(1)
n &lt;- 25
x &lt;- (seq_len(n) - 1) * 3 / (n - 1)
f &lt;- function(A, lam, b, x) A * exp(-lam * x) + b
y &lt;- f(A = 5, lam = 1.5, b = 1, x) + rnorm(n, sd = 0.25)

## model fit
ex1_fit &lt;- gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = 0, lam = 0, b = 0)                       ## starting values
)
summary(ex1_fit)                                         ## model summary
predict(ex1_fit, interval = "prediction")                ## prediction intervals

## multi-start
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                             ## model formula
  data = data.frame(x = x, y = y),                            ## model fit data
  start = list(A = c(0, 100), lam = c(0, 10), b = c(-10, 10)) ## starting ranges
)
## missing starting values
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = NA, lam = NA, b = NA)                    ## unknown start
)

## analytic Jacobian 1
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = 0, lam = 0, b = 0),                      ## starting values
  jac = function(par) with(as.list(par),                 ## jacobian
    cbind(A = exp(-lam * x), lam = -A * x * exp(-lam * x), b = 1)
  )
)

## analytic Jacobian 2
gsl_nls(
  fn = y ~ A * exp(-lam * x) + b,                        ## model formula
  data = data.frame(x = x, y = y),                       ## model fit data
  start = c(A = 0, lam = 0, b = 0),                      ## starting values
  jac = TRUE                                             ## automatic derivation
)

## self-starting model
gsl_nls(
  fn =  y ~ SSasymp(x, Asym, R0, lrc),                   ## model formula
  data = data.frame(x = x, y = y)                        ## model fit data
)

# Example 2: Gaussian function
# (https://www.gnu.org/software/gsl/doc/html/nls.html#geodesic-acceleration-example-2)

## data
set.seed(1)
n &lt;- 100
x &lt;- seq_len(n) / n
f &lt;- function(a, b, c, x) a * exp(-(x - b)^2 / (2 * c^2))
y &lt;- f(a = 5, b = 0.4, c = 0.15, x) * rnorm(n, mean = 1, sd = 0.1)

## Levenberg-Marquardt (default)
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  trace = TRUE                                          ## verbose output
)

## Levenberg-Marquardt w/ geodesic acceleration 1
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  algorithm = "lmaccel",                                ## algorithm
  trace = TRUE                                          ## verbose output
)

## Levenberg-Marquardt w/ geodesic acceleration 2
## second directional derivative
fvv &lt;- function(par, v, x) {
  with(as.list(par), {
    zi &lt;- (x - b) / c
    ei &lt;- exp(-zi^2 / 2)
    2 * v[["a"]] * v[["b"]] * zi / c * ei + 2 * v[["a"]] * v[["c"]] * zi^2 / c * ei -
      v[["b"]]^2 * a / c^2 * (1 - zi^2) * ei -
      2 * v[["b"]] * v[["c"]] * a / c^2 * zi * (2 - zi^2) * ei -
      v[["c"]]^2 * a / c^2 * zi^2 * (3 - zi^2) * ei
  })
}

## analytic fvv 1
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  algorithm = "lmaccel",                                ## algorithm
  trace = TRUE,                                         ## verbose output
  fvv = fvv,                                            ## analytic fvv
  x = x                                                 ## argument passed to fvv
)

## analytic fvv 2
gsl_nls(
  fn = y ~ a * exp(-(x - b)^2 / (2 * c^2)),             ## model formula
  data = data.frame(x = x, y = y),                      ## model fit data
  start = c(a = 1, b = 0, c = 1),                       ## starting values
  algorithm = "lmaccel",                                ## algorithm
  trace = TRUE,                                         ## verbose output
  fvv = TRUE                                            ## automatic derivation
)

# Example 3: Branin function
# (https://www.gnu.org/software/gsl/doc/html/nls.html#comparing-trs-methods-example)

## Branin model function
branin &lt;- function(x) {
  a &lt;- c(-5.1 / (4 * pi^2), 5 / pi, -6, 10, 1 / (8 * pi))
  f1 &lt;- x[2] + a[1] * x[1]^2 + a[2] * x[1] + a[3]
  f2 &lt;- sqrt(a[4] * (1 + (1 - a[5]) * cos(x[1])))
  c(f1, f2)
}

## Dogleg minimization w/ model as function
gsl_nls(
  fn = branin,                   ## model function
  y = c(0, 0),                   ## response vector
  start = c(x1 = 6, x2 = 14.5),  ## starting values
  algorithm = "dogleg"           ## algorithm
)

# Available example problems
nls_test_list()

## BOD regression
## (https://www.itl.nist.gov/div898/strd/nls/nls_main.shtml)
(boxbod &lt;- nls_test_problem(name = "BoxBOD"))
with(boxbod,
     gsl_nls(
       fn = fn,
       data = data,
       start = list(b1 = NA, b2 = NA)
     )
)

## Rosenbrock function
(rosenbrock &lt;- nls_test_problem(name = "Rosenbrock"))
with(rosenbrock,
     gsl_nls(
       fn = fn,
       y = y,
       start = c(x1 = NA, x2 = NA),
       jac = jac
     )
)

</code></pre>


</div>