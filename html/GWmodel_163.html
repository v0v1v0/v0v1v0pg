<div class="container">

<table style="width: 100%;"><tr>
<td>gwr.multiscale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiscale GWR</h2>

<h3>Description</h3>

<p>This function implements multiscale GWR to detect variations in regression relationships across
different spatial scales. This function can not only find a different bandwidth for each 
relationship but also (and simultaneously) find a different distance metric for 
each relationship (if required to do so).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gwr.multiscale(formula, data, kernel = "bisquare", adaptive = FALSE,
                 criterion = "dCVR", max.iterations = 2000, threshold =
                 1e-05, dMats, var.dMat.indx, p.vals, theta.vals,
                 longlat = FALSE, bws0, bw.seled, approach = "AIC", bws.thresholds, 
                 bws.reOpts = 5, verbose = F,
                 hatmatrix = T, predictor.centered = rep(T,
                 length(bws0) - 1), nlower = 10, parallel.method = F,
                 parallel.arg = NULL, force.armadillo = F)
## S3 method for class 'multiscalegwr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Regression model formula of a formula object </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a Spatial*DataFrame, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span>, or a sf object defined in package <span class="pkg">sf</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>function chosen as follows:
</p>
<p>gaussian: wgt = exp(-.5*(vdist/bw)^2);
</p>
<p>exponential: wgt = exp(-vdist/bw);
</p>
<p>bisquare: wgt = (1-(vdist/bw)^2)^2 if vdist &lt; bw, wgt=0 otherwise;
</p>
<p>tricube: wgt = (1-(vdist/bw)^3)^3 if vdist &lt; bw, wgt=0 otherwise; 
</p>
<p>boxcar: wgt=1 if dist &lt; bw, wgt=0 otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>if TRUE calculate an adaptive kernel where the bandwidth (bw) corresponds to the number of nearest neighbours (i.e. adaptive distance); default is FALSE, where a fixed kernel is found (bandwidth is a fixed distance)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>criterion for determining the convergence of the back-fitting procedure, could be "CVR" or "dCVR", which corespond to the changing value of RSS (CVR) and the differential version (dCVR), respectively; and "dCVR" is used as default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iterations</code></td>
<td>
<p>maximum number of iterations in the back-fitting procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>threshold value to terminate the back-fitting iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dMats</code></td>
<td>
<p>a list of distance matrices used for estimating each specific parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.dMat.indx</code></td>
<td>
<p>index corresponds to a specific distance matrix for each exploratory variable, if dMats is provided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.vals</code></td>
<td>
<p> a collection of positive numbers used as the power of the Minkowski distance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.vals</code></td>
<td>
<p>a collection of values used as angles in radians to rotate the coordinate system</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longlat</code></td>
<td>
<p>if TRUE, great circle distances will be calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bws0</code></td>
<td>
<p>a vector of initializing bandwidths for the back-fitting procedure, of which the length should equal to the number of paramters if specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw.seled</code></td>
<td>
<p>a vector of boolean variables to determine whether the corresponding bandwidth should be re-selected or not: if TRUE, the corresponding bandwiths for the specific parameters are                      supposed to be given in bws0; otherwise, the bandwidths for the specific parameters will be selected within the back-fitting iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approach</code></td>
<td>
<p>specified by CV for cross-validation approach or by AIC corrected (AICc) approach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bws.thresholds</code></td>
<td>
<p>threshold values to define whether the bandwidth for a specific parameter has converged or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bws.reOpts</code></td>
<td>
<p>the number times of continually optimizing each parameter-specific bandwidth even though it meets the criterion of convergence, for avoiding  sub-optimal choice due to illusion of                           convergence;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if TRUE and bandwidth selection is undertaken, the bandwidth searches are reported</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictor.centered</code></td>
<td>
<p>a logical vector of length equalling to the number of predictors, and note intercept is not included; if the element is TRUE, the corresponding predictor will be centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatmatrix</code></td>
<td>
<p>if TRUE the hatmatrix for the whole model will be calculated, and AICc, adjusted-R2 values will be returned accordingly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlower</code></td>
<td>
<p>the minmum number of nearest neighbours if an adaptive kernel is used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.method</code></td>
<td>
<p> FALSE as default, and the calibration will be conducted traditionally via the serial technique, 
"omp": multi-thread technique with the OpenMP API, 
"cluster": multi-process technique with the <span class="pkg">parallel</span> package,
"cuda": parallel computing technique with CUDA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.arg</code></td>
<td>
<p> if parallel.method is not FALSE, then set the argument by following:
if parallel.method is "omp", parallel.arg refers to the number of threads used, and its default value is 
the number of cores - 1;
if parallel.method is "cluster", parallel.arg refers to the number of R sessions used, and its default value is 
the number of cores - 1;
if parallel.method is "cuda",  parallel.arg refers to the number of calibrations  included in each group, 
but note a too large value may cause the overflow of GPU memory. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.armadillo</code></td>
<td>
<p>if TRUE, use the original RcppArmadillo implementation instead of the new RcppEigen implementation. Only matters if parallel.method = F or parallel.method = "omp".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class “multiscalegwr”, returned by the function gwr.multiscale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of class “psdmgwr”:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded), or 
SpatialPolygonsDataFrame object (see package “sp”), or sf object  (see package “sf”) 
integrated with data locations,coefficient estimates from the PSDM GWR model,predicted y values,residuals,
coefficient standard errors and t-values in its "data" slot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GW.arguments</code></td>
<td>
<p>a list class object including the model fitting parameters for generating the report file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GW.diagnostic</code></td>
<td>
<p>a list class object including the diagnostic information of the model fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lm</code></td>
<td>
<p>an object of class inheriting from “lm”, see lm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bws.vars</code></td>
<td>
<p>bandwidths used for all the parameters within the back-fitting procedure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timings</code></td>
<td>
<p>starting and ending time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This function implements multiscale GWR to detect variations in regression 
relationships across different spatial scales. This function can not only find 
a different bandwidth for each relationship, but also (and simultaneously), find
a different distance metric for each relationship (i.e. Parameter-Specific Distance 
Metric GWR, i.e. PSDM GWR).  Note that multiscale GWR (MGWR) has also been referred 
to as flexible bandwidth GWR (FBGWR) and conditional GWR (CGWR) in the literature. 
All are one and the same model, but where PSDM-GWR additionally provides a different 
distance metric option for each relationship.  An MGWR model is calibrated if no “dMats” 
and “p.vals” are specified; a mixed GWR model will be calibrated if an 
infinite bandwidth and another regular bandwidth are used for estimating the global and local 
parameters (again when no “dMats” and “p.vals” are specified). 
In other words, the gwr.multiscale function is specified with Euclidean distances 
in both cases. Note that the results from this function for a mixed GWR model 
and gwr.mixed might be different, as a back-fitting algorithm is used in
gwr.multiscale, while an approximating algorithm is applied in gwr.mixed. 
The gwr.mixed function performs better in computational efficiency, but 
poorer in prediction accuracy.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>References</h3>

<p>Yang, W. (2014). An Extension of Geographically Weighted Regression with 
Flexible Bandwidths. St Andrews, St Andrews, UK.
</p>
<p>Lu, B., Harris, P., Charlton, M., &amp; Brunsdon, C. (2015). Calibrating a 
Geographically Weighted Regression Model with Parameter-specific Distance 
Metrics. Procedia Environmental Sciences, 26, 109-114.
</p>
<p>Lu, B., Brunsdon, C., Charlton, M., &amp; Harris, P. (2017). Geographically weighted 
regression with parameter-specific distance metrics. International Journal of 
Geographical Information Science, 31, 982-998.
</p>
<p>Fotheringham, A. S., Yang, W. &amp; Kang, W. (2017). Multiscale Geographically 
Weighted Regression (MGWR). Annals of the American Association of Geographers, 
107, 1247-1265.
</p>
<p>Yu, H., A. S. Fotheringham, Z. Li, T. Oshan, W. Kang &amp; L. J. Wolf. 2019. Inference 
in multiscale geographically weighted regression. Geographical Analysis(In press).
</p>
<p>Leong, Y.Y., &amp; Yue, J.C. (2017). A modification to geographically weighted 
regression. International Journal of Health Geographics, 16 (1), 11.
</p>
<p>Lu, B., Yang, W. Ge, Y. &amp; Harris, P. (2018). Improvements to the calibration of 
a geographically weighted regression with parameter-specific distance metrics 
and bandwidths. Forthcoming Computers, Environment and Urban Systems.
</p>
<p>Wolf, L.J, Oshan, T.M, Fotheringham, A.S. (2018). Single and multiscale models of 
process spatial heterogeneity. Geographical Analysis, 50(3): 223-246.
</p>
<p>Murakami, D., Lu, B., Harris, P., Brunsdon, C., Charlton, M., Nakaya, T., &amp; Griffith, D. (2019) 
The importance of scale in spatially varying coefficient modelling. 
Forthcoming Annals of the Association of American Geographers.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(LondonHP)
EUDM &lt;- gw.dist(coordinates(londonhp))
#No bandwidth is selected, and bws0 values are used
## Not run: 
###Similar as the basic GWR
res1&lt;-gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, criterion="dCVR",kernel="gaussian", 
adaptive=T, bws0=c(100, 100, 100),bw.seled=rep(T, 3), dMats=list(EUDM,EUDM,EUDM))
#FBGWR
res2&lt;-gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, criterion="dCVR",kernel="gaussian",
adaptive=T, bws0=c(100, 100, 100), dMats=list(EUDM,EUDM,EUDM))
#Mixed GWR
res3&lt;-gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, bws0=c(Inf, 100, 100, Inf),
               bw.seled=rep(T, 3),kernel="gaussian", dMats=list(EUDM,EUDM,EUDM))
#PSDM GWR
res4&lt;- gwr.multiscale(PURCHASE~FLOORSZ+PROF, data=londonhp, kernel="gaussian", p.vals=c(1,2,3))

## End(Not run)
</code></pre>


</div>