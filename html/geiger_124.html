<div class="container">

<table style="width: 100%;"><tr>
<td>pp.mcmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
using posterior predictive MCMC for modeling quantitative trait evolution
</h2>

<h3>Description</h3>

<p>performs posterior predictive checks for models of quantitative trait evolution. At present, only BM, EB, and clade.shift models are implemented
</p>


<h3>Usage</h3>

<pre><code class="language-R">pp.mcmc(phy, d, Ngens = 1000000, sampleFreq = 1000, printFreq = 1000,
        prop.width = 1, model = "BM", eb.type = "exponential",
        clade = NULL, rlm.maxit = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phy</code></td>
<td>

<p>A time calibrated phylogeny in "phylo" format
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>A named vector or dataframe of trait values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ngens</code></td>
<td>

<p>Number of generations that the posterior predictive MCMC will run for. Default is 1 million generations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleFreq</code></td>
<td>

<p>The frequency with which model parameters will be sampled from the chain and simulations run. Default is every 1000 generations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printFreq</code></td>
<td>

<p>The frequency with which the current number of generations and acceptance rates will be printed to screen. Default is every 1000 generations
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop.width</code></td>
<td>

<p>The width of the sliding window proposal distribution for ln(Sigmasq) and, if applicable, the exponential change parameter for EB. The width for the EB parameter is obtained by dividing by 10. Default proposal width is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>The model to fit and simulate under. Default is Brownian motion (BM). Other options are early burst (EB) or an edge shift model (edge.shift) where the rate is allowed to change along an internal edge leading to a specified clade (see argument "clade" and Slater and Pennell in press for an example)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eb.type </code></td>
<td>

<p>The type of exponential change model assumed. If eb.type = "exponential" (the default), then an exponentially declining rate will be assumed and contrasts will be log transformed when computing the node height test. If eb.type = "linear", a linear decline in rate will be assumed and untransformed contrasts will be used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clade </code></td>
<td>

<p>Default = NULL and is used if model = "BM" or model = "EB". If using model = "edge.shift", then a clade must be specified for which the stem lineage experiences a different rate of evolution. The clade is specified by giving the names of two taxa spanning the clade of interest, e.g. clade = c("A", "B")
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlm.maxit</code></td>
<td>

<p>Maximum number of interations to use for the iteratively reweighted least squares optimization of the robust regression algorithm (see ?rlm). Default is 20 and should be sufficient for most problems
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function runs a posterior predictive MCMC under the specified model, sampling model parameters from their posterior distributions and simulating under that model. Simulated data are summarized using the Node height test (Freckleton and Harvey 2006) slope  (OLS and robust regression) and Morphological Disparity Index (Harmon et al. 2003). Model adequacy can then be assessed by comparing observed values for these summary statistics to the posterior predictive distributions
</p>


<h3>Value</h3>

<p>A dataframe containing the following columns:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$generation </code></td>
<td>
<p>the generation at which parameters where sampled and simulations conducted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$logLk </code></td>
<td>
<p>The sampled logLikelihood values for the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$Sigma </code></td>
<td>
<p>Brownian rate parameter values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$node.height.slope.lm </code></td>
<td>
<p>posterior predictive distribution of slopes for the node height test using an ordinary least squares regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$node.height.slope.rlm </code></td>
<td>
<p>posterior predictive distribution of slopes for the node height test using a robust regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$MDI </code></td>
<td>
<p>posterior predictive distribution of MDI values</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Graham Slater and Matthew Pennell
</p>


<h3>References</h3>

<p>Slater GJ and MW Pennell (2014) Robust regression and posterior predictive simulation increase power to detect early bursts of trait evolution. <em>Systematic Biology</em>.
</p>
<p>Freckleton RP and PH Harvey (2006) Detecting non-brownian evolution in adaptive radiations. <em>PLoS Biology</em> 4:e373.
</p>
<p>Harmon LJ, JA Schulte, A Larson, and JB Losos (2003). Tempo and mode of evolutionary readiations in iguanian lizards. <em>Science</em> 301:961-964.
</p>


<h3>See Also</h3>

<p><code>nh.test</code>, <code>dtt</code>, <code>fitContinuous</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(whales)

tmp &lt;- treedata(whales$phy, whales$dat[,1])

phy &lt;- tmp$phy
dat &lt;- tmp$data[,1]

## compute observed statistics

nht.ols &lt;- nh.test(phy, dat, regression.type = "lm",
log = TRUE, show.plot = FALSE)$coefficients[2,1]

nht.rlm &lt;- nh.test(phy, dat, regression.type = "rlm",
 log = TRUE, show.plot = FALSE)$coefficients[2,1]

mdi.exp &lt;- 0

#---- run short pp.mcmc

pp.eb &lt;- pp.mcmc(phy, dat, Ngens = 1000, sampleFreq = 10, printFreq = 100, model ="EB")

# ---- plot results

# quartz(width = 5, height = 7)
par(mar = c(4,5,1,1))
par(mfcol = c(3,1))


hist(pp.eb$MDI, col = "gray", border = "gray", main = NULL, xlab = "pp.MDI",
ylab = "Frequency", cex.axis = 1.2)

abline(v = mdi.exp, col = "black", lwd = 3, lty = 2)

mdi.p &lt;- length(which(pp.eb$MDI&lt;=0))/length(pp.eb$MDI)

hist(pp.eb$node.height.slope.lm, col = "gray", border = "gray", main = NULL, xlab = "pp.nht_ols",
ylab = "Frequency", cex.axis = 1.2)

abline(v = nht.ols, col = "black", lwd = 3, lty = 2)

node.height.ols.p &lt;- length(which(pp.eb$node.height.slope.lm &lt;= nht.ols)) /
(length(pp.eb$node.height.slope.lm) +1)


hist(pp.eb$node.height.slope.rlm, col = "gray", border = "gray", main = NULL, xlab = "pp.nht_ols",
ylab = "Frequency", cex.axis = 1.2)

abline(v = nht.rlm, col = "black", lwd = 3, lty = 2)

node.height.rr.p &lt;- length(which(pp.eb$node.height.slope.rlm &lt;= nht.rlm)) /
(length(pp.eb$node.height.slope.rlm) +1)


</code></pre>


</div>