<div class="container">

<table style="width: 100%;"><tr>
<td>h_of_dist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Finds the distance of each element in a matrix x to the its boundary of the domain while fixing the others in the same row (dist(x, domain)), and calculates element-wise h(dist(x, domain)) and h\'(dist(x, domain)) (w.r.t. each element in x).</h2>

<h3>Description</h3>

<p>Finds the distance of each element in a matrix  <code>x</code> to its boundary of the <code>domain</code> while fixing the others in the same row (<code>dist(x, domain)</code>), and calculates element-wise <code>h(dist(x, domain))</code> and <code>h\'(dist(x, domain))</code> (w.r.t. each element in <code>x</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">h_of_dist(h_hp, x, domain, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>h_hp</code></td>
<td>
<p>A function, the <code class="reqn">h</code> and <code class="reqn">hp</code> (the derivative of <code>h</code>) functions. <code>h_hp(x)</code> should return a list of elements <code>hx</code> (<code>h(x)</code>) and <code>hpx</code> (<code>hp(x)</code>), both of which have the same size as <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An <code>n</code> by <code>p</code> matrix, the data matrix, where <code>n</code> is the sample size and <code>p</code> the dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>A list returned from <code>make_domain()</code> that represents the domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>A logical, defaults to <code>FALSE</code>. If <code>TRUE</code>, assumes that <code>h_hp</code> contains in fact the log of <code>h</code> and <code>hp</code>, and this function will return the log of <code>h(dist(x, domain))</code> and <code>abs(h\'(dist(x, domain)))</code> along with the sign of <code>h\'(dist(x, domain))</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Define <code>dist(x, domain)</code> as the matrix whose <code>i,j</code>-th component is the distance of <code class="reqn">x_{i,j}</code> to the boundary of <code>domain</code>, assuming <code class="reqn">x_{i,-j}</code> are fixed. The matrix has the same size of <code>x</code> (<code>n</code> by <code>p</code>), or if <code>domain$type == "simplex"</code> and <code>x</code> has full dimension <code>p</code>, it has <code>p-1</code> columns.<br>
Define <code>dist\'(x, domain)</code> as the component-wise derivative of <code>dist(x, domain)</code> in its components. That is, its <code>i,j</code>-th component is 0 if <code class="reqn">x_{i,j}</code> is unbounded or is bounded from both below and above or is at the boundary, or -1 if <code class="reqn">x_{i,j}</code> is closer to its lower boundary (or if its bounded from below but unbounded from above), or 1 otherwise.<br><code>h_of_dist(h_hp, x, domain)</code> simply returns <code>h_hp(dist(x, domain))$hx</code> and <code>h_hp(dist(x, domain))$hpx * dist\'(x, domain)</code> (element-wise derivative of <code>h_hp(dist(x, domain))$hx</code> w.r.t. <code>x</code>).
</p>


<h3>Value</h3>

<p>If <code>log == FALSE</code>, a list that contains <code>h(dist(x, domain))</code> and <code>h\'(dist(x, domain))</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>hdx</code></td>
<td>
<p><code>h(dist(x, domain))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hpdx</code></td>
<td>
<p><code>hp(dist(x, domain))</code>.</p>
</td>
</tr>
</table>
<p>If <code>log == TRUE</code>, a list that contains the log of <code>h(dist(x, domain))</code> and <code>abs(h\'(dist(x, domain)))</code> as well as the sign of <code>h\'(dist(x, domain))</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>log_hdx</code></td>
<td>
<p><code>log(h(dist(x, domain)))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_hpdx</code></td>
<td>
<p><code>log(abs(hp(dist(x, domain))))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_hpdx</code></td>
<td>
<p><code>sign(hp(dist(x, domain)))</code>.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 20
p &lt;- 10
eta &lt;- rep(0, p)
K &lt;- diag(p)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))

# Gaussian on R^p:
domain &lt;- make_domain("R", p=p)
x &lt;- mvtnorm::rmvnorm(n, mean=solve(K, eta), sigma=solve(K))
# Equivalently:

x2 &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain,
       finite_infinity=100, xinit=NULL, burn_in=1000, thinning=100, verbose=FALSE)

h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx is all Inf and hpdx is all 0 since each coordinate is unbounded with domain R
c(all(is.infinite(hd$hdx)), all(hd$hpdx==0))


# exp on R_+^p:
domain &lt;- make_domain("R+", p=p)
x &lt;- gen(n, setting="exp", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx is x^2 and hpdx is 2*x; with domain R+, the distance of x to the boundary is just x itself
c(max(abs(hd$hdx - x^2)), max(abs(hd$hpdx - 2*x)))


# Gaussian on sum(x^2) &gt; p with x allowed to be negative
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste("sum(x^2)&gt;", p), abs=FALSE, nonnegative=FALSE)))
x &lt;- gen(n, setting="gaussian", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
quota &lt;- p - (rowSums(x^2) - x^2) # How much should xij^2 at least be so that sum(xi^2) &gt; p?
# How far is xij from +/-sqrt(quota), if quota &gt;= 0?
dist_to_bound &lt;- abs(x[quota &gt;= 0]) - abs(sqrt(quota[quota &gt;= 0]))
# Should be equal to our own calculations
max(abs(dist$dx[is.finite(dist$dx)] - dist_to_bound))
# dist'(x) should be the same as the sign of x
all(dist$dpx[is.finite(dist$dx)] == sign(x[quota &gt;= 0]))
# quota is negative &lt;-&gt; sum of x_{i,-j}^2 already &gt; p &lt;-&gt; xij unbounded given others
#      &lt;-&gt; distance to boundary is Inf
all(quota[is.infinite(dist$dx)] &lt; 0)

h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx[is.finite(dist$dx)] - dist$dx[is.finite(dist$dx)]^2)))
# hdx = Inf if dist = Inf
print(all(is.infinite(hd$hdx[is.infinite(dist$dx)])))
 # hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx[is.finite(dist$dx)] - 2*(dist$dpx*dist$dx)[is.finite(dist$dx)])))
print(all(hd$hpdx[is.infinite(dist$dx)] == 0)) # hpdx = 0 if dist = Inf


# gamma on ([0, 1] v [2,3])^p
domain &lt;- make_domain("uniform", p=p, lefts=c(0,2), rights=c(1,3))
x &lt;- gen(n, setting="gamma", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# If 0 &lt;= xij &lt;= 1, distance to boundary is min(x-0, 1-x)
max(abs(dist$dx - pmin(x, 1-x))[x &gt;= 0 &amp; x &lt;= 1])
# If 0 &lt;= xij &lt;= 1, dist'(xij) is 1 if it is closer to 0, or -1 if it is closer 1,
#   assuming xij %in% c(0, 0.5, 1) with probability 0
all((dist$dpx == 2 * (1-x &gt; x) - 1)[x &gt;= 0 &amp; x &lt;= 1])
# If 2 &lt;= xij &lt;= 3, distance to boundary is min(x-2, 3-x)
max(abs(dist$dx - pmin(x-2, 3-x))[x &gt;= 2 &amp; x &lt;= 3])
# If 2 &lt;= xij &lt;= 3, dist'(xij) is 1 if it is closer to 2, or -1 if it is closer 3,
#   assuming xij %in% c(2, 2.5, 3) with probability 0
all((dist$dpx == 2 * (3-x &gt; x-2) - 1)[x &gt;= 2 &amp; x &lt;= 3])
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))


# a0.6_b0.7 on {x1 &gt; 1 &amp;&amp; log(1.3) &lt; x2 &lt; 1 &amp;&amp; x3 &gt; log(1.3) &amp;&amp; ... &amp;&amp; xp &gt; log(1.3)}
domain &lt;- make_domain("polynomial", p=p, rule="1 &amp;&amp; 2 &amp;&amp; 3",
       ineqs=list(list("expression"="x1&gt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="x2&lt;1", abs=FALSE, nonnegative=TRUE),
                      list("expression"="exp(x)&gt;1.3", abs=FALSE, nonnegative=FALSE)))
set.seed(1)
xinit &lt;- c(1.5, 0.5, abs(stats::rnorm(p-2)) + log(1.3))
x &lt;- gen(n, setting="ab_3/5_7/10", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=xinit, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# x_{i1} has uniform bound [1, +Inf), so its distance to its boundary is x_{i1} - 1
max(abs(dist$dx[,1] - (x[,1] - 1)))
# x_{i2} has uniform bound [log(1.3), 1], so its distance to its boundary
#    is min(x_{i2} - log(1.3), 1 - x_{i2})
max(abs(dist$dx[,2] - pmin(x[,2] - log(1.3), 1 - x[,2])))
# x_{ij} for j &gt;= 3 has uniform bound [log(1.3), +Inf), so its distance to its boundary is
#    simply x_{ij} - log(1.3)
max(abs(dist$dx[,3:p] - (x[,3:p] - log(1.3))))
# dist'(xi2) is 1 if it is closer to log(1.3), or -1 if it is closer 1,
#    assuming x_{i2} %in% c(log(1.3), (1+log(1.3))/2, 1) with probability 0
all((dist$dpx[,2] == 2 * (1 - x[,2] &gt; x[,2] - log(1.3)) - 1))
all(dist$dpx[,-2] == 1) # x_{ij} for j != 2 is bounded from below but unbounded from above,
#    so dist'(xij) is always 1
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))


# log_log model on {x in R_+^p: sum_j j * xj &lt;= 1}
domain &lt;- make_domain("polynomial", p=p,
       ineqs=list(list("expression"=paste(paste(sapply(1:p,
                           function(j){paste(j, "x", j, sep="")}), collapse="+"), "&lt;1"),
                     abs=FALSE, nonnegative=TRUE)))
x &lt;- gen(n, setting="log_log", abs=FALSE, eta=eta, K=K, domain=domain, finite_infinity=100, 
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
dist &lt;- get_dist(x, domain)
# Upper bound for j * xij so that sum_j j * xij &lt;= 1
quota &lt;- 1 - (rowSums(t(t(x) * 1:p)) - t(t(x) * 1:p))
# Distance of xij to its boundary is min(xij - 0, quota_{i,j} / j - xij)
max(abs(dist$dx - pmin((t(t(quota) / 1:p) - x), x)))
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))


# log_log_sum0 model on the simplex with K having row and column sums 0 (Aitchison model)
domain &lt;- make_domain("simplex", p=p)
K &lt;- -cov_cons("band", p=p, spars=3, eig=1)
diag(K) &lt;- diag(K) - rowSums(K) # So that rowSums(K) == colSums(K) == 0
eigen(K)$val[(p-1):p] # Make sure K has one 0 and p-1 positive eigenvalues
x &lt;- gen(n, setting="log_log_sum0", abs=FALSE, eta=eta, K=K, domain=domain,
       xinit=NULL, seed=2, burn_in=1000, thinning=100, verbose=FALSE)
# Note that dist$dx and dist$dpx only has p-1 columns -- excluding the last coordinate in x
dist &lt;- get_dist(x, domain)
# Upper bound for x_{i,j} so that x_{i,1} + ... + x_{i,p-1} &lt;= 1
quota &lt;- 1 - (rowSums(x[,-p]) - x[,-p])
# Distance of x_{i,j} to its boundary is min(xij - 0, quota_{i,j} - xij)
max(abs(dist$dx - pmin(quota - x[,-p], x[,-p])))
h_hp &lt;- get_h_hp("pow", 2) # For demonstration only
# Now confirm that h_of_dist indeed applies h and hp to dists
hd &lt;- h_of_dist(h_hp, x, domain)
# hdx = dist ^ 2
print(max(abs(hd$hdx - dist$dx^2)))
# hpdx = 2 * dist' * dist
print(max(abs(hd$hpdx - 2*dist$dpx*dist$dx)))
</code></pre>


</div>