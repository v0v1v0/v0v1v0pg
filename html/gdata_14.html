<div class="container">

<table style="width: 100%;"><tr>
<td>mapLevels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mapping levels</h2>

<h3>Description</h3>

<p><code>mapLevels</code> produces a map with information on levels and/or
internal integer codes. As such can be conveniently used to store level
mapping when one needs to work with internal codes of a factor and later
transfrorm back to factor or when working with several factors that
should have the same levels and therefore the same internal coding.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mapLevels(x, codes=TRUE, sort=TRUE, drop=FALSE, combine=FALSE, ...)
mapLevels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object whose levels will be mapped, look into details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codes</code></td>
<td>
<p>boolean, create integer levelsMap (with internal
codes) or character levelsMap (with level names)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>boolean, sort levels of character <code>x</code>, look into
details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>boolean, drop unused levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combine</code></td>
<td>
<p>boolean, combine levels, look into details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for <code>sort</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>levelsMap or listLevelsMap, output of <code>mapLevels</code>
methods or constructed by user, look into details</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>mapLevels()</code> returns “levelsMap” or “listLevelsMap”
objects as described in levelsMap and listLevelsMap section.
</p>
<p>Result of <code>mapLevels&lt;-</code> is always a factor with remapped levels or
a “list/data.frame” with remapped factors.
</p>


<h3>mapLevels</h3>

<p>The <code>mapLevels</code> function was written primarly for work with
“factors”, but is generic and can also be used with
“character”, “list” and “data.frame”, while
“default” method produces error. Here the term levels is also
used for unique character values.
</p>
<p>When <code>codes=TRUE</code> <b>integer “levelsMap”</b> with
information on mapping internal codes with levels is produced. Output
can be used to transform integer to factor or remap factor levels as
described below. With <code>codes=FALSE</code> <b>character
“levelsMap”</b> is produced. The later is usefull, when one would
like to remap factors or combine factors with some overlap in levels as
described in <code>mapLevels&lt;-</code> section and shown in examples.
</p>
<p><code>sort</code> argument provides possibility to sort levels of
“character” <code>x</code> and has no effect when <code>x</code> is a
“factor”.
</p>
<p>Argument <code>combine</code> has effect only in “list” and
“data.frame” methods and when <code>codes=FALSE</code> i.e. with
<b>character “levelsMaps”</b>. The later condition is necesarry
as it is not possible to combine maps with different mapping of level
names and integer codes. It is assumed that passed “list” and
“data.frame” have all components for which methods
exist. Otherwise an error is produced.
</p>


<h3>levelsMap and listLevelsMap</h3>

<p>Function <code>mapLevels</code> returns a map of levels. This map is of class
“levelsMap”, which is actually a list of length equal to number
of levels and with each component of length 1. Components need not be of
length 1. There can be either integer or character
“levelsMap”. <b>Integer “levelsMap”</b> (when
<code>codes=TRUE</code>) has names equal to levels and components equal to
internal codes. <b>Character “levelsMap”</b> (when
<code>codes=FALSE</code>) has names and components equal to levels. When
<code>mapLevels</code> is applied to “list” or “data.frame”,
result is of class “listLevelsMap”, which is a list of
“levelsMap” components described previously. If
<code>combine=TRUE</code>, result is a “levelsMap” with all levels in
<code>x</code> components.
</p>
<p>For ease of inspection, print methods unlists “levelsMap” with
proper names. <code>mapLevels&lt;-</code> methods are fairly general and
therefore additional convenience methods are implemented to ease the
work with maps: <code>is.levelsMap</code> and <code>is.listLevelsMap</code>;
<code>as.levelsMap</code> and <code>as.listLevelsMap</code> for coercion of user
defined maps; generic <code>"["</code> and <code>c</code> for both classes (argument
<code>recursive</code> can be used in <code>c</code> to coerce
“listLevelsMap” to “levelsMap”) and generic <code>unique</code>
and <code>sort</code> (generic from <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 2.4) for “levelsMap”.
</p>


<h3>mapLevels&lt;-</h3>

<p>Workhorse under <code>mapLevels&lt;-</code> methods is
<code>levels&lt;-</code>. <code>mapLevels&lt;-</code> just control the assignment
of “levelsMap” (integer or character) or “listLevelsMap”
to <code>x</code>. The idea is that map values are changed to map names as
indicated in <code>levels</code> examples. <b>Integer
“levelsMap”</b> can be applied to “integer” or
“factor”, while <b>character “levelsMap”</b> can be
applied to “character” or “factor”. Methods for
“list” and “data.frame” can work only on mentioned atomic
components/columns and can accept either “levelsMap” or
“listLevelsMap”. Recycling occurs, if length of <code>value</code> is not
the same as number of components/columns of a “list/data.frame”.
</p>


<h3>Author(s)</h3>

<p>Gregor Gorjanc</p>


<h3>See Also</h3>

<p><code>factor</code>, <code>levels</code> and <code>unclass</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Integer levelsMap
(f &lt;- factor(sample(letters, size=20, replace=TRUE)))
(mapInt &lt;- mapLevels(f))

## Integer to factor
(int &lt;- as.integer(f))
(mapLevels(int) &lt;- mapInt)
all.equal(int, f)

## Remap levels of a factor
(fac &lt;- factor(as.integer(f)))
(mapLevels(fac) &lt;- mapInt) # the same as levels(fac) &lt;- mapInt
all.equal(fac, f)

## Character levelsMap
f1 &lt;- factor(letters[1:10])
f2 &lt;- factor(letters[5:14])

## Internal codes are the same, but levels are not
as.integer(f1)
as.integer(f2)

## Get character levelsMaps and combine them
mapCha1 &lt;- mapLevels(f1, codes=FALSE)
mapCha2 &lt;- mapLevels(f2, codes=FALSE)
(mapCha &lt;- c(mapCha1, mapCha2))

## Remap factors
mapLevels(f1) &lt;- mapCha # the same as levels(f1) &lt;- mapCha
mapLevels(f2) &lt;- mapCha # the same as levels(f2) &lt;- mapCha

## Internal codes are now "consistent" among factors
as.integer(f1)
as.integer(f2)

## Remap characters to get factors
f1 &lt;- as.character(f1); f2 &lt;- as.character(f2)
mapLevels(f1) &lt;- mapCha
mapLevels(f2) &lt;- mapCha

## Internal codes are now "consistent" among factors
as.integer(f1)
as.integer(f2)
</code></pre>


</div>