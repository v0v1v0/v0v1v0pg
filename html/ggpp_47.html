<div class="container">

<table style="width: 100%;"><tr>
<td>geom_label_pairwise</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Label pairwise comparisons</h2>

<h3>Description</h3>

<p>Add a plot layer with a text label and a segment connecting two
values along the <code>x</code> aesthetic. These are usually two levels of a
factor mapped to the <code>x</code> aesthetic when used to report significance or
highlighting pairwise comparisons.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_label_pairwise(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "all",
  color.target = colour.target,
  default.alpha = NA,
  alpha.target = "segment",
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  segment.linewidth = 0.5,
  arrow = NULL,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_text_pairwise(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "all",
  color.target = colour.target,
  default.alpha = NA,
  alpha.target = "all",
  segment.linewidth = 0.5,
  arrow = NULL,
  check_overlap = FALSE,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Set of aesthetic mappings created by
<code>aes</code>. With <code>inherit.aes = FALSE</code>
(the default) it is not combined with the default mapping at the top level of
the plot. You always need to supply a <code>mapping</code> unless you set
<code>inherit.aes = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. There
are three types of arguments you can use here:
</p>
 <ul>
<li>
<p> Aesthetics: to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. </p>
</li>
<li>
<p> Other arguments to the
layer, for example you override the default <code>stat</code> associated with the
layer. </p>
</li>
<li>
<p> Other arguments passed on to the stat. </p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nudge_x, nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.colour, default.color</code></td>
<td>
<p>A colour definition to use for elements
not targeted by the colour aesthetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colour.target, color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code>arrow</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size.unit</code></td>
<td>
<p>How the 'size' aesthetic is interpreted: as millimetres
('"mm"', default), points ('"pt"'), centimetres ('"cm"'), inches ('"in"'),
or picas ('"pc"').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code> includes a legend if any aesthetics are mapped.
<code>FALSE</code>, the default, never includes it, and <code>TRUE</code> always includes it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> takes place at draw
time and in the order of the data, thus its action depends of the size at
which the plot is drawn.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Geometries <code>geom_text_pairwise()</code> and
<code>geom_label_pairwise()</code> have an interface similar to that of
<code>geom_text</code> and <code>geom_label</code>, but
add a segment connecting two values along <code>x</code>. In the most
frequent use case they add a segment connecting pairs of levels from a
grouping factor mapped to the <em>x</em> or <em>y</em> aesthetic. They can
also be used to label ranges of values.
</p>
<p>The segment extends from <code>xmin</code> to <code>xmax</code>, and the text label is
located at <code>x</code> with a default that positions the label at the centre
of the bar. The ends of the bar can be terminated with arrow heads given
by parameter <code>arrow</code>, with a default of a plain segment without
arrow tips. The text label is located slightly above the segment by the
default value of <code>vjust</code> in <code>geom_text_pairwise()</code> and on top
of the segment in <code>geom_label_pairwise()</code>.
</p>
<p>Layer functions <code>geom_text_pairwise()</code> and
<code>geom_label_pairwise()</code> use by default
<code>position_nudge</code>. Nudging affects both text label and
bar, and its default of no displacement will very rarely need to be
changed.
</p>
<p>Differently to <code>geom_text_repel()</code> and <code>geom_label_repel()</code>,
<code>geom_text_pairwise()</code> and <code>geom_label_pairwise()</code> do not make
use of additional aesthetics for the segments or boxes, but instead allow
the choice of which elements are targeted by the usual 'ggplot2' aesthetics
and which are rendered using a default constant value. In the grammar of
graphics using the same aesthetic with multiple meanings is not allowed,
thus, the approach used in package 'ggpp' attempts to enforce this.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Under development!</h3>

<p>This geometry is still under development
and its user interface subject to change.
</p>


<h3>Plot boundaries and clipping</h3>

<p>Note that when you change the scale
limits for <em>x</em> and/or <em>y</em> of a plot, text labels stay the same
size, as determined by the <code>size</code> aesthetic, given in millimetres. The
actual size as seen in the plotted output is decided during the rendering
of the plot to a graphics device. Limits are expanded only to include the
anchor point of the labels because the "width" and "height" of a text
element are 0 (as seen by ggplot2). Text labels do have height and width,
but in grid units, not data units. Either function
<code>expand_limits</code> or the scale expansion can be used to
ensure text labels remain within the plotting area.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). Values outside the range 0..1 displace the text label so
that the anchor point is outside the text label. In addition, you can use
special alignments for justification including <code>"position"</code>,
<code>"inward"</code> and <code>"outward"</code>. Inward always aligns text towards the
center of the plotting area, and outward aligns it away from the center of
the plotting area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"identity"</code>.
</p>


<h3>Aesthetics</h3>

<p>Layer functions <code>geom_text_pairwise()</code> and
<code>geom_label_pairwise()</code> require aesthetics <code>xmin</code>, <code>xmax</code>,
<code>x</code>, <code>y</code> and
<code>label</code> and support aesthetics: <code>alpha</code>, <code>colour</code>,
<code>group</code>, <code>size</code> (of text), <code>family</code>, <code>fontface</code>,
<code>linewidth</code>, <code>linetype</code>, <code>hjust</code> and <code>vjust</code>. In addition,
<code>geom_text_pairwise</code> supports <code>angle</code> and <code>geom_label_pairwise</code> supports
<code>fill</code>. See
<code>aes_colour_fill_alpha</code>,
<code>aes_linetype_size_shape</code>,
<code>aes_position</code>, and
<code>aes_group_order</code>.
</p>
<p>In 'ggplot2' <code>linewidth</code> when applied to the border of the box drawn
by <code>geom_label()</code> is given in points rather than in mm because of a
historical error in the code. In other geometries such as
<code>geom_segment()</code> <code>linewidth</code> is given in mm. As in
<code>geom_label_pairwise()</code> it is important to remain consistent among
different <code>linewidth</code> specifications, mm are used both for the box
border and linking segment. To imitate the behaviour of <code>geom_label()</code>
a correction factor of 0.75 (more exactly 1 pt = 0.7528 mm) can be used for
the line width of the border of the box.
</p>


<h3>See Also</h3>

<p><code>geom_text_s</code>, <code>geom_label_s</code>,
<code>geom_text</code>, <code>geom_label</code> and
other documentation of package 'ggplot2'.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
my.cars &lt;- mtcars
my.cars$name &lt;- rownames(my.cars)
p1 &lt;- ggplot(my.cars, aes(factor(cyl), mpg)) +
       geom_boxplot(width = 0.33)

# With a factor mapped to x, highlight pairs

my.pairs &lt;-
  data.frame(A = 1:2, B = 2:3, bar.height = c(12, 30),
             p.value = c(0.01, 0.05678))
p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = p.value),
                     parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     colour = "red",
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

p1 +
  geom_label_pairwise(data = my.pairs,
                      aes(xmin = A, xmax = B,
                          y = bar.height,
                          label = sprintf("italic(P)~`=`~%.2f", p.value)),
                      colour = "red", size = 2.75,
                      arrow = grid::arrow(angle = 30,
                                          length = unit(1.5, "mm"),
                                          ends = "both"),
                      parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     colour = "red", colour.target = "segment",
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     colour = "red", colour.target = "text",
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

# with a numeric vector mapped to x, indicate range

p2 &lt;-
  ggplot(my.cars, aes(disp, mpg)) +
    geom_point()

my.ranges &lt;-
  data.frame(A = c(50, 400),
             B = c(200, 500),
             bar.height = 5,
             text = c("small", "large"))

p2 +
  geom_text_pairwise(data = my.ranges,
                     aes(xmin = A, xmax = B,
                     y = bar.height, label = text))

p2 +
  geom_text_pairwise(data = my.ranges,
                     aes(xmin = A, xmax = B,
                         y = bar.height, label = text),
                     angle = 90, hjust = -0.1)

p2 +
  geom_label_pairwise(data = my.ranges,
                      aes(xmin = A, xmax = B,
                          y = bar.height, label = text),
                     angle = 90, hjust = -0.1)

p2 +
  geom_label_pairwise(data = my.ranges,
                      aes(xmin = A, xmax = B,
                          y = bar.height, label = text))

p2 +
  geom_text_pairwise(data = my.ranges,
                     aes(xmin = A, xmax = B,
                         y = bar.height, label = text),
                     arrow = grid::arrow(ends = "both", length = unit(2, "mm")))

</code></pre>


</div>