<div class="container">

<table style="width: 100%;"><tr>
<td>GPModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a <code>GPModel</code> object</h2>

<h3>Description</h3>

<p>Create a <code>GPModel</code> which contains a Gaussian process and / or mixed effects model with grouped random effects
</p>


<h3>Usage</h3>

<pre><code class="language-R">GPModel(likelihood = "gaussian", group_data = NULL,
  group_rand_coef_data = NULL, ind_effect_group_rand_coef = NULL,
  drop_intercept_group_rand_effect = NULL, gp_coords = NULL,
  gp_rand_coef_data = NULL, cov_function = "exponential",
  cov_fct_shape = 0.5, gp_approx = "none", cov_fct_taper_range = 1,
  cov_fct_taper_shape = 0, num_neighbors = 20L,
  vecchia_ordering = "random", ind_points_selection = "kmeans++",
  num_ind_points = 500L, cover_tree_radius = 1,
  matrix_inversion_method = "cholesky", seed = 0L, cluster_ids = NULL,
  free_raw_data = FALSE, vecchia_approx = NULL, vecchia_pred_type = NULL,
  num_neighbors_pred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>likelihood</code></td>
<td>
<p>A <code>string</code> specifying the likelihood function (distribution) of the response variable. 
Available options:
</p>

<ul>
<li>
<p> "gaussian" 
</p>
</li>
<li>
<p> "bernoulli_probit": binary data with Bernoulli likelihood and a probit link function 
</p>
</li>
<li>
<p> "bernoulli_logit": binary data with Bernoulli likelihood and a logit link function 
</p>
</li>
<li>
<p> "gamma": gamma distribution with a with log link function 
</p>
</li>
<li>
<p> "poisson": Poisson distribution with a with log link function 
</p>
</li>
<li>
<p> "negative_binomial": negative binomial distribution with a with log link function 
</p>
</li>
<li>
<p> Note: other likelihoods could be implemented upon request 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_data</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> whose columns are categorical grouping variables. 
The elements being group levels defining grouped random effects.
The elements of 'group_data' can be integer, double, or character.
The number of columns corresponds to the number of grouped (intercept) random effects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_rand_coef_data</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with numeric covariate data 
for grouped random coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_effect_group_rand_coef</code></td>
<td>
<p>A <code>vector</code> with integer indices that 
indicate the corresponding categorical grouping variable (=columns) in 'group_data' for 
every covariate in 'group_rand_coef_data'. Counting starts at 1.
The length of this index vector must equal the number of covariates in 'group_rand_coef_data'.
For instance, c(1,1,2) means that the first two covariates (=first two columns) in 'group_rand_coef_data'
have random coefficients corresponding to the first categorical grouping variable (=first column) in 'group_data',
and the third covariate (=third column) in 'group_rand_coef_data' has a random coefficient
corresponding to the second grouping variable (=second column) in 'group_data'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_intercept_group_rand_effect</code></td>
<td>
<p>A <code>vector</code> of type <code>logical</code> (boolean). 
Indicates whether intercept random effects are dropped (only for random coefficients). 
If drop_intercept_group_rand_effect[k] is TRUE, the intercept random effect number k is dropped / not included. 
Only random effects with random slopes can be dropped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_coords</code></td>
<td>
<p>A <code>matrix</code> with numeric coordinates (= inputs / features) for defining Gaussian processes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_rand_coef_data</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with numeric covariate data for
Gaussian process random coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_function</code></td>
<td>
<p>A <code>string</code> specifying the covariance function for the Gaussian process. 
Available options:
</p>

<ul>
<li>
<p>"exponential": Exponential covariance function (using the parametrization of Diggle and Ribeiro, 2007) 
</p>
</li>
<li>
<p>"gaussian": Gaussian, aka squared exponential, covariance function (using the parametrization of Diggle and Ribeiro, 2007) 
</p>
</li>
<li>
<p> "matern": Matern covariance function with the smoothness specified by 
the <code>cov_fct_shape</code> parameter (using the parametrization of Rasmussen and Williams, 2006) 
</p>
</li>
<li>
<p>"powered_exponential": powered exponential covariance function with the exponent specified by 
the <code>cov_fct_shape</code> parameter (using the parametrization of Diggle and Ribeiro, 2007) 
</p>
</li>
<li>
<p> "wendland": Compactly supported Wendland covariance function (using the parametrization of Bevilacqua et al., 2019, AOS) 
</p>
</li>
<li>
<p> "matern_space_time": Spatio-temporal Matern covariance function with different range parameters for space and time. 
Note that the first column in <code>gp_coords</code> must correspond to the time dimension 
</p>
</li>
<li>
<p> "matern_ard": anisotropic Matern covariance function with Automatic Relevance Determination (ARD), 
i.e., with a different range parameter for every coordinate dimension / column of <code>gp_coords</code> 
</p>
</li>
<li>
<p> "gaussian_ard": anisotropic Gaussian, aka squared exponential, covariance function with Automatic Relevance Determination (ARD), 
i.e., with a different range parameter for every coordinate dimension / column of <code>gp_coords</code> 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_fct_shape</code></td>
<td>
<p>A <code>numeric</code> specifying the shape parameter of the covariance function 
(=smoothness parameter for Matern covariance)  
This parameter is irrelevant for some covariance functions such as the exponential or Gaussian</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_approx</code></td>
<td>
<p>A <code>string</code> specifying the large data approximation
for Gaussian processes. Available options: 
</p>

<ul>
<li>
<p>"none": No approximation 
</p>
</li>
<li>
<p>"vecchia": A Vecchia approximation; see Sigrist (2022, JMLR) for more details 
</p>
</li>
<li>
<p>"tapering": The covariance function is multiplied by 
a compactly supported Wendland correlation function 
</p>
</li>
<li>
<p>"fitc": Fully Independent Training Conditional approximation aka 
modified predictive process approximation; see Gyger, Furrer, and Sigrist (2024) for more details 
</p>
</li>
<li>
<p>"full_scale_tapering": A full scale approximation combining an 
inducing point / predictive process approximation with tapering on the residual process; 
see Gyger, Furrer, and Sigrist (2024) for more details 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_fct_taper_range</code></td>
<td>
<p>A <code>numeric</code> specifying the range parameter 
of the Wendland covariance function and Wendland correlation taper function. 
We follow the notation of Bevilacqua et al. (2019, AOS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_fct_taper_shape</code></td>
<td>
<p>A <code>numeric</code> specifying the shape (=smoothness) parameter 
of the Wendland covariance function and Wendland correlation taper function. 
We follow the notation of Bevilacqua et al. (2019, AOS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_neighbors</code></td>
<td>
<p>An <code>integer</code> specifying the number of neighbors for 
the Vecchia approximation. Note: for prediction, the number of neighbors can 
be set through the 'num_neighbors_pred' parameter in the 'set_prediction_data'
function. By default, num_neighbors_pred = 2 * num_neighbors. Further, 
the type of Vecchia approximation used for making predictions is set through  
the 'vecchia_pred_type' parameter in the 'set_prediction_data' function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_ordering</code></td>
<td>
<p>A <code>string</code> specifying the ordering used in 
the Vecchia approximation. Available options:
</p>

<ul>
<li>
<p>"none": the default ordering in the data is used 
</p>
</li>
<li>
<p>"random": a random ordering 
</p>
</li>
<li>
<p>"time": ordering accorrding to time (only for space-time models) 
</p>
</li>
<li>
<p>"time_random_space": ordering according to time and randomly for all 
spatial points with the same time points (only for space-time models) 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_points_selection</code></td>
<td>
<p>A <code>string</code> specifying the method for choosing inducing points
Available options:
</p>

<ul>
<li>
<p>"kmeans++: the k-means++ algorithm 
</p>
</li>
<li>
<p>"cover_tree": the cover tree algorithm 
</p>
</li>
<li>
<p>"random": random selection from data points 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_ind_points</code></td>
<td>
<p>An <code>integer</code> specifying the number of inducing 
points / knots for, e.g., a predictive process approximation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cover_tree_radius</code></td>
<td>
<p>A <code>numeric</code> specifying the radius (= "spatial resolution") 
for the cover tree algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix_inversion_method</code></td>
<td>
<p>A <code>string</code> specifying the method used for inverting covariance matrices. 
Available options:
</p>

<ul>
<li>
<p>"cholesky": Cholesky factorization 
</p>
</li>
<li>
<p>"iterative": iterative methods. A combination of conjugate gradient, Lanczos algorithm, and other methods. 
</p>
<p>This is currently only supported for the following cases: 
</p>

<ul>
<li>
<p>likelihood != "gaussian" and gp_approx == "vecchia" (non-Gaussian likelihoods with a Vecchia-Laplace approximation) 
</p>
</li>
<li>
<p>likelihood == "gaussian" and gp_approx == "full_scale_tapering" (Gaussian likelihood with a full-scale tapering approximation) 
</p>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An <code>integer</code> specifying the seed used for model creation 
(e.g., random ordering in Vecchia approximation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_ids</code></td>
<td>
<p>A <code>vector</code> with elements indicating independent realizations of 
random effects / Gaussian processes (same values = same process realization).
The elements of 'cluster_ids' can be integer, double, or character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>free_raw_data</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, the data (groups, coordinates, covariate data for random coefficients) 
is freed in R after initialization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_approx</code></td>
<td>
<p>Discontinued. Use the argument <code>gp_approx</code> instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_pred_type</code></td>
<td>
<p>A <code>string</code> specifying the type of Vecchia approximation used for making predictions.
This is discontinued here. Use the function 'set_prediction_data' to specify this</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_neighbors_pred</code></td>
<td>
<p>an <code>integer</code> specifying the number of neighbors for making predictions.
This is discontinued here. Use the function 'set_prediction_data' to specify this</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>GPModel</code> containing ontains a Gaussian process and / or mixed effects model with grouped random effects
</p>


<h3>Author(s)</h3>

<p>Fabio Sigrist
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See https://github.com/fabsig/GPBoost/tree/master/R-package for more examples

data(GPBoost_data, package = "gpboost")

#--------------------Grouped random effects model: single-level random effect----------------
gp_model &lt;- GPModel(group_data = group_data[,1], likelihood="gaussian")

#--------------------Gaussian process model----------------
gp_model &lt;- GPModel(gp_coords = coords, cov_function = "exponential",
                    likelihood="gaussian")

#--------------------Combine Gaussian process with grouped random effects----------------
gp_model &lt;- GPModel(group_data = group_data,
                    gp_coords = coords, cov_function = "exponential",
                    likelihood="gaussian")
</code></pre>


</div>