<div class="container">

<table style="width: 100%;"><tr>
<td>ch4.solutions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solution code for Chapter 4: Introducing GAMs</h2>

<h3>Description</h3>

<p>R code for Chapter 4 exercise solutions.</p>


<h3>Author(s)</h3>

<p>Simon Wood &lt;simon@r-project.org&gt;
</p>
<p>Maintainer: Simon Wood &lt;simon@r-project.org&gt;
</p>


<h3>References</h3>

<p>Wood, S.N. (2017) <em>Generalized Additive Models: An Introduction with R</em>, CRC
</p>


<h3>See Also</h3>

<p><code>mgcv</code>, <code>ch4</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(gamair); library(mgcv)
## Q.1
set.seed(1)
x &lt;- sort(runif(40)*10)^.5
y &lt;- sort(runif(40))^0.1
## polynomial fits ...
xx &lt;- seq(min(x),max(x),length=200)
plot(x,y)
b&lt;-lm(y~poly(x,5))
lines(xx,predict(b,data.frame(x=xx)))
b&lt;-lm(y~poly(x,10))
lines(xx,predict(b,data.frame(x=xx)),col=2)
## spline fits ...
sb &lt;- function(x,xk) { abs(x-xk)^3}
q&lt;-11
xk&lt;-((1:(q-2)/(q-1))*10)^.5
## lazy person's formula construction ...
form&lt;-paste("sb(x,xk[",1:(q-2),"])",sep="",collapse="+")
form &lt;- paste("y~x+",form)
b&lt;-lm(formula(form))
lines(xx,predict(b,data.frame(x=xx)),col=3)

## Q.2
## x,y, and xx from previous question
b1 &lt;- lm(form)
plot(x,y)
lines(xx,predict(b1,data.frame(x=xx)),col=4)
X &lt;- model.matrix(b1)   # extract model matrix
beta &lt;- solve(t(X)%*%X,t(X)%*%y,tol=0)
b1$coefficients &lt;- beta # trick for simple prediction
lines(xx,predict(b1,data.frame(x=xx)),col=5)
## ... upping the basis dimension to 11 makes the
## normal equations estimates perform very badly.

## Q.8 Additive model as a mixed model

## from 4.2.1 and 4.3.1...
tf &lt;- function(x,xj,j) {
## generate jth tent function from set defined by knots xj
  dj &lt;- xj*0;dj[j] &lt;- 1
  approx(xj,dj,x)$y
}

tf.X &lt;- function(x,xj) {
## tent function basis matrix given data x
## and knot sequence xj
  nk &lt;- length(xj); n &lt;- length(x)
  X &lt;- matrix(NA,n,nk)
  for (j in 1:nk) X[,j] &lt;- tf(x,xj,j)
  X
}

tf.XD &lt;- function(x,xk,cmx=NULL,m=2) {
## get X and D subject to constraint
  nk &lt;- length(xk)
  X &lt;- tf.X(x,xk)[,-nk]                   ## basis matrix
  D &lt;- diff(diag(nk),differences=m)[,-nk] ## root penalty
  if (is.null(cmx)) cmx &lt;- colMeans(X)
  X &lt;- sweep(X,2,cmx)        ## subtract cmx from columns
  list(X=X,D=D,cmx=cmx)
} ## tf.XD

## Solution code...
## a)

XZmixed &lt;- function(x,xk=NULL,k=10,sep=TRUE) {
## Get re-parameterized model matrix/matrices...
  if (is.null(xk)) xk &lt;- seq(min(x),max(x),length=k)
  xd &lt;- tf.XD(x,xk)
  D &lt;- rbind(0,xd$D); D[1,1] &lt;- 1
  X &lt;- t(solve(t(D),t(xd$X)))
  if (sep) list(X=X[,1,drop=FALSE],Z=X[,-1],xk=xk)
  else list(X=X,xk=xk) 
} ## XZmixed

## b)
## get components of smooths for Height and Girth...
xh &lt;- XZmixed(trees$Height)
xg &lt;- XZmixed(trees$Girth)

## Fit as mixed model...
X &lt;- cbind(1,xh$X,xg$X)
Zg &lt;- xg$Z; Zh &lt;- xh$Z
g1 &lt;- g &lt;- factor(rep(1,nrow(X)))
vol &lt;- trees$Volume
b &lt;- lme(vol~X-1,random=list(g=pdIdent(~Zh-1),
         g1=pdIdent(~Zg-1)))

## c)
## raw vs. fitted and residual plot 
par(mfrow=c(1,2))
plot(fitted(b),vol)
rsd &lt;- vol - fitted(b)
plot(fitted(b),rsd)

## extract coefs for each smooth...
bh &lt;- as.numeric(coef(b)[c(2,4:11)]) ## coefs for s(Height)
bg &lt;- as.numeric(coef(b)[c(3,12:19)]) ## coefs for s(Height)

## get smooth specific prediction matrices...
Xh &lt;- XZmixed(trees$Height,xk=xh$xk,sep=FALSE)$X
Xg &lt;- XZmixed(trees$Girth,xk=xg$xk,sep=FALSE)$X

## d)
## plot smooths over partial residuals... 
sh &lt;- Xh%*%bh
sg &lt;- Xg%*%bg

par(mfrow=c(1,2))
plot(trees$Girth,sg+rsd,pch=19,col="grey",
     xlab="Girth",ylab="s(Girth)")
lines(trees$Girth,sg)
plot(trees$Height,sh+rsd,pch=19,col="grey",
     xlab="Height",ylab="s(Height)")
lines(trees$Height,sh)

## Q.9 Generalized version of 8 by PQL
## a)

gamm.fit &lt;- function(y,X,Zh,Zg) {
## gamma error log link 2 term gam fit via PQL...
  eta &lt;- log(y) ## get initial eta
  g &lt;- g1 &lt;- factor(rep(1,nrow(X)))
  not.converged &lt;- TRUE
  old.reml &lt;- 1e100 ## don't converge immediately
  while (not.converged) {
    mu &lt;- exp(eta)  ## current mu estimate  
    z &lt;- (y - mu)/mu + eta ## pseudodata
    fit &lt;- lme(z~X-1,random=list(g=pdIdent(~Zh-1),g1=pdIdent(~Zg-1)))
    if (abs(logLik(fit)-old.reml)&lt;1e-5*abs(logLik(fit))) { 
      not.converged &lt;- FALSE
    }
    old.reml &lt;- logLik(fit) 
    eta &lt;- fitted(fit) ## updated eta
  }
  fit
} ## gamm.fit

## b) re-using arguments from Q.8...
m &lt;- gamm.fit(vol,X,Zh,Zg)

## c)
rsd &lt;- residuals(m)
par(mfrow=c(1,2))
plot(exp(fitted(m)),vol);abline(0,1)
plot(fitted(m),rsd)

## d)
bh &lt;- as.numeric(coef(m)[c(2,4:11)]) ## coefs for s(Height)
bg &lt;- as.numeric(coef(m)[c(3,12:19)]) ## coefs for s(Height)

sh &lt;- Xh%*%bh
sg &lt;- Xg%*%bg

par(mfrow=c(1,2))
plot(trees$Girth,sg+rsd,pch=19,col="grey",
     xlab="Girth",ylab="s(Girth)")
lines(trees$Girth,sg)
plot(trees$Height,sh+rsd,pch=19,col="grey",
     xlab="Height",ylab="s(Height)")
lines(trees$Height,sh)


</code></pre>


</div>