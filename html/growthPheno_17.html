<div class="container">

<table style="width: 100%;"><tr>
<td>byIndv4Times_SplinesGRs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>For a response in a <code>data.frame</code> in long format, computes, 
for a single set of smoothing parameters, smooths of the 
response, possibly along with growth rates calculated from the 
smooths.</h2>

<h3>Description</h3>

<p>Uses <code>smoothSpline</code> to fit a spline to the values 
of <code>response</code> for each <code>individual</code> and stores the fitted 
values in <code>data</code>. The degree of smoothing is controlled by the 
tuning parameters <code>df</code> and <code>lambda</code>, related to the 
penalty, and by <code>npspline.segments</code>. The <code>smoothing.method</code> 
provides for <code>direct</code> and <code>logarithmic</code> smoothing. 
</p>
<p>The Absolute and Relative Growth Rates ( AGR and RGR) can be computed 
either using the first derivatives of the splines or by differencing 
the smooths. If using the first derivative to obtain growth rates, 
<code>correctBoundaries</code> must be <code>FALSE</code>. Derivatives other than the 
first derivative can also be produced. The function 
<code>byIndv4Times_GRsDiff</code> is used to obtain growth rates by 
differencing.
</p>
<p>The handling of missing values in the observations is controlled via 
<code>na.x.action</code> and <code>na.y.action</code>. If there are not 
at least four distinct, nonmissing x-values, a warning is issued and 
all smoothed values and derivatives are set to <code>NA</code>. 
</p>
<p>The function <code>probeSmoothing</code> can be used to investgate the effect 
the smoothing parameters <br> (<code>smoothing.method</code>, <code>df</code> or  
<code>lambda</code>) on the smooth that results.
</p>


<h3>Usage</h3>

<pre><code class="language-R">byIndv4Times_SplinesGRs(data, response, response.smoothed = NULL, 
                        individuals = "Snapshot.ID.Tag", times, 
                        smoothing.method = "direct", smoothing.segments = NULL, 
                        spline.type = "NCSS", df=NULL, lambda = NULL, 
                        npspline.segments = NULL, 
                        correctBoundaries = FALSE, 
                        rates.method = "differences", 
                        which.rates = c("AGR","RGR"), 
                        suffices.rates = NULL, sep.rates = ".", 
                        avail.times.diffs = FALSE, ntimes2span = 2, 
                        extra.derivs = NULL, suffices.extra.derivs=NULL, 
                        sep.levels = ".", 
                        na.x.action="exclude", na.y.action = "trimx", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.frame</code> containing the column to be smoothed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> that is to be smoothed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response.smoothed</code></td>
<td>
<p>A <code>character</code> specifying the name of the column 
containing the values of the smoothed response variable, corresponding 
to <code>response</code>. If <code>response.smoothed</code> is <code>NULL</code>, then 
<code>response.smoothed</code> is set to the <code>response</code> to which is added 
the prefix <code>s</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>individuals</code></td>
<td>
<p>A <code>character</code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of <code>response</code> 
that correspond to the <code>response</code> values for an individual 
(e.g. plant, pot, cart, plot or unit) that are to be smoothed 
separately. If the columns corresponding to <code>individuals</code> are 
not <code>factor</code>(s) then they will be coerced to 
<code>factor</code>(s). The subsets are formed 
using <code>split</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> containing the times at which the data was 
collected, either as a <code>numeric</code>, <code>factor</code>, or 
<code>character</code>. It will be used as the values of the predictor 
variable to be supplied to <code>smooth.spline</code> and in 
calculating growth rates. If a <code>factor</code> or 
<code>character</code>, the values should be numerics stored as characters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing.method</code></td>
<td>
<p>A <code>character</code> giving the smoothing method 
to use. The two possibilites are (i) <code>"direct"</code>, for directly 
smoothing the observed <code>response</code>, and (ii) <code>"logarithmic"</code>, for 
smoothing the <code>log</code>-transformed <code>response</code> and then 
back-transforming by taking the exponentional of the fitted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing.segments</code></td>
<td>
<p>A named <code>list</code>, each of whose components 
is a numeric pair specifying the first and last values of an 
<code>times</code>-interval whose data is to be subjected as an entity to smoothing 
using splines. The separate smooths will be combined to form a whole 
smooth for each individual. If <code>get.rates</code> is <code>TRUE</code>, 
<code>rates.method</code> is <code>differences</code> and <code>ntimes2span</code> is 2, 
the smoothed growth rates will be computed over the set of segments; 
otherwise, they will be computed within segments. 
If <code>smoothing.segments</code> is <code>NULL</code>, the data is not 
segmented for smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.type</code></td>
<td>
<p>A <code>character</code> giving the type of spline  
to use. Currently, the possibilites are (i) <code>"NCSS"</code>, for natural 
cubic smoothing splines, and (ii) <code>"PS"</code>, for P-splines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>A <code>numeric</code> specifying, for natural cubic smoothing splines 
(<code>NCSS</code>), the desired equivalent number of degrees of freedom of the 
smooth (trace of the smoother matrix). Lower values result in more smoothing. 
If <code>df = NULL</code>, the amount of smoothing can be controlled by setting 
<code>lambda</code>. If both <code>df</code> and <code>lambda</code> are <code>NULL</code>, smoothing 
is controlled by the default arguments for <code>smooth.spline</code>, and any 
that you supply via the ellipsis (...) argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A <code>numeric</code> specifying the positive penalty to apply. 
The amount of smoothing decreases as <code>lamda</code> decreases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npspline.segments</code></td>
<td>
<p>A <code>numeric</code> specifying, for P-splines (<code>PS</code>), 
the number of equally spaced segments between <code>min(times)</code> and <code>max(times)</code>, 
excluding missing values, to use in constructing the B-spline basis for the 
spline fitting. If <code>npspline.segments</code> is NULL, <code>npspline.segments</code> 
is set to the maximum of 10 and <code>ceiling((nrow(data)-1)/2)</code> i.e. there will 
be at least 10 segments and, for more than 22 <code>times</code> values, there will be 
half as many segments as there are <code>times</code> values. The amount of smoothing 
decreases as <code>npspline.segments</code> increases. When the data has been 
segmented for smoothing (<code>smoothing.segments</code> is not <code>NULL</code>), 
an <code>npspline.segments</code> value can be supplied for each segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correctBoundaries</code></td>
<td>
<p>A <code>logical</code> indicating whether the fitted spline 
values are to have the method of Huang (2001) applied 
to them to correct for estimation bias at the end-points. Note that 
<code>spline.type</code> must be <code>NCSS</code> and <code>lambda</code> and <code>deriv</code> 
must be <code>NULL</code> for <code>correctBoundaries</code> to be set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rates.method</code></td>
<td>
<p>A <code>character</code> specifying the method to use in 
calculating the growth rates. The possibilities are 
<code>none</code>, <code>differences</code> and <code>derivatives</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.rates</code></td>
<td>
<p>A <code>character</code> giving the growth rates that are 
to be calculated. It should be a combination of one or more of 
<code>"AGR"</code>, <code>"PGR"</code> and <code>"RGR"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffices.rates</code></td>
<td>
<p>A <code>character</code> giving the characters to be 
appended to the names of the responses to provide the names of the 
columns containing the calculated growth rates. The order of the 
suffices in <code>suffices.rates</code> should correspond to the order 
of the elements of <code>which.rates</code>. If <code>NULL</code>, the values 
of <code>which.rates</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep.rates</code></td>
<td>
<p>A <code>character</code> giving the character(s) to be used 
to separate the <code>suffices.rates</code> value from a <code>response</code> 
value in constructing the name for a new rate. For no separator, 
set to <code>""</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avail.times.diffs</code></td>
<td>
<p>A <code>logical</code> indicating whether there is an 
appropriate column of <code>times</code> diffserences that can be used as 
the denominator in computing the growth rates. If <code>TRUE</code>, it will 
be assumed that the name of the column is the value of  <code>times</code> 
with <code>.diffs</code> appended. If <code>FALSE</code>, a column, whose 
column name will be the value of <code>times</code> with <code>.diffs</code> 
appended, will be formed and saved in the result, overwriting any 
existing columns with the constructed name in <code>data</code>. It will 
be calculated using the values of times in <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntimes2span</code></td>
<td>
<p>A <code>numeric</code> giving the number of values in 
<code>times</code> to span in calculating growth rates by differencing. 
Each growth rate is calculated as the difference in the values of 
one of the <code>responses</code> for pairs of <code>times</code> values that 
are spanned by <code>ntimes2span</code> <code>times</code> values divided by 
the difference between this pair of <code>times</code> values. For 
<code>ntimes2span</code> set to 2, a growth rate is the  
difference between consecutive pairs of values of one of the 
<code>responses</code> divided by the difference between consecutive 
pairs of <code>times</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra.derivs</code></td>
<td>
<p>A <code>numeric</code> specifying one or more orders of derivatives 
that are required, in addition to any required for calculating the growth 
rates. When <code>rates.method</code> is <code>derivatives</code>, these can be 
derivatives other than the first. Otherwise, any derivatives can be 
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffices.extra.derivs</code></td>
<td>
<p>A <code>character</code> giving the characters to be 
appended to <code>response.method</code> to construct the names of the derivatives. 
If <code>NULL</code> and the derivatives are to be retained, then <code>.dv</code> 
followed by the order of the derivative is appended to 
<code>response.method</code></p>
</td>
</tr>
</table>
<p>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sep.levels</code></td>
<td>
<p>A <code>character</code> giving the separator to use when the 
levels of <code>individuals</code> are combined. This is needed to avoid 
using a <code>character</code> that occurs in a <code>factor</code> to delimit 
levels when the levels of <code>individuals</code> are combined to identify 
subsets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.x.action</code></td>
<td>
<p>A <code>character</code> string that specifies the action to 
be taken when values of <code>x</code>, or the <code>times</code>, are <code>NA</code>. 
The possible values are <code>fail</code>, <code>exclude</code> or <code>omit</code>. 
For <code>exclude</code> and <code>omit</code>, predictions and derivatives 
will only be obtained for nonmissing values of <code>x</code>. 
The difference between these two codes is that for <code>exclude</code> the returned 
<code>data.frame</code> will have as many rows as <code>data</code>, the 
missing values have been incorporated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.y.action</code></td>
<td>
<p>A <code>character</code> string that specifies the action to 
be taken when values of <code>y</code>, or the <code>response</code>, are 
<code>NA</code>.  The possible values are <code>fail</code>, <code>exclude</code>, 
<code>omit</code>, <code>allx</code>, <code>trimx</code>, <code>ltrimx</code> or 
<code>rtrimx</code>. For  all options, except <code>fail</code>, missing 
values in <code>y</code> will be removed before smoothing. 
For <code>exclude</code> and <code>omit</code>, predictions 
and derivatives will be obtained only for nonmissing values of 
<code>x</code> that do not have missing <code>y</code> values. Again, the 
difference between these two is that, only for <code>exclude</code> 
will the missing values be incorporated into the 
returned <code>data.frame</code>. For <code>allx</code>, predictions and 
derivatives will be obtained for all nonmissing <code>x</code>. 
For <code>trimx</code>, they will be obtained for all nonmissing 
<code>x</code> between the first and last nonmissing <code>y</code> values 
that have been ordered for <code>x</code>; for <code>ltrimx</code> and 
<code>utrimx</code> either the lower or upper missing <code>y</code> 
values, respectively, are trimmed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>allows for arguments to be passed to <code>smooth.spline</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>data.frame</code> containing  <code>data</code> to which has been 
added a column with the fitted smooth, the name of the column being 
the value of <code>response.smoothed</code>. If <code>rates.method</code> is 
not <code>none</code>, columns for the growth rates listed in 
<code>which.rates</code> will be added to <code>data</code>; the names each of 
these columns will be the value of <code>response.smoothed</code> with 
the elements of <code>which.rates</code> appended. 
</p>
<p>When <code>rates.method</code> is <code>derivatives</code> and 
<code>smoothing.method</code> is <code>direct</code>, the <code>AGR</code> is obtained 
from the first derivative of the spline for each value of <code>times</code> 
and the <code>RGR</code> is calculated as the <code>AGR</code> divided by the 
value of the <code>response.smoothed</code> for the corresponding time. 
When <code>rates.method</code> is <code>derivatives</code> and 
<code>smoothing.method</code> is <code>logarithmic</code>, the <code>RGR</code> is 
obtained from the first derivative of the spline and the <code>AGR</code> 
is calculated as the <code>RGR</code> multiplied by the corresponding 
value of the <code>response.smoothed</code>.
</p>
<p>If <code>extra.derivs</code> is not <code>NULL</code>, the values for the 
nominated derivatives will also be added to <code>data</code>; the names 
each of these columns will be the value of <code>response.smoothed</code> 
with <code>.dvf</code> appended, where <code>f</code> is the order of the 
derivative, or  the value of <code>response.smoothed</code> 
with the corresponding element of <code>suffices.deriv</code> appended. 
</p>
<p>Any pre-existing smoothed and growth rate columns in <code>data</code> will be 
replaced. The ordering of the <code>data.frame</code> for the <code>times</code> 
values will be preserved as far as is possible; the main difficulty 
is with the handling of missing values by the function <code>merge</code>. 
Thus, if missing values in <code>times</code> are retained, they will occur at 
the bottom of each subset of <code>individuals</code> and the order will be 
problematic when there are missing values in <code>y</code> and 
<code>na.y.action</code> is set to <code>omit</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Eilers, P.H.C and Marx, B.D. (2021) <em>Practical smoothing: the joys of P-splines</em>. Cambridge University Press, Cambridge.
</p>
<p>Huang, C. (2001) Boundary corrected cubic smoothing splines. <em>Journal of Statistical Computation and Simulation</em>, <b>70</b>, 107-121.</p>


<h3>See Also</h3>

<p><code>smoothSpline</code>, <code>probeSmoothing</code>, <code>byIndv4Times_GRsDiff</code>, 
<code>smooth.spline</code>, <code>predict.smooth.spline</code>, <br><code>split</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(exampleData)
#smoothing with growth rates calculated using derivates
longi.dat &lt;- byIndv4Times_SplinesGRs(data = longi.dat, 
                                     response="PSA", response.smoothed = "sPSA", 
                                     times="DAP", 
                                     df = 4, rates.method = "deriv", 
                                     suffices.rates = c("AGRdv", "RGRdv"))
#Use P-splines
longi.dat &lt;- byIndv4Times_SplinesGRs(data = longi.dat, 
                                     response="PSA", response.smoothed = "sPSA", 
                                     individuals = "Snapshot.ID.Tag", times="DAP", 
                                     spline.type = "PS", lambda = 0.1, 
                                     npspline.segments = 10, 
                                     rates.method = "deriv", 
                                     suffices.rates = c("AGRdv", "RGRdv"))
#with segmented smoothing and no growth rates
longi.dat &lt;- byIndv4Times_SplinesGRs(data = longi.dat, 
                                     response="PSA", response.smoothed = "sPSA", 
                                     individuals = "Snapshot.ID.Tag", times="DAP", 
                                     smoothing.segments = list(c(28,34), c(35,42)), 
                                     df = 5, rates.method = "none")
</code></pre>


</div>