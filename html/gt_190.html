<div class="container">

<table style="width: 100%;"><tr>
<td>tab_spanner_delim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create column labels and spanners via delimited column names</h2>

<h3>Description</h3>

<p><code>tab_spanner_delim()</code> can take specially-crafted column names and generate
one or more spanners (and revise column labels at the same time). This is
done by splitting the column name by the specified delimiter text (<code>delim</code>)
and placing the fragments from top to bottom (i.e., higher-level spanners to
the column labels) or vice versa. Furthermore, neighboring text fragments on
different spanner levels that have the same text will be coalesced together.
For instance, having the three side-by-side column names <code>rating_1</code>,
<code>rating_2</code>, and <code>rating_3</code> will (in the default case at least) result in a
spanner with the label <code>"rating"</code> above columns with the labels <code>"1"</code>, <code>"2"</code>,
and <code>"3"</code>. There are many options in <code>cols_spanner_delim()</code> to slice and dice
delimited column names in different ways:
</p>

<ul>
<li>
<p> delimiter text: choose the delimiter text to use for the fragmentation of
column names into spanners with the <code>delim</code> argument
</p>
</li>
<li>
<p> direction and amount of splitting: we can choose to split <em>n</em> times
according to a <code>limit</code> argument, and, we get to specify from which side of
the column name the splitting should commence
</p>
</li>
<li>
<p> reversal of fragments: we can reverse the order the fragments we get from
the splitting procedure with the <code>reverse</code> argument
</p>
</li>
<li>
<p> column constraints: it's possible to constrain which columns in a <strong>gt</strong>
table should participate in spanner creation using vectors or
<strong>tidyselect</strong>-style expressions
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">tab_spanner_delim(
  data,
  delim,
  columns = everything(),
  split = c("last", "first"),
  limit = NULL,
  reverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><em>The gt table data object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;gt_tbl&gt;⁠</code> // <strong>required</strong>
</p>
<p>This is the <strong>gt</strong> table object that is commonly created through use of the
<code>gt()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delim</code></td>
<td>
<p><em>Delimiter for splitting</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <strong>required</strong>
</p>
<p>The delimiter text to use to split one of more column names (i.e., those
that are targeted via the <code>columns</code> argument).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>The columns to consider for the splitting, relabeling, and spanner setting
operations. Can either be a series of column names provided in <code>c()</code>, a
vector of column indices, or a select helper function (e.g.,
<code>starts_with()</code>, <code>ends_with()</code>, <code>contains()</code>, <code>matches()</code>, <code>num_range()</code>,
and <code>everything()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p><em>Splitting side</em>
</p>
<p><code style="white-space: pre;">⁠singl-kw:[last|first]⁠</code> // <em>default:</em> <code>"last"</code>
</p>
<p>Should the delimiter splitting occur from the <code>"last"</code> instance of the
<code>delim</code> character or from the <code>"first"</code>? The default here uses the <code>"last"</code>
keyword, and splitting begins at the last instance of the delimiter in the
column name. This option only has some consequence when there is a <code>limit</code>
value applied that is lesser than the number of delimiter characters for a
given column name (i.e., number of splits is not the maximum possible
number).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit</code></td>
<td>
<p><em>Limit for splitting</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;numeric|integer|character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An optional limit to place on the splitting procedure. The default <code>NULL</code>
means that a column name will be split as many times are there are
delimiter characters. In other words, the default means there is no limit.
If an integer value is given to <code>limit</code> then splitting will cease at the
iteration given by <code>limit</code>. This works in tandem with <code>split</code> since we can
adjust the number of splits from either the right side (<code>split = "last"</code>)
or left side (<code>split = "first"</code>) of the column name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p><em>Reverse vector of split names</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should the order of split names be reversed? By default, this is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>gt_tbl</code>.
</p>


<h3>Details on column splitting</h3>

<p>If we take a hypothetical table that includes the column names
<code>province.NL_ZH.pop</code>, <code>province.NL_ZH.gdp</code>, <code>province.NL_NH.pop</code>, and
<code>province.NL_NH.gdp</code>, we can see that we have a naming system that has a
well-defined structure. We start with the more general to the left
(<code>"province"</code>) and move to the more specific on the right (<code>"pop"</code>). If the
columns are in the table in this exact order, then things are in an ideal
state as the eventual spanner labels will form from this neighboring.
When using <code>tab_spanner_delim()</code> here with <code>delim</code> set as <code>"."</code> we get the
following text fragments:
</p>

<ul>
<li> <p><code>province.NL_ZH.pop</code> -&gt; <code>"province"</code>, <code>"NL_ZH"</code>, <code>"pop"</code>
</p>
</li>
<li> <p><code>province.NL_ZH.gdp</code> -&gt; <code>"province"</code>, <code>"NL_ZH"</code>, <code>"gdp"</code>
</p>
</li>
<li> <p><code>province.NL_NH.pop</code> -&gt; <code>"province"</code>, <code>"NL_NH"</code>, <code>"pop"</code>
</p>
</li>
<li> <p><code>province.NL_NH.gdp</code> -&gt; <code>"province"</code>, <code>"NL_NH"</code>, <code>"gdp"</code>
</p>
</li>
</ul>
<p>This gives us the following arrangement of column labels and spanner labels:
</p>
<div class="sourceCode default"><pre>--------- `"province"` ---------- &lt;- level 2 spanner
---`"NL_ZH"`--- | ---`"NL_NH"`--- &lt;- level 1 spanners
`"pop"`|`"gdp"` | `"pop"`|`"gdp"` &lt;- column labels
---------------------------------
</pre></div>
<p>There might be situations where the same delimiter is used throughout but
only the last instance requires a splitting. With a pair of column names like
<code>north_holland_pop</code> and <code>north_holland_area</code> you would only want <code>"pop"</code> and
<code>"area"</code> to be column labels underneath a single spanner (<code>"north_holland"</code>).
To achieve this, the <code>split</code> and <code>limit</code> arguments are used and the values
for each need to be <code>split = "last"</code> and <code>limit = 1</code>. This will give us
the following arrangement:
</p>
<div class="sourceCode default"><pre>--`"north_holland"`-- &lt;- level 1 spanner
 `"pop"`  |  `"area"` &lt;- column labels
---------------------
</pre></div>


<h3>Examples</h3>

<p>With a subset of the <code>towny</code> dataset, we can create a <strong>gt</strong> table and then
use <code>tab_spanner_delim()</code> to automatically generate column spanner labels.
In this case we have some column names in the form <code style="white-space: pre;">⁠population_&lt;year&gt;⁠</code>.
The underscore character is the delimiter that separates a common word
<code>"population"</code> and a year value. In this default way of splitting, fragments
to the right are lowest (really they become new column labels) and moving
left we get spanners. Let's have a look at how <code>tab_spanner_delim()</code> handles
these column names:
</p>
<div class="sourceCode r"><pre>towny_subset_gt &lt;-
  towny |&gt;
  dplyr::select(name, starts_with("population")) |&gt;
  dplyr::filter(grepl("^F", name)) |&gt;
  gt() |&gt;
  tab_spanner_delim(delim = "_") |&gt;
  fmt_integer()

towny_subset_gt
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_delim_1.png" alt="This image of a table was generated from the first code example in the `tab_spanner_delim()` help file." style="width:100%;"><p>The spanner created through this use of <code>tab_spanner_delim()</code> is
automatically given an ID value by <strong>gt</strong>. Because it's hard to know what the
ID value is, we can use <code>tab_info()</code> to inspect the table's indices and ID
values.
</p>
<div class="sourceCode r"><pre>towny_subset_gt |&gt; tab_info()
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_delim_2.png" alt="This image of a table was generated from the second code example in the `tab_spanner_delim()` help file." style="width:100%;"><p>From this informational table, we see that the ID for the spanner is
<code>"spanner-population_1996"</code>. Also, the columns are still accessible by the
original column names (<code>tab_spanner_delim()</code> did change their labels though).
Let's use <code>tab_style()</code> along with <code>cells_column_spanners()</code> to add some
styling to the spanner label of the <code>towny_subset_gt</code> table.
</p>
<div class="sourceCode r"><pre>towny_subset_gt |&gt;
  tab_style(
    style = cell_text(weight = "bold", transform = "capitalize"),
    locations = cells_column_spanners(spanners = "spanner-population_1996")
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_delim_3.png" alt="This image of a table was generated from the third code example in the `tab_spanner_delim()` help file." style="width:100%;"><p>We can plan ahead a bit and refashion the column names with <strong>dplyr</strong> before
introducing the table to <code>gt()</code> and <code>tab_spanner_delim()</code>. Here the column
labels have underscore delimiters where splitting is not wanted (so a period
or space character is used instead). The usage of <code>tab_spanner_delim()</code> gives
two levels of spanners. We can further touch up the labels after that with
<code>cols_label_with()</code> and <code>text_transform()</code>.
</p>
<div class="sourceCode r"><pre>towny |&gt;
  dplyr::slice_max(population_2021, n = 5) |&gt;
  dplyr::select(name, ends_with("pct")) |&gt;
  dplyr::rename_with(
    .fn = function(x) {
      x |&gt;
        sub("pop_change_", "Population Change.", x = _) |&gt;
        sub("_pct", ".pct", x = _)
    }
  ) |&gt;
  gt(rowname_col = "name") |&gt;
  tab_spanner_delim(delim = ".") |&gt;
  fmt_number(decimals = 1, scale_by = 100) |&gt;
  cols_label_with(
    fn = function(x) gsub("pct", "%", x)
  ) |&gt;
  text_transform(
    fn = function(x) gsub("_", " - ", x, fixed = TRUE),
    locations = cells_column_spanners()
  ) |&gt;
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |&gt;
  tab_style(
    style = "padding-right: 36px;",
    locations = cells_body()
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_delim_4.png" alt="This image of a table was generated from the fourth code example in the `tab_spanner_delim()` help file." style="width:100%;"><p>With a summarized, filtered, and pivoted version of the <code>pizzaplace</code>
dataset, we can create another <strong>gt</strong> table and then use
<code>tab_spanner_delim()</code> with the delimiter/separator also used in
<code>tidyr::pivot_wider()</code>. We can also process the generated column labels with
<code>cols_label_with()</code>.
</p>
<div class="sourceCode r"><pre>pizzaplace |&gt;
  dplyr::select(name, date, type, price) |&gt;
  dplyr::group_by(name, date, type) |&gt;
  dplyr::summarize(
    revenue = sum(price),
    sold = dplyr::n(),
    .groups = "drop"
  ) |&gt;
  dplyr::filter(date %in% c("2015-01-01", "2015-01-02", "2015-01-03")) |&gt;
  dplyr::filter(type %in% c("classic", "veggie")) |&gt;
  tidyr::pivot_wider(
    names_from = date,
    names_sep = ".",
    values_from = c(revenue, sold),
    values_fn = sum,
    names_sort = TRUE
  ) |&gt;
  gt(rowname_col = "name", groupname_col = "type") |&gt;
  tab_spanner_delim(delim = ".") |&gt;
  sub_missing(missing_text = "") |&gt;
  fmt_currency(columns = starts_with("revenue")) |&gt;
  data_color(
    columns = starts_with("revenue"),
    method = "numeric",
    palette = c("white", "lightgreen")
  ) |&gt;
  cols_label_with(
    fn = function(x) {
      paste0(x, " (", vec_fmt_datetime(x, format = "E"), ")")
    }
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_delim_5.png" alt="This image of a table was generated from the fifth code example in the `tab_spanner_delim()` help file." style="width:100%;"><h3>Function ID</h3>

<p>2-3
</p>


<h3>Function Introduced</h3>

<p><code>v0.2.0.5</code> (March 31, 2020)
</p>


<h3>See Also</h3>

<p><code>tab_spanner()</code> to manually create spanners with more control over
spanner labels.
</p>
<p>Other part creation/modification functions: 
<code>tab_caption()</code>,
<code>tab_footnote()</code>,
<code>tab_header()</code>,
<code>tab_info()</code>,
<code>tab_options()</code>,
<code>tab_row_group()</code>,
<code>tab_source_note()</code>,
<code>tab_spanner()</code>,
<code>tab_stub_indent()</code>,
<code>tab_stubhead()</code>,
<code>tab_style()</code>,
<code>tab_style_body()</code>
</p>


</div>