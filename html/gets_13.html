<div class="container">

<table style="width: 100%;"><tr>
<td>diagnostics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Diagnostics tests</h2>

<h3>Description</h3>

<p>Auxiliary function (i.e. not intended for the average user) called by the <code>arx</code>, <code>getsm</code>, <code>getsv</code>, <code>isat</code>, <code>getsFun</code> and <code>blocksFun</code> functions. The <code>diagnostics</code> function undertakes tests for autocorrelation, ARCH and non-normality in a residual series, and user-defined diagnostics provided via the <code>user.fun</code> argument (see details). The autocorrelation and ARCH tests are conducted as Ljung and Box (1979) tests for autocorrelation in the residuals and squared residuals, respectively, whereas the test for non-normality is that of Jarque and Bera (1980).</p>


<h3>Usage</h3>

<pre><code class="language-R">diagnostics(x, ar.LjungB=c(1, 0.025), arch.LjungB=c(1, 0.025),
  normality.JarqueB=NULL, verbose=TRUE, user.fun=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>list</code>, for example the estimation result of <code>ols</code>. The tests for serial correlation, ARCH and normality look for an entry in the list named <code>std.residuals</code> or <code>residuals</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.LjungB</code></td>
<td>
<p>a two element vector or <code>NULL</code>. In the former case, the first element contains the AR-order, the second element the significance level. If <code>NULL</code>, then a test for autocorrelation is not conducted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arch.LjungB</code></td>
<td>
<p>a two element vector or <code>NULL</code>. In the former case, the first element contains the ARCH-order, the second element the significance level. If <code>NULL</code>, then a test for ARCH is not conducted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normality.JarqueB</code></td>
<td>
<p><code>NULL</code> (the default) or a value between 0 and 1. In the latter case, a test for non-normality is conducted using a significance level equal to <code>normality.JarqueB</code>. If <code>NULL</code>, then no test for non-normality is conducted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a <code>data.frame</code> with the results of the diagnostics is returned. If <code>FALSE</code>, then the return-value is a <code>logical</code> that indicates whether the model passes the diagnostics (<code>TRUE</code> if it does, otherwise <code>FALSE</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user.fun</code></td>
<td>
<p><code>NULL</code> or a <code>list</code> with at least one entry, <code>name</code> (must be of class <code>character</code>), which should contain the name of the user-defined function. See details </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments (ignored) to accommodate deleted arguments from past versions of the functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The argument <code>user.fun</code> enables the user to specify additional diagnostics. To do this, the argument should be a <code>list</code> with at least one entry, <code>name</code> (of class <code>character</code>), that contains the name of the user-defined function. The call to this function is executed with <code>do.call</code>, whose default value on <code>envir</code> is <code>parent.frame()</code>. Usually, this will be the global environment (<code>.GlobalEnv</code>), but it can be changed by adding an entry named <code>envir</code> to the list that indicates where the user-defined function resides. If the <code>verbose</code> argument is set to <code>FALSE</code>, then an entry named <code>pval</code> must be provided. This entry should contain the chosen significance level or levels, i.e. either a scalar or a vector of length equal to the number of <em>p</em>-values returned by the user-defined diagnostics function (see examples). The user can also specify whether a rejection of the tests should cause the diagnostics to fail (default behaviour) or whether a rejection is desirable. For that purpose, a named entry <code>is.reject.bad</code> can be added that stores a logical vector of length equal to the number of tests conducted in the user diagnostics function. The first entry of the vector governs the diagnostic decision for the first row that the user diagnostics function returns, the second entry the decision for the second row etc. Additional entries in the <code>list</code> are passed on as arguments to the user-defined function.
</p>
<p>The user-defined function should refer to the named items of the estimation result <code>x</code> (see examples), and the value returned by the user-defined function should be a matrix of dimension <em>m</em> x 3. Here, <em>m</em> is the number of diagnostic tests performed by the user-defined function. For example, if only a single test is performed, then <em>m</em> = 1 and so the returned value should be a 1 x 3 matrix (or a vector of length 3). The three columns of the <em>m</em> x 3 matrix should contain, in the following order, 1) the value(s) of the test-statistic(s) (or <code>NA</code>), 2) the degree(s) of freedom(s) (or <code>NA</code>) of the tests, and 3) the <em>p</em>-value(s) of the test(s). When checking whether the model passes the diagnostics or not, the <em>p</em>-value(s) is(are) checked against the value(s) in the entry named <code>pval</code> in the <code>list</code> provided to <code>user.fun</code>. By default, a calculated <em>p</em>-value below the corresponding element in <code>pval</code> causes the diagnostics to fail. If a named entry <code>is.reject.bad</code> exists, this decision rule is only applied to tests whose corresponding entry is <code>TRUE</code> while the decision rule is reversed for those with entry <code>FALSE</code>. For these tests, the diagnostics fail if the hypothesis cannot be rejected.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>verbose=TRUE</code></td>
<td>
<p>a <code>data.frame</code> that contains the diagnostics results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose=FALSE</code></td>
<td>
<p>a <code>logical</code> (of length one) indicating whether the residuals and/or model passes ALL the diagnostics (<code>TRUE</code> if it does, <code>FALSE</code> otherwise)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Genaro Sucarrat, <a href="http://www.sucarrat.net/">http://www.sucarrat.net/</a><br>
Jonas Kurle, <a href="https://www.jonaskurle.com/">https://www.jonaskurle.com/</a>
</p>


<h3>References</h3>

<p>C. Jarque and A. Bera (1980): 'Efficient Tests for Normality,
Homoscedasticity and Serial Independence'. Economics Letters 6,
pp. 255-259
</p>
<p>G. Ljung and G. Box (1979): 'On a Measure of Lack of Fit in Time
Series Models'. Biometrika 66, pp. 265-270
</p>


<h3>See Also</h3>

<p><code>arx</code>, <code>getsm</code>, <code>getsv</code>, <code>isat</code>, <code>getsFun</code>, <code>blocksFun</code></p>


<h3>Examples</h3>

<pre><code class="language-R">##generate some data:
set.seed(123)
vY &lt;- rnorm(20) #the regressand
mX &lt;- matrix(rnorm(3*20), 20, 3) #the regressors
est &lt;- ols(vY,mX)

##return a data-frame with autocorrelation and ARCH diagnostics (default),
##and check whether they pass (the default p-value is 0.025):
diagnostics(est)
diagnostics(est, verbose=FALSE)

##add the Jarque-Bera normality test to the diagnostics (w/p-value=0.05):
diagnostics(est, normality.JarqueB=0.05)
diagnostics(est, normality.JarqueB=0.05, verbose=FALSE)

##user-defined Shapiro-Wilks test for non-normality of the residuals:
SWtest &lt;- function(x, ...){
  tmp &lt;- shapiro.test(x$residuals)
  return( c(tmp$statistic, NA, tmp$p.value) )
}
diagnostics(est, user.fun=list(name="SWtest", pval=0.05))
diagnostics(est, user.fun=list(name="SWtest", pval=0.05), verbose=FALSE)

##user-defined test but diagnostics fail if do not reject (illustration only)
diagnostics(est, user.fun=list(name="SWtest", pval=0.05, is.reject.bad = FALSE))
diagnostics(est, user.fun=list(name="SWtest", pval=0.05, is.reject.bad = FALSE),
  verbose=FALSE)

</code></pre>


</div>