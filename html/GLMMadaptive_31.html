<div class="container">

<table style="width: 100%;"><tr>
<td>MixMod Methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Various Methods for Standard Generics
</h2>

<h3>Description</h3>

<p>Methods for object of class <code>"MixMod"</code> for standard generic functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
coef(object, ...)

## S3 method for class 'MixMod'
coef(object, sub_model = c("main", "zero_part"), 
    ...)

fixef(object, ...)

## S3 method for class 'MixMod'
fixef(object, sub_model = c("main", "zero_part"), ...)

ranef(object, ...)

## S3 method for class 'MixMod'
ranef(object, post_vars = FALSE, ...)

confint(object, parm, level = 0.95, ...)

## S3 method for class 'MixMod'
confint(object, 
  parm = c("fixed-effects", "var-cov","extra", "zero_part"), 
  level = 0.95, sandwich = FALSE, ...)

anova(object, ...)

## S3 method for class 'MixMod'
anova(object, object2, test = TRUE, 
  L = NULL, sandwich = FALSE, ...)

fitted(object, ...)

## S3 method for class 'MixMod'
fitted(object, 
  type = c("mean_subject", "subject_specific", "marginal"),
  link_fun = NULL, ...)

residuals(object, ...)

## S3 method for class 'MixMod'
residuals(object, 
  type = c("mean_subject", "subject_specific", "marginal"), 
  link_fun = NULL, tasnf_y = function (x) x, ...)
  
predict(object, ...)

## S3 method for class 'MixMod'
predict(object, newdata, newdata2 = NULL, 
    type_pred = c("response", "link"),
    type = c("mean_subject", "subject_specific", "marginal", "zero_part"),
    se.fit = FALSE, M = 300, df = 10, scale = 0.3, level = 0.95, 
    seed = 1, return_newdata = FALSE, sandwich = FALSE, ...)
    
simulate(object, nsim = 1, seed = NULL, ...)

## S3 method for class 'MixMod'
simulate(object, nsim = 1, seed = NULL, 
    type = c("subject_specific", "mean_subject"), new_RE = FALSE,
    acount_MLEs_var = FALSE, sim_fun = NULL, 
    sandwich = FALSE, ...)
    
terms(x, ...)

## S3 method for class 'MixMod'
terms(x, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)

formula(x, ...)

## S3 method for class 'MixMod'
formula(x, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)


model.frame(formula, ...)

## S3 method for class 'MixMod'
model.frame(formula, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)

model.matrix(object, ...)

## S3 method for class 'MixMod'
model.matrix(object, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)

nobs(object, ...)

## S3 method for class 'MixMod'
nobs(object, level = 1, ...)

VIF(object, ...)

## S3 method for class 'MixMod'
VIF(object, type = c("fixed", "zi_fixed"), ...)

cooks.distance(model, ...)

## S3 method for class 'MixMod'
cooks.distance(model, cores = max(parallel::detectCores() - 1, 1), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object, object2, x, formula, model</code></td>
<td>
<p>objects inheriting from class <code>"MixMod"</code>. When <code>object2</code>
is also provided, then the model behind <code>object</code> must be nested within the model 
behind <code>object2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub_model</code></td>
<td>
<p>character string indicating for which sub-model to extract the estimated
coefficients; it is only relevant for zero-inflated models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post_vars</code></td>
<td>
<p>logical; if <code>TRUE</code> the posterior variances of the random effects
are returned as an extra attribute of the numeric matrix produced by <code>ranef()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>character string; for which type of parameters to calculate confidence 
intervals. Option <code>"var-cov"</code> corresponds to the variance-covariance matrix of the 
random effects. Option <code>extra</code> corresponds to extra (shape/dispersion) 
parameters in the distribution of the outcome (e.g., the <code class="reqn">\theta</code> parameter in
the negative binomial family). Option <code>zero_inflated</code> corresponds to the 
coefficients of the zero-inflated sub-model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>numeric scalar between 0 and 1 denoting the level of the confidence interval.
In the <code>nobs()</code> method it denotes the level at which the number of observations is
counted. The value 0 corresponds to the number of independent sample units 
determined by the number of levels of the grouping variable. If set to a value greater
than zero, it returns the total number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>logical; should a p-value be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a numeric matrix representing a contrasts matrix. This is only used when in 
<code>anova()</code> only <code>object</code> is provided, and it can only be specified for the fixed 
effects. When <code>L</code> is used, a Wald test is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sandwich</code></td>
<td>
<p>logical; if <code>TRUE</code> the sandwich estimator is used in the calculation
of standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character string indicating the type of fitted values / residuals / predictions 
/ variance inflation factors to calculate. Option <code>"mean_subject"</code> corresponds to only using the fixed-effects
part; option <code>"subject_specific"</code> corresponds to using both the fixed- and 
random-effects parts; option <code>"marginal"</code> is based in multiplying the fixed 
effects design matrix with the marginal coefficients obtained by 
<code>marginal_coefs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link_fun</code></td>
<td>
<p>the <code>link_fun</code> of <code>marginal_coefs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tasnf_y</code></td>
<td>
<p>a function to transform the grouped / repeated measurements outcome before
calculating the residuals; for example, relevant in two-part models for semi-continuous
data, in which it is assumed that the log outcome follows a normal distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata, newdata2</code></td>
<td>
<p>a data frame based on which predictions are to be calculated.
<code>newdata2</code> is only relevant when <code>level = "subject_specific"</code>; see 
<b>Details</b> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_pred</code></td>
<td>
<p>character string indicating at which scale to calculate predictions. 
Options are <code>"link"</code> indicating to calculate predictions at the link function / 
linear predictor scale, and <code>"response"</code> indicating to calculate predictions at
the scale of the response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>logical, if <code>TRUE</code> standard errors of predictions are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples; see 
<b>Details</b> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>numeric scalar denoting the degrees of freedom for the Student's t proposal
distribution; see <b>Details</b> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>numeric scalar or vector denoting the scaling applied to the subject-specific
covariance matrices of the random effects; see <b>Details</b> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>numerical scalar giving the seed to be used in the Monte Carlo scheme.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_newdata</code></td>
<td>
<p>logical; if <code>TRUE</code> the <code>predict()</code> method returns a copy
of the <code>newdata</code> and of <code>newdata2</code> if the corresponding argument was not 
<code>NULL</code>, with extra columns the predictions, and the lower and upper limits of
the cofidence intervals when <code>type = "subject_specific"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>numeric scalar giving the number of times to simulate the response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_RE</code></td>
<td>
<p>logical; if <code>TRUE</code>, new random effects will be simulated, and new outcome
data will be simulated by <code>simulate()</code> using these new random effect. Otherwise,
the empirical Bayes estimates of the random effects from the fitted model will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acount_MLEs_var</code></td>
<td>
<p>logical; if <code>TRUE</code> it accounts for the variability of the 
maximum likelihood estimates (MLEs) by simulating a new value for the parameters from 
a multivariate normal distribution with mean the MLEs and covariance matrix the 
covariance matrix of the MLEs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim_fun</code></td>
<td>
<p>a function based on which to simulate the response variable. This is 
relevant for non-standard models. The <code>simulate()</code> function also tries to extract 
this function from the <code>family</code> component of <code>object</code>. The function should 
have the following four arguments: <code>n</code> a numeric scalar denoting the number of
observations to simulate, <code>mu</code> a numeric vector of means, <code>phis</code> a numeric
vector of extra dispersion/scale parameters, and <code>eta_zi</code> a numeric vector for 
the zero-part of the model, if this is relevant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>the number of cores to use in the computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments; currently none is used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In generic terms, we assume that the mean of the outcome <code class="reqn">y_i</code> (<code class="reqn">i = 1, ..., n</code> 
denotes the subjects) conditional on the random effects is given by the equation: 
</p>
<p style="text-align: center;"><code class="reqn">g{E(y_i | b_i)} = \eta_i = X_i \beta + Z_i b_i,</code>
</p>

<p>where <code class="reqn">g(.)</code> denotes the link function, <code class="reqn">b_i</code> the vector of random effects, 
<code class="reqn">\beta</code> the vector of fixed effects, and <code class="reqn">X_i</code> and <code class="reqn">Z_i</code> the design matrices
for the fixed and random effects, respectively.
</p>
<p>Argument <code>type_pred</code> of <code>predict()</code> specifies whether predictions will be 
calculated in the link / linear predictor scale, i.e., <code class="reqn">\eta_i</code> or in the response 
scale, i.e., <code class="reqn">g{E(y_i | b_i)}</code>.
</p>
<p>When <code>type = "mean_subject"</code>, predictions are calculated using only the fixed 
effects, i.e., the <code class="reqn">X_i \beta</code> part, where <code class="reqn">X_i</code> is evaluated in <code>newdata</code>. 
This corresponds to predictions for the 'mean' subjects, i.e., subjects who have 
random effects value equal to 0. Note, that in the case of nonlinear link functions this
does not correspond to the averaged over the population predictions (i.e., marginal 
predictions).
</p>
<p>When <code>type = "marginal"</code>, predictions are calculated using only the fixed 
effects, i.e., the <code class="reqn">X_i \beta</code> part, where <code class="reqn">X_i</code> is evaluated in <code>newdata</code>,
but with <code class="reqn">\beta</code> coefficients the marginalized coefficients obtain from 
<code>marginal_coefs</code>. These predictions will be marginal / population averaged 
predictions.
</p>
<p>When <code>type = "zero_part"</code>, predictions are calculated for the logistic regression of
the extra zero-part of the model (i.e., applicable for zero-inflated and hurdle models).
</p>
<p>When <code>type = "subject_specific"</code>, predictions are calculated using both the fixed- 
and random-effects parts, i.e., <code class="reqn">X_i \beta + Z_i b_i</code>, where <code class="reqn">X_i</code> and <code class="reqn">Z_i</code> 
are evaluated in <code>newdata</code>. Estimates for the random effects of each subject are 
obtained as modes from the posterior distribution <code class="reqn">[b_i | y_i; \theta]</code> evaluated in 
<code>newdata</code> and with <code class="reqn">theta</code> (denoting the parameters of the model, fixed effects
and variance components) replaced by their maximum likelihood estimates. 
</p>
<p><b>Notes:</b> (i) When <code>se.fit = TRUE</code> and <code>type_pred = "response"</code>, the 
standard errors returned are on the linear predictor scale, not the response scale. 
(ii) When <code>se.fit = TRUE</code> and the model contains an extra zero-part, no standard 
errors are computed when <code>type = "mean_subject"</code>. (iii) When the model contains an 
extra zero-part, <code>type = "marginal"</code> predictions are not yet implemented.
</p>
<p>When <code>se.fit = TRUE</code> and <code>type = "subject_specific"</code>, standard errors and 
confidence intervals for the subject-specific predictions are obtained by a Monte Carlo 
scheme entailing three steps repeated <code>M</code> times, namely
</p>

<dl>
<dt>Step I</dt>
<dd>
<p>Account for the variability of maximum likelihood estimates (MLES) by 
simulating a new value <code class="reqn">\theta^*</code> for the parameters <code class="reqn">\theta</code> from a 
multivariate normal distribution with mean the MLEs and covariance matrix the 
covariance matrix of the MLEs.</p>
</dd>
<dt>Step II</dt>
<dd>
<p>Account for the variability in the random effects estimates by 
simulating a new value <code class="reqn">b_i^*</code> for the random effects <code class="reqn">b_i</code> from the posterior
distribution <code class="reqn">[b_i | y_i; \theta^*]</code>. Because the posterior distribution does not
have a closed-form, a Metropolis-Hastings algorithm is used to sample the new value 
<code class="reqn">b_i^*</code> using as proposal distribution a multivariate Student's-t distribution
with degrees of freedom <code>df</code>, centered at the mode of the posterior distribution
<code class="reqn">[b_i | y_i; \theta]</code> with <code class="reqn">\theta</code> the MLEs, and scale matrix the inverse
Hessian matrix of the log density of <code class="reqn">[b_i | y_i; \theta]</code> evaluated at the modes,
but multiplied by <code>scale</code>. The <code>scale</code> and <code>df</code> parameters can be used 
to adjust the acceptance rate.</p>
</dd>
<dt>Step III</dt>
<dd>
<p>The predictions are calculated using <code class="reqn">X_i \beta^* + Z_i b_i^*</code>.</p>
</dd>
</dl>
<p>Argument <code>newdata2</code> can be used to calculate dynamic subject-specific predictions. 
I.e., using the observed responses <code class="reqn">y_i</code> in <code>newdata</code>, estimates of the random
effects of each subject are obtained. For the same subjects we want to obtain predictions
in new covariates settings for which no response data are yet available. For example, 
in a longitudinal study, for a subject we have responses up to a follow-up <code class="reqn">t</code> 
(<code>newdata</code>) and we want the prediction at <code class="reqn">t + \Delta t</code> (<code>newdata2</code>).
</p>


<h3>Value</h3>

<p>The estimated fixed and random effects, coefficients (this is similar as in package 
<b>nlme</b>), confidence intervals fitted values (on the scale on the response) and 
residuals.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code>mixed_model</code>,
<code>marginal_coefs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# simulate some data
set.seed(123L)
n &lt;- 500
K &lt;- 15
t.max &lt;- 25

betas &lt;- c(-2.13, -0.25, 0.24, -0.05)
D &lt;- matrix(0, 2, 2)
D[1:2, 1:2] &lt;- c(0.48, -0.08, -0.08, 0.18)

times &lt;- c(replicate(n, c(0, sort(runif(K-1, 0, t.max)))))
group &lt;- sample(rep(0:1, each = n/2))
DF &lt;- data.frame(year = times, group = factor(rep(group, each = K)))
X &lt;- model.matrix(~ group * year, data = DF)
Z &lt;- model.matrix(~ year, data = DF)

b &lt;- cbind(rnorm(n, sd = sqrt(D[1, 1])), rnorm(n, sd = sqrt(D[2, 2])))
id &lt;- rep(1:n, each = K)
eta.y &lt;- as.vector(X %*% betas + rowSums(Z * b[id, ]))
DF$y &lt;- rbinom(n * K, 1, plogis(eta.y))
DF$id &lt;- factor(id)

################################################

fm1 &lt;- mixed_model(fixed = y ~ year + group, random = ~ year | id, data = DF,
                   family = binomial())

head(coef(fm1))
fixef(fm1)
head(ranef(fm1))


confint(fm1)
confint(fm1, "var-cov")

head(fitted(fm1, "subject_specific"))
head(residuals(fm1, "marginal"))

fm2 &lt;- mixed_model(fixed = y ~ year * group, random = ~ year | id, data = DF,
                   family = binomial())

# likelihood ratio test between fm1 and fm2
anova(fm1, fm2)

# the same but with a Wald test
anova(fm2, L = rbind(c(0, 0, 0, 1)))

</code></pre>


</div>