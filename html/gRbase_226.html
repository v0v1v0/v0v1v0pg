<div class="container">

<table style="width: 100%;"><tr>
<td>graph-mcs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximum cardinality search on undirected graph.</h2>

<h3>Description</h3>

<p>Returns (if it exists) a perfect ordering of the
vertices in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcs(object, root = NULL, index = FALSE)

## Default S3 method:
mcs(object, root = NULL, index = FALSE)

mcsMAT(amat, vn = colnames(amat), root = NULL, index = FALSE)

mcs_marked(object, discrete = NULL, index = FALSE)

## Default S3 method:
mcs_marked(object, discrete = NULL, index = FALSE)

mcs_markedMAT(amat, vn = colnames(amat), discrete = NULL, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An undirected graph represented either as a
<code>graphNEL</code> object, an <code>igraph</code>, a (dense)
<code>matrix</code>, a (sparse) <code>dgCMatrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>A vector of variables. The first variable in the
perfect ordering will be the first variable on 'root'. The
ordering of the variables given in 'root' will be followed as
far as possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>If TRUE, then a permutation is returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>amat</code></td>
<td>
<p>Adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vn</code></td>
<td>
<p>Nodes in the graph given by adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete</code></td>
<td>
<p>A vector indicating which of the nodes are
discrete. See 'details' for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>An undirected graph is decomposable iff there exists a
perfect ordering of the vertices. The maximum cardinality
search algorithm returns a perfect ordering of the vertices if
it exists and hence this algorithm provides a check for
decomposability. The <code>mcs()</code> functions finds such an
ordering if it exists.
</p>
<div class="sourceCode"><pre>The notion of strong decomposability is used in connection with
e.g. mixed interaction models where some vertices represent
discrete variables and some represent continuous
variables. Such graphs are said to be marked. The
\code{mcsmarked()} function will return a perfect ordering iff
the graph is strongly decomposable. As graphs do not know about
whether vertices represent discrete or continuous variables,
this information is supplied in the \code{discrete} argument.
</pre></div>


<h3>Value</h3>

<p>A vector with a linear ordering (obtained by maximum
cardinality search) of the variables or character(0) if such an
ordering can not be created.
</p>


<h3>Note</h3>

<p>The workhorse is the <code>mcsMAT</code> function.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code>moralize</code>, <code>junction_tree</code>,
<code>rip</code>, <code>ug</code>, <code>dag</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
uG &lt;- ug(~ me:ve + me:al + ve:al + al:an + al:st + an:st)
mcs(uG)
mcsMAT(as(uG, "matrix"))
## Same as
uG &lt;- ug(~ me:ve + me:al + ve:al + al:an + al:st + an:st, result="matrix")
mcsMAT(uG)

## Marked graphs
uG1 &lt;- ug(~ a:b + b:c + c:d)
uG2 &lt;- ug(~ a:b + a:d + c:d)
## Not strongly decomposable:
mcs_marked(uG1, discrete=c("a","d"))
## Strongly decomposable:
mcs_marked(uG2, discrete=c("a","d"))

</code></pre>


</div>