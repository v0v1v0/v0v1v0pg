<div class="container">

<table style="width: 100%;"><tr>
<td>ssanova9</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Smoothing Spline ANOVA Models with Correlated Data</h2>

<h3>Description</h3>

<p>Fit smoothing spline ANOVA models with correlated Gaussian data.
The symbolic model specification via <code>formula</code> follows the same
rules as in <code>lm</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ssanova9(formula, type=NULL, data=list(), subset, offset,
         na.action=na.omit, partial=NULL, method="v", alpha=1.4,
         varht=1, id.basis=NULL, nbasis=NULL, seed=NULL, cov,
         skip.iter=FALSE)

para.arma(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code>mkterm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for smoothing parameter selection.  Supported
are <code>method="v"</code> for V, <code>method="m"</code> for M, and
<code>method="u"</code> for U; see the reference for definitions of U,
V, and M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter modifying V or U; larger absolute values
yield smoother fits.  Ignored when <code>method="m"</code> are
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varht</code></td>
<td>
<p>External variance estimate needed for
<code>method="u"</code>.  Ignored when <code>method="v"</code> or
<code>method="m"</code> are specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.basis</code></td>
<td>
<p>Index designating selected "knots".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p>Number of "knots" to be selected.  Ignored when
<code>id.basis</code> is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed to be used for the random generation of "knots".
Ignored when <code>id.basis</code> is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>Input for covariance functions.  See <code>mkcov</code>
for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See notes on skipping theta
iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p><code>ssanova9</code> fit with ARMA error.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model specification via <code>formula</code> is intuitive.  For
example, <code>y~x1*x2</code> yields a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	y = C + f_{1}(x1) + f_{2}(x2) + f_{12}(x1,x2) + e
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>A subset of the observations are selected as "knots."  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
"knots" <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>
<p>Using <code class="reqn">q</code> "knots," <code>ssanova</code> calculates an approximate
solution to the penalized least squares problem using algorithms of
the order <code class="reqn">O(nq^{2})</code>, which for <code class="reqn">q&lt;&lt;n</code> scale better than
the <code class="reqn">O(n^{3})</code> algorithms of <code>ssanova0</code>.  For the
exact solution, one may set <code class="reqn">q=n</code> in <code>ssanova</code>, but
<code>ssanova0</code> would be much faster.
</p>


<h3>Value</h3>

<p><code>ssanova9</code> returns a list object of class
<code>c("ssanova9","ssanova")</code>.
</p>
<p>The method <code>summary.ssanova9</code> can be used to obtain
summaries of the fits.  The method <code>predict.ssanova</code> can
be used to evaluate the fits at arbitrary points along with standard
errors.  The method <code>project.ssanova9</code> can be used to
calculate the Kullback-Leibler projection for model selection.  The
methods <code>residuals.ssanova</code> and
<code>fitted.ssanova</code> extract the respective traits from the
fits.
</p>
<p><code>para.arma</code> returns the fitted ARMA coefficients for
<code>cov=list("arma",c(p,q))</code> in the call to <code>ssanova9</code>.
</p>


<h3>Skipping Theta Iteration</h3>

<p>For the selection of multiple smoothing parameters,
<code>nlm</code> is used to minimize the selection criterion such
as the GCV score.  When the number of smoothing parameters is large,
the process can be time-consuming due to the great amount of
function evaluations involved.
</p>
<p>The starting values for the <code>nlm</code> iteration are obtained using
Algorith 3.2 in Gu and Wahba (1991).  These starting values usually
yield good estimates themselves, leaving the subsequent quasi-Newton
iteration to pick up the "last 10%" performance with extra effort
many times of the initial one.  Thus, it is often a good idea to
skip the iteration by specifying <code>skip.iter=TRUE</code>, especially
in high-dimensions and/or with multi-way interactions.
</p>
<p><code>skip.iter=TRUE</code> could be made the default in future releases.
</p>


<h3>Note</h3>

<p>The results may vary from run to run. For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>References</h3>

<p>Han, C. and Gu, C. (2008), Optimal smoothing with correlated data,
<em>Sankhya</em>, <b>70-A</b>, 38â€“72.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- runif(100); y &lt;- 5 + 3*sin(2*pi*x) + rnorm(x)
## independent fit
fit &lt;- ssanova9(y~x,cov=list("known",diag(1,100)))
## AR(1) fit
fit &lt;- ssanova9(y~x,cov=list("arma",c(1,0)))
para.arma(fit)
## MA(1) fit
e &lt;- rnorm(101); e &lt;- e[-1]-.5*e[-101]
x &lt;- runif(100); y &lt;- 5 + 3*sin(2*pi*x) + e
fit &lt;- ssanova9(y~x,cov=list("arma",c(0,1)))
para.arma(fit)
## Clean up
## Not run: rm(x,y,e,fit)
</code></pre>


</div>