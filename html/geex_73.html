<div class="container">

<table style="width: 100%;"><tr>
<td>m_estimate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate parameters and their covariance from a set of estimating equations</h2>

<h3>Description</h3>

<p>M-estimation theory provides a framework for asympotic properties of estimators
that are solutions to estimating equations. Many R packages implement specific
applications of estimating equations. <span class="pkg">geex</span> aims to be provide a more general
framework that any modelling method can use to compute point and variance estimates
for parameters that are solutions to estimating equations of the form:
</p>
<p style="text-align: center;"><code class="reqn">\sum_i \psi(O_i, \hat{\theta}) = 0</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">m_estimate(
  estFUN,
  data,
  units = character(0),
  weights = numeric(0),
  outer_args = list(),
  inner_args = list(),
  roots = NULL,
  compute_roots = TRUE,
  compute_vcov = TRUE,
  Asolver = solve,
  corrections,
  deriv_control,
  root_control,
  approx_control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>estFUN</code></td>
<td>
<p>a function that takes in group-level data and returns a function
that takes parameters as its first argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>units</code></td>
<td>
<p>an optional character string identifying the grouping variable in <code>data</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outer_args</code></td>
<td>
<p>a list of arguments passed to the outer (data) function of <code>estFUN</code>. (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner_args</code></td>
<td>
<p>a list of arguments passed to the inner (theta) function of <code>estFUN</code>. (optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roots</code></td>
<td>
<p>a vector of parameter estimates must be provided if <code>compute_roots = FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_roots</code></td>
<td>
<p>whether or not to find the roots of the estimating equations.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_vcov</code></td>
<td>
<p>whether or not to compute the variance-covariance matrix.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Asolver</code></td>
<td>
<p>a function passed to <code>compute_sigma</code> used to compute the
inverse of the "bread" matrix. Defaults to <code>solve</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corrections</code></td>
<td>
<p>an optional list of small sample corrections where each
list element is a <code>correct_control</code> object which contains
two elements: <code>correctFUN</code> and <code>correctFUN_options</code>. The function
<code>correction</code> constructs <code>correct_control</code> objects.
See details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv_control</code></td>
<td>
<p>a <code>deriv_control</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root_control</code></td>
<td>
<p>a <code>root_control</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx_control</code></td>
<td>
<p>a <code>approx_control</code> object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The basic idea of <span class="pkg">geex</span> is for the analyst to provide at least
two items:
</p>

<ul>
<li>
<p> data
</p>
</li>
<li> <p><code>estFUN</code>: (the <code class="reqn">\psi</code> function), a function that takes unit-level
data and returns a function in terms of parameters (<code class="reqn">\theta</code>)
</p>
</li>
</ul>
<p>With the <code>estFUN</code>, <span class="pkg">geex</span> computes the roots of the estimating equations
and/or the empirical sandwich variance estimator.
</p>
<p>The root finding algorithm defaults to <code>multiroot</code> to
estimate roots though the solver algorithm can be specified in the <code>rootFUN</code>
argument. Starting values for <code>multiroot</code> are passed via the
<code>root_control</code> argument. See <code>vignette("v03_root_solvers", package = "geex")</code>
for information on customizing the root solver function.
</p>
<p>To compute only the covariance matrix, set <code>compute_roots = FALSE</code> and pass
estimates of <code class="reqn">\theta</code> via the <code>roots</code> argument.
</p>
<p>M-estimation is often used for clustered data, and a variable by which to split
the data.frame  into independent units is specified by the <code>units</code> argument.
This argument defaults to <code>NULL</code>, in which case the number of units equals
the number of rows in the data.frame.
</p>
<p>For information on the finite-sample corrections, refer to the finite sample
correction API vignette: <code>vignette("v05_finite_sample_corrections", package = "geex")</code>
</p>


<h3>Value</h3>

<p>a <code>geex</code> object
</p>


<h3>Writing an estFUN</h3>



<h4>Description</h4>

<p>An <code>estFUN</code> is a function representing <code class="reqn">\psi</code>. <span class="pkg">geex</span> works
by breaking <code class="reqn">\psi</code> into two parts:
</p>

<ul>
<li>
<p> the "outer" part of the <code>estFUN</code> which manipulates <code>data</code> and
<code>outer_args</code> and returns an
</p>
</li>
<li>
<p> "inner" function of <code>theta</code> and <code>inner_args</code>. Internally, this
"inner" function is called <code>psiFUN</code>.
</p>
</li>
</ul>
<p>In pseudo-code this looks like:
</p>
<pre>
function(data, &lt;&lt;outer_args&gt;&gt;){
  O &lt;- manipulate(data, &lt;&lt;outer_args&gt;&gt;)
  function(theta, &lt;&lt;inner_args&gt;&gt;){
    map(O, to = theta, and = &lt;&lt;inner_args&gt;&gt;)
  }
}</pre>
<p>See the examples below or the package vignettes to see an <code>estFUN</code>
in action.
</p>
<p>Importantly, the <code>data</code> used in an <code>estFUN</code> is *unit* level data,
which may be single rows in a data.frame or block of rows for clustered data.
</p>



<h4>Additional arguments</h4>

<p>Additional arguments may be passed to both the inner and outer function of the
<code>estFUN</code>. Elements in an <code>outer_args</code> list are passed to the outer
function; any elements of the <code>inner_args</code> list are passed to the inner
function. For an example, see the finite sample correction vignette [<code>
vignette("v05_finite_sample_corrections", package = "geex")</code>].
</p>



<h3>Setting up root_control</h3>

<p>To estimate roots of the estimating functions, <span class="pkg">geex</span> uses the <span class="pkg">rootSolve</span>
<code>multiroot</code> function by default, which requires starting
values. The <code>root_control</code> argument expects a <code>root_control</code>
object, which the utility function <code>setup_root_control</code> aids in
creating. For example, <code>setup_root_control(start = 4)</code> creates a
<code>root_control</code> setting the starting value to 4. In general,
the dimension of <code>start</code> must the same as <code>theta</code> in the inner
<code>estFUN</code>.
</p>


<h3>Using weights</h3>

<p>In some situations, use of weights can massively speed computations. Refer
to <code>vignette("v04_weights", package = "geex")</code> for an example.
</p>


<h3>References</h3>

<p>Stefanski, L. A., &amp; Boos, D. D. (2002). The calculus of M-estimation.
The American Statistician, 56(1), 29-38.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Estimate the mean and variance of Y1 in the geexex dataset
ex_eeFUN &lt;- function(data){
 function(theta){
   with(data,
    c(Y1 - theta[1],
     (Y1 - theta[1])^2 - theta[2] ))
}}

m_estimate(
 estFUN = ex_eeFUN,
 data  = geexex,
 root_control = setup_root_control(start = c(1,1)))

# compare to the mean() and variance() functions
mean(geexex$Y1)
n &lt;- nrow(geexex)
var(geexex$Y1) * (n - 1)/n

# A simple linear model for regressing X1 and X2 on Y4
lm_eefun &lt;- function(data){
 X &lt;- cbind(1, data$X1, data$X2)
 Y &lt;- data$Y4
 function(theta){
    t(X) %*% (Y - X %*% theta)
   }
 }

m_estimate(
 estFUN = lm_eefun,
 data  = geexex,
 root_control = setup_root_control(start = c(0, 0, 0)))

# Compare to lm() results
summary(lm(Y4 ~ X1 + X2, data = geexex))
</code></pre>


</div>