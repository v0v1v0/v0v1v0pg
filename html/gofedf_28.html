<div class="container">

<table style="width: 100%;"><tr>
<td>testYourModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply the Goodness of Fit Test Based on Empirical Distribution Function to Any Likelihood Model.</h2>

<h3>Description</h3>

<p>This function applies the goodness-of-fit test based on empirical distribution function.
It requires certain inputs depending on whether the model involves parameter estimation or not.
If the model is known and there is no parameter estimation, the function requires the sample as a vector and
the probability transformed (or pit) values of the sample. This ought to be a vector as well. If there is
parameter estimation in the model, the function additionally requires the score as a matrix with n
rows and p columns, where n is the sample size and p is the number of estimated parameters.
The function checks if the score is zero at the estimated parameter (which is assumed to be the maximum
likelihood estimate).
</p>


<h3>Usage</h3>

<pre><code class="language-R">testYourModel(
  x,
  pit,
  score = NULL,
  ngrid = length(x),
  gridpit = TRUE,
  precision = 1e-09,
  method = "cvm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a non-empty numeric vector of sample data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pit</code></td>
<td>
<p>The probability transformed (or pit) values of the sample which ought to be a numeric vector with
the same size as x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>The default value is null and refers to no parameter estimation case. If there is parameter estimation,
the score matrix must be a matrix with n rows and p columns, where n is the sample size and p is the number of
estimated parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngrid</code></td>
<td>
<p>the number of equally spaced points to discretize the (0,1) interval for computing the covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gridpit</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default value), the parameter ngrid is ignored and (0,1) interval is divided
based on probability inverse transformed values obtained from the sample. If <code>FALSE</code>, the interval is divided into ngrid
equally spaced points for computing the covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>The theory behind goodness-of-fit test based on empirical distribution function (edf) works well
if the MLE is indeed the root of derivative of log likelihood function. A precision of 1e-9 (default value) is used
to check this. A warning message is generated if the score evaluated at MLE is not close enough to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string indicating which goodness-of-fit statistic is to be computed. The default value is
'cvm' for the Cramer-von-Mises statistic. Other options include 'ad' for the Anderson-Darling statistic, and 'both'
to compute both cvm and ad.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of two containing the following components:
</p>

<ul>
<li>
<p> Statistic: the value of goodness-of-fit statistic.
</p>
</li>
<li>
<p> p-value: the approximate p-value for the goodness-of-fit test based on empirical distribution function.
if method = 'cvm' or method = 'ad', it returns a numeric value for the statistic and p-value. If method = 'both', it
returns a numeric vector with two elements and one for each statistic.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Example: Inverse Gaussian (IG) distribution with weights

# Set the seed to reproduce example.
set.seed(123)

# Set the sample size
n &lt;- 50

# Assign weights
weights &lt;- rep(1.5,n)

# Set mean and shape parameters for IG distribution.
mio        &lt;- 2
lambda     &lt;- 2

# Generate a random sample from IG distribution with weighted shape.
sim_data &lt;- statmod::rinvgauss(n, mean = mio, shape = lambda * weights)

# Compute MLE of parameters, score matrix, and pit values.
theta_hat    &lt;- inversegaussianMLE(obs = sim_data,   w = weights)
ScoreMatrix  &lt;- inversegaussianScore(obs = sim_data, w = weights, mle = theta_hat)
pitvalues    &lt;- inversegaussianPIT(obs = sim_data ,  w = weights, mle = theta_hat)

# Apply the goodness-of-fit test.
testYourModel(x = sim_data, pit = pitvalues, score = ScoreMatrix)

</code></pre>


</div>