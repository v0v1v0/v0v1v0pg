<div class="container">

<table style="width: 100%;"><tr>
<td>gamlssVGD</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A  Set of Functions for selecting Models using Validation or Test Data Sets and Cross Validation 
</h2>

<h3>Description</h3>

<p>This is a set of function useful for selecting appropriate models. 
</p>
<p>The functions <code>gamlssVGD</code>, <code>VGD</code>, <code>getTGD</code>, <code>TGD</code> can be used when a subset of the data is used for validation or testing. 
</p>
<p>The function <code>stepVGD()</code> is a stepwise procedure for selecting an appropriate model for any of the parameters of the model minimising the test global deviance. The function   <code>stepVGDAll.A()</code> can select a model using strategy A for all the parameters. 
</p>
<p>The functions <code>gamlssCV</code>, <code>CV</code> can be used for a k-fold cross validation.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">gamlssVGD(formula = NULL, sigma.formula = ~1, nu.formula = ~1, 
          tau.formula = ~1, data = NULL, family = NO, 
          control = gamlss.control(trace = FALSE), 
          rand = NULL, newdata = NULL, ...)
          
VGD(object, ...)          

getTGD(object, newdata = NULL, ...)

TGD(object, ...)  

gamlssCV(formula = NULL, sigma.formula = ~1, nu.formula = ~1, 
         tau.formula = ~1, data = NULL, family = NO, 
         control = gamlss.control(trace = FALSE), 
         K.fold = 10, set.seed = 123, rand = NULL, 
         parallel = c("no", "multicore", "snow"), 
         ncpus = 1L, cl = NULL, ...)

CV(object, ...)

drop1TGD(object, scope, newdata, parameter = c("mu", "sigma", "nu", "tau"), 
         sorted = FALSE, trace = FALSE, 
         parallel = c("no", "multicore", "snow"), 
         ncpus = 1L, cl = NULL, ...)
         
add1TGD(object, scope, newdata, parameter = c("mu", "sigma", "nu", "tau"), 
        sorted = FALSE, trace = FALSE, 
        parallel = c("no", "multicore", "snow"), 
        ncpus = 1L, cl = NULL, ...)

stepTGD(object, scope, newdata, 
        direction = c("both", "backward", "forward"),
        trace = TRUE, keep = NULL, steps = 1000, 
        parameter = c("mu", "sigma", "nu", "tau"), 
        parallel = c("no", "multicore", "snow"), 
        ncpus = 1L, cl = NULL, ...)
        
stepTGDAll.A(object, scope = NULL, newdata = NULL, 
        steps = 1000, sigma.scope = NULL, nu.scope = NULL, 
        tau.scope = NULL, mu.try = TRUE, sigma.try = TRUE, 
        nu.try = TRUE, tau.try = TRUE,
        parallel = c("no", "multicore", "snow"), 
        ncpus = 1L, cl = NULL, ...)        

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A <code>gamlss</code> <code>mu</code> formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.formula</code></td>
<td>
<p>Formula for <code>sigma</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.formula</code></td>
<td>
<p>Formula for <code>nu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.formula</code></td>
<td>
<p>Formula for <code>tau</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The data frame required for the fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The <code>gamlss.family</code> distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>The control for fitting the gamlss model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p>For <code>gamlssVGD</code> a variable with values 1 (for fitting) and 2 (for predicting). For <code>gamlssCV</code> a variable with k values indicating the cross validation sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>The new data set (validation or test) for prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A relevant R object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection similar to <code>stepGAIC()</code> where you can see examples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection for <code>sigma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection for <code>nu</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.scope</code></td>
<td>
<p>defines the range of models examined in the stepwise selection for <code>tau</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.try</code></td>
<td>
<p>whether should try fitting models for <code>mu</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.try</code></td>
<td>
<p>whether should try fitting models for <code>sigma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu.try</code></td>
<td>
<p>whether should try fitting models for <code>nu</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.try</code></td>
<td>
<p>whether should try fitting models for <code>tau</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>which distribution parameter is required, default <code>what="mu"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sorted</code></td>
<td>
<p>should the results be sorted on the value of TGD</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>f <code>TRUE</code> additional information may be given on the fits as they are tried.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>The mode of stepwise search, can be one of <code>both</code>, <code>backward</code>, or <code>forward</code>, with a default of <code>both</code>. If the scope argument is missing the default for direction is backward</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>see <code>stepGAIC()</code> for explanation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>the maximum number of steps to be considered. The default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.fold</code></td>
<td>
<p>the number of subsets of the data used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set.seed</code></td>
<td>
<p>the seed to be used in creating <code>rand</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, the default is "no".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically one would chose this to the number of available CPUs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel = "snow"</code>. If not supplied, a cluster on the local machine is created for the duration of the call.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be pass in the gamlss fit</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>gamlssVGD()</code> fits a gamlss model to the training data set determined by the arguments <code>rand</code> or <code>newdata</code>. The results is a <code>gamlssVGD</code> objects which contains the gamlss fit to the training data plus three extra components: i) <code>VGD</code> the global deviance applied to the validation data sets. ii) <code>predictError</code> which is <code>VGD</code>
divided with the number of observations in the validation data set and iii) <code>residVal</code> the residuals for the  validation data set. 
</p>
<p>The function <code>VGD()</code> extract the validated global deviance from one or more fitted  <code>gamlssVGD</code> objects and can be used foe model comparison. 
</p>
<p>The function <code>getTGD()</code> operates different from the function <code>gamlssVGD()</code>. It assumes that the users already have fitted models using <code>gamlss()</code> and now he/she wants to evaluate the global deviance at a new (validation or test) data set. 
</p>
<p>The function <code>TGD()</code>  extract the validated/test global deviance  from one or more fitted  <code>gamlssTGD</code> objects and can be use to compare models.
</p>
<p>The <code>gamlssCV()</code> performs a k-fold cross validation on a gamlss models. 
</p>
<p>The function <code>CV()</code> extract the cross validated  global deviance from one or more fitted  <code>gamlssCV</code> objects and can be use to compare models.
</p>
<p>The functions <code>add1TGD()</code>, <code>drop1TGD()</code> and <code>stepTGD</code> behave similar to  <code>add1()</code>, <code>drop1()</code> and <code>stepGAIC()</code> functions respectively  but they used  validation or test deviance as the selection criterion rather than the GAIC.
</p>


<h3>Value</h3>

<p>A fitted models of a set of global deviances.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1991). <em>Statistical Models in S</em>, Chapman and Hall, London. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied
Statistics with S</em>. Fourth edition.  Springer.
</p>


<h3>See Also</h3>

<p><code>stepGAIC</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(abdom)
# generate the random split of the data
rand &lt;- sample(2, 610, replace=TRUE, prob=c(0.6,0.4))
# the proportions in the sample
table(rand)/610
olddata&lt;-abdom[rand==1,] # training data
newdata&lt;-abdom[rand==2,] # validation data
#------------------------------------------------------------------------------
#  gamlssVGD
#-------------------------------------------------------------------------------
# Using rand
v1 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=NO, 
              rand=rand)
v2 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=LO, 
              rand=rand)
v3 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=TF, 
              rand=rand)
VGD(v1,v2,v3)
#-------------------------------------------------------------------------------
## Not run: 
#-------------------------------------------------------------------------------
# using two data set
v11 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, 
                  family=NO, newdata=newdata)
v12 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, 
                 family=LO, newdata=newdata)
v13 &lt;- gamlssVGD(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, 
                 family=TF, newdata=newdata)
VGD(v11,v12,v13)
#-------------------------------------------------------------------------------
# function getTGD
#-------------------------------------------------------------------------------
# fit gamlss models first
g1 &lt;- gamlss(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, family=NO)
g2 &lt;- gamlss(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, family=LO)
g3 &lt;- gamlss(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=olddata, family=TF)
# and then use 
gg1 &lt;-getTGD(g1, newdata=newdata)
gg2 &lt;-getTGD(g2, newdata=newdata)
gg3 &lt;-getTGD(g3, newdata=newdata)

TGD(gg1,gg2,gg3)
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# function gamlssCV
#-------------------------------------------------------------------------------
set.seed(123)
rand1 &lt;- sample (10 , 610, replace=TRUE)
g1 &lt;- gamlssCV(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=NO, 
               rand=rand1)
g2 &lt;- gamlssCV(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=LO, 
               rand=rand1)
g3 &lt;- gamlssCV(y~pb(x,df=2),sigma.formula=~pb(x,df=1), data=abdom, family=TF, 
               rand=rand1)
CV(g1,g2,g3)
CV(g1)
# using parallel 
set.seed(123)
rand1 &lt;- sample (10 , 610, replace=TRUE)
nC &lt;- detectCores()

system.time(g21 &lt;- gamlssCV(y~pb(x,df=2), sigma.formula=~pb(x,df=1), data=abdom,
             family=NO, rand=rand1,parallel = "no", ncpus = nC ))

system.time(g22 &lt;- gamlssCV(y~pb(x,df=2), sigma.formula=~pb(x,df=1), data=abdom,
             family=LO, rand=rand1,parallel = "multicore", ncpus = nC ))

system.time(g23 &lt;- gamlssCV(y~pb(x,df=2), sigma.formula=~pb(x,df=1), data=abdom,
             family=TF, rand=rand1,parallel = "snow", ncpus = nC ))


CV(g21,g22,g23)
#-------------------------------------------------------------------------------
# functions add1TGD() drop1TGD() and stepTGD()
#-------------------------------------------------------------------------------
# the data
data(rent)
rand &lt;- sample(2, dim(rent)[1], replace=TRUE, prob=c(0.6,0.4))
# the proportions in the sample
table(rand)/dim(rent)[1]
oldrent&lt;-rent[rand==1,] # training set
newrent&lt;-rent[rand==2,] # validation set

# null model
v0 &lt;- gamlss(R~1, data=oldrent, family=GA)
# complete model
v1 &lt;- gamlss(R~pb(Fl)+pb(A)+H+loc, sigma.fo=~pb(Fl)+pb(A)+H+loc, 
             data=oldrent, family=GA)

# drop1TGDP
system.time(v3&lt;- drop1TGD(v1, newdata=newrent,  parallel="no"))
system.time(v4&lt;- drop1TGD(v1, newdata=newrent,  parallel="multicore", 
                          ncpus=nC) )
system.time(v5&lt;- drop1TGD(v1, newdata=newrent,  parallel="snow", ncpus=nC))
cbind(v3,v4,v5)

# add1TGDP
system.time(d3&lt;- add1TGD(v0,scope=~pb(Fl)+pb(A)+H+loc, newdata=newrent,  
                       parallel="no"))
system.time(d4&lt;- add1TGD(v0,scope=~pb(Fl)+pb(A)+H+loc, newdata=newrent,  
                        parallel="multicore", ncpus=nC) )
system.time(d5&lt;- add1TGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent,  
                        parallel="snow", ncpus=nC))

# stepTGD
system.time(d6&lt;- stepTGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent))
system.time(d7&lt;- stepTGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent,
                         parallel="multicore", ncpus=nC))
system.time(d8&lt;- stepTGD(v0, scope=~pb(Fl)+pb(A)+H+loc,newdata=newrent,
                         parallel="snow", ncpus=nC))

## End(Not run)
</code></pre>


</div>