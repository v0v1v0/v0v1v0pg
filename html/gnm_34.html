<div class="container">

<table style="width: 100%;"><tr>
<td>nonlin.function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Functions to Specify Nonlinear Terms in gnm Models  </h2>

<h3>Description</h3>

<p>Nonlinear terms maybe be specified in the formula argument to gnm by
a call to a function of class <code>"nonlin"</code>.  A <code>"nonlin"</code>
function takes a list of arguments and returns a list of arguments for
the internal <code>nonlinTerms</code> function.
</p>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments required to define the term, e.g. symbolic
representations of predictors in the term. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inst</code></td>
<td>
<p>(optional) an integer specifying the instance number of
the term - for compatibility with <code>instances</code>. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function should return a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>predictors</code></td>
<td>
<p> a list of symbolic expressions or formulae with no
left hand side which represent (possibly nonlinear)
predictors that form part of the term. Intercepts will be added by
default to predictors specified by formulae. If predictors are
named, these names will be used as a prefix for parameter labels or
the parameter label itself in the single parameter case (in either
case, prefixed by the call if supplied.) Predictors that may include
an intercept should always be named or matched to a call. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p> an optional list of expressions representing variables
in the term. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term</code></td>
<td>
<p> a function which takes the arguments <code>predLabels</code>
and <code>varLabels</code>, which are vectors of labels defined by
<code>gnm</code> that correspond to the specified predictors and variables,
and returns a deparsed mathematical expression of the full
term. Only functions recognised by <code>deriv</code> should be used in
the expression, e.g. <code>+</code> rather than <code>sum</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common</code></td>
<td>
<p> an optional numeric index of <code>predictors</code> with
duplicated indices identifying single factor predictors for which
homologous effects are to be estimated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p> an optional call to be used as a prefix for parameter
labels, specified as an R expression. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match</code></td>
<td>
<p> (if <code>call</code> is non-<code>NULL</code>) a numeric index
of <code>predictors</code> specifying which arguments of <code>call</code> the
predictors match to - zero indicating no match. If <code>NULL</code>,
predictors will not be matched. It is recommended that matches are
specified wherever possible, to ensure parameter labels are
well-defined. Parameters in matched predictors 
are labelled using "dot-style" labelling, see examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p> an optional function which takes a named vector of parameters
corresponding to the predictors and returns a vector of
starting values for those parameters. This function is ignored if the
term is nested within another nonlinear term.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code>Const</code> to specify a constant,
<code>Dref</code> to specify a diagonal reference term,
<code>Exp</code> to specify the exponential of a predictor,
<code>Inv</code> to specify the reciprocal of a predictor,


<code>Mult</code> to specify a multiplicative interaction,
<code>MultHomog</code> to specify a homogeneous multiplicative
interaction,

</p>


<h3>Examples</h3>

<pre><code class="language-R">### Equivalent of weighted.MM function in ?nls
weighted.MM &lt;- function(resp, conc){
    list(predictors = list(Vm = substitute(conc), K = 1),
         variables = list(substitute(resp), substitute(conc)),
         term = function(predictors, variables) {
             pred &lt;- paste("(", predictors[1], "/(", predictors[2],
                           " + ", variables[2], "))", sep = "")
             pred &lt;- paste("(", variables[1], " - ", pred, ")/sqrt(",
                           pred, ")", sep = "")
         })
}
class(weighted.MM) &lt;- "nonlin"

## use to fitted weighted Michaelis-Menten model
Treated &lt;- Puromycin[Puromycin$state == "treated", ]
Pur.wt.2 &lt;- gnm( ~ -1 + weighted.MM(rate, conc), data = Treated,
                start = c(Vm = 200, K = 0.1), verbose = FALSE)
Pur.wt.2
## 
## Call:
## gnm(formula = ~-1 + weighted.MM(rate, conc), data = Treated, 
##     start = c(Vm = 200, K = 0.1), verbose = FALSE)
## 
## Coefficients:
##        Vm          K  
## 206.83477    0.05461  
## 
## Deviance:            14.59690 
## Pearson chi-squared: 14.59690 
## Residual df:         10

### The definition of MultHomog
MultHomog &lt;- function(..., inst = NULL){
    dots &lt;- match.call(expand.dots = FALSE)[["..."]]
    list(predictors = dots,
         common = rep(1, length(dots)),
         term = function(predictors, ...) {
             paste("(", paste(predictors, collapse = ")*("), ")", sep = "")
         },
         call = as.expression(match.call()))
}
class(MultHomog) &lt;- "nonlin"
## use to fit homogeneous multiplicative interaction
set.seed(1)
RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination), ofInterest = "MultHomog",
               family = poisson, data = occupationalStatus,
               verbose = FALSE)
RChomog
## 
## Call:
## 
## gnm(formula = Freq ~ origin + destination + Diag(origin, destination) + 
##     MultHomog(origin, destination), ofInterest = "MultHomog", family = poisson, 
##     data = occupationalStatus, verbose = FALSE)
## 
## Coefficients of interest:
## MultHomog(origin, destination)1  
##                              -1.50089  
## MultHomog(origin, destination)2  
##                              -1.28260  
## MultHomog(origin, destination)3  
##                              -0.68443  
## MultHomog(origin, destination)4  
##                              -0.10055  
## MultHomog(origin, destination)5  
##                              -0.08338  
## MultHomog(origin, destination)6  
##                               0.42838  
## MultHomog(origin, destination)7  
##                               0.84452  
## MultHomog(., .).`origin|destination`8  
##                               1.08809  
## 
## Deviance:            32.56098 
## Pearson chi-squared: 31.20716 
## Residual df:         34 
##

## the definition of Exp
Exp &lt;- function(expression, inst = NULL){
    list(predictors = list(substitute(expression)),
         term = function(predictors, ...) {
             paste("exp(", predictors, ")", sep = "")
         },
         call = as.expression(match.call()),
         match = 1)
}
class(Exp) &lt;- "nonlin"


## use to fit exponentional model
x &lt;- 1:100
y &lt;- exp(- x / 10)
set.seed(4)
exp1 &lt;- gnm(y ~ Exp(1 + x), verbose = FALSE)
exp1
## 
## Call:
## gnm(formula = y ~ Exp(1 + x), verbose = FALSE)
## 
## Coefficients:
##            (Intercept)  Exp(. + x).(Intercept)
##              1.549e-11              -7.934e-11
##           Exp(1 + .).x  
##             -1.000e-01 
## 
## Deviance:            9.342418e-20 
## Pearson chi-squared: 9.342418e-20 
## Residual df:         97
</code></pre>


</div>