<div class="container">

<table style="width: 100%;"><tr>
<td>gwpcor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Geographically Weighted Correlation and Partial Correlation
</h2>

<h3>Description</h3>

<p>This function calculates the geographically weighted correlation and partial correlation between two variables given others. The function is designed by the gwss function from the GWmodel package, and the cor2pcor function from the corpcor package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gwpcor(sdata, res_dp, vars, method = c("pearson", "spearman"), 
kernel = "bisquare", adaptive = FALSE, bw, dMat, 
geodisic_measure = "cheap", foreach = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sdata</code></td>
<td>

<p>a Spatial*DataFrame (i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package sp),
or a sf object. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res_dp</code></td>
<td>

<p>A Spatial*DataFrame object for providing summary locations, i.e. SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package sp, or a sf object. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>

<p>A vector of variable names to be used for the analysis.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>A character string indicating which correlation and partial correlation coefficients to compute. "pearson" or "spearman" are accepted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>

<p>function chosen as follows:
gaussian: wgt = exp( -0.5 * (vdist / bw)^2);
exponential: wgt = exp( -vdist / bw);
bisquare: wgt = ( 1 -(vdist / bw)^2)^2 if vdist &lt; bw, wgt = 0 otherwise;
tricube: wgt = (1 -(vdist / bw)^3)^3 if vdist &lt; bw, wgt = 0 otherwise;
boxcar: wgt = 1 if dist &lt; bw, wgt = 0 otherwise
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>

<p>if TRUE, an adaptive kernel where the bandwidth (bw) corresponds to the proportion of the number of nearest neighbours (i.e. adaptive distance) is employed. The default is FALSE, where a fixed kernel is employed (bandwidth is a fixed distance).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>

<p>Bandwidth size. If adaptive kernel, bw should be the proportion of the number of nearest neighbours (0 &lt; bw &lt;=1). For fixed kernel, the Euclid distance.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dMat</code></td>
<td>

<p>A pre-specified distance matrix, it can be calculated by the function st_distance().
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geodisic_measure</code></td>
<td>

<p>geodisic_measure is used when latlon coordinate. The distance is cauclated by geodist::geodist(). One of "haversine" "vincenty", "geodesic", or "cheap" specifying desired method of geodesic distance calculation. "Cheap" is the fastest way but may have errors if the ROI is large.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foreach</code></td>
<td>

<p>Whether parallel computation is implemented or not.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>SDF </code></td>
<td>

<p>A SpatialPointsDataFrame (may be gridded) or SpatialPolygonsDataFrame object (see package “sp”) when the input is Spatial*DataFrame or a sf class object when input is sf, with local covariances, local correlations (Pearson's), local correlations (Spearman's),  p-values of local correlations (Pearson's), p-values of local correlations (Spearman's), local partial correlations (Pearson's), local partial correlations (Spearman's), p-values of local partial correlations (Pearson's), and p-values of local partial correlations (Spearman's).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>

<p>Names of variables used for the calculation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>

<p>The name of kernel used for the calculation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>

<p>Whether aadaptive kernel is employed or not (TRUE/FALSE),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>

<p>The bandwidth size used for the calculation.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Tsutsumida N. and Percival J.
</p>


<h3>References</h3>

<p>Percival J. and Tsutsumida N. (2017) Geographically weighted partial correlation for spatial analysis, GI_forum, Issue 1, 36-43, URL http://dx.doi.org/10.1553/giscience2017_01_s36
</p>
<p>Isabella Gollini, Binbin Lu, Martin Charlton, Christopher Brunsdon, Paul Harris (2015). GWmodel: An R Package for Exploring Spatial Heterogeneity Using Geographically Weighted Models. Journal of Statistical Software, 63(17), 1-50. URL http://www.jstatsoft.org/v63/i17/.
</p>
<p>Binbin Lu, Paul Harris, Martin Charlton, Christopher Brunsdon (2014). The GWmodel R package: further topics for exploring spatial heterogeneity using geographically weighted models. Geo-spatial Information Science, 17(2), 85-101. URL http://dx.doi.org/10.1080/10095020.2014.917453
</p>


<h3>Examples</h3>

<pre><code class="language-R">#NOTE: This example only shows how to implement gwpcor using sample data (meuse) in sp package. 
#Results do not suggest any meanings.

#import data from sp package
library(sp)
library(sf)
data(meuse, package = "sp") 
meuse_sf &lt;- st_as_sf(meuse, coords = c("x", "y"), crs = 28992)

#implement gwpcor as an example
#the bandwidth is arbitrary.
res &lt;- gwpcor(sdata = meuse_sf, vars = c("cadmium","copper", "zinc"),
method = "pearson", kernel = "bisquare",adaptive = TRUE, 
bw = 0.25, geodisic_measure = "cheap", foreach = FALSE)

</code></pre>


</div>