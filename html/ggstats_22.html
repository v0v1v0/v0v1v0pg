<div class="container">

<table style="width: 100%;"><tr>
<td>gglikert</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting Likert-type items</h2>

<h3>Description</h3>

<p>Combines several factor variables using the same list of ordered levels
(e.g. Likert-type scales) into a unique data frame and generates a centered
bar plot.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gglikert(
  data,
  include = dplyr::everything(),
  weights = NULL,
  y = ".question",
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "prop_lower", "mean", "median"),
  sort_prop_include_center = totals_include_center,
  factor_to_sort = ".question",
  exclude_fill_values = NULL,
  cutoff = NULL,
  data_fun = NULL,
  add_labels = TRUE,
  labels_size = 3.5,
  labels_color = "auto",
  labels_accuracy = 1,
  labels_hide_below = 0.05,
  add_totals = TRUE,
  totals_size = labels_size,
  totals_color = "black",
  totals_accuracy = labels_accuracy,
  totals_fontface = "bold",
  totals_include_center = FALSE,
  totals_hjust = 0.1,
  y_reverse = TRUE,
  y_label_wrap = 50,
  reverse_likert = FALSE,
  width = 0.9,
  facet_rows = NULL,
  facet_cols = NULL,
  facet_label_wrap = 50,
  symmetric = FALSE
)

gglikert_data(
  data,
  include = dplyr::everything(),
  weights = NULL,
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "prop_lower", "mean", "median"),
  sort_prop_include_center = TRUE,
  factor_to_sort = ".question",
  exclude_fill_values = NULL,
  cutoff = NULL,
  data_fun = NULL
)

gglikert_stacked(
  data,
  include = dplyr::everything(),
  weights = NULL,
  y = ".question",
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "prop_lower", "mean", "median"),
  sort_prop_include_center = FALSE,
  factor_to_sort = ".question",
  data_fun = NULL,
  add_labels = TRUE,
  labels_size = 3.5,
  labels_color = "auto",
  labels_accuracy = 1,
  labels_hide_below = 0.05,
  add_median_line = FALSE,
  y_reverse = TRUE,
  y_label_wrap = 50,
  reverse_fill = TRUE,
  width = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include</code></td>
<td>
<p>variables to include, accepts tidy-select
syntax</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional variable name of a weighting variable,
accepts tidy-select syntax</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>name of the variable to be plotted on <code>y</code> axis (relevant when
<code>.question</code> is mapped to "facets, see examples),
accepts tidy-select syntax</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable_labels</code></td>
<td>
<p>a named list or a named vector of custom variable
labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>should the factor defined by <code>factor_to_sort</code> be sorted according
to the answers (see <code>sort_method</code>)? One of "none" (default), "ascending" or
"descending"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort_method</code></td>
<td>
<p>method used to sort the variables: <code>"prop"</code> sort according
to the proportion of answers higher than the centered level, <code>"prop_lower"</code>
according to the proportion lower than the centered level,  <code>"mean"</code>
considers answer as a score and sort according to the mean score, <code>"median"</code>
used the median and the majority judgment rule for tie-breaking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort_prop_include_center</code></td>
<td>
<p>when sorting with <code>"prop"</code> and if the number
of levels is uneven, should half of the central level be taken into account
to compute the proportion?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor_to_sort</code></td>
<td>
<p>name of the factor column to sort if <code>sort</code> is not
equal to <code>"none"</code>; by default the list of questions passed to <code>include</code>;
should be one factor column of the tibble returned by <code>gglikert_data()</code>;
accepts tidy-select syntax</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude_fill_values</code></td>
<td>
<p>Vector of values that should not be displayed
(but still taken into account for computing proportions),
see <code>position_likert()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>number of categories to be displayed negatively (i.e. on the
left of the x axis or the bottom of the y axis), could be a decimal value:
<code>2</code> to display negatively the two first categories, <code>2.5</code> to display
negatively the two first categories and half of the third, <code>2.2</code> to display
negatively the two first categories and a fifth of the third (see examples).
By default (<code>NULL</code>), it will be equal to the number of categories divided
by 2, i.e. it will be centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_fun</code></td>
<td>
<p>for advanced usage, custom function to be applied to the
generated dataset at the end of <code>gglikert_data()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_labels</code></td>
<td>
<p>should percentage labels be added to the plot?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_size</code></td>
<td>
<p>size of the percentage labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_color</code></td>
<td>
<p>color of the percentage labels (<code>"auto"</code> to use
<code>hex_bw()</code> to determine a font color based on background color)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_accuracy</code></td>
<td>
<p>accuracy of the percentages, see
<code>scales::label_percent()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_hide_below</code></td>
<td>
<p>if provided, values below will be masked, see
<code>label_percent_abs()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_totals</code></td>
<td>
<p>should the total proportions of negative and positive
answers be added to plot? <strong>This option is not compatible with facets!</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals_size</code></td>
<td>
<p>size of the total proportions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals_color</code></td>
<td>
<p>color of the total proportions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals_accuracy</code></td>
<td>
<p>accuracy of the total proportions, see
<code>scales::label_percent()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals_fontface</code></td>
<td>
<p>font face of the total proportions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals_include_center</code></td>
<td>
<p>if the number of levels is uneven, should half
of the center level be added to the total proportions?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals_hjust</code></td>
<td>
<p>horizontal adjustment of totals labels on the x axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_reverse</code></td>
<td>
<p>should the y axis be reversed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_label_wrap</code></td>
<td>
<p>number of characters per line for y axis labels, see
<code>scales::label_wrap()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse_likert</code></td>
<td>
<p>if <code>TRUE</code>, will reverse the default stacking order,
see <code>position_likert()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>bar width, see <code>ggplot2::geom_bar()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>facet_rows, facet_cols</code></td>
<td>
<p>A set of variables or expressions quoted by
<code>ggplot2::vars()</code> and defining faceting groups on the rows or columns
dimension (see examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>facet_label_wrap</code></td>
<td>
<p>number of characters per line for facet labels, see
<code>ggplot2::label_wrap_gen()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>should the x-axis be symmetric?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_median_line</code></td>
<td>
<p>add a vertical line at 50%?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse_fill</code></td>
<td>
<p>if <code>TRUE</code>, will reverse the default stacking order,
see <code>ggplot2::position_fill()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You could use <code>gglikert_data()</code> to just produce the dataset to be plotted.
</p>
<p>If variable labels have been defined (see <code>labelled::var_label()</code>), they will
be considered. You can also pass custom variables labels with the
<code>variable_labels</code> argument.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot or a <code>tibble</code>.
</p>


<h3>See Also</h3>

<p><code>vignette("gglikert")</code>, <code>position_likert()</code>, <code>stat_prop()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ggplot2)
library(dplyr)

likert_levels &lt;- c(
  "Strongly disagree",
  "Disagree",
  "Neither agree nor disagree",
  "Agree",
  "Strongly agree"
)
set.seed(42)
df &lt;-
  tibble(
    q1 = sample(likert_levels, 150, replace = TRUE),
    q2 = sample(likert_levels, 150, replace = TRUE, prob = 5:1),
    q3 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),
    q4 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),
    q5 = sample(c(likert_levels, NA), 150, replace = TRUE),
    q6 = sample(likert_levels, 150, replace = TRUE, prob = c(1, 0, 1, 1, 0))
  ) |&gt;
  mutate(across(everything(), ~ factor(.x, levels = likert_levels)))

gglikert(df)

gglikert(df, include = q1:3) +
  scale_fill_likert(pal = scales::brewer_pal(palette = "PRGn"))

gglikert(df, sort = "ascending")


gglikert(df, sort = "ascending", sort_prop_include_center = TRUE)

gglikert(df, sort = "ascending", sort_method = "mean")

gglikert(df, reverse_likert = TRUE)

gglikert(df, add_totals = FALSE, add_labels = FALSE)

gglikert(
  df,
  totals_include_center = TRUE,
  totals_hjust = .25,
  totals_size = 4.5,
  totals_fontface = "italic",
  totals_accuracy = .01,
  labels_accuracy = 1,
  labels_size = 2.5,
  labels_hide_below = .25
)

gglikert(df, exclude_fill_values = "Neither agree nor disagree")

if (require("labelled")) {
  df |&gt;
    set_variable_labels(
      q1 = "First question",
      q2 = "Second question"
    ) |&gt;
    gglikert(
      variable_labels = c(
        q4 = "a custom label",
        q6 = "a very very very very very very very very very very long label"
      ),
      y_label_wrap = 25
    )
}

# Facets
df_group &lt;- df
df_group$group &lt;- sample(c("A", "B"), 150, replace = TRUE)

gglikert(df_group, q1:q6, facet_rows = vars(group))

gglikert(df_group, q1:q6, facet_cols = vars(group))

gglikert(df_group, q1:q6, y = "group", facet_rows = vars(.question))

# Custom function to be applied on data
f &lt;- function(d) {
  d$.question &lt;- forcats::fct_relevel(d$.question, "q5", "q2")
  d
}
gglikert(df, include = q1:q6, data_fun = f)

# Custom center
gglikert(df, cutoff = 2)

gglikert(df, cutoff = 1)

gglikert(df, cutoff = 1, symmetric = TRUE)


gglikert_stacked(df, q1:q6)

gglikert_stacked(df, q1:q6, add_median_line = TRUE, sort = "asc")


gglikert_stacked(df_group, q1:q6, y = "group", add_median_line = TRUE) +
  facet_grid(rows = vars(.question))

</code></pre>


</div>