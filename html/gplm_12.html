<div class="container">

<table style="width: 100%;"><tr>
<td>kgplm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized partial linear model</h2>

<h3>Description</h3>

<p>Fits a generalized partial linear model (kernel-based)
using the (generalized) Speckman estimator or backfitting (in the
generalized case combined with local scoring) for two additive
component functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kgplm(x, t, y, h, family, link,
          b.start=NULL, m.start=NULL, grid = NULL, 
          offset = 0, method = "speckman", sort = TRUE, weights = 1,
          weights.trim = 1, weights.conv = 1, max.iter = 25, eps.conv = 1e-8,
          kernel = "biweight", kernel.product = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>n x p matrix, data for linear part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>n x 1 vector, responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>n x q matrix, data for nonparametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>scalar or 1 x q, bandwidth(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>text string, family of distributions (e.g.
"gaussian" or "bernoulli", see details for <code>glm.ll</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>text string, link function (depending on family,
see details for <code>glm.ll</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.start</code></td>
<td>
<p>p x 1 vector, start values for linear part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.start</code></td>
<td>
<p>n x 1 vector, start values for nonparametric part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>m x q matrix, where to calculate the nonparametric function (default = t)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>offset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>"speckman" or "backfit"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>logical, TRUE if data need to be sorted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>binomial weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.trim</code></td>
<td>
<p>trimming weights for fitting the linear part</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights.conv</code></td>
<td>
<p>weights for convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximal number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.conv</code></td>
<td>
<p>convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>text string, see <code>kernel.function</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.product</code></td>
<td>
<p>(if p&gt;1) product or spherical kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print additional convergence information</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>p x 1 vector, linear coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.cov</code></td>
<td>
<p>p x p matrix, linear coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>n x 1 vector, nonparametric function estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.grid</code></td>
<td>
<p>m x 1 vector, nonparametric function estimate on grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>it</code></td>
<td>
<p>number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>deviance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>approximate degrees of freedom (residuals)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>
<p>Akaike's information criterion</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Marlene Mueller</p>


<h3>References</h3>

<p>Mueller, M. (2001).
Estimation and testing in generalized partial linear models – A
comparative study. <em>Statistics and Computing</em>, 11:299–309.
</p>
<p>Hastie, T. and Tibshirani, R. (1990).
<em>Generalized Additive Models</em>. London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code>kernel.function</code>, <code>kreg</code></p>


<h3>Examples</h3>

<pre><code class="language-R">  ## data
  n &lt;- 1000; b &lt;- c(1,-1); rho &lt;- 0.7
  m &lt;- function(t){ 1.5*sin(pi*t) }
  x1 &lt;- runif(n,min=-1,max=1); u  &lt;- runif(n,min=-1,max=1)
  t  &lt;- runif(n,min=-1,max=1); x2 &lt;- round(m(rho*t + (1-rho)*u))
  x  &lt;- cbind(x1,x2)
  y  &lt;- x %*% b + m(t) + rnorm(n)

  ## partial linear model (PLM)
  gh &lt;- kgplm(x,t,y,h=0.25,family="gaussian",link="identity")
  o &lt;- order(t)
  plot(t[o],m(t[o]),type="l",col="green")
  lines(t[o],gh$m[o]); rug(t)

  ## partial linear probit model (GPLM)
  y &lt;- (y&gt;0)
  gh &lt;- kgplm(x,t,y,h=0.25,family="bernoulli",link="probit")

  o &lt;- order(t)
  plot(t[o],m(t[o]),type="l",col="green")
  lines(t[o],gh$m[o]); rug(t)

  ## data with two-dimensional m-function 
  n &lt;- 1000; b &lt;- c(1,-1); rho &lt;- 0.7
  m &lt;- function(t1,t2){ 1.5*sin(pi*t1)+t2 }
  x1 &lt;- runif(n,min=-1,max=1); u  &lt;- runif(n,min=-1,max=1)
  t1 &lt;- runif(n,min=-1,max=1); t2 &lt;- runif(n,min=-1,max=1)
  x2 &lt;- round( m( rho*t1 + (1-rho)*u , t2 ) )
  x  &lt;- cbind(x1,x2); t  &lt;- cbind(t1,t2)
  y  &lt;- x %*% b + m(t1,t2) + rnorm(n)

  ## partial linear model (PLM)
  grid1 &lt;- seq(min(t[,1]),max(t[,1]),length=20)
  grid2 &lt;- seq(min(t[,2]),max(t[,2]),length=25)
  grid  &lt;- create.grid(list(grid1,grid2))

  gh &lt;- kgplm(x,t,y,h=0.5,grid=grid,family="gaussian",link="identity")

  o &lt;- order(grid[,2],grid[,1])
  est.m  &lt;- (matrix(gh$m.grid[o],length(grid1),length(grid2)))
  orig.m &lt;- outer(grid1,grid2,m)
  par(mfrow=c(1,2))
  persp(grid1,grid2,orig.m,main="Original Function",
        theta=30,phi=30,expand=0.5,col="lightblue",shade=0.5)
  persp(grid1,grid2,est.m,main="Estimated Function",
        theta=30,phi=30,expand=0.5,col="lightblue",shade=0.5)
  par(mfrow=c(1,1))
</code></pre>


</div>