<div class="container">

<table style="width: 100%;"><tr>
<td>stat_poly_line</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predicted line from linear model fit</h2>

<h3>Description</h3>

<p>Predicted values and a confidence band are computed and, by default, plotted.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_poly_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = "lm",
  formula = NULL,
  se = TRUE,
  fm.values = FALSE,
  n = 80,
  fullrange = FALSE,
  level = 0.95,
  method.args = list(),
  n.min = 2L,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>function or character If character, "lm", "rlm" or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rlm:M"</code>). If a
function different to <code>lm()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, and <code>method</code> and return a
model fit object of class <code>lm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Display confidence interval around smooth? ('TRUE' by default, see
'level' to control.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fm.values</code></td>
<td>
<p>logical Add R2, adjusted R2, p-value and n as columns to
returned data? ('FALSE' by default.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fullrange</code></td>
<td>
<p>Should the fit span the full range of the plot, or just
the data?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Level of confidence interval to use (0.95 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character Either "x" or "y" controlling the default for
<code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This statistic is similar to <code>stat_smooth</code> but has
different defaults. It interprets the argument passed to <code>formula</code>
differently, accepting <code>y</code> as explanatory variable and setting
<code>orientation</code> automatically. The default for <code>method</code> is
<code>"lm"</code> and spline-based smoothers like <code>loess</code> are not supported.
Other defaults are consistent with those in <code>stat_poly_eq()</code>,
<code>stat_quant_line()</code>, <code>stat_quant_eq()</code>, <code>stat_ma_line()</code>,
<code>stat_ma_eq()</code>.
</p>
<p><code>geom_poly_line()</code> treats the x and y aesthetics differently and can
thus have two orientations. The orientation can be deduced from the argument
passed to <code>formula</code>. Thus, <code>stat_poly_line()</code> will by default guess
which orientation the layer should have. If no argument is passed to
<code>formula</code>, the formula defaults to <code>y ~ x</code>. For consistency with
<code>stat_smooth</code> orientation can be also specified directly
passing an argument to the <code>orientation</code> parameter, which can be either
<code>"x"</code> or <code>"y"</code>. The value of <code>orientation</code> gives the axis that
is taken as the explanatory variable or <code>x</code> in the model formula.
Package 'ggpmisc' does not define new geometries matching the new statistics
as they are not needed and conceptually transformations of <code>data</code> are
statistics in the grammar of graphics.
</p>
<p>A ggplot statistic receives as <code>data</code> a data frame that is not the one
passed as argument by the user, but instead a data frame with the variables
mapped to aesthetics. <code>stat_poly_eq()</code> mimics how <code>stat_smooth()</code>
works, except that only polynomials can be fitted. Similarly to these
statistics the model fits respect grouping, so the scales used for <code>x</code>
and <code>y</code> should both be continuous scales rather than discrete.
</p>
<p>With method <code>"lm"</code>, singularity results in terms being dropped with a
message if more numerous than can be fitted with a singular (exact) fit.
In this case and if the model results in a perfect fit due to low
number of observation, estimates for various parameters are <code>NaN</code> or
<code>NA</code>.
</p>
<p>With methods other than <code>"lm"</code>, the model fit functions simply fail
in case of singularity, e.g., singular fits are not implemented in
<code>"rlm"</code>.
</p>
<p>In both cases the minimum number of observations with distinct values in
the explanatory variable can be set through parameter <code>n.min</code>. The
default <code>n.min = 2L</code> is the smallest suitable for method <code>"lm"</code>
but too small for method <code>"rlm"</code> for which <code>n.min = 3L</code> is
needed. Anyway, model fits with very few observations are of little
interest and using larger values of <code>n.min</code> than the default is
wise.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, with <code>n</code>
rows of predicted values and their confidence limits. Optionally it will
also include additional values related to the model fit.
</p>


<h3>Computed variables</h3>

<p>'stat_poly_line()' provides the following
variables, some of which depend on the orientation: </p>
 <dl>
<dt>y *or*
x</dt>
<dd>
<p>predicted value</p>
</dd> <dt>ymin *or* xmin</dt>
<dd>
<p>lower pointwise confidence
interval around the mean</p>
</dd> <dt>ymax *or* xmax</dt>
<dd>
<p>upper pointwise confidence
interval around the mean</p>
</dd> <dt>se</dt>
<dd>
<p>standard error</p>
</dd> </dl>
<p>If <code>fm.values = TRUE</code> is passed then columns based on the summary of
the model fit are added, with the same value in each row within a group.
This is wasteful and disabled by default, but provides a simple and robust
approach to achieve effects like colouring or hiding of the model fit line
based on P-values, r-squared, adjusted r-squared or the number of
observations.
</p>


<h3>Aesthetics</h3>

<p><code>stat_poly_line</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code>. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"geom_smooth"</code> is the default) are understood and grouping
respected.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for linear and polynomial regression: 
<code>stat_poly_eq()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line()

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line(formula = x ~ poly(y, 3))

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  stat_poly_line(se = FALSE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line() +
  facet_wrap(~drv)

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_poly_line(geom = "debug")

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_poly_line(geom = "debug", fm.values = TRUE)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_poly_line(geom = "debug", method = lm, fm.values = TRUE)

</code></pre>


</div>