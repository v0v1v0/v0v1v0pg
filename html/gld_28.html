<div class="container">

<table style="width: 100%;"><tr>
<td>starship</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Carry out the “starship” estimation method for the generalised
lambda distribution</h2>

<h3>Description</h3>

<p>Estimates parameters of the generalised lambda
distribution on the basis of data, using the starship method.
The starship method is built on the fact that the 
generalised lambda distribution (<code>gld</code>)
is a transformation of the uniform distribution.  This method finds the 
parameters that transform the data closest to the uniform distribution.
This function uses a grid-based search to find a suitable starting point (using
<code>starship.adaptivegrid</code>) then uses <code>optim</code> to find
the parameters that do this.
</p>


<h3>Usage</h3>

<pre><code class="language-R">starship(data, optim.method = "Nelder-Mead", initgrid = NULL, 
inverse.eps = .Machine$double.eps, param="FMKL", optim.control=NULL, return.data=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data to be fitted, as a vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p>Optimisation method for <code>optim</code> to use, 
defaults to Nelder-Mead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initgrid</code></td>
<td>
<p>Grid of values of <code class="reqn">\lambda_3</code> and
<code class="reqn">\lambda_4</code>
to try, in <code>starship.adaptivegrid</code>.  This should be a list with
elements, 
<code>lcvect</code>, a vector of values for <code class="reqn">\lambda_3</code>,
<code>ldvect</code>, a vector of values for <code class="reqn">\lambda_4</code> and
<code>levect</code>, a vector of values for <code class="reqn">\lambda_5</code> 
(<code>levect</code> is only required if <code>param</code> is <code>fm5</code>).
</p>
<p>If it is left as NULL, the default grid depends on the parameterisation.
For <code>fmkl</code>, both lcvect and ldvect default to:
</p>

<table><tr>
<td style="text-align: center;">-1.5</td>
<td style="text-align: center;"> -1</td>
<td style="text-align: center;"> -0.5</td>
<td style="text-align: center;"> -0.1</td>
<td style="text-align: center;"> 0</td>
<td style="text-align: center;"> 0.1</td>
<td style="text-align: center;"> 0.2</td>
<td style="text-align: center;"> 0.4</td>
<td style="text-align: center;"> 0.8</td>
<td style="text-align: center;"> 1</td>
<td style="text-align: center;"> 1.5</td>
</tr></table>
<p>(<code>levect</code> is NULL).
</p>
<p>For <code>rs</code>, both lcvect and ldvect default to:
</p>

<table><tr>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;"> 0.2</td>
<td style="text-align: center;"> 0.4</td>
<td style="text-align: center;"> 0.8</td>
<td style="text-align: center;"> 1</td>
<td style="text-align: center;"> 1.5</td>
</tr></table>
<p>(<code>levect</code> is NULL).  Note that this restricts the estimates to only part of the region
of the  <code class="reqn">\lambda_3</code>, <code class="reqn">\lambda_4</code> plane.
</p>
<p>For <code>gpd</code>, the defaults are: <code class="reqn">\delta</code>: </p>

<table><tr>
<td style="text-align: center;">0.3</td>
<td style="text-align: center;"> 0.5</td>
<td style="text-align: center;"> 0.7</td>
</tr></table>
<p> and <code class="reqn">\lambda</code>: </p>

<table><tr>
<td style="text-align: center;">-1.5</td>
<td style="text-align: center;">-.5</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">.2</td>
<td style="text-align: center;">.4</td>
<td style="text-align: center;">0.8</td>
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">5</td>
</tr></table>
<p>For <code>fm5</code>, both lcvect and ldvect default to:
</p>

<table><tr>
<td style="text-align: center;">-1.5</td>
<td style="text-align: center;"> -1</td>
<td style="text-align: center;"> -.5</td>
<td style="text-align: center;"> -0.1</td>
<td style="text-align: center;"> 0</td>
<td style="text-align: center;"> 0.1</td>
<td style="text-align: center;"> 0.2</td>
<td style="text-align: center;"> 0.4</td>
<td style="text-align: center;"> 0.8</td>
<td style="text-align: center;"> 1</td>
<td style="text-align: center;"> 1.5</td>
</tr></table>
<p>and <code>levect</code> defaults to:
</p>

<table><tr>
<td style="text-align: center;">-0.5</td>
<td style="text-align: center;"> 0.25</td>
<td style="text-align: center;"> 0</td>
<td style="text-align: center;"> 0.25</td>
<td style="text-align: center;"> 0.5</td>
</tr></table>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverse.eps</code></td>
<td>
<p>Accuracy of calculation for the numerical determination of 
<code class="reqn">F(x)</code>, defaults to <code>.Machine$double.eps</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>choose parameterisation: 
<code>fmkl</code> uses <em>Freimer, Mudholkar, Kollia and Lin (1988)</em> (default).
<code>rs</code> uses <em>Ramberg and Schmeiser (1974)</em>
<code>fm5</code> uses the 5 parameter version of the FMKL parameterisation 
(paper to appear)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.control</code></td>
<td>
<p>List of options for the optimisation step.  See
<code>optim</code> for details.  If left as NULL, the parscale 
control is set to scale <code class="reqn">\lambda_1</code>
and <code class="reqn">\lambda_2</code> by the absolute value of their starting points.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.data</code></td>
<td>
<p>Logical: Should the function return the data (from the argument <code>data</code>)?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The starship method is described in King &amp; MacGillivray, 1999 (see
references). It is built on the fact that the 
generalised lambda distribution (<code>gld</code>)
is a transformation of the uniform distribution.  Thus the inverse of this
transformation is the distribution function for the gld.  The starship method
applies different values of the parameters of the distribution to the
distribution function, calculates the depths <em>q</em> corresponding to the data
and chooses the parameters that make the depths closest to a uniform
distribution.
</p>
<p>The closeness to the uniform is assessed by calculating the Anderson-Darling
goodness-of-fit test on the transformed data against the uniform, for a
sample of size <code>length(data)</code>.
</p>
<p>This is implemented in 2 stages in this function.  First a grid search is
carried out, over a small number of possible parameter values
(see <code>starship.adaptivegrid</code> for details).  Then the minimum from
this search is given as a starting point for an optimisation of the 
Anderson-Darling value using optim, with method given by <code>optim.method</code>
</p>
<p>See <code>GeneralisedLambdaDistribution</code> for details on
parameterisations.
</p>


<h3>Value</h3>

<p><code>starship</code> returns an object of <code>class</code> <code>"starship"</code>.
</p>
<p><code>print</code> prints the estimated values of the parameters, while
<code>summary.starship</code> prints these by default, but can also provide
details of the estimation process (from the components <code>grid.results</code> and 
<code>optim</code> detailed below).
</p>
<p>An object of class <code>"starship"</code> is a list containing at least the
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A vector of length 4 (or 5, for the <em>fm5</em> parameterisation), giving 
the estimated parameters, in order,
<code class="reqn">\lambda_1</code> - location parameter
<code class="reqn">\lambda_2</code> - scale parameter
<code class="reqn">\lambda_3</code> - first shape parameter
<code class="reqn">\lambda_4</code> - second shape parameter
(See <code>gld</code> for details of the parameters in the <em>fm5</em> parameterisation)
</p>
<p>In the <em>gpd</em> parameterisation, the parameters are labelled:
<code class="reqn">\alpha</code> - location parameter
<code class="reqn">\beta</code> - scale parameter
<code class="reqn">\delta</code> - skewness parameter
<code class="reqn">\lambda</code> - tailweight parameter  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid.results</code></td>
<td>
<p>output from the grid search - see
<code>starship.adaptivegrid</code> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>output from the optim search -
<code>optim</code> for details</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Robert King, <a href="mailto:robert.king.newcastle@gmail.com">robert.king.newcastle@gmail.com</a>,
<a href="https://github.com/newystats/">https://github.com/newystats/</a>
</p>
<p>Darren Wraith</p>


<h3>References</h3>

<p> Freimer, M., Mudholkar, G. S., Kollia, G. &amp; Lin, C. T. (1988), 
<em>A study of the generalized tukey lambda family</em>, Communications 
in Statistics - Theory and Methods <b>17</b>, 3547–3567.
</p>
<p>Ramberg, J. S. &amp; Schmeiser, B. W. (1974), <em>An approximate method for
generating asymmetric random variables</em>, Communications of the ACM <b>17</b>, 
78–82.
</p>
<p>King, R.A.R. &amp; MacGillivray, H. L. (1999), <em>A starship method for
fitting the generalised <code class="reqn">\lambda</code> distributions</em>,
Australian and New Zealand Journal of
Statistics <b>41</b>, 353–374
</p>
<p>Owen, D. B. (1988), <em>The starship</em>, Communications in Statistics - 
Computation and Simulation <b>17</b>, 315–323.
</p>
<p><a href="https://github.com/newystats/gld/">https://github.com/newystats/gld/</a>
</p>


<h3>See Also</h3>

 
<p><code>starship.adaptivegrid</code>, 
<code>starship.obj</code> 
</p>


<h3>Examples</h3>

<pre><code class="language-R">exampledata &lt;- rgl(300,c(0,1,0.2,0))
starship(exampledata)
</code></pre>


</div>