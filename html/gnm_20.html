<div class="container">

<table style="width: 100%;"><tr>
<td>getContrasts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Estimated Contrasts and Standard Errors for Parameters in a gnm
Model </h2>

<h3>Description</h3>

<p>Computes contrasts or scaled contrasts for a set of (non-eliminated)
parameters from a <code>gnm</code> model, and computes standard errors
for the estimated contrasts.  Where possible, quasi standard errors are
also computed. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">getContrasts(model, set = NULL,  ref = "first", scaleRef = "mean",
  scaleWeights = NULL, dispersion = NULL, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p> a model object of class <code>"gnm"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set</code></td>
<td>
<p> a vector of indices (numeric) or coefficient names
(character). If <code>NULL</code>, a dialog will open for parameter
selection. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref</code></td>
<td>
<p>either a single numeric index, or a vector
of real numbers which sum to 1, or one of the character
strings <code>"first"</code>, <code>"last"</code> or <code>"mean"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleRef</code></td>
<td>
<p>as for <code>ref</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleWeights</code></td>
<td>
<p>either <code>NULL</code>, a vector of real numbers,
<code>"unit"</code> or <code>"setLength"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dispersion</code></td>
<td>
<p>either <code>NULL</code>, or a positive number by which
the model's variance-covariance matrix should be scaled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> or a numeric vector – for
which of the specified parameter combinations should estimability be
checked? If <code>TRUE</code>, all are checked; if <code>FALSE</code>, none is checked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> arguments to pass to other functions. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The indices in <code>set</code>
must all be in <code>1:length(coef(object))</code>.  If
<code>set = NULL</code>, a dialog is presented for the selection
of indices (model coefficients).
</p>
<p>For the set of coefficients selected, contrasts and their standard
errors are computed. A check is performed first on the estimability of
all such contrasts (if <code>check = TRUE</code>) or on a specified subset
(if <code>check</code> is a numeric index vector).  The specific
contrasts to be computed are controlled by the choice of <code>ref</code>:
this may be <code>"first"</code> (the default), for contrasts with the first
of the selected coefficients, or <code>"last"</code> for contrasts with the
last, or <code>"mean"</code> for contrasts with the arithmetic mean of the
coefficients in the selected set; or it may be an arbitrary vector of
weights (summing to 1, not necessarily all non-negative) which specify
a weighted mean against which contrasts are taken; or it may be a
single index specifying one of the coefficients with which all
contrasts should be taken.  Thus, for example, <code>ref = 1</code> is
equivalent to <code>ref = "first"</code>, and <code>ref = c(1/3, 1/3, 1/3)</code>
is equivalent to <code>ref = "mean"</code> when there are three coefficients
in the selected <code>set</code>.
</p>
<p>The contrasts may be scaled by
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\sqrt{\sum_r v_r * d_r^2}}</code>
</p>

<p>where <code class="reqn">d_r</code> is a contrast of the r'th coefficient in <code>set</code>
with the reference level specified by <code>scaleRef</code> and <code class="reqn">v</code> is a
vector of weights (of the same length as <code>set</code>)
specified by <code>scaleWeights</code>. If
<code>scaleWeights</code> is <code>NULL</code> (the default), <code>scaleRef</code>
is ignored and no scaling is performed. Other options for
<code>scaleWeights</code> are <code>"unit"</code> for weights equal to one and
<code>"setLength"</code> for weights equal to the reciprocal of
<code>length(set)</code>. If <code>scaleRef</code>
is the same as <code>ref</code>, these options constrain the sum of squared
contrasts to 1 and <code>length(set)</code> respectively.
</p>
<p>Quasi-variances (and corresponding quasi standard errors) are
reported for <b>unscaled</b> contrasts where possible. These statistics are
invariant to the choice of <code>ref</code>, see Firth (2003) or Firth and
Menezes (2004) for more details.
</p>


<h3>Value</h3>

<p>An object of class
<code>qv</code> — see <code>qvcalc</code>.
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>References</h3>

<p>Firth, D (2003).  Overcoming the reference category problem in the
presentation of statistical models.  <em>Sociological Methodology</em>
<b>33</b>, 1–18.
</p>
<p>Firth, D and Menezes, R X de (2004).  Quasi-variances.
<em>Biometrika</em> <b>91</b>, 65–80.
</p>


<h3>See Also</h3>

 <p><code>gnm</code>, <code>se.gnm</code>,
<code>checkEstimable</code>, <code>qvcalc</code>,
<code>ofInterest</code></p>


<h3>Examples</h3>

<pre><code class="language-R">### Unscaled contrasts ###
set.seed(1)

## Fit the "UNIDIFF" mobility model across education levels -- see ?yaish
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               ofInterest = "[.]educ", family = poisson,
               data = yaish,  subset = (dest != 7))
## Examine the education multipliers (differences on the log scale):
unidiffContrasts &lt;- getContrasts(unidiff, ofInterest(unidiff))
plot(unidiffContrasts,
  main = "Unidiff multipliers (log scale): intervals based on
           quasi standard errors",
  xlab = "Education level", levelNames = 1:5)


### Scaled contrasts (elliptical contrasts) ###
set.seed(1)

##  Goodman Row-Column association model fits well (deviance 3.57, df 8)
mentalHealth$MHS &lt;- C(mentalHealth$MHS, treatment)
mentalHealth$SES &lt;- C(mentalHealth$SES, treatment)
RC1model &lt;- gnm(count ~ SES + MHS + Mult(SES, MHS),
                family = poisson, data = mentalHealth)
## Row scores and column scores are both unnormalized in this
## parameterization of the model 

## The scores can be normalized as in Agresti's eqn (9.15):
rowProbs &lt;- with(mentalHealth, tapply(count, SES, sum) / sum(count))
colProbs &lt;- with(mentalHealth, tapply(count, MHS, sum) / sum(count))
mu &lt;- getContrasts(RC1model, pickCoef(RC1model, "[.]SES"),
                   ref = rowProbs, scaleRef = rowProbs,
                   scaleWeights = rowProbs)
nu &lt;- getContrasts(RC1model, pickCoef(RC1model, "[.]MHS"),
                   ref = colProbs, scaleRef = colProbs,
                   scaleWeights = colProbs)
all.equal(sum(mu$qv[,1] * rowProbs), 0)
all.equal(sum(nu$qv[,1] * colProbs), 0)
all.equal(sum(mu$qv[,1]^2 * rowProbs), 1)
all.equal(sum(nu$qv[,1]^2 * colProbs), 1)
</code></pre>


</div>