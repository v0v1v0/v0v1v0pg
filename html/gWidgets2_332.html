<div class="container">

<table style="width: 100%;"><tr>
<td>gtree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>constructor for widget to display heirarchical data</h2>

<h3>Description</h3>

<p>The <code>gtree</code> widget is used to present structured heirarchical
data. This data may be specified through a data frame with some
accompanying columns by which to split the data, or dynamically
through a function (<code>offspring</code>).
</p>
<p>For a <code>GTree</code> object, svalue refers to the path specified as
a  vector of keys or (if <code>INDEX=TRUE</code>) by an integer vector
of offspring positions. The <code>drop</code> argument is used to
indicate if the terminus of the path is returned or the entire
path, defaults=TRUE. To get the data associated with a row, use the <code>[</code> method.
</p>
<p>For a <code>GTree</code> object, svalue refers to the path specified as
a  vector of keys . For the assignment method, one assigns by
index. That is <code>svalue(tr, index=TRUE) &lt;- svalue(tr,
index=TRUE)</code> should not change the state of the widget. (The
<code>index=TRUE</code> argument is the case for setting, but not
getting.)
</p>
<p>The <code>[</code> method is used to return the data associated with a
selected row. The <code>svalue</code> method returns the path or its
endpoint, the <code>[</code> method returns the row data associated with
the path.
</p>
<p>The update method for <code>GTree</code> recomputes the base nodes, then reopens the given node if still available
</p>


<h3>Usage</h3>

<pre><code class="language-R">gtree(
  x = NULL,
  INDICES = NULL,
  offspring = x,
  offspring.data = NULL,
  chosen.col = 1,
  offspring.col = 2,
  icon.col = NULL,
  tooltip.col = NULL,
  multiple = FALSE,
  handler = NULL,
  action = NULL,
  container = NULL,
  ...,
  toolkit = guiToolkit()
)

.gtree(
  toolkit,
  offspring = NULL,
  offspring.data = NULL,
  chosen.col = 1,
  offspring.col = 2,
  icon.col = NULL,
  tooltip.col = NULL,
  multiple = FALSE,
  handler = NULL,
  action = NULL,
  container = NULL,
  ...
)

## S3 method for class 'GTree'
svalue(obj, index = FALSE, drop = TRUE, ...)

## S3 replacement method for class 'GTree'
 svalue(obj, index=TRUE, ...) &lt;- value

## S3 method for class 'GTree'
x[i, j, ..., drop = FALSE]

## S3 method for class 'GTree'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Data frame. Optional, if given specify INDICES
value to split data into heirarchical data structure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>INDICES</code></td>
<td>
<p>Integers or column names, referring to columns of <code>x</code>. Used to form heirarchical structure. Order is important.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring</code></td>
<td>
<p>function. A function passed values <code>path</code> and <code>data</code>, the latter from <code>offspring.data</code>. The path is the current position of the parent item using the named keys from the chosen column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.data</code></td>
<td>
<p>Passed to second argument of <code>offspring</code> function. Used to parameterize a function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chosen.col</code></td>
<td>
<p>integer or one of column names of data frame
returned by <code>offspring</code>. The chosen column gives the key and
value of the path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offspring.col</code></td>
<td>
<p>integer or column name. Points to column containing logical values indicating if a row has offspring.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icon.col</code></td>
<td>
<p>integer of one of the column names of the data
frame. If provided (non-NULL), then this column should provide a
stock icon name to be placed in the row for the given data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tooltip.col</code></td>
<td>
<p>integer or one of the column names of the data frame. If provided (non-NULL), then the row for this item will have a tooltip given by the pointed to value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple</code></td>
<td>
<p>logical. Is multiple selection allowed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>handler</code></td>
<td>
<p>A handler assigned to the default change
signal. Handlers are called when some event triggers a widget to
emit a signal. For each widget some default signal is assumed, and
handlers may be assigned to that through <code>addHandlerChanged</code>
or at construction time. Handlers are functions whose first
argument, <code>h</code> in the documentation, is a list with atleast
two components <code>obj</code>, referring to the object emitting the
signal and <code>action</code>, which passes in user-specified data to
parameterize the function call.
</p>
<p>Handlers may also be added via <code>addHandlerXXX</code> methods for
the widgets, where <code>XXX</code> indicates the signal, with a default
signal mapped to <code>addHandlerChanged</code>
(cf. <code>addHandler</code> for a listing). These methods pass
back a handler ID that can be used with <code>blockHandler</code> and
<code>unblockHandler</code> to suppress temporarily the calling of the
handler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>action</code></td>
<td>
<p>User supplied data passed to the handler when it is called</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>container</code></td>
<td>
<p>A parent container. When a widget is created it can be
incorporated into the widget heirarchy by passing in a parent
container at construction time. (For some toolkits this is not
optional, e.g. <span class="pkg">gWidgets2tcltk</span> or <span class="pkg">gWidgets2WWW2</span>.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed to update method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>toolkit</code></td>
<td>
<p>Each widget constructor is passed in the toolkit it
will use. This is typically done using the default, which will
lookup the toolkit through <code>guiToolkit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>index</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>do we return tip or path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>vector of indices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>j</code></td>
<td>
<p>ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>object to update</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the former case, the data frame is split up by the columns
specified by INDICES. The first index is used to give the intial
branches, the second index the second, etc. The end leaves are the
data associated with a given path, with key given by that column
specified by <code>chosen.col</code>
</p>
<p>For the latter case, the "path" of the current node (the node and
its ancestors) is passed to the <code>offspring</code> function which
computes the next level in the heirarchy. This level is specified
through a data frame. This data frame has special columns. The
<code>chosen.col</code> specifies which column is used as the key in the
path, the <code>icon.col</code> (when given) points to a stock icon name
to decorate the column. Similarly, the <code>tooltip.columns</code>. The
fact that a row in the data frame has offspring is specified
through the <code>offspring.col</code> column, again specifed by index
or column name.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##################################################
## This tree reads a list
offspring &lt;- function(path=character(0), lst, ...) {
  if(length(path))
    obj &lt;- lst[[path]]
    else
      obj &lt;- lst
  nms &lt;- names(obj)
  hasOffspring &lt;- sapply(nms, function(i) {
    newobj &lt;- obj[[i]]
    is.recursive(newobj) &amp;&amp; !is.null(names(newobj))
    })
  data.frame(comps=nms, hasOffspring=hasOffspring, ## fred=nms,
             stringsAsFactors=FALSE)
}
l &lt;- list(a="1", b= list(a="21", b="22", c=list(a="231")))

## Not run: 
w &lt;- gwindow("Tree test")
t &lt;- gtree(offspring=offspring, offspring.data=l, cont=w)

## End(Not run)

##################################################
## This tree looks at recursive objects
describe &lt;- function(x) UseMethod("describe")
describe.default &lt;- function(x) sprintf("An object with class %s", class(x)[1])
describe.integer &lt;- function(x) sprintf("An integer with %s value%s", length(x),
   ifelse(length(x) &gt; 1, "s", ""))
describe.numeric &lt;- function(x) sprintf("A numeric with %s value%s", length(x),
   ifelse(length(x) &gt; 1, "s", ""))
describe.factor &lt;- function(x) sprint("A factor with %s level%s", length(levels(x)),
   ifelse(length(levels(x)) &gt; 1, "s", ""))

offspring &lt;- function(path, obj) {
  if(length(path) &gt; 0)
    x &lt;- obj[[path]]
  else
    x &lt;- obj

  nms &lt;- names(x)
  recursive &lt;- sapply(x, function(i) {
    is.recursive(i) &amp;&amp;
    !is.null(attr(i, "names")) &amp;&amp;
    length(i) &gt; 0
    })
  descr &lt;- sapply(x, describe)
  
  data.frame(Variable=nms, offspring=recursive, Description=descr, stringsAsFactors=FALSE)
}

l &lt;- lm(mpg ~ wt, mtcars)
## Not run: 
w &lt;- gwindow("test")
gtree(offspring=offspring, offspring.data=l, cont=w)

## End(Not run)

</code></pre>


</div>