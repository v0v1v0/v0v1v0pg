<div class="container">

<table style="width: 100%;"><tr>
<td>gamsel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit Regularization Path for Gaussian or Binomial Generalized Additive Model</h2>

<h3>Description</h3>

<p>Using overlap grouped lasso penalties, gamsel selects whether a term in a
gam is nonzero, linear, or a non-linear spline (up to a specified max df per
variable). It fits the entire regularization path on a grid of values for
the overall penalty lambda, both for gaussian and binomial families.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gamsel(
  x,
  y,
  num_lambda = 50,
  lambda = NULL,
  family = c("gaussian", "binomial"),
  degrees = rep(10, p),
  gamma = 0.4,
  dfs = rep(5, p),
  bases = pseudo.bases(x, degrees, dfs, parallel = parallel, ...),
  tol = 1e-04,
  max_iter = 2000,
  traceit = FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input (predictor) matrix of dimension <code>nobs</code> x <code>nvars</code>.
Each observation is a row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response variable.  Quantitative for <code>family="gaussian"</code> and
with values in <code>{0,1}</code> for <code>family="binomial"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_lambda</code></td>
<td>
<p>Number of <code>lambda</code> values to use. (Length of
<code>lambda</code> sequence.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>User-supplied <code>lambda</code> sequence.  For best performance,
leave as <code>NULL</code> and allow the routine to automatically select
<code>lambda</code>.  Otherwise, supply a (preferably gradually) decreasing
sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Response type. <code>"gaussian"</code> for linear model (default).
<code>"binomial"</code> for logistic model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degrees</code></td>
<td>
<p>An integer vector of length <code>nvars</code> specifying the
maximum number of spline basis functions to use for each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Penalty mixing parameter <code class="reqn">0 \le\gamma\le 1</code>.  Values <code class="reqn">
\gamma &lt; 0.5</code> penalize linear fit less than non-linear fit.  The default is
<code class="reqn">\gamma = 0.4</code>, which encourages a linear term over a nonlinear term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfs</code></td>
<td>
<p>Numeric vector of length <code>nvars</code> specifying the maximum
(end-of-path) degrees of freedom for each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bases</code></td>
<td>
<p>A list of orthonormal bases for the non-linear terms for each
variable. The function <code>pseudo.bases</code> generates these, using the
parameters <code>dfs</code> and <code>degrees</code>. See the documentation for
<code>pseudo.bases</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Convergence threshold for coordinate descent.  The coordinate
descent loop continues until the total change in objective after a pass over
all variables is less than <code>tol</code>.  Default is <code>1e-4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>Maximum number of coordinate descent iterations over all the
variables for each <code>lambda</code> value.  Default is 2000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traceit</code></td>
<td>
<p>If <code>TRUE</code>, various information is printed during the
fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>passed on to the <code>pseudo.bases()</code> function. Uses
multiple process if available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed on to <code>pseudo.bases()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of models along the <code>lambda</code> path is fit by (block)
cordinate descent.  In the case of logistic regression the fitting routine
may terminate before all <code>num_lambda</code> values of <code>lambda</code> have been
used.  This occurs when the fraction of null deviance explained by the model
gets too close to 1, at which point the fit becomes numerically unstable.
Each of the smooth terms is computed using an approximation to the
Demmler-Reinsch smoothing spline basis for that variable, and the
accompanying diagonal pernalty matrix.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>gamsel</code>.  %% If it is a LIST, use
</p>
<table>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Intercept sequence of length <code>num_lambda</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p><code>nvars</code> x <code>num_lambda</code> matrix of linear coefficient
estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betas</code></td>
<td>
<p><code>sum(degrees)</code> x <code>num_lambda</code> matrix of
non-linear coefficient estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>The sequence of lambda
values used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degrees</code></td>
<td>
<p>Number of basis functions used for each
variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parms</code></td>
<td>
<p>A set of parameters that capture the bases used. This
allows for efficient generation of the bases elements for
<code>predict.gamsel</code></p>
</td>
</tr>
</table>
<p>, the <code>predict</code> method for this class.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p><code>"gaussian"</code> or <code>"binomial"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null
deviance (deviance of the intercept model)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>Vector of
length <code>num_lambda</code> giving fraction of (null) deviance explained by
each model along the <code>lambda</code> sequence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that
produced this object</p>
</td>
</tr>
</table>
<p> %% ...
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>, <a href="https://arxiv.org/abs/1506.03850">https://arxiv.org/abs/1506.03850</a>
</p>


<h3>See Also</h3>

<p><code>predict.gamsel</code>, <code>cv.gamsel</code>,
<code>plot.gamsel</code>, <code>summary.gamsel</code>,
<code>basis.gen</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
par(mfrow=c(1,2),mar=c(5,4,3,1))
summary(gamsel.out)
gamsel.cv=cv.gamsel(X,y,bases=bases)
par(mfrow=c(1,1))
plot(gamsel.cv)
par(mfrow=c(3,4))
plot(gamsel.out,newx=X,index=20)
# Binomial model
gamsel.out=gamsel(X,yb,family="binomial")
par(mfrow=c(1,2),mar=c(5,4,3,1))
summary(gamsel.out)
par(mfrow=c(3,4))
plot(gamsel.out,newx=X,index=30)

</code></pre>


</div>