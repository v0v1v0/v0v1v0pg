<div class="container">

<table style="width: 100%;"><tr>
<td>glmnet.path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a GLM with elastic net regularization for a path of lambda values</h2>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood for a path of
lambda values. Can deal with any GLM family.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmnet.path(
  x,
  y,
  weights = NULL,
  lambda = NULL,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  alpha = 1,
  offset = NULL,
  family = gaussian(),
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-10,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = integer(0),
  lower.limits = -Inf,
  upper.limits = Inf,
  trace.it = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input matrix, of dimension <code>nobs x nvars</code>; each row is an
observation vector. Can be a sparse matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Quantitative response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Observation weights. Default is 1 for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied lambda sequence. Typical usage is to have the
program compute its own lambda sequence based on <code>nlambda</code> and
<code>lambda.min.ratio</code>. Supplying a value of lambda overrides this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values, default is 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Smallest value for lambda as a fraction of lambda.max,
the (data derived) entry value (i.e. the smallest value for which all
coefficients are zero). The default depends on the sample size <code>nobs</code>
relative to the number of variables <code>nvars</code>. If <code>nobs &gt;= nvars</code>, the
default is 0.0001, close to zero. If <code>nobs &lt; nvars</code>, the default is 0.01.
A very small value of <code>lambda.min.ratio</code> will lead to a saturated fit
in the <code>nobs &lt; nvars</code> case. This is undefined for some families of
models, and the function will exit gracefully when the percentage deviance
explained is almost 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.
The penalty is defined as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in the linear
predictor. Useful for the "poisson" family (e.g. log of exposure time), or
for refining a model by starting at a current fit. Default is NULL. If
supplied, then values must also be supplied to the <code>predict</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A description of the error distribution and link function to be
used in the model. This is the result of a call to a family function. Default
is <code>gaussian()</code>. (See <code>family</code> for details on
family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Logical flag for x variable standardization, prior to
fitting the model sequence. The coefficients are always returned on the
original scale. Default is <code>standardize=TRUE</code>. If variables are in the
same units already, you might not wish to standardize.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Should intercept be fitted (default=TRUE) or set to zero (FALSE)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each inner
coordinate-descent loop continues until the maximum change in the objective
after any coefficient update is less than thresh times the null deviance.
Default value is <code>1e-10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of passes over the data; default is <code>10^5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies <code>lambda</code> to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and that
variable is always included in the model. Default is 1 for all variables (and
implicitly infinity for variables listed in exclude). Note: the penalty
factors are internally rescaled to sum to <code>nvars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>Indices of variables to be excluded from the model. Default is
none. Equivalent to an infinite penalty factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient; default
<code>-Inf</code>. Each of these must be non-positive. Can be presented as a single
value (which will then be replicated), else a vector of length <code>nvars</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient; default
<code>Inf</code>. See <code>lower.limits</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.it</code></td>
<td>
<p>Controls how much information is printed to screen. Default is
<code>trace.it=0</code> (no information printed). If <code>trace.it=1</code>, a progress
bar is displayed. If <code>trace.it=2</code>, some information about the fitting
procedure is printed to the console as the model is being fitted.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>glmnet.path</code> solves the elastic net problem for a path of lambda values.
It generalizes <code>glmnet::glmnet</code> in that it works for any GLM family.
</p>
<p>Sometimes the sequence is truncated before <code>nlambda</code> values of lambda
have been used. This happens when <code>glmnet.path</code> detects that the decrease
in deviance is marginal (i.e. we are near a saturated fit).
</p>


<h3>Value</h3>

<p>An object with class "glmnetfit" and "glmnet".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients, stored in
sparse matrix format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used. When alpha=0, the
largest lambda reported does not quite give the zero coefficients reported
(lambda=inf would in principle). Instead, the largest lambda for alpha=0.001
is used, and the sequence of lambda values is derived from this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the intercept model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>Total passes over the data summed over all lambda values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Family used for the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
x &lt;- matrix(rnorm(100 * 20), nrow = 100)
y &lt;- ifelse(rnorm(100) &gt; 0, 1, 0)

# binomial with probit link
fit1 &lt;- glmnet:::glmnet.path(x, y, family = binomial(link = "probit"))
</code></pre>


</div>