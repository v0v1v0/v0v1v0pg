<div class="container">

<table style="width: 100%;"><tr>
<td>geom_seq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>draw seqs</h2>

<h3>Description</h3>

<p><code>geom_seq()</code> draws contigs for each sequence/chromosome supplied in the <code>seqs</code> track.
Several sequences belonging to the same bin will be plotted next to one another.
</p>
<p>If <code>seqs</code> track is empty, sequences are inferred from the <code>feats</code> or <code>links</code> track respectively.
</p>
<p>(<em>The length of sequences can be deduced from the axis and is typically indicated in base pairs.</em>)
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_seq(mapping = NULL, data = seqs(), arrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>seq_layout: Uses the first data frame stored in the <code>seqs</code> track, by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrow</code></td>
<td>
<p>set to non-NULL to generate default arrows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li>
<p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li>
<p> When constructing a layer using
a <code style="white-space: pre;">⁠stat_*()⁠</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li>
<p> Inversely, when constructing a layer using a
<code style="white-space: pre;">⁠geom_*()⁠</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li>
<p> The <code>key_glyph</code> argument of <code>layer()</code> may also be passed on through
<code>...</code>. This can be one of the functions described as
key glyphs, to change the display of the layer in the legend.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>geom_seq()</code> uses <code>ggplot2::geom_segment()</code> under the hood. As a result,
different aesthetics such as <em>alpha</em>, <em>linewidth</em>, <em>color</em>, etc.
can be called upon to modify the visualization of the data.
</p>
<p>Note: The <code>seqs</code> track indicates the length/region of the sequence/contigs that will be plotted.
<em>Feats</em> or <em>links</em> data that falls outside of this region are ignored!
</p>


<h3>Value</h3>

<p>Sequence data drawn as contigs is added as a layer/component to the plot.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Simple example of geom_seq
gggenomes(seqs = emale_seqs) +
  geom_seq() + # creates contigs
  geom_bin_label() # labels bins/sequences

# No sequence information supplied, will inform/warn that seqs are inferred from feats.
gggenomes(genes = emale_genes) +
  geom_seq() + # creates contigs
  geom_gene() + # draws genes on top of contigs
  geom_bin_label() # labels bins/sequences

# Sequence data controls what sequences and/or regions will be plotted.
# Here one sequence is filtered out, Notice that the genes of the removed
# sequence are silently ignored and thus not plotted.
missing_seqs &lt;- emale_seqs |&gt;
  dplyr::filter(seq_id != "Cflag_017B") |&gt;
  dplyr::arrange(seq_id) # `arrange` to restore alphabetical order.

gggenomes(seqs = missing_seqs, genes = emale_genes) +
  geom_seq() + # creates contigs
  geom_gene() + # draws genes on top of contigs
  geom_bin_label() # labels bins/sequences

# Several sequences belonging to the same *bin* are plotted next to one another
seqs &lt;- tibble::tibble(
  bin_id = c("A", "A", "A", "B", "B", "B", "B", "C", "C"),
  seq_id = c("A1", "A2", "A3", "B1", "B2", "B3", "B4", "C1", "C2"),
  start = c(0, 100, 200, 0, 50, 150, 250, 0, 400),
  end = c(100, 200, 400, 50, 100, 250, 300, 300, 500),
  length = c(100, 100, 200, 50, 50, 100, 50, 300, 100)
)

gggenomes(seqs = seqs) +
  geom_seq() +
  geom_bin_label() + # label bins
  geom_seq_label() # label individual sequences

# Wrap bins uptill a certain amount.
gggenomes(seqs = seqs, wrap = 300) +
  geom_seq() +
  geom_bin_label() + # label bins
  geom_seq_label() # label individual sequences

# Change the space between sequences belonging to one bin
gggenomes(seqs = seqs, spacing = 100) +
  geom_seq() +
  geom_bin_label() + # label bins
  geom_seq_label() # label individual sequences
</code></pre>


</div>