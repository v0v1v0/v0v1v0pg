<div class="container">

<table style="width: 100%;"><tr>
<td>cov.wendland</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Wendland Covariance Function</h2>

<h3>Description</h3>

<p>A fully parametrized generalized Wendland covariance function for use in geostatistical modeling, as well as multiple methods of obtaining computationally inexpensive approximations.
</p>
<p style="text-align: center;"><code class="reqn">\rho_{\beta,\kappa,\mu} = \begin{cases}\sigma + \theta \quad 0 \leq r &lt; \epsilon \\ \frac{\sigma}{B(1+2\kappa,\mu)} \int_r^1 (u^2-r^2)^\kappa (1-u)^{\mu-1} du \quad \epsilon \leq r &lt; 1 \\ 0 \quad 1 \leq r \end{cases}</code>
</p>

<p>where <code class="reqn">r=h/\beta</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">cov.wendland(h, theta, ..., cov.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>A numeric vector, matrix, or spam object storing distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Numeric vector <code class="reqn">\vec{\theta}=(\beta, \sigma, \kappa, \mu, \theta)</code> storing parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.args</code></td>
<td>
<p>Named list of arguments. See Details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Using the list cov.args, users can provide the following additional arguments:
</p>

<dl>
<dt>numint.abstol (default: <code>1e-3</code>)</dt>
<dd>
<p>Absolute tolerance for numerical integration.</p>
</dd>
<dt>numint.reltol (default: <code>1e-3</code>)</dt>
<dd>
<p>Relative tolerance for numerical integration.</p>
</dd>
<dt>numint.qag_key (default: <code>0</code>)</dt>
<dd>
<p>Method to use in QAG integration (Values 1 - 6)</p>
</dd>
<dt>numint.subintervals (default: <code>0</code>)</dt>
<dd>
<p>Number of subintervals to use in QAG/QAGS integration.</p>
</dd>
<dt>interp.method (default: <code>'none'</code>)</dt>
<dd>
<p>Method to use for covariance interpolation. Valid methods are 'none', 'linear', 'polynomial', and 'cspline'.</p>
</dd>
<dt>interp.num_support (default: <code>0</code>)</dt>
<dd>
<p>Number of support points to use for covariance interpolation.</p>
</dd>
<dt>cov.reparameterize (default: <code>TRUE</code>)</dt>
<dd>
<p>Whether to apply the reparameterization <code class="reqn">\mu=\frac{1+d}{2} + \kappa + \nu</code>, where <code class="reqn">\nu</code> takes the place of <code class="reqn">\mu</code> in input vector <code class="reqn">\vec{\theta}</code>. This allows users to use box constraints in maximum likelihood estimation, as the covariance function is valid for <code class="reqn">\nu \in [0,\infty)</code> rather than <code class="reqn">\mu \in [\frac{1+d}{2} + \kappa,\infty)</code>.</p>
</dd>
<dt>cov.eps (default: <code>.Machine$double.eps^0.5</code>)</dt>
<dd>
<p>The threshold distance <code class="reqn">\epsilon</code> below which the function will return <code class="reqn">\sigma + \theta</code>.</p>
</dd>
<dt>cov.d_value (default: <code>2</code>)</dt>
<dd>
<p>Dimensionality of space in which measurements were taken. This only takes effect if <code>cov.reparameterize</code> is TRUE.</p>
</dd>
</dl>
<h3>Value</h3>

<p>Returns an object of the same type as input object h which stores the computed covariance values, i.e. a spam object if input h was also a spam object.
</p>


<h3>Author(s)</h3>

<p>Thomas Caspar Fischer</p>


<h3>References</h3>

<p>Moreno Bevilacqua and Tarik Faouzi and Reinhard Furrer and Emilio Porcu (2019) Estimation and prediction using generalized Wendland covariance functions under fixed domain asymptotics, <em>Annals of Statistics</em>, <b>47</b>(2), 828â€“856.
</p>


<h3>Examples</h3>

<pre><code class="language-R">h &lt;- seq(0, 1, 0.01)
plot(0, type = "n", xlab = "Distance", ylab = "Covariance",
     xlim = c(0, 1), ylim = c(0,1))

theta &lt;- c(range=1, sill=1, kappa=1, mu=0, nugget=0)
cov.args &lt;- list()
lines(x = h, y = cov.wendland(h, theta, cov.args = cov.args),
      lwd = 2)

theta &lt;- c(range=1, sill=1, kappa=1, mu=0, nugget=0)
cov.args &lt;- list(cov.reparametrize = FALSE, cov.d_value = 2)
theta[4] &lt;- (1 + cov.args[[2]])/2 + theta[3] + theta[4]
lines(x = h, y = cov.wendland(h, theta, cov.args = cov.args),
      col = "red", lty = 3, lwd = 3.5)

theta &lt;- c(range=0.5, sill=1, kappa=1, mu=0, nugget=0)
cov.args &lt;- list(interp.method="cspline", interp.num_support=100)
lines(x = h, y = cov.wendland(h, theta, cov.args = cov.args),
      col = "green", lwd = 2)

legend("topright", legend = c("Default", "No reparameterization",
                              "Cubic spline interpolation"),
       col = c(1, 2, 3), lty = c(1,3,1), lwd = c(2, 3.5, 2))
</code></pre>


</div>