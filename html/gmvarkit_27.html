<div class="container">

<table style="width: 100%;"><tr>
<td>fitGSMVAR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two-phase maximum likelihood estimation of a GMVAR, StMVAR, or G-StMVAR model</h2>

<h3>Description</h3>

<p><code>fitGSMVAR</code> estimates a GMVAR, StMVAR, or G-StMVAR model model in two phases:
in the first phase it uses a genetic algorithm to find starting values for a gradient based
variable metric algorithm, which it then uses to finalize the estimation in the second phase.
Parallel computing is utilized to perform multiple rounds of estimations in parallel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitGSMVAR(
  data,
  p,
  M,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  ncalls = (M + 1)^5,
  ncores = 2,
  maxit = 1000,
  seeds = NULL,
  print_res = TRUE,
  use_parallel = TRUE,
  filter_estimates = TRUE,
  calc_std_errors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt>
<dd>
<p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt>
<dd>
<p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>is "GMVAR", "StMVAR", or "G-StMVAR" model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li>
</ul>
<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncalls</code></td>
<td>
<p>the number of estimation rounds that should be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seeds</code></td>
<td>
<p>a length <code>ncalls</code> vector containing the random number generator seed for each call to the genetic algorithm,
or <code>NULL</code> for not initializing the seed. Exists for creating reproducible results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_res</code></td>
<td>
<p>should summaries of estimation results be printed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, no progression bar etc will be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter_estimates</code></td>
<td>
<p>should the likely inappropriate estimates be filtered? See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc_std_errors</code></td>
<td>
<p>calculate approximate standard errors for the estimates?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional settings passed to the function <code>GAfit</code> employing the genetic algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If you wish to estimate a structural model without overidentifying constraints that is identified statistically,
specify your W matrix is <code>structural_pars</code> to be such that it contains the same sign constraints in a single row
(e.g. a row of ones) and leave the other elements as <code>NA</code>. In this way, the genetic algorithm works the best.
The ordering and signs of the columns of the W matrix can be changed afterwards with the functions
<code>reorder_W_columns</code> and <code>swap_W_signs</code>.
</p>
<p>Because of complexity and high multimodality of the log-likelihood function, it's <strong>not certain</strong> that the estimation
algorithms will end up in the global maximum point. It's expected that most of the estimation rounds will end up in
some local maximum or saddle point instead. Therefore, a (sometimes large) number of estimation rounds is required
for reliable results. Because of the nature of the model, the estimation may fail especially in the cases where the
number of mixture components is chosen too large. <strong>With two regimes and couple hundred observations in a two-dimensional
time series, 50 rounds is usually enough. Several hundred estimation rounds often suffices for reliably fitting two-regimes
models to 3 or 4 dimensional time series. With more than two regimes and more than couple hundred
observations, thousands of estimation rounds (or more) are often required to obtain reliable results.</strong>
</p>
<p>The estimation process is computationally heavy and it might take considerably long time for large models with
large number of observations. If the iteration limit <code>maxit</code> in the variable metric algorithm is reached,
one can continue the estimation by iterating more with the function <code>iterate_more</code>. Alternatively, one may
use the found estimates as starting values for the genetic algorithm and and employ another round of estimation
(see <code>?GAfit</code> how to set up an initial population with the dot parameters).
</p>
<p><strong>If the estimation algorithm fails to create an initial population for the genetic algorithm</strong>,
it usually helps to scale the individual series so that the AR coefficients (of a VAR model) will be
relative small, preferably less than one. Even if one is able to create an initial population, it should
be preferred to scale the series so that most of the AR coefficients will not be very large, as the
estimation algorithm works better with relatively small AR coefficients. If needed, another package can be used
to fit linear VARs to the series to see which scaling of the series results in relatively small AR coefficients.
</p>
<p>The code of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em> but it
includes some extra features that were found useful for this particular estimation problem. For instance,
the genetic algorithm uses a slightly modified version of the individually adaptive crossover and mutation
rates described by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed
by <em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>The gradient based variable metric algorithm used in the second phase is implemented with function <code>optim</code>
from the package <code>stats</code>.
</p>
<p>Note that the structural models are even more difficult to estimate than the reduced form models due to
the different parametrization of the covariance matrices, so larger number of estimation rounds should be considered.
Also, be aware that if the lambda parameters are constrained in any other way than by restricting some of them to be
identical, the parameter "lambda_scale" of the genetic algorithm (see <code>?GAfit</code>) needs to be carefully adjusted accordingly.
<strong>When estimating a structural model that imposes overidentifiying constraints to a time series with <code class="reqn">d&gt;3</code>,
it is highly recommended to create an initial population based on the estimates of a statistically identified model
(when <code class="reqn">M=2</code>). This is because currently obtaining the ML estimate reliably to such a structural model seems
difficult in many application.</strong>
</p>
<p>Finally, the function fails to calculate approximate standard errors and the parameter estimates are near the border
of the parameter space, it might help to use smaller numerical tolerance for the stationarity and positive
definiteness conditions. The numerical tolerance of an existing model can be changed with the function
<code>update_numtols</code>.
</p>
<p><strong>Filtering inappropriate estimates:</strong> If <code>filter_estimates == TRUE</code>, the function will automatically filter
out estimates that it deems "inappropriate". That is, estimates that are not likely solutions of interest.
Specifically, solutions that incorporate a near-singular error term covariance matrix (any eigenvalue less than <code class="reqn">0.002</code>),
mixing weights such that they are close to zero for almost all <code class="reqn">t</code> for at least one regime, or mixing weight parameter
estimate close to zero (or one). It also filters out estimates with any modulus "bold A" eigenvalues larger than 0.9985,
as the solution is near the boundary of the stationarity region and likely not a local maximum. You can also set
<code>filter_estimates=FALSE</code> and find the solutions of interest yourself by using the
function <code>alt_gsmvar</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the estimated (reduced form or structural) GMVAR, StMVAR, or G-StMVAR model.
Multivariate quantile residuals (Kalliovirta and Saikkonen 2010) are also computed and included in the returned object.
In addition, the returned object contains the estimates and log-likelihood values from all the estimation rounds performed.
The estimated parameter vector can be obtained at <code>gsmvar$params</code> (and corresponding approximate standard errors
at <code>gsmvar$std_errors</code>). See <code>?GSMVAR</code> for the form of the parameter vector, if needed.
</p>
<p>Remark that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>S3 methods</h3>

<p>The following S3 methods are supported for class <code>'gsmvar'</code>: <code>logLik</code>, <code>residuals</code>, <code>print</code>, <code>summary</code>,
<code>predict</code>, <code>simulate</code>, and <code>plot</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li>
<p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li>
<p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li>
<p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li>
<p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li>
<p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>GSMVAR</code>, <code>iterate_more</code>, <code>stmvar_to_gstmvar</code>, <code>predict.gsmvar</code>,
<code>profile_logliks</code>, <code>simulate.gsmvar</code>, <code>quantile_residual_tests</code>, <code>print_std_errors</code>,
<code>swap_parametrization</code>, <code>get_gradient</code>, <code>GIRF</code>, <code>GFEVD</code>, <code>LR_test</code>,
<code>Wald_test</code>, <code>gsmvar_to_sgsmvar</code>, <code>stmvar_to_gstmvar</code>, <code>reorder_W_columns</code>,
<code>swap_W_signs</code>, <code>cond_moment_plot</code>, <code>update_numtols</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## These are long running examples that use parallel computing!
# Running all the below examples will take approximately 3-4 minutes.

# GMVAR(1,2) model: 10 estimation rounds with seeds set
# for reproducibility
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=10, seeds=1:10)
fit12
plot(fit12)
summary(fit12)
print_std_errors(fit12)
profile_logliks(fit12)

# The rest of the examples only use a single estimation round with a given
# seed that produces the MLE to reduce running time of the examples. When
# estimating models for empirical applications, a large number of estimation
# rounds (ncalls = a large number) should be performed to ensure reliability
# of the estimates (see the section details).

# StMVAR(2, 2) model
fit22t &lt;- fitGSMVAR(gdpdef, p=2, M=2, model="StMVAR", ncalls=1, seeds=1)
fit22t # Overly large degrees of freedom estimate in the 2nd regime!
fit22gs &lt;- stmvar_to_gstmvar(fit22t) # So switch it to GMVAR type!
fit22gs # This is the appropriate G-StMVAR model based on the above StMVAR model.
fit22gss &lt;- gsmvar_to_sgsmvar(fit22gs) # Switch to structural model
fit22gss # This is the implied statistically identified structural model.

# Structural GMVAR(1,2) model identified with sign
# constraints.
W_122 &lt;- matrix(c(1, 1, -1, 1), nrow=2)
fit12s &lt;- fitGSMVAR(gdpdef, p=1, M=2, structural_pars=list(W=W_122),
  ncalls=1, seeds=1)
fit12s
# A statistically identified structural model can also be obtained with
# gsmvar_to_sgsmvar(fit12)


# GMVAR(2,2) model with autoregressive parameters restricted
# to be the same for both regimes
C_mat &lt;- rbind(diag(2*2^2), diag(2*2^2))
fit22c &lt;- fitGSMVAR(gdpdef, p=2, M=2, constraints=C_mat, ncalls=1, seeds=1)
fit22c

# G-StMVAR(2, 1, 1) model with autoregressive parameters and unconditional means restricted
# to be the same for both regimes:
fit22gscm &lt;- fitGSMVAR(gdpdef, p=2, M=c(1, 1), model="G-StMVAR", constraints=C_mat,
   parametrization="mean", same_means=list(1:2), ncalls=1, seeds=1)

# GMVAR(2,2) model with autoregressive parameters restricted
# to be the same for both regimes and non-diagonal elements
# the coefficient matrices constrained to zero.
tmp &lt;- matrix(c(1, rep(0, 10), 1, rep(0, 8), 1, rep(0, 10), 1),
 nrow=2*2^2, byrow=FALSE)
C_mat2 &lt;- rbind(tmp, tmp)
fit22c2 &lt;- fitGSMVAR(gdpdef, p=2, M=2, constraints=C_mat2, ncalls=1,
  seeds=1)
fit22c2

</code></pre>


</div>