<div class="container">

<table style="width: 100%;"><tr>
<td>param_em</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Learn the parameters of a Gaussian mixture graphical model with incomplete
data</h2>

<h3>Description</h3>

<p>This function learns the parameters of a Gaussian mixture graphical model
with incomplete data using the parametric EM algorithm. At each iteration,
inference (smoothing inference for a dynamic Bayesian network) is performed
to complete the data given the current estimate of the parameters (E step).
The completed data are then used to update the parameters (M step), and so
on. Each iteration is guaranteed to increase the log-likelihood until
convergence to a local maximum (Koller and Friedman, 2009). In practice, due
to the sampling process inherent in particle-based inference, it may happen
that the monotonic increase no longer occurs when approaching the local
maximum, resulting in an earlier termination of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">param_em(
  gmgm,
  data,
  nodes = structure(gmgm)$nodes,
  col_seq = NULL,
  n_part = 1000,
  max_part_sim = 1e+06,
  min_ess = 1,
  max_iter_pem = 5,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gmgm</code></td>
<td>
<p>An object of class <code>gmbn</code> (non-temporal) or <code>gmdbn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing the data used for learning. Its columns
must explicitly be named after nodes of <code>gmgm</code> and can contain missing
values (columns with no value can be removed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>A character vector containing the nodes whose local conditional
models are learned (by default all the nodes of <code>gmgm</code>). If <code>gmgm</code>
is a <code>gmdbn</code> object, the same nodes are learned for each of its
<code>gmbn</code> elements. This constraint can be overcome by passing a list of
character vectors named after some of these elements (<code>b_1</code>, ...) and
containing learned nodes specific to them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_seq</code></td>
<td>
<p>A character vector containing the column names of <code>data</code>
that describe the observation sequence. If <code>NULL</code> (the default), all the
observations belong to a single sequence. If <code>gmgm</code> is a <code>gmdbn</code>
object, the observations of a same sequence must be ordered such that the
<code class="reqn">t</code>th one is related to time slice <code class="reqn">t</code> (note that the sequences can
have different lengths). If <code>gmgm</code> is a <code>gmbn</code> object, this
argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_part</code></td>
<td>
<p>A positive integer corresponding to the number of particles
generated for each observation (if <code>gmgm</code> is a <code>gmbn</code> object) or
observation sequence (if <code>gmgm</code> is a <code>gmdbn</code> object) during
inference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_part_sim</code></td>
<td>
<p>An integer greater than or equal to <code>n_part</code>
corresponding to the maximum number of particles that can be processed
simultaneously during inference. This argument is used to prevent memory
overflow, dividing <code>data</code> into smaller subsets that are handle
sequentially.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_ess</code></td>
<td>
<p>A numeric value in [0, 1] corresponding to the minimum ESS
(expressed as a proportion of <code>n_part</code>) under which the renewal step of
sequential importance resampling is performed. If <code>1</code> (the default),
this step is performed at each time slice. If <code>gmgm</code> is a <code>gmbn</code>
object, this argument is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter_pem</code></td>
<td>
<p>A non-negative integer corresponding to the maximum
number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A logical value indicating whether iterations in progress
are displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to function <code>em</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>gmgm</code></td>
<td>
<p>The final <code>gmbn</code> or <code>gmdbn</code> object (with the highest
log-likelihood).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame (tibble) containing the complete data used to learn
the final <code>gmbn</code> or <code>gmdbn</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seq_loglik</code></td>
<td>
<p>A numeric matrix containing the sequence of log-likelihoods
measured after the E and M steps of each iteration.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Koller, D. and Friedman, N. (2009). <em>Probabilistic Graphical Models:
Principles and Techniques</em>. The MIT Press.
</p>


<h3>See Also</h3>

<p><code>param_learn</code>, <code>struct_em</code>,
<code>struct_learn</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(0)
data(data_body)
data_1 &lt;- data_body
data_1$GENDER[sample.int(2148, 430)] &lt;- NA
data_1$AGE[sample.int(2148, 430)] &lt;- NA
data_1$HEIGHT[sample.int(2148, 430)] &lt;- NA
data_1$WEIGHT[sample.int(2148, 430)] &lt;- NA
data_1$FAT[sample.int(2148, 430)] &lt;- NA
data_1$WAIST[sample.int(2148, 430)] &lt;- NA
data_1$GLYCO[sample.int(2148, 430)] &lt;- NA
gmbn_1 &lt;- gmbn(
  AGE = split_comp(add_var(NULL, data_1[, "AGE"]), n_sub = 3),
  FAT = split_comp(add_var(NULL,
                           data_1[, c("FAT", "GENDER", "HEIGHT", "WEIGHT")]),
                   n_sub = 2),
  GENDER = split_comp(add_var(NULL, data_1[, "GENDER"]), n_sub = 2),
  GLYCO = split_comp(add_var(NULL, data_1[, c("GLYCO", "AGE", "WAIST")]),
                     n_sub = 2),
  HEIGHT = split_comp(add_var(NULL, data_1[, c("HEIGHT", "GENDER")])),
  WAIST = split_comp(add_var(NULL,
                             data_1[, c("WAIST", "AGE", "FAT", "HEIGHT",
                                        "WEIGHT")]),
                     n_sub = 3),
  WEIGHT = split_comp(add_var(NULL, data_1[, c("WEIGHT", "HEIGHT")]), n_sub = 2)
)
res_learn_1 &lt;- param_em(gmbn_1, data_1, verbose = TRUE)

library(dplyr)
set.seed(0)
data(data_air)
data_2 &lt;- data_air
data_2$NO2[sample.int(7680, 1536)] &lt;- NA
data_2$O3[sample.int(7680, 1536)] &lt;- NA
data_2$TEMP[sample.int(7680, 1536)] &lt;- NA
data_2$WIND[sample.int(7680, 1536)] &lt;- NA
data_3 &lt;- data_2 %&gt;%
  group_by(DATE) %&gt;%
  mutate(NO2.1 = lag(NO2), O3.1 = lag(O3), TEMP.1 = lag(TEMP),
         WIND.1 = lag(WIND)) %&gt;%
  ungroup()
gmdbn_1 &lt;- gmdbn(
  b_2 = gmbn(
    NO2 = split_comp(add_var(NULL, data_3[, c("NO2", "NO2.1", "WIND")]),
                     n_sub = 3),
    O3 = split_comp(add_var(NULL,
                            data_3[, c("O3", "NO2", "NO2.1", "O3.1", "TEMP",
                                       "TEMP.1")]),
                    n_sub = 3),
    TEMP = split_comp(add_var(NULL, data_3[, c("TEMP", "TEMP.1")]), n_sub = 3),
    WIND = split_comp(add_var(NULL, data_3[, c("WIND", "WIND.1")]), n_sub = 3)
  ),
  b_13 = gmbn(
    NO2 = split_comp(add_var(NULL, data_3[, c("NO2", "NO2.1", "WIND")]),
                     n_sub = 3),
    O3 = split_comp(add_var(NULL,
                            data_3[, c("O3", "O3.1", "TEMP", "TEMP.1",
                                       "WIND")]),
                    n_sub = 3),
    TEMP = split_comp(add_var(NULL, data_3[, c("TEMP", "TEMP.1")]), n_sub = 3),
    WIND = split_comp(add_var(NULL, data_3[, c("WIND", "WIND.1")]), n_sub = 3)
  )
)
res_learn_2 &lt;- param_em(gmdbn_1, data_2, col_seq = "DATE", verbose = TRUE)

</code></pre>


</div>