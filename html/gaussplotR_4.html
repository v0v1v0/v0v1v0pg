<div class="container">

<table style="width: 100%;"><tr>
<td>fit_gaussian_2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine the best-fit parameters for a specific 2D-Gaussian model</h2>

<h3>Description</h3>

<p>Determine the best-fit parameters for a specific 2D-Gaussian model
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_gaussian_2D(
  data,
  method = "elliptical",
  constrain_amplitude = FALSE,
  constrain_orientation = "unconstrained",
  user_init = NULL,
  maxiter = 1000,
  verbose = FALSE,
  print_initial_params = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame that contains the raw data (generally rectilinearly
gridded data, but this is not a strict requirement). Columns must be named
<code>"X_values"</code>, <code>"Y_values"</code> and <code>"response"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Choice of <code>"elliptical"</code>, <code>"elliptical_log"</code>, or
<code>"circular"</code>. Determine which specific implementation of 2D-Gaussian
to use. See Details for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrain_amplitude</code></td>
<td>
<p>Default FALSE; should the amplitude of the
Gaussian be set to the maximum value of the <code>"response"</code> variable
(<code>TRUE</code>), or should the amplitude fitted by <code>stats::nls()</code>
(<code>FALSE</code>)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrain_orientation</code></td>
<td>
<p>If using <code>"elliptical"</code> or <code>method =
  "elliptical_log"</code>, should the orientation of the Gaussian be unconstrained
(i.e. the best-fit orientation is returned) or should it be pre-set by the
user? See Details for more. Defaults to <code>"unconstrained"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_init</code></td>
<td>
<p>Default NULL; if desired, the user can supply initial values
for the parameters of the chosen model. See Details for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Default 1000. A positive integer specifying the maximum number
of iterations allowed. See <code>stats::nls.control()</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>TRUE or FALSE; should the trace of the iteration be printed?
See the <code>trace</code> argument of <code>stats::nls()</code> for more detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_initial_params</code></td>
<td>
<p>TRUE or FALSE; should the set of initial
parameters supplied to <code>stats::nls()</code> be printed to the console? Set
to FALSE by default to avoid confusion with the fitted parameters attained
after using <code>stats::nls()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>stats::nls.control()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stats::nls()</code> is used to fit parameters for a 2D-Gaussian to
the supplied data. Each method uses (slightly) different sets of
parameters. Note that for a small (but non-trivial) proportion of data
sets, nonlinear least squares may fail due to singularities or other
issues. Most often, this occurs because of the starting parameters that are
fed in. By default, this function attempts to set default parameters by
making an educated guess about the major aspects of the supplied data.
Should this strategy fail, the user can make use of the <code>user_init</code>
argument to supply an alternate set of starting values.
</p>
<p>The simplest method is <code>method = "circular"</code>. Here, the 2D-Gaussian is
constrained to have a roughly circular shape (i.e. spread in X- and Y- are
roughly equal). If this method is used, the fitted parameters are: Amp
(amplitude), X_peak (x-axis peak location), Y_peak (y-axis peak location),
X_sig (spread along x-axis), and Y_sig (spread along y-axis).
</p>
<p>A more generic method (and the default) is <code>method = "elliptical"</code>.
This allows the fitted 2D-Gaussian to take a more ellipsoid shape (but note
that <code>method = "circular"</code> can be considered a special case of this).
If this method is used, the fitted parameters are: A_o (a constant term),
Amp (amplitude), theta (rotation, in radians, from the x-axis in the
clockwise direction), X_peak (x-axis peak location), Y_peak (y-axis peak
location), a (width of Gaussian along x-axis), and b (width of Gaussian
along y-axis).
</p>
<p>A third method is <code>method = "elliptical_log"</code>. This is a further
special case in which log2-transformed data may be used. See Priebe et al.
2003 for more details. Parameters from this model include: Amp (amplitude),
Q (orientation parameter), X_peak (x-axis peak location), Y_peak (y-axis
peak location), X_sig (spread along x-axis), and Y_sig (spread along
y-axis).
</p>
<p>If using either <code>method = "elliptical"</code> or <code>method =
  "elliptical_log"</code>, the <code>"constrain_orientation"</code> argument can be used
to specify how the orientation is set. In most cases, the user should use
the default "unconstrained" setting for this argument. Doing so will
provide the best-fit 2D-Gaussian (assuming that the solution yielded by
<code>stats::nls()</code> converges on the global optimum).
</p>
<p>Setting <code>constrain_orientation</code> to a numeric (e.g.
<code>constrain_orientation = pi/2</code>) will force the orientation of the
Gaussian to the specified value. Note that this is handled differently by
<code>method = "elliptical"</code> vs <code>method = "elliptical_log"</code>. In
<code>method = "elliptical"</code>, the theta parameter dictates the rotation, in
radians, from the x-axis in the clockwise direction. In contrast, the
<code>method = "elliptical_log"</code> procedure uses a Q parameter to determine
the orientation of the 2D-Gaussian. Setting <code>constrain_orientation =
  0</code> will result in a diagonally-oriented Gaussian, whereas setting
<code>constrain_orientation = -1</code> will result in horizontal orientation.
See Priebe et al. 2003 for more details.
</p>
<p>The <code>user_init</code> argument can also be used to supply a vector of
initial values for the A, Q, X_peak, Y_peak, X_var, and Y_var parameters.
If the user chooses to make use of <code>user_init</code>, then a vector
containing all parameters must be supplied in a particular order.
</p>
<p>Additional arguments to the <code>control</code> argument in <code>stats::nls()</code>
can be supplied via <code>...</code>.
</p>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li>
<p>"coefs" A data.frame of fitted model parameters.
</p>
</li>
<li>
<p>"model" The model object, fitted by <code>stats::nls()</code>.
</p>
</li>
<li>
<p>"model_error_stats" A data.frame detailing the rss, rmse, deviance,
and AIC of the fitted model.
</p>
</li>
<li>
<p>"fit_method" A character vector that indicates which method and
orientation strategy was used by this function.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>References</h3>

<p>Priebe NJ, Cassanello CR, Lisberger SG. The neural representation
of speed in macaque area MT/V5. J Neurosci. 2003 Jul 2;23(13):5650-61. doi:
10.1523/JNEUROSCI.23-13-05650.2003.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (interactive()) {
  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]


  #### Example 1: Unconstrained elliptical ####
  ## This fits an unconstrained elliptical by default
  gauss_fit &lt;-
    fit_gaussian_2D(samp_dat)

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  library(ggplot2); library(metR)
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)


  #### Example 2: Constrained elliptical_log ####
  ## This fits a constrained elliptical, as in Priebe et al. 2003
  gauss_fit &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_orientation = -1
    )

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)
}
</code></pre>


</div>