<div class="container">

<table style="width: 100%;"><tr>
<td>cut_interval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Discretise numeric data into categorical</h2>

<h3>Description</h3>

<p><code>cut_interval()</code> makes <code>n</code> groups with equal range, <code>cut_number()</code>
makes <code>n</code> groups with (approximately) equal numbers of observations;
<code>cut_width()</code> makes groups of width <code>width</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cut_interval(x, n = NULL, length = NULL, ...)

cut_number(x, n = NULL, ...)

cut_width(x, width, center = NULL, boundary = NULL, closed = "right", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of intervals to create, OR</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>length of each interval</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>base::cut.default</code>
</p>

<dl>
<dt><code>breaks</code></dt>
<dd>
<p>either a numeric vector of two or more unique cut points or a
single number (greater than or equal to 2) giving the number of
intervals into which <code>x</code> is to be cut.</p>
</dd>
<dt><code>labels</code></dt>
<dd>
<p>labels for the levels of the resulting category.  By default,
labels are constructed using <code>"(a,b]"</code> interval notation.  If
<code>labels = FALSE</code>, simple integer codes are returned instead of
a factor.</p>
</dd>
<dt><code>right</code></dt>
<dd>
<p>logical, indicating if the intervals should be closed on
the right (and open on the left) or vice versa.</p>
</dd>
<dt><code>dig.lab</code></dt>
<dd>
<p>integer which is used when labels are not given.  It
determines the number of digits used in formatting the break numbers.</p>
</dd>
<dt><code>ordered_result</code></dt>
<dd>
<p>logical: should the result be an ordered factor?</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>The bin width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center, boundary</code></td>
<td>
<p>Specify either the position of edge or the center of
a bin. Since all bins are aligned, specifying the position of a single bin
(which doesn't need to be in the range of the data) affects the location of
all bins. If not specified, uses the "tile layers algorithm", and sets
the boundary to half of the binwidth.
</p>
<p>To center on integers, <code>width = 1</code> and <code>center = 0</code>.
<code>boundary = 0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Randall Prium contributed most of the implementation of
<code>cut_width()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">table(cut_interval(1:100, 10))
table(cut_interval(1:100, 11))

set.seed(1)

table(cut_number(runif(1000), 10))

table(cut_width(runif(1000), 0.1))
table(cut_width(runif(1000), 0.1, boundary = 0))
table(cut_width(runif(1000), 0.1, center = 0))
table(cut_width(runif(1000), 0.1, labels = FALSE))
</code></pre>


</div>