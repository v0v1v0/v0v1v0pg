<div class="container">

<table style="width: 100%;"><tr>
<td>gBridge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a group bridge regression path</h2>

<h3>Description</h3>

<p>Fit regularization paths for linear and logistic group bridge-penalized
regression models over a grid of values for the regularization parameter
lambda.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gBridge(
  X,
  y,
  group = 1:ncol(X),
  family = c("gaussian", "binomial", "poisson"),
  nlambda = 100,
  lambda,
  lambda.min = {
     if (nrow(X) &gt; ncol(X)) 
         0.001
     else 0.05
 },
  lambda.max,
  alpha = 1,
  eps = 0.001,
  delta = 1e-07,
  max.iter = 10000,
  gamma = 0.5,
  group.multiplier,
  warn = TRUE,
  returnX = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The design matrix, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response vector (or matrix), as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The grouping vector, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Either "gaussian" or "binomial", depending on the response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied sequence of <code style="white-space: pre;">⁠lambda values, as in ⁠</code>grpreg()'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>The smallest value for <code>lambda</code>, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.max</code></td>
<td>
<p>The maximum value for <code>lambda</code>.  Unlike the penalties
in <code>grpreg</code>, it is not possible to solve for <code>lambda.max</code> directly
with group bridge models.  Thus, it must be specified by the user.  If it is
not specified, <code>gBridge</code> will attempt to guess <code>lambda.max</code>, but
this is not particularly accurate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Tuning parameter for the balance between the group penalty and
the L2 penalty, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence threshhold, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The group bridge penalty is not differentiable at zero, and
requires a small number <code>delta</code> to bound it away from zero.  There is
typically no need to change this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Maximum number of iterations, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Tuning parameter of the group bridge penalty (the exponent to
which the L1 norm of the coefficients in the group are raised).  Default is
0.5, the square root.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group.multiplier</code></td>
<td>
<p>The multiplicative factor by which each group's
penalty is to be multiplied, as in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>Should the function give a warning if it fails to converge?  As
in <code>grpreg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnX</code></td>
<td>
<p>Return the standardized design matrix (and associated group
structure information)?  Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method fits the group bridge method of Huang et al. (2009).  Unlike the
penalties in <code>grpreg</code>, the group bridge is not differentiable at zero;
because of this, a number of changes must be made to the algorithm, which is
why it has its own function.  Most notably, the method is unable to start at
<code>lambda.max</code>; it must start at <code>lambda.min</code> and proceed in the
opposite direction.
</p>
<p>In other respects, the usage and behavior of the function is similar to the
rest of the <code>grpreg</code> package.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"grpreg"</code>, as in <code>grpreg</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p> Huang J, Ma S, Xie H, and Zhang C. (2009) A group bridge approach for
variable selection. <em>Biometrika</em>, <strong>96</strong>: 339-355. <a href="https://doi.org/10.1093/biomet/asp020">doi:10.1093/biomet/asp020</a>
</p>
</li>
<li>
<p> Breheny P and Huang J. (2009) Penalized methods for bi-level variable
selection. <em>Statistics and its interface</em>, <strong>2</strong>: 369-380.
<a href="https://doi.org/10.4310/sii.2009.v2.n3.a10">doi:10.4310/sii.2009.v2.n3.a10</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>grpreg()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Birthwt)
X &lt;- Birthwt$X
group &lt;- Birthwt$group

## Linear regression
y &lt;- Birthwt$bwt
fit &lt;- gBridge(X, y, group, lambda.max=0.08)
plot(fit)
select(fit)$beta

## Logistic regression
y &lt;- Birthwt$low
fit &lt;- gBridge(X, y, group, family="binomial", lambda.max=0.17)
plot(fit)
select(fit)$beta
</code></pre>


</div>