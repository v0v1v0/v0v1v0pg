<div class="container">

<table style="width: 100%;"><tr>
<td>predict.cv.glmnet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>make predictions from a "cv.glmnet" object.</h2>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated glmnet model, using
the stored <code>"glmnet.fit"</code> object, and the optimal value chosen for
<code>lambda</code> (and <code>gamma</code> for a 'relaxed' fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cv.glmnet'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)

## S3 method for class 'cv.relaxed'
predict(
  object,
  newx,
  s = c("lambda.1se", "lambda.min"),
  gamma = c("gamma.1se", "gamma.min"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Fitted <code>"cv.glmnet"</code> or <code>"cv.relaxed"</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newx</code></td>
<td>
<p>Matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix; can be sparse as in <code>Matrix</code> package. See
documentation for <code>predict.glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV <code>object</code>. Alternatively <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used. (For historical reasons we use the symbol 's' rather than 'lambda' to
reference this parameter)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Value (single) of 'gamma' at which predictions are to be made</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation to make
a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends on the ... argument which is passed
on to the <code>predict</code> method for <code>glmnet</code> objects.
</p>


<h3>Author(s)</h3>

<p>Jerome Friedman, Trevor Hastie and Rob Tibshirani<br> Maintainer:
Trevor Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008)
<em>Regularization Paths for Generalized Linear Models via Coordinate
Descent (2010), Journal of Statistical Software, Vol. 33(1), 1-22</em>,
<a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>.<br>
Simon, N., Friedman, J., Hastie, T. and Tibshirani, R. (2011)
<em>Regularization Paths for Cox's Proportional
Hazards Model via Coordinate Descent, Journal of Statistical Software, Vol.
39(5), 1-13</em>,
<a href="https://doi.org/10.18637/jss.v039.i05">doi:10.18637/jss.v039.i05</a>.<br>
Hastie, T., Tibshirani, Robert and Tibshirani, Ryan (2020) <em>Best Subset,
Forward Stepwise or Lasso? Analysis and Recommendations Based on Extensive Comparisons,
Statist. Sc. Vol. 35(4), 579-592</em>,
<a href="https://arxiv.org/abs/1707.08692">https://arxiv.org/abs/1707.08692</a>.<br>
Glmnet webpage with four vignettes, <a href="https://glmnet.stanford.edu">https://glmnet.stanford.edu</a>.
</p>


<h3>See Also</h3>

<p><code>glmnet</code>, and <code>print</code>, and <code>coef</code> methods, and
<code>cv.glmnet</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x = matrix(rnorm(100 * 20), 100, 20)
y = rnorm(100)
cv.fit = cv.glmnet(x, y)
predict(cv.fit, newx = x[1:5, ])
coef(cv.fit)
coef(cv.fit, s = "lambda.min")
predict(cv.fit, newx = x[1:5, ], s = c(0.001, 0.002))
cv.fitr = cv.glmnet(x, y, relax = TRUE)
predict(cv.fit, newx = x[1:5, ])
coef(cv.fit)
coef(cv.fit, s = "lambda.min", gamma = "gamma.min")
predict(cv.fit, newx = x[1:5, ], s = c(0.001, 0.002), gamma = "gamma.min")

</code></pre>


</div>