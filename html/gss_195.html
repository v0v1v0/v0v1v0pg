<div class="container">

<table style="width: 100%;"><tr>
<td>sscden</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating Conditional Probability Density Using Smoothing
Splines</h2>

<h3>Description</h3>

<p>Estimate conditional probability densities using smoothing spline
ANOVA models.  The symbolic model specification via <code>formula</code>
follows the same rules as in <code>lm</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sscden(formula, response, type=NULL, data=list(), weights, subset,
       na.action=na.omit, alpha=1.4, id.basis=NULL, nbasis=NULL,
       seed=NULL, ydomain=as.list(NULL), yquad=NULL, prec=1e-7,
       maxiter=30, skip.iter=FALSE)

sscden1(formula, response, type=NULL, data=list(), weights, subset,
        na.action=na.omit, alpha=1.4, id.basis=NULL, nbasis=NULL,
        seed=NULL, rho=list("xy"), ydomain=as.list(NULL), yquad=NULL,
        prec=1e-7, maxiter=30, skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>Formula listing response variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code>mkterm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional vector of counts for duplicated data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter defining cross-validation scores for
smoothing parameter selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.basis</code></td>
<td>
<p>Index of observations to be used as "knots."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p>Number of "knots" to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed to be used for the random generation of "knots."
Ignored when <code>id.basis</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ydomain</code></td>
<td>
<p>Data frame specifying marginal support of conditional
density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yquad</code></td>
<td>
<p>Quadrature for calculating integral on Y domain.
Mandatory if response variables other than factors or numerical
vectors are involved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code>ssanova</code> for
notes on skipping theta iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>rho function needed for sscden1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model is specified via <code>formula</code> and <code>response</code>, where
<code>response</code> lists the response variables.  For example,
<code>sscden(~y*x,~y)</code> prescribe a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
        log f(y|x) = g_{y}(y) + g_{xy}(x,y) + C(x)
    </code>
</p>

<p>with the terms denoted by <code>"y"</code>, <code>"y:x"</code>; the term(s) not
involving response(s) are removed and the constant <code>C(x)</code> is
determined by the fact that a conditional density integrates to one
on the <code>y</code> axis.  <code>sscden1</code> does keep terms not involving
response(s) during estimation, although those terms cancel out when
one evaluates the estimated conditional density.    
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>A subset of the observations are selected as "knots."  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
"knots" <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>sscden</code> returns a list object of class <code>"sscden"</code>.
<code>sscden1</code> returns a list object of class
<code>c("sscden1","sscden")</code>.
</p>
<p><code>dsscden</code> and <code>cdsscden</code> can be used to
evaluate the estimated conditional density <code class="reqn">f(y|x)</code> and
<code class="reqn">f(y1|x,y2)</code>; <code>psscden</code>, <code>qsscden</code>,
<code>cpsscden</code>, and <code>cqsscden</code> can be used to
evaluate conditional cdf and quantiles.  The methods
<code>project.sscden</code> or <code>project.sscden1</code> can
be used to calculate the Kullback-Leibler or square-error
projections for model selection.
</p>


<h3>Note</h3>

<p>Default quadrature on the Y domain will be constructed for numerical
vectors on a hyper cube, then outer product with factor levels will
be taken if factors are involved.  The sides of the hyper cube are
specified by <code>ydomain</code>; for <code>ydomain$y</code> missing, the default
is <code>c(min(y),max(y))+c(-1,1)*(max(y)-mimn(y))*.05</code>.
</p>
<p>On a 1-D interval, the quadrature is the 200-point Gauss-Legendre
formula returned from <code>gauss.quad</code>.  For multiple
numerical vectors, delayed Smolyak cubatures from
<code>smolyak.quad</code> are used on cubes with the marginals
properly transformed; see Gu and Wang (2003) for the marginal
transformations.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>
<p>For reasonable execution time in high dimensions, set
<code>skip.iter=TRUE</code>.
</p>


<h3>References</h3>

<p>Gu, C. (1995), Smoothing spline density estimation: Conditional
distribution.  <em>Statistica Sinica</em>, <b>5</b>, 709â€“726.
Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(penny); set.seed(5732)
fit &lt;- sscden1(~year*mil,~mil,data=penny,
              ydomain=data.frame(mil=c(49,61)))
yy &lt;- 1944+(0:92)/2
quan &lt;- qsscden(fit,c(.05,.25,.5,.75,.95),
                data.frame(year=yy))
plot(penny$year+.1*rnorm(90),penny$mil,ylim=c(49,61))
for (i in 1:5) lines(yy,quan[i,])
## Clean up
## Not run: rm(penny,yy,quan)
</code></pre>


</div>