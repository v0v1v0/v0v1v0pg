<div class="container">

<table style="width: 100%;"><tr>
<td>gs_design_npe</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Group sequential design computation with non-constant effect and information</h2>

<h3>Description</h3>

<p>Derives group sequential design size,
bounds and boundary crossing probabilities based on proportionate
information and effect size at analyses.
It allows a non-constant treatment effect over time,
but also can be applied for the usual homogeneous effect size designs.
It requires treatment effect and proportionate statistical information
at each analysis as well as a method of deriving bounds, such as spending.
The routine enables two things not available in the gsDesign package:
</p>

<ol>
<li>
<p> non-constant effect, 2) more flexibility in boundary selection.
For many applications, the non-proportional-hazards design function
<code>gs_design_nph()</code> will be used; it calls this function.
Initial bound types supported are 1) spending bounds,
</p>
</li>
<li>
<p> fixed bounds, and 3) Haybittle-Peto-like bounds.
The requirement is to have a boundary update method that
can each bound without knowledge of future bounds.
As an example, bounds based on conditional power that
require knowledge of all future bounds are not supported by this routine;
a more limited conditional power method will be demonstrated.
Boundary family designs Wang-Tsiatis designs including
the original (non-spending-function-based) O'Brien-Fleming and Pocock designs
are not supported by <code>gs_power_npe()</code>.
</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">gs_design_npe(
  theta = 0.1,
  theta0 = NULL,
  theta1 = NULL,
  info = 1,
  info0 = NULL,
  info1 = NULL,
  info_scale = c("h0_h1_info", "h0_info", "h1_info"),
  alpha = 0.025,
  beta = 0.1,
  upper = gs_b,
  upar = qnorm(0.975),
  lower = gs_b,
  lpar = -Inf,
  test_upper = TRUE,
  test_lower = TRUE,
  binding = FALSE,
  r = 18,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Natural parameter for group sequential design
representing expected incremental drift at all analyses;
used for power calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta0</code></td>
<td>
<p>Natural parameter used for upper bound spending;
if <code>NULL</code>, this will be set to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta1</code></td>
<td>
<p>Natural parameter used for lower bound spending;
if <code>NULL</code>, this will be set to <code>theta</code>
which yields the usual beta-spending.
If set to 0, spending is 2-sided under null hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>Proportionate statistical information at
all analyses for input <code>theta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info0</code></td>
<td>
<p>Proportionate statistical information
under null hypothesis, if different than alternative;
impacts null hypothesis bound calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info1</code></td>
<td>
<p>Proportionate statistical information
under alternate hypothesis;
impacts null hypothesis bound calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info_scale</code></td>
<td>
<p>Information scale for calculation. Options are:
</p>

<ul>
<li> <p><code>"h0_h1_info"</code> (default): variance under both null and alternative hypotheses is used.
</p>
</li>
<li> <p><code>"h0_info"</code>: variance under null hypothesis is used.
</p>
</li>
<li> <p><code>"h1_info"</code>: variance under alternative hypothesis is used.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>One-sided Type I error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Type II error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>Function to compute upper bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upar</code></td>
<td>
<p>Parameters passed to the function provided in <code>upper</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Function to compare lower bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpar</code></td>
<td>
<p>Parameters passed to the function provided in <code>lower</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test_upper</code></td>
<td>
<p>Indicator of which analyses should include
an upper (efficacy) bound; single value of <code>TRUE</code> (default) indicates
all analyses; otherwise, a logical vector of the same length as <code>info</code>
should indicate which analyses will have an efficacy bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test_lower</code></td>
<td>
<p>Indicator of which analyses should include an lower bound;
single value of <code>TRUE</code> (default) indicates all analyses;
single value <code>FALSE</code> indicates no lower bound; otherwise,
a logical vector of the same length as <code>info</code> should indicate which
analyses will have a lower bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binding</code></td>
<td>
<p>Indicator of whether futility bound is binding;
default of <code>FALSE</code> is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer value controlling grid for numerical integration
as in Jennison and Turnbull (2000); default is 18, range is 1 to 80.
Larger values provide larger number of grid points and greater accuracy.
Normally <code>r</code> will not be changed by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance parameter for boundary convergence (on Z-scale).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The inputs <code>info</code> and <code>info0</code> should be
vectors of the same length with increasing positive numbers.
The design returned will change these by some constant scale
factor to ensure the design has power <code>1 - beta</code>.
The bound specifications in <code>upper</code>, <code>lower</code>, <code>upar</code>, <code>lpar</code>
will be used to ensure Type I error and other boundary properties are as specified.
</p>


<h3>Value</h3>

<p>A tibble with columns analysis, bound, z, probability, theta, info, info0.
</p>


<h3>Specification</h3>


<p>The contents of this section are shown in PDF user manual only.
</p>


<h3>Author(s)</h3>

<p>Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)
library(gsDesign)

# Example 1 ----
# Single analysis
# Lachin book p 71 difference of proportions example
pc &lt;- .28 # Control response rate
pe &lt;- .40 # Experimental response rate
p0 &lt;- (pc + pe) / 2 # Ave response rate under H0

# Information per increment of 1 in sample size
info0 &lt;- 1 / (p0 * (1 - p0) * 4)
info &lt;- 1 / (pc * (1 - pc) * 2 + pe * (1 - pe) * 2)

# Result should round up to next even number = 652
# Divide information needed under H1 by information per patient added
gs_design_npe(theta = pe - pc, info = info, info0 = info0)


# Example 2 ----
# Fixed bound
x &lt;- gs_design_npe(
  alpha = 0.0125,
  theta = c(.1, .2, .3),
  info = (1:3) * 80,
  info0 = (1:3) * 80,
  upper = gs_b,
  upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF, alpha = 0.0125)$upper$bound,
  lower = gs_b,
  lpar = c(-1, 0, 0)
)
x

# Same upper bound; this represents non-binding Type I error and will total 0.025
gs_power_npe(
  theta = rep(0, 3),
  info = (x %&gt;% filter(bound == "upper"))$info,
  upper = gs_b,
  upar = (x %&gt;% filter(bound == "upper"))$z,
  lower = gs_b,
  lpar = rep(-Inf, 3)
)

# Example 3 ----
# Spending bound examples
# Design with futility only at analysis 1; efficacy only at analyses 2, 3
# Spending bound for efficacy; fixed bound for futility
# NOTE: test_upper and test_lower DO NOT WORK with gs_b; must explicitly make bounds infinite
# test_upper and test_lower DO WORK with gs_spending_bound
gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  info0 = (1:3) * 40,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_b,
  lpar = c(-1, -Inf, -Inf),
  test_upper = c(FALSE, TRUE, TRUE)
)

# one can try `info_scale = "h1_info"` or `info_scale = "h0_info"` here
gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  info0 = (1:3) * 30,
  info_scale = "h1_info",
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_b,
  lpar = c(-1, -Inf, -Inf),
  test_upper = c(FALSE, TRUE, TRUE)
)

# Example 4 ----
# Spending function bounds
# 2-sided asymmetric bounds
# Lower spending based on non-zero effect
gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  info0 = (1:3) * 30,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)
)

# Example 5 ----
# Two-sided symmetric spend, O'Brien-Fleming spending
# Typically, 2-sided bounds are binding
xx &lt;- gs_design_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  binding = TRUE,
  upper = gs_spending_bound,
  upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),
  lower = gs_spending_bound,
  lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)
)
xx

# Re-use these bounds under alternate hypothesis
# Always use binding = TRUE for power calculations
gs_power_npe(
  theta = c(.1, .2, .3),
  info = (1:3) * 40,
  binding = TRUE,
  upper = gs_b,
  lower = gs_b,
  upar = (xx %&gt;% filter(bound == "upper"))$z,
  lpar = -(xx %&gt;% filter(bound == "upper"))$z
)
</code></pre>


</div>