<div class="container">

<table style="width: 100%;"><tr>
<td>graph_modul_compar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compare the partition into modules of two graphs</h2>

<h3>Description</h3>

<p>The function computes the Adjusted Rand Index (ARI) to
compare two graphs' partitions into modules or clusters more generally.
Both graphs must have the same number of nodes, but not necessarily the same
number of links. They must also have the same node names and in the
same order.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graph_modul_compar(
  x,
  y,
  mode = "graph",
  nb_modul = NULL,
  algo = "fast_greedy",
  node_inter = "distance",
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The first graph object
</p>

<ul>
<li>
<p>If <code>mode = 'graph'</code> (default), <code>x</code> is a graph object of
class <code>igraph</code>.
Then, its nodes must have the same names as in graph <code>y</code>.
</p>
</li>
<li>
<p>If <code>mode = 'data.frame'</code>, <code>x</code> refers to a column of
the <code>data.frame</code> 'data'.
Then <code>x</code> must be a character string indicating the name of the
column of 'data' with the modules' labels of the nodes in the first graph.
In that case, the column can be of class <code>numeric</code>, <code>character</code>
or <code>factor</code> but will be converted into a <code>numeric</code> vector
in any case.
</p>
</li>
<li>
<p>If <code>mode = 'vector'</code>, <code>x</code> is a vector of
class <code>character</code>, <code>factor</code> or <code>numeric</code>.
In that case, it must have the same length as vector <code>y</code> and
will be converted into a <code>numeric</code> vector.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The second graph object
Same classes possible as for <code>x</code>. Must be of the same format as <code>x</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>A character string indicating whether x and y are igraph objects,
vectors or columns from a data.frame. <code>mode</code> can be 'graph',
'data.frame' or 'vector'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb_modul</code></td>
<td>
<p>(if x and y are igraph objects) A numeric or integer value
or a numeric vector with 2 elements indicating the number of modules to
create in both graphs.
</p>

<ul>
<li>
<p>If <code>nb_modul</code> is a numeric value, then the same number of modules
are created in both graphs.
</p>
</li>
<li>
<p>If <code>nb_modul</code> is a numeric vector of length 2, then the
numbers of modules created in graphs <code>x</code> and <code>y</code> are the
first and second elements of <code>nb_modul</code>, respectively.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>(if x and y are igraph objects) A character string indicating the
algorithm used to create the modules with <span class="pkg">igraph</span>.
</p>

<ul>
<li>
<p>If <code>algo = 'fast_greedy'</code> (default),
function <code>cluster_fast_greedy</code>
from <span class="pkg">igraph</span> is used (Clauset et al., 2004).
</p>
</li>
<li>
<p>If <code>algo = 'walktrap'</code> (default), function <code>cluster_walktrap</code>
from <span class="pkg">igraph</span> is used (Pons et Latapy, 2006) with
4 steps (default options).
</p>
</li>
<li>
<p>If <code>algo = 'louvain'</code>, function <code>cluster_louvain</code>
from <span class="pkg">igraph</span> is used (Blondel et al., 2008).
In that case, the number of modules created in each graph is imposed.
</p>
</li>
<li>
<p>If <code>algo = 'optimal'</code>, function <code>cluster_optimal</code>
from <span class="pkg">igraph</span> is used (Brandes et al., 2008) (can be very long).
In that case, the number of modules created in each graph is imposed.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node_inter</code></td>
<td>
<p>(optional, if x and y are igraph objects,
default is 'none') A character string indicating whether the links of the
graph are weighted by distances or by similarity indices. It is only used
to compute the modularity index. It can be: </p>

<ul>
<li>
<p>'distance': Link weights correspond to distances. Nodes that are close
to each other will more likely be in the same module.
</p>
</li>
<li>
<p>'similarity': Link weights correspond to similarity indices. Nodes that
are similar to each other will more likely be in the same module. Inverse
link weights are then used to compute the modularity index.
</p>
</li>
<li>
<p>'none': Links are not weighted for the computation, which is only
based on graph topology.
</p>
</li>
</ul>
<p>Two different weightings can be used to create the modules of the two graphs.
</p>

<ul>
<li>
<p>If <code>node_inter</code> is a character string, then the same link
weighting is used for both graphs.
</p>
</li>
<li>
<p>If <code>node_inter</code> is a character vector of length 2, then
the link weighting used by the algorithm to create the modules of
graphs <code>x</code> and <code>y</code> is determined by the first and second elements
of <code>node_inter</code>, respectively.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>(if x and y are columns from a data.frame) An object of class
data.frame with at least two columns and as many rows as there are nodes
in the graphs compared. The columns indicate the modules of each node in
2 different classifications.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This index takes values between -1 and 1. It measures how often
pairs of nodes pertaining to the same module in one graph also pertain to
the same module in the other graph.
Therefore, large values indicate that both partitions are similar.
The Rand Index can be defined as the frequency of agreement between two
classifications into discrete classes. It is the number of times a pair of
elements are classified into the same class or in two different classes
in both compared classifications, divided by the total number of possible
pairs of elements. The Rand Index is between 0 and 1 but its maximum value
depends on the number of elements. Thus, another 'adjusted' index was
created, the Adjusted Rand Index. According to the Hubert et
Arabie's formula, the ARI is computed as follows:
<code class="reqn">ARI=\frac{Index - Expected index}{Maximum index - Expected index}</code>
where the values of Index, Expected index and Maximum index are computed
from a contingency table.
This function uses <code>adjustedRandIndex</code> from package <span class="pkg">mclust</span> which
applies the Hubert and Arabie's formula for the ARI.
This function works for undirected graphs only.
</p>


<h3>Value</h3>

<p>The value of the ARI
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Dyer RJ, Nason JD (2004).
“Population graphs: the graph theoretic shape of genetic structure.”
<em>Molecular ecology</em>, <b>13</b>(7), 1713–1727.
Hubert L, Arabie P (1985).
“Comparing partitions.”
<em>Journal of classification</em>, <b>2</b>(1), 193–218.
Clauset A, Newman ME, Moore C (2004).
“Finding community structure in very large networks.”
<em>Physical review E</em>, <b>70</b>(6).
Blondel VD, Guillaume J, Lambiotte R, Lefebvre E (2008).
“Fast unfolding of communities in large networks.”
<em>Journal of Statistical Mechanics - Theory and Experiment</em>, <b>10</b>.
Brandes U, Delling D, Gaertler M, Gorke R, Hoefer M, Nikoloski Z, Wagner D (2008).
“On modularity clustering.”
<em>IEEE transactions on knowledge and data engineering</em>, <b>20</b>(2), 172–188.
Pons P, Latapy M (2006).
“Computing communities in large networks using random walks.”
<em>J. Graph Algorithms Appl.</em>, <b>10</b>(2), 191–218.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(data_ex_genind)
data(pts_pop_ex)
mat_dist &lt;- suppressWarnings(graph4lg::mat_geo_dist(data=pts_pop_ex,
      ID = "ID",
      x = "x",
      y = "y"))
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                      order(as.character(colnames(mat_dist)))]
graph_obs &lt;- gen_graph_thr(mat_w = mat_dist, mat_thr = mat_dist,
                            thr = 24000, mode = "larger")
mat_gen &lt;- mat_gen_dist(x = data_ex_genind, dist = "DPS")
graph_pred &lt;- gen_graph_topo(mat_w = mat_gen, mat_topo = mat_dist,
                            topo = "gabriel")
ARI &lt;- graph_modul_compar(x = graph_obs, y = graph_pred)
</code></pre>


</div>