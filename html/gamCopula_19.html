<div class="container">

<table style="width: 100%;"><tr>
<td>gamBiCopPredict</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict method of a Generalized Additive model for the copula parameter
or Kendall's tau</h2>

<h3>Description</h3>

<p>Predict method of a Generalized Additive model for the copula parameter
or Kendall's tau
</p>


<h3>Usage</h3>

<pre><code class="language-R">gamBiCopPredict(
  object,
  newdata = NULL,
  target = "calib",
  alpha = 0,
  type = "link"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>gamBiCop-class</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>(Same as in <code>predict.gam</code> from the
<code>mgcv</code> package) A matrix or data frame
containing the values of the model covariates at which predictions are
required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then it should contain all
the variables needed for prediction: a warning is generated if not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>Either <code>'calib'</code>, <code>'par'</code> or <code>'tau'</code> or a
combination of those. <code>'calib'</code> (default) corresponds to the calibration
function, <code>'par'</code> to the copula parameter and
<code>'tau'</code> to Kendall's tau.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>In (0,1) to return the corresponding confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>(Similar as in <code>predict.gam</code> from the
<code>mgcv</code> package, only active for
<code>type = 'calib'</code>). When this has the value <code>'link'</code> (default), the
calibration function is returned.  When <code>type = 'terms'</code> each component
of the linear predictor is returned separately (possibly with standard
errors): this includes parametric model components, followed by each smooth
component, but excludes any offset and any intercept. When
<code>type = 'lpmatrix'</code> then a matrix is returned which yields the values of
the linear predictor (minus any offset) when post-multiplied by the parameter
vector (in this case alpha is ignored).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>target = 'calib'</code>, then a list with 1 item <code>calib</code>.
If <code>target = 'par'</code>, <code>target = 'tau'</code> or
<code>target = c('par', 'tau')</code>,
then a list with 2, 2 or 3 items, namely <code>calib</code> and <code>par</code>,
<code>tau</code> and <code>par</code>, or  <code>calib</code>, <code>tau</code> and <code>par</code>.
</p>
<p>If <code>alpha</code> is in (0,1), then a additional items of the list are
<code>calib.CI</code> as well as e.g. <code>par.CI</code> and/or <code>tau.CI</code> depending
on the value of <code>target</code>.
</p>
<p>Otherwise, if <code>type = 'lpmatrix'</code> (only active for
<code>type = 'calib'</code>), then a matrix is returned which will give a vector of
linear predictor values (minus any offset) at the supplied covariate values,
when applied to the model coefficient vector (similar as
<code>predict.gam</code> from the <code>mgcv</code>).
</p>


<h3>See Also</h3>

<p><code>gamBiCop</code> and <code>gamBiCopFit</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(copula)
set.seed(0)

## Simulation parameters (sample size, correlation between covariates,
## Clayton copula family)
n &lt;- 5e2
rho &lt;- 0.5
fam &lt;- 1

## A calibration surface depending on three variables
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

## 3-dimensional matrix X of covariates
covariates.distr &lt;- mvdc(normalCopula(rho, dim = 3),
  c("unif"), list(list(min = 0, max = 1)),
  marginsIdentical = TRUE
)
X &lt;- rMvdc(n, covariates.distr)
colnames(X) &lt;- paste("x", 1:3, sep = "")

## U in [0,1]x[0,1] with copula parameter depending on X
U &lt;- condBiCopSim(fam, function(x1, x2, x3) {
  eta0 + sum(mapply(function(f, x)
    f(x), calib.surf, c(x1, x2, x3)))
}, X[, 1:3], par2 = 6, return.par = TRUE)

## Merge U and X
data &lt;- data.frame(U$data, X)
names(data) &lt;- c(paste("u", 1:2, sep = ""), paste("x", 1:3, sep = ""))

## Model fit with penalized cubic splines (via min GCV)
basis &lt;- c(3, 10, 10)
formula &lt;- ~ s(x1, k = basis[1], bs = "cr") +
  s(x2, k = basis[2], bs = "cr") +
  s(x3, k = basis[3], bs = "cr")
system.time(fit &lt;- gamBiCopFit(data, formula, fam))

## Extract the gamBiCop objects and show various methods
(res &lt;- fit$res)
EDF(res)
pred &lt;- gamBiCopPredict(fit$res, X, target = c("calib", "par", "tau"))
</code></pre>


</div>