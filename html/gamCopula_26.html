<div class="container">

<table style="width: 100%;"><tr>
<td>gamVineCopSelect</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sequential pair-copula selection and maximum penalized likelihood estimation
of a GAM-Vine model.</h2>

<h3>Description</h3>

<p>This function select the copula family and estimates the parameter(s) of a
Generalized Additive model
(GAM) Vine model, where GAMs for individual edges are specified either for
the copula parameter or Kendall's tau.
It solves the maximum penalized likelihood estimation for the copula families
supported in this package by reformulating each Newton-Raphson iteration as
a generalized ridge regression, which is solved using
the <code>mgcv</code> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gamVineCopSelect(
  data,
  Matrix,
  lin.covs = NULL,
  smooth.covs = NULL,
  simplified = FALSE,
  familyset = NA,
  rotations = TRUE,
  familycrit = "AIC",
  level = 0.05,
  trunclevel = NA,
  tau = TRUE,
  method = "FS",
  tol.rel = 0.001,
  n.iters = 10,
  parallel = FALSE,
  verbose = FALSE,
  select.once = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A matrix or data frame containing the data in [0,1]^d.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Matrix</code></td>
<td>
<p>Lower triangular <code>d x d</code> matrix that defines the R-vine
tree structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lin.covs</code></td>
<td>
<p>A matrix or data frame containing the parametric (i.e.,
linear) covariates (default: <code>lin.covs = NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.covs</code></td>
<td>
<p>A matrix or data frame containing the non-parametric
(i.e., smooth) covariates (default: <code>smooth.covs = NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplified</code></td>
<td>
<p>If <code>TRUE</code>, then a simplified vine is fitted (which is
possible only if there are exogenous covariates). If <code>FALSE</code> (default),
then a non-simplified vine is fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>familyset</code></td>
<td>
<p>An integer vector of pair-copula families to select from
(the independence copula MUST NOT be specified in this vector unless one
wants to fit an independence vine!). The vector has to include at least one
pair-copula family that allows for positive and one that allows for negative
dependence. Not listed copula families might be included to better handle
limit cases. If <code>familyset = NA</code> (default), selection among all
possible families is performed. Coding of pair-copula families:
<code>1</code> Gaussian, <code>2</code> Student t,
<code>3</code> Clayton, <code>4</code> Gumbel, <code>13</code> Survival Clayton,
<code>14</code> Survival Gumbel,  <code>23</code> Rotated (90 degrees) Clayton,
<code>24</code> Rotated (90 degrees) Gumbel,
<code>33</code> Rotated (270 degrees) Clayton and
<code>34</code> Rotated (270 degrees) Gumbel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in familyset
are included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>familycrit</code></td>
<td>
<p>Character indicating the criterion for bivariate copula
selection. Possible choices: <code>familycrit = 'AIC'</code> (default) or
<code>'BIC'</code>, as in <code>BiCopSelect</code> from the
<code>VineCopula</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>Numerical; Passed to <code>gamBiCopSelect</code>, it is the
significance level of the test for removing individual
predictors (default: <code>level = 0.05</code>) for each conditional pair-copula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trunclevel</code></td>
<td>
<p>Integer; level of truncation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p><code>TRUE</code> (default) for a calibration function specified for
Kendall's tau or <code>FALSE</code> for a calibration function specified
for the Copula parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p><code>'NR'</code> for Newton-Raphson
and  <code>'FS'</code> for Fisher-scoring (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol.rel</code></td>
<td>
<p>Relative tolerance for <code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iters</code></td>
<td>
<p>Maximal number of iterations for
<code>'FS'</code>/<code>'NR'</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p><code>TRUE</code> (default) for parallel selection of copula
family at each edge or <code>FALSE</code> for the sequential version.
for the Copula parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> if informations should be printed during the
estimation and <code>FALSE</code> (default) for a silent version.
from <code>mgcv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select.once</code></td>
<td>
<p>if <code>TRUE</code> the GAM structure is only selected once,
for the family that appears first in <code>familyset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed to <code>gam</code>
from <code>mgcv</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>gamVineCopSelect</code> returns a <code>gamVine-class</code> object.
</p>


<h3>See Also</h3>

<p><code>gamVineSeqFit</code>,<code>gamVineStructureSelect</code>,
<code>gamVine-class</code>, <code>gamVineSimulate</code> and
<code>gamBiCopFit</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(mgcv)
set.seed(0)

##  Simulation parameters
# Sample size
n &lt;- 1e3
# Copula families
familyset &lt;- c(1:2, 301:304, 401:404)
# Define a 4-dimensional R-vine tree structure matrix
d &lt;- 4
Matrix &lt;- c(2, 3, 4, 1, 0, 3, 4, 1, 0, 0, 4, 1, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, d, d)
nnames &lt;- paste("X", 1:d, sep = "")

## A function factory
eta0 &lt;- 1
calib.surf &lt;- list(
  calib.quad &lt;- function(t, Ti = 0, Tf = 1, b = 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- -(b / 3) * (Tf^2 - 3 * Tf * Tm + 3 * Tm^2)
    return(a + b * (t - Tm)^2)
  },
  calib.sin &lt;- function(t, Ti = 0, Tf = 1, b = 1, f = 1) {
    a &lt;- b * (1 - 2 * Tf * pi / (f * Tf * pi +
      cos(2 * f * pi * (Tf - Ti))
      - cos(2 * f * pi * Ti)))
    return((a + b) / 2 + (b - a) * sin(2 * f * pi * (t - Ti)) / 2)
  },
  calib.exp &lt;- function(t, Ti = 0, Tf = 1, b = 2, s = Tf / 8) {
    Tm &lt;- (Tf - Ti) / 2
    a &lt;- (b * s * sqrt(2 * pi) / Tf) * (pnorm(0, Tm, s) - pnorm(Tf, Tm, s))
    return(a + b * exp(-(t - Tm)^2 / (2 * s^2)))
  }
)

##  Create the model
# Define gam-vine model list
count &lt;- 1
model &lt;- vector(mode = "list", length = d * (d - 1) / 2)
sel &lt;- seq(d, d^2 - d, by = d)

# First tree
for (i in 1:(d - 1)) {
  # Select a copula family
  family &lt;- sample(familyset, 1)
  model[[count]]$family &lt;- family

  # Use the canonical link and a randomly generated parameter
  if (is.element(family, c(1, 2))) {
    model[[count]]$par &lt;- tanh(rnorm(1) / 2)
    if (family == 2) {
      model[[count]]$par2 &lt;- 2 + exp(rnorm(1))
    }
  } else {
    if (is.element(family, c(401:404))) {
      rr &lt;- rnorm(1)
      model[[count]]$par &lt;- sign(rr) * (1 + abs(rr))
    } else {
      model[[count]]$par &lt;- rnorm(1)
    }
    model[[count]]$par2 &lt;- 0
  }
  count &lt;- count + 1
}

# A dummy dataset
data &lt;- data.frame(u1 = runif(1e2), u2 = runif(1e2), matrix(runif(1e2 * d), 1e2, d))

# Trees 2 to (d-1)
for (j in 2:(d - 1)) {
  for (i in 1:(d - j)) {
    # Select a copula family
    family &lt;- sample(familyset, 1)

    # Select the conditiong set and create a model formula
    cond &lt;- nnames[sort(Matrix[(d - j + 2):d, i])]
    tmpform &lt;- paste("~", paste(paste("s(", cond, ", k=10, bs='cr')",
      sep = ""
    ), collapse = " + "))
    l &lt;- length(cond)
    temp &lt;- sample(3, l, replace = TRUE)

    # Spline approximation of the true function
    m &lt;- 1e2
    x &lt;- matrix(seq(0, 1, length.out = m), nrow = m, ncol = 1)
    if (l != 1) {
      tmp.fct &lt;- paste("function(x){eta0+",
        paste(sapply(1:l, function(x)
          paste("calib.surf[[", temp[x], "]](x[", x, "])",
            sep = ""
          )), collapse = "+"), "}",
        sep = ""
      )
      tmp.fct &lt;- eval(parse(text = tmp.fct))
      x &lt;- eval(parse(text = paste0("expand.grid(",
        paste0(rep("x", l), collapse = ","), ")",
        collapse = ""
      )))
      y &lt;- apply(x, 1, tmp.fct)
    } else {
      tmp.fct &lt;- function(x) eta0 + calib.surf[[temp]](x)
      colnames(x) &lt;- cond
      y &lt;- tmp.fct(x)
    }

    # Estimate the gam model
    form &lt;- as.formula(paste0("y", tmpform))
    dd &lt;- data.frame(y, x)
    names(dd) &lt;- c("y", cond)
    b &lt;- gam(form, data = dd)
    # plot(x[,1],(y-fitted(b))/y)

    # Create a dummy gamBiCop object
    tmp &lt;- gamBiCopFit(data = data, formula = form, family = 1, n.iters = 1)$res

    # Update the copula family and the model coefficients
    attr(tmp, "model")$coefficients &lt;- coefficients(b)
    attr(tmp, "model")$smooth &lt;- b$smooth
    attr(tmp, "family") &lt;- family
    if (family == 2) {
      attr(tmp, "par2") &lt;- 2 + exp(rnorm(1))
    }
    model[[count]] &lt;- tmp
    count &lt;- count + 1
  }
}

# Create the gamVineCopula object
GVC &lt;- gamVine(Matrix = Matrix, model = model, names = nnames)
print(GVC)
## Not run: 
## Simulate and fit the model
sim &lt;- gamVineSimulate(n, GVC)
fitGVC &lt;- gamVineSeqFit(sim, GVC, verbose = TRUE)
fitGVC2 &lt;- gamVineCopSelect(sim, Matrix, verbose = TRUE)

## Plot the results
par(mfrow = c(3, 4))
plot(GVC, ylim = c(-2.5, 2.5))

plot(fitGVC, ylim = c(-2.5, 2.5))

plot(fitGVC2, ylim = c(-2.5, 2.5))

## End(Not run)

</code></pre>


</div>