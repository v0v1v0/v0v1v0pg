<div class="container">

<table style="width: 100%;"><tr>
<td>surf.tri</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find surface triangles from tetrahedral mesh</h2>

<h3>Description</h3>

<p>Find surface triangles from tetrahedral mesh typically obtained
with <code>delaunayn</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">surf.tri(p, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>An <code>n</code>-by-<code>3</code> matrix. The rows of <code>p</code> represent
<code>n</code> points in <code>dim</code>-dimensional space.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>Matrix with 4 columns, interpreted as output of
<code>delaunayn</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>surf.tri</code> and <code>convhulln</code> serve a similar purpose in 3D,
but <code>surf.tri</code> also works for non-convex meshes obtained e.g. with
<code>distmeshnd</code>.  It also does not produce currently unavoidable
diagnostic output on the console as <code>convhulln</code> does at the Rterm
consoleâ€“i.e., <code>surf.tri</code> is silent.
</p>


<h3>Value</h3>

<p>An <code>m</code>-by-<code>3</code> index matrix of which each row defines a
triangle. The indices refer to the rows in <code>p</code>.
</p>


<h3>Note</h3>

<p><code>surf.tri</code> was based on Matlab code for mesh of Per-Olof Persson
(<a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>).
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>See Also</h3>

<p><code>tri.mesh</code>, <code>convhulln</code>,
<code>surf.tri</code>, <code>distmesh2d</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
# more extensive example of surf.tri

# url's of publically available data:
data1.url = "http://neuroimage.usc.edu/USCPhantom/mesh_data.bin"
data2.url = "http://neuroimage.usc.edu/USCPhantom/CT_PCS_trans.bin"

meshdata = R.matlab::readMat(url(data1.url))
elec = R.matlab::readMat(url(data2.url))$eeg.ct2pcs/1000
brain = meshdata$mesh.brain[,c(1,3,2)]
scalp = meshdata$mesh.scalp[,c(1,3,2)]
skull = meshdata$mesh.skull[,c(1,3,2)]
tbr = t(surf.tri(brain, delaunayn(brain)))
tsk = t(surf.tri(skull, delaunayn(skull)))
tsc = t(surf.tri(scalp, delaunayn(scalp)))
rgl::triangles3d(brain[tbr,1], brain[tbr,2], brain[tbr,3],col="gray")
rgl::triangles3d(skull[tsk,1], skull[tsk,2], skull[tsk,3],col="white", alpha=0.3)
rgl::triangles3d(scalp[tsc,1], scalp[tsc,2], scalp[tsc,3],col="#a53900", alpha=0.6)
rgl::view3d(-40,30,.4,zoom=.03)
lx = c(-.025,.025); ly = -c(.02,.02);
rgl::spheres3d(elec[,1],elec[,3],elec[,2],radius=.0025,col='gray')
rgl::spheres3d( lx, ly,.11,radius=.015,col="white")
rgl::spheres3d( lx, ly,.116,radius=.015*.7,col="brown")
rgl::spheres3d( lx, ly,.124,radius=.015*.25,col="black")

## End(Not run)

</code></pre>


</div>