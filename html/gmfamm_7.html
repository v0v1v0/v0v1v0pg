<div class="container">

<table style="width: 100%;"><tr>
<td>gmfamm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Family object for bamlss for Generalized Multivariate Functional Additive
Mixed Models</h2>

<h3>Description</h3>

<p>Family object for bamlss for Generalized Multivariate Functional Additive
Mixed Models
</p>


<h3>Usage</h3>

<pre><code class="language-R">gmfamm(family, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Vector of bamlss family names to construct the full family.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used at the moment.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>family.bamlss</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Short example to see how a family can be specified.
gmfamm(family = c("binomial", "poisson", "gaussian"))

# Long example to see how an analysis can be done.

library(tidyverse)
library(registr)
library(funData)
library(MFPCA)
library(MJMbamlss)
library(refund)

# Take only three outcomes (normal, binary, poisson)
# Log-transformation of serBilir to get normal distribution
pbc &lt;- pbc_gmfamm %&gt;%
  filter(outcome %in% c("serBilir", "hepatomegaly", "platelets")) %&gt;%
  droplevels() %&gt;%
  mutate(y = case_when(outcome == "serBilir" ~ log(y),
                       outcome != "serBilir" ~ y),
         year = ifelse(year &gt; 9.99, 9.99, year))

pbc_list &lt;- split(pbc, pbc$outcome) %&gt;%
  lapply(function (dat) {
    dat &lt;- dat %&gt;%
      mutate(value = y, index = year) %&gt;%
      select(id, value, index) %&gt;%
      arrange(id, index)
  })

# Fit separate univariate GPFCAs
# Two numbers (x, y) in npc criterion indicate x% total variance but each pc
# hast to contribute at least y%
gfpcs &lt;- mapply(function (data, fams) {
  gfpca_twoStep(Y = data, family = fams, npc_criterion = c(0.99, 0.001),
                verbose = FALSE)
}, data = pbc_list, fams = list("binomial", "poisson", "gaussian"),
SIMPLIFY = FALSE)

# Convert fitted values to funData
mfdata &lt;- multiFunData(lapply(gfpcs, function (x) {
  funData(argvals = x$t_vec,
          X = matrix(x$Yhat$value, ncol = length(x$t_vec), byrow = TRUE))
}))

# Convert estimated eigenfunctions to funData
uniexpansions &lt;- lapply(gfpcs, function (x) {
  list(type = "given",
       functions =  funData(argvals = x$t_vec, X = t(x$efunctions)))
})

# Calculate the maximal number of MFPCs
m &lt;- sum(sapply(gfpcs, "[[", "npc"))

# Estimate the MFPCs with weights 1
mfpca &lt;- MFPCA(mFData = mfdata, M = m, uniExpansions = uniexpansions)

# Choose number of MFPCs based on threshold
nfpc &lt;- min(which(cumsum(mfpca$values) / sum(mfpca$values) &gt; 0.95))

# Attach estimated MFPCs
pbc &lt;- attach_wfpc(mfpca, pbc, n = nfpc, marker = "outcome", obstime = "year")

# Specify formula
f &lt;- list(
  gm(y, outcome) ~ year + drug + sex, # hepatomegaly
  mu2 ~ year, # platelets
  mu3 ~ year + age, # serBilir
  sigma3 ~ 1, # serBilir sd
  Lambda ~ -1 + s(id, fpc.1, bs = "pcre") +
    s(id, fpc.2, bs = "pcre") + s(id, fpc.3, bs = "pcre") +
    s(id, fpc.4, bs = "pcre")
)

b &lt;- bamlss(f,
            family = gmfamm(c("binomial", "poisson", "gaussian")),
            data = pbc)


</code></pre>


</div>