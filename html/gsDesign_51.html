<div class="container">

<table style="width: 100%;"><tr>
<td>gsBinomialExact</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>One-Sample Binomial Routines</h2>

<h3>Description</h3>

<p><code>gsBinomialExact</code> computes power/Type I error and expected sample size
for a group sequential design in a single-arm trial with a binary outcome.
This can also be used to compare event rates in two-arm studies. The print
function has been extended using <code>print.gsBinomialExact</code> to print
<code>gsBinomialExact</code> objects. Similarly, a plot function has
been extended using <code>plot.gsBinomialExact</code> to plot
<code>gsBinomialExact</code> objects.
</p>
<p><code>binomialSPRT</code> computes a truncated binomial sequential probability
ratio test (SPRT) which is a specific instance of an exact binomial group
sequential design for a single arm trial with a binary outcome.
</p>
<p><code>gsBinomialPP</code> computes a truncated binomial (group) sequential design
based on predictive probability.
</p>
<p><code>nBinomial1Sample</code> uses exact binomial calculations to compute power
and sample size for single arm binomial experiments.
</p>
<p><code>gsBinomialExact</code> is based on the book "Group Sequential Methods with
Applications to Clinical Trials," Christopher Jennison and Bruce W.
Turnbull, Chapter 12, Section 12.1.2 Exact Calculations for Binary Data.
This computation is often used as an approximation for the distribution of
the number of events in one treatment group out of all events when the
probability of an event is small and sample size is large.
</p>
<p>An object of class <code>gsBinomialExact</code> is returned. On output, the values
of <code>theta</code> input to <code>gsBinomialExact</code> will be the parameter values
for which the boundary crossing probabilities and expected sample sizes are
computed.
</p>
<p>Note that a[1] equal to -1 lower bound at n.I[1] means 0 successes continues
at interim 1; a[2]==0 at interim 2 means 0 successes stops trial for
futility at 2nd analysis.  For final analysis, set a[k] equal to b[k]-1 to
incorporate all possibilities into non-positive trial; see example.
</p>
<p>The sequential probability ratio test (SPRT) is a sequential testing scheme
allowing testing after each observation. This likelihood ratio is used to
determine upper and lower cutoffs which are linear and parallel in the
number of responses as a function of sample size.  <code>binomialSPRT</code>
produces a variation the the SPRT that tests only within a range of sample
sizes. While the linear SPRT bounds are continuous, actual bounds are the
integer number of response at or beyond each linear bound for each sample
size where testing is performed. Because of the truncation and
discretization of the bounds, power and Type I error achieve will be lower
than the nominal levels specified by <code>alpha</code> and <code>beta</code> which can
be altered to produce desired values that are achieved by the planned sample
size. See also example that shows computation of Type I error when futility
bound is considered non-binding.
</p>
<p>Note that if the objective of a design is to demonstrate that a rate (e.g.,
failure rate) is lower than a certain level, two approaches can be taken.
First, 1 minus the failure rate is the success rate and this can be used for
planning. Second, the role of <code>beta</code> becomes to express Type I error
and <code>alpha</code> is used to express Type II error.
</p>
<p>Plots produced include boundary plots, expected sample size, response rate
at the boundary and power.
</p>
<p><code>gsBinomial1Sample</code> uses exact binomial computations based on the base
R functions <code>qbinom()</code> and <code>pbinom()</code>. The tabular output may be
convenient for plotting. Note that input variables are largely not checked,
so the user is largely responsible for results; it is a good idea to do a
run with <code>outtype=3</code> to check that you have done things appropriately.
If <code>n</code> is not ordered (a bad idea) or not sequential (maybe OK), be
aware of possible consequences.
</p>
<p><code>nBinomial1Sample</code> is based on code from Marc Schwartz <a href="mailto:marc_schwartz@me.com">marc_schwartz@me.com</a>. 
The possible sample size vector <code>n</code> needs to be selected in such a fashion
that it covers the possible range of values that include the true minimum. 
NOTE: the one-sided evaluation of significance is more conservative than using the 2-sided exact test in <code>binom.test</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gsBinomialExact(
  k = 2,
  theta = c(0.1, 0.2),
  n.I = c(50, 100),
  a = c(3, 7),
  b = c(20, 30)
)

binomialSPRT(
  p0 = 0.05,
  p1 = 0.25,
  alpha = 0.1,
  beta = 0.15,
  minn = 10,
  maxn = 35
)

## S3 method for class 'gsBinomialExact'
plot(x, plottype = 1, ...)

## S3 method for class 'binomialSPRT'
plot(x, plottype = 1, ...)

nBinomial1Sample(
  p0 = 0.9,
  p1 = 0.95,
  alpha = 0.025,
  beta = NULL,
  n = 200:250,
  outtype = 1,
  conservative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of analyses planned, including interim and final.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Vector of possible underling binomial probabilities for a
single binomial sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.I</code></td>
<td>
<p>Sample size at analyses (increasing positive integers); vector of
length k.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Number of "successes" required to cross lower bound cutoffs to
reject <code>p1</code> in favor of <code>p0</code> at each analysis; vector of length k;
-1 (minimum allowed) means no lower bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Number of "successes" required to cross upper bound cutoffs for
rejecting <code>p0</code> in favor of <code>p1</code> at each analysis; vector of length
k; value &gt; n.I means no upper bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>Lower of the two response (event) rates hypothesized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>Higher of the two response (event) rates hypothesized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Nominal probability of rejecting response (event) rate
<code>p0</code> when it is true.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Nominal probability of rejecting response (event) rate <code>p1</code>
when it is true. If NULL, Type II error will be computed for all input values 
of <code>n</code> and output will be in a data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minn</code></td>
<td>
<p>Minimum sample size at which sequential testing begins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxn</code></td>
<td>
<p>Maximum sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Item of class <code>gsBinomialExact</code> or <code>binomialSPRT</code> for
<code>print.gsBinomialExact</code>. Item of class <code>gsBinomialExact</code> for
<code>plot.gsBinomialExact</code>. Item of class <code>binomialSPRT</code> for item of
class <code>plot.binomialSPRT</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plottype</code></td>
<td>
<p>1 produces a plot with counts of response at bounds (for
<code>binomialSPRT</code>, also produces linear SPRT bounds); 2 produces a plot
with power to reject null and alternate response rates as well as the
probability of not crossing a bound by the maximum sample size; 3 produces a
plot with the response rate at the boundary as a function of sample size
when the boundary is crossed; 6 produces a plot of the expected sample size
by the underlying event rate (this assumes there is no enrollment beyond the
sample size where the boundary is crossed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed through to <code>ggplot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample sizes to be considered for <code>nBinomial1Sample</code>. These
should be ordered from smallest to largest and be &gt; 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outtype</code></td>
<td>
<p>Operative when <code>beta != NULL</code>. <code>1</code> means routine
will return a single integer sample size while for <code>output=2</code>a data frame 
is returned (see Value); note that this not operative is <code>beta</code> is <code>NULL</code> 
in which case a data table is returned with Type II error and power for each input 
value of <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conservative</code></td>
<td>
<p>operative when <code>outtype=1</code> or <code>2</code> and
<code>beta != NULL</code>. Default <code>FALSE</code> selects minimum sample size for
which power is at least <code>1-beta</code>. When <code>conservative=TRUE</code>, the
minimum sample sample size for which power is at least <code>1-beta</code> and
there is no larger sample size in the input <code>n</code> where power is less
than <code>1-beta</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>gsBinomialExact()</code> returns a list of class
<code>gsBinomialExact</code> and <code>gsProbability</code> (see example); when
displaying one of these objects, the default function to print is
<code>print.gsProbability()</code>.  The object returned from
<code>gsBinomialExact()</code> contains the following elements: </p>
<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>As
input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>As input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.I</code></td>
<td>
<p>As input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>A list
containing two elements: <code>bound</code> is as input in <code>a</code> and
<code>prob</code> is a matrix of boundary crossing probabilities. Element
<code>i,j</code> contains the boundary crossing probability at analysis <code>i</code>
for the <code>j</code>-th element of <code>theta</code> input. All boundary crossing is
assumed to be binding for this computation; that is, the trial must stop if
a boundary is crossed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>A list of the same form as <code>lower</code>
containing the upper bound and upper boundary crossing probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>en</code></td>
<td>
<p>A vector of the same length as <code>theta</code> containing expected
sample sizes for the trial design corresponding to each value in the vector
<code>theta</code>.</p>
</td>
</tr>
</table>
<p><code>binomialSPRT</code> produces an object of class <code>binomialSPRT</code> that is
an extension of the <code>gsBinomialExact</code> class. The values returned in
addition to those returned by <code>gsBinomialExact</code> are: </p>
<table>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>A
vector of length 2 with the intercepts for the two SPRT bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope</code></td>
<td>
<p>A scalar with the common slope of the SPRT bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>As input. Note that this will exceed the actual Type I error
achieved by the design returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>As input. Note that this will
exceed the actual Type II error achieved by the design returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>As input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>As input.</p>
</td>
</tr>
</table>
<p><code>nBinomial1Sample</code> produces a data frame with power for each input value in <code>n</code> 
if <code>beta=NULL</code>. Otherwise, a sample size achieving the desired power is returned unless 
the minimum power for the values input in <code>n</code> is greater than or equal to the target or 
the maximum yields power less than the target, in which case an error message is shown. 
The input variable <code>outtype</code> has no effect if <code>beta=NULL</code>. 
Otherwise, <code>outtype=1</code> results in return of an integer sample size and <code>outtype=2</code> 
results in a data frame with one record which includes the desired sample size.
When a data frame is returned, the variables include: </p>
<table>
<tr style="vertical-align: top;">
<td><code>p0</code></td>
<td>
<p>Input null
hypothesis event (or response) rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p1</code></td>
<td>
<p>Input alternative hypothesis
(or response) rate; must be <code>&gt; p0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Input Type I error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Input Type II error except when input is <code>NULL</code> in which
case realized Type II error is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>cutoff given <code>n</code> to control
Type I error; value is <code>NULL</code> if no such value exists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphaR</code></td>
<td>
<p>Type I error achieved for each 
output value of <code>n</code>; less than or equal to the input value <code>alpha</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Power</code></td>
<td>
<p>Power achieved 
for each output value of <code>n</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The gsDesign technical manual is available at
<a href="https://keaven.github.io/gsd-tech-manual/">https://keaven.github.io/gsd-tech-manual/</a>.
</p>


<h3>Author(s)</h3>

<p>Jon Hartzel, Yevgen Tymofyeyev and Keaven Anderson <a href="mailto:keaven_anderson@merck.com">keaven_anderson@merck.com</a>
</p>


<h3>References</h3>

<p>Jennison C and Turnbull BW (2000), <em>Group Sequential
Methods with Applications to Clinical Trials</em>. Boca Raton: Chapman and Hall.
</p>
<p>Code for nBinomial1Sample was based on code developed by
<a href="mailto:marc_schwartz@me.com">marc_schwartz@me.com</a>.
</p>


<h3>See Also</h3>

<p><code>gsProbability</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ggplot2)

zz &lt;- gsBinomialExact(
  k = 3, theta = seq(0.1, 0.9, 0.1), n.I = c(12, 24, 36),
  a = c(-1, 0, 11), b = c(5, 9, 12)
)

# let's see what class this is
class(zz)

# because of "gsProbability" class above, following is equivalent to
# \code{print.gsProbability(zz)}
zz

# also plot (see also plots below for \code{binomialSPRT})
# add lines using geom_line()
plot(zz) + 
ggplot2::geom_line()

# now for SPRT examples
x &lt;- binomialSPRT(p0 = .05, p1 = .25, alpha = .1, beta = .2)
# boundary plot
plot(x)
# power plot
plot(x, plottype = 2)
# Response (event) rate at boundary
plot(x, plottype = 3)
# Expected sample size at boundary crossing or end of trial
plot(x, plottype = 6)

# sample size for single arm exact binomial

# plot of table of power by sample size
# note that outtype need not be specified if beta is NULL
nb1 &lt;- nBinomial1Sample(p0 = 0.05, p1=0.2,alpha = 0.025, beta=NULL, n = 25:40)
nb1
library(scales)
ggplot2::ggplot(nb1, ggplot2::aes(x = n, y = Power)) + 
ggplot2::geom_line() + 
ggplot2::geom_point() + 
ggplot2::scale_y_continuous(labels = percent)

# simple call with same parameters to get minimum sample size yielding desired power
nBinomial1Sample(p0 = 0.05, p1 = 0.2, alpha = 0.025, beta = .2, n = 25:40)

# change to 'conservative' if you want all larger sample
# sizes to also provide adequate power
nBinomial1Sample(p0 = 0.05, p1 = 0.2, alpha = 0.025, beta = .2, n = 25:40, conservative = TRUE)

# print out more information for the selected derived sample size
nBinomial1Sample(p0 = 0.05, p1 = 0.2, alpha = 0.025, beta = .2, n = 25:40, conservative = TRUE,
 outtype = 2)
# Reproduce realized Type I error alphaR
stats::pbinom(q = 5, size = 39, prob = .05, lower.tail = FALSE)
# Reproduce realized power
stats::pbinom(q = 5, size = 39, prob = 0.2, lower.tail = FALSE)
# Reproduce critical value for positive finding
stats::qbinom(p = 1 - .025, size = 39, prob = .05) + 1
# Compute p-value for 7 successes
stats::pbinom(q = 6, size = 39, prob = .05, lower.tail = FALSE)
# what happens if input sample sizes not sufficient?
## Not run:  
  nBinomial1Sample(p0 = 0.05, p1 = 0.2, alpha = 0.025, beta = .2, n = 25:30)

## End(Not run)
</code></pre>


</div>