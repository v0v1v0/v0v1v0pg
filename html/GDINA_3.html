<div class="container">

<table style="width: 100%;"><tr>
<td>att.structure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate hierarchical attribute structures</h2>

<h3>Description</h3>

<p>This function can be used to generate hierarchical attributes structures, and
to provide prior joint attribute distribution with hierarchical structures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">att.structure(hierarchy.list = NULL, K, Q, att.prob = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>hierarchy.list</code></td>
<td>
<p>a list specifying the hierarchical structure between attributes. Each
element in this list specifies a DIRECT prerequisite relation between two or more attributes.
See <code>example</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>the number of attributes involved in the assessment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>Q-matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>att.prob</code></td>
<td>
<p>How are the probabilities for latent classes simulated? It can be <code>"random"</code> or <code>"uniform"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>att.str reduced latent classes under the specified hierarchical structure
</p>
<p>impossible.latentclass impossible latent classes under the specified hierarchical structure
</p>
<p>att.prob probabilities for all latent classes; 0 for impossible latent classes
</p>


<h3>Author(s)</h3>

<p>Wenchao Ma, The University of Alabama, <a href="mailto:wenchao.ma@ua.edu">wenchao.ma@ua.edu</a> <br> Jimmy de la Torre, The University of Hong Kong
</p>


<h3>See Also</h3>

<p><code>GDINA</code>, <code>autoGDINA</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#################
#
# Leighton et al. (2004, p.210)
#
##################
# linear structure A1-&gt;A2-&gt;A3-&gt;A4-&gt;A5-&gt;A6
K &lt;- 6
linear=list(c(1,2),c(2,3),c(3,4),c(4,5),c(5,6))
att.structure(linear,K)

# convergent structure A1-&gt;A2-&gt;A3-&gt;A5-&gt;A6;A1-&gt;A2-&gt;A4-&gt;A5-&gt;A6
K &lt;- 6
converg &lt;- list(c(1,2),c(2,3),c(2,4),
               c(3,4,5), #this is how to show that either A3 or A4 is a prerequisite to A5
               c(5,6))
att.structure(converg,K)

# convergent structure [the difference between this one and the previous one is that
#                       A3 and A4 are both needed in order to master A5]
K &lt;- 6
converg2 &lt;- list(c(1,2),c(2,3),c(2,4),
               c(3,5), #this is how to specify that both A3 and A4 are needed for A5
               c(4,5), #this is how to specify that both A3 and A4 are needed for A5
               c(5,6))
att.structure(converg2,K)

# divergent structure A1-&gt;A2-&gt;A3;A1-&gt;A4-&gt;A5;A1-&gt;A4-&gt;A6
diverg &lt;- list(c(1,2),
               c(2,3),
               c(1,4),
               c(4,5),
               c(4,6))
att.structure(diverg,K)

# unstructured A1-&gt;A2;A1-&gt;A3;A1-&gt;A4;A1-&gt;A5;A1-&gt;A6
unstru &lt;- list(c(1,2),c(1,3),c(1,4),c(1,5),c(1,6))
att.structure(unstru,K)

## See Example 4 and 5 in GDINA function

## End(Not run)
</code></pre>


</div>