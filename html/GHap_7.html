<div class="container">

<table style="width: 100%;"><tr>
<td>ghap.anctrain</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Construction of prototype alleles
</h2>

<h3>Description</h3>

<p>This function builds prototype alleles to be used in ancestry predictions.
</p>


<h3>Usage</h3>

<pre><code class="language-R"> ghap.anctrain(object, train = NULL,
               method = "unsupervised",
               K = 2, iter.max = 10, nstart = 10,
               nmarkers = 5000, tune = FALSE,
               only.active.samples = TRUE,
               only.active.markers = TRUE,
               batchsize = NULL, ncores = 1,
               verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<p>The following arguments are used by both the 'supervised' and 'unsupervised' methods:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>A GHap.phase object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train</code></td>
<td>

<p>Character vector of individuals to use as reference samples. All active individuals are used if this    vector is not provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>Character value indicating which method to use: 'supervised' or 'unsupervised' (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.active.samples</code></td>
<td>

<p>A logical value specifying whether only active samples should be included in predictions (default = TRUE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.active.markers</code></td>
<td>

<p>A logical value specifying whether only active markers should be used for predictions (default = TRUE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batchsize</code></td>
<td>

<p>A numeric value controlling the number of markers to be processed at a time (default = nmarkers/10).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>

<p>A numeric value specifying the number of cores to be used in parallel computing (default = 1).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>A logical value specfying whether log messages should be printed (default = TRUE).
</p>
</td>
</tr>
</table>
<p>The following arguments are only used by the 'unsupervised' method:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>A numeric value specifying the number of clusters in K-means (default = 2). Proxy for the number of ancestral populations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>

<p>A numeric value specifying the maximum number of iterations of the K-means clustering (default = 10).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>

<p>A numeric value specifying the number of independent runs of the K-means clustering (default = 10).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmarkers</code></td>
<td>

<p>A numeric value specifying the number of seeding markers to be used by the K-means clustering (default = 10).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune</code></td>
<td>

<p>A logical value specfying if a Best K analysis should be performed (default = FALSE).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function builds prototype alleles (i.e., cluster centroids, representing lineage-specific allele frequencies) through two methods: <br></p>
<p>The 'unsupervised' method uses the K-means clustering algorithm to group haplotypes into K pseudo-lineages. A random sample of seeding markers (default value of nmarkers = 5000) is used to group all 2*nsamples haplotypes in a user-specified number of clusters (default value of K = 2). Then, for each interrogated block, prototype alleles are built for every cluster using the arithmetic mean of observed haplotypes initially assigned to that cluster. If train = NULL, the function uses all active haplotypes to build prototype alleles. If the user is working with a severely unbalanced data set (ex. one population with a large number of individuals and others with few individuals), it is recommended that a vector of individual names is provided via the train argument such that prototype alleles are built using a more balanced subset of the data.
</p>
<p>The 'supervised' method works in a similar way, but skips the K-means algorithm and uses population labels present in the GHap.phase object as clusters. <br></p>


<h3>Value</h3>

<p>The function returns a dataframe with the first column giving marker names and remaining columns containing prototype alleles for each pseudo-lineage. If method 'unsupervised' is ran with tune = TRUE, the function returns the following list:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>ssq</code></td>
<td>

<p>Within-cluster sum of squares for each value of K.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chindex</code></td>
<td>

<p>Calinski Harabasz Index for consecutive values of K.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pchange</code></td>
<td>

<p>Percent change in ssq for consecutive values of K.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yuri Tani Utsunomiya &lt;ytutsunomiya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Y.T. Utsunomiya et al. Unsupervised detection of ancestry tracks with the GHap R package. Methods in Ecology and Evolution. 2020. 11:1448â€“54.
</p>


<h3>See Also</h3>

<p><code>ghap.anctest</code>, <code>ghap.ancsmooth</code>, <code>ghap.ancplot</code>, <code>ghap.ancmark</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# #### DO NOT RUN IF NOT NECESSARY ###
# 
# # Copy phase data in the current working directory
# exfiles &lt;- ghap.makefile(dataset = "example",
#                          format = "phase",
#                          verbose = TRUE)
# file.copy(from = exfiles, to = "./")
# 
# # Load phase data
# 
# phase &lt;- ghap.loadphase("example")
# 
# ### RUN ###
# 
# # Calculate marker density
# mrkdist &lt;- diff(phase$bp)
# mrkdist &lt;- mrkdist[which(mrkdist &gt; 0)]
# density &lt;- mean(mrkdist)
# 
# # Generate blocks for admixture events up to g = 10 generations in the past
# # Assuming mean block size in Morgans of 1/(2*g)
# # Approximating 1 Morgan ~ 100 Mbp
# g &lt;- 10
# window &lt;- (100e+6)/(2*g)
# window &lt;- ceiling(window/density)
# step &lt;- ceiling(window/4)
# blocks &lt;- ghap.blockgen(phase, windowsize = window,
#                         slide = step, unit = "marker")
# 
# # BestK analysis
# bestK &lt;- ghap.anctrain(object = phase, K = 5, tune = TRUE)
# plot(bestK$ssq, type = "b", xlab = "K",
#      ylab = "Within-cluster sum of squares")
# 
# # Unsupervised analysis with best K
# prototypes &lt;- ghap.anctrain(object = phase, K = 2)
# hapadmix &lt;- ghap.anctest(object = phase,
#                          blocks = blocks,
#                          prototypes = prototypes,
#                          test = unique(phase$id))
# anctracks &lt;- ghap.ancsmooth(object = phase, admix = hapadmix)
# ghap.ancplot(ancsmooth = anctracks)
# 
# # Supervised analysis
# train &lt;- unique(phase$id[which(phase$pop != "Cross")])
# prototypes &lt;- ghap.anctrain(object = phase, train = train,
#                             method = "supervised")
# hapadmix &lt;- ghap.anctest(object = phase,
#                          blocks = blocks,
#                          prototypes = prototypes,
#                          test = unique(phase$id))
# anctracks &lt;- ghap.ancsmooth(object = phase, admix = hapadmix)
# ghap.ancplot(ancsmooth = anctracks)


</code></pre>


</div>