<div class="container">

<table style="width: 100%;"><tr>
<td>portfolio.optimize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Portfolio optimization with respect to alternative risk measures</h2>

<h3>Description</h3>

<p>This function performs a optimization of a portfolio with respect to
one of the risk measures “sd”, “value.at.risk” or
“expected.shortfall”. The optimization task is either to
find the <em>global minimum risk</em> portfolio, the <em>tangency</em>
portfolio or the <em>minimum risk</em> portfolio given a target-return.
</p>


<h3>Usage</h3>

<pre><code class="language-R">portfolio.optimize(object,
                   risk.measure = c("sd", "value.at.risk", "expected.shortfall"),
                   type = c("minimum.risk", "tangency", "target.return"),
                   level = 0.95, distr = c("loss", "return"),
                   target.return = NULL, risk.free = NULL,
                   silent = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A multivariate <code>ghyp</code> object
representing the loss distribution. In case <code>object</code> gives the
return distribution set the argument <code>distr</code> to “return”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk.measure</code></td>
<td>
<p>How risk shall be measured.  Must be one of
“sd” (standard deviation),
“value.at.risk” or
“expected.shortfall”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The tpye of the optimization problem. Must be one of
“minimum.risk”, “tangency” or “target.return”
(see <b>Details</b>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>The confidence level which shall be used if
<code>risk.measure</code> is either “value.at.risk” or
“expected.shortfall”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr</code></td>
<td>
<p>The default distribution is “loss”. If <code>object</code>
gives the return distribution set <code>distr</code> to “return”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target.return</code></td>
<td>
<p>A numeric scalar specifying the target return if
the optimization problem is of <code>type</code> “target.return”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk.free</code></td>
<td>
<p>A numeric scalar giving the risk free rate in case the
optimization problem is of <code>type</code> “tangency”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>If <code>TRUE</code> no prompts will appear in the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>optim</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>type</code> is “minimum.risk” the global minimum risk
portfolio is returned. <br></p>
<p>If <code>type</code> is “tangency” the portfolio maximizing the slope
of “(expected return - risk free rate) / risk” will be
returned. <br></p>
<p>If <code>type</code> is “target.return” the portfolio with expected
return <code>target.return</code> which minimizes the risk will be
returned. <br></p>
<p>Note that in case of an elliptical distribution (symmetric generalized
hyperbolic distributions) it does not matter which risk measure is
used. That is, minimizing the standard deviation results in a
portfolio which also minimizes the value-at-risk et cetera. <br></p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>portfolio.dist</code></td>
<td>
<p>An univariate generalized hyperbolic object of class <code>ghyp</code> which
represents the distribution of the optimal portfolio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk.measure</code></td>
<td>
<p>The risk measure which was used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p>The risk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.weights</code></td>
<td>
<p>The optimal weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>Convergence returned from <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A possible error message returned from <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>The number of iterations returned from <code>optim</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>In case <code>object</code> denotes a non-elliptical distribution and the
risk measure is either “value.at.risk” or
“expected.shortfall”, then the type “tangency”
optimization problem is not supported. <br></p>
<p>Constraints like avoiding short-selling are not supported yet. <br></p>


<h3>Author(s)</h3>

<p>David Luethi</p>


<h3>See Also</h3>

<p><code>transform</code>, <code>fit.ghypmv</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
data(indices)

t.object &lt;- fit.tmv(-indices, silent = TRUE)
gauss.object &lt;- fit.gaussmv(-indices)

t.ptf &lt;- portfolio.optimize(t.object,
                            risk.measure = "expected.shortfall",
                            type = "minimum.risk",
                            level = 0.99,
                            distr = "loss",
                            silent = TRUE)

gauss.ptf &lt;- portfolio.optimize(gauss.object,
                                risk.measure = "expected.shortfall",
                                type = "minimum.risk",
                                level = 0.99,
                                distr = "loss")

par(mfrow = c(1, 3))

plot(c(t.ptf$risk, gauss.ptf$risk),
     c(-mean(t.ptf$portfolio.dist), -mean(gauss.ptf$portfolio.dist)),
     xlim = c(0, 0.035), ylim = c(0, 0.004),
     col = c("black", "red"), lwd = 4,
     xlab = "99 percent expected shortfall",
     ylab = "Expected portfolio return",
     main = "Global minimum risk portfolios")

legend("bottomleft", legend = c("Asymmetric t", "Gaussian"),
       col = c("black", "red"), lty = 1)

plot(t.ptf$portfolio.dist, type = "l",
     xlab = "log-loss ((-1) * log-return)", ylab = "Density")
lines(gauss.ptf$portfolio.dist, col = "red")

weights &lt;- cbind(Asymmetric.t = t.ptf$opt.weights,
                 Gaussian = gauss.ptf$opt.weights)

barplot(weights, beside = TRUE, ylab = "Weights")

</code></pre>


</div>