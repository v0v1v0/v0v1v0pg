<div class="container">

<table style="width: 100%;"><tr>
<td>GPModel_shared_params</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Documentation for parameters shared by <code>GPModel</code>, <code>gpb.cv</code>, and <code>gpboost</code>
</h2>

<h3>Description</h3>

<p>Documentation for parameters shared by <code>GPModel</code>, <code>gpb.cv</code>, and <code>gpboost</code>
</p>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>likelihood</code></td>
<td>
<p>A <code>string</code> specifying the likelihood function (distribution) of the response variable. 
Available options:
</p>

<ul>
<li>
<p> "gaussian" 
</p>
</li>
<li>
<p> "bernoulli_probit": binary data with Bernoulli likelihood and a probit link function 
</p>
</li>
<li>
<p> "bernoulli_logit": binary data with Bernoulli likelihood and a logit link function 
</p>
</li>
<li>
<p> "gamma": gamma distribution with a with log link function 
</p>
</li>
<li>
<p> "poisson": Poisson distribution with a with log link function 
</p>
</li>
<li>
<p> "negative_binomial": negative binomial distribution with a with log link function 
</p>
</li>
<li>
<p> Note: other likelihoods could be implemented upon request 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_data</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> whose columns are categorical grouping variables. 
The elements being group levels defining grouped random effects.
The elements of 'group_data' can be integer, double, or character.
The number of columns corresponds to the number of grouped (intercept) random effects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_rand_coef_data</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with numeric covariate data 
for grouped random coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_effect_group_rand_coef</code></td>
<td>
<p>A <code>vector</code> with integer indices that 
indicate the corresponding categorical grouping variable (=columns) in 'group_data' for 
every covariate in 'group_rand_coef_data'. Counting starts at 1.
The length of this index vector must equal the number of covariates in 'group_rand_coef_data'.
For instance, c(1,1,2) means that the first two covariates (=first two columns) in 'group_rand_coef_data'
have random coefficients corresponding to the first categorical grouping variable (=first column) in 'group_data',
and the third covariate (=third column) in 'group_rand_coef_data' has a random coefficient
corresponding to the second grouping variable (=second column) in 'group_data'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_intercept_group_rand_effect</code></td>
<td>
<p>A <code>vector</code> of type <code>logical</code> (boolean). 
Indicates whether intercept random effects are dropped (only for random coefficients). 
If drop_intercept_group_rand_effect[k] is TRUE, the intercept random effect number k is dropped / not included. 
Only random effects with random slopes can be dropped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_coords</code></td>
<td>
<p>A <code>matrix</code> with numeric coordinates (= inputs / features) for defining Gaussian processes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_rand_coef_data</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with numeric covariate data for
Gaussian process random coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_function</code></td>
<td>
<p>A <code>string</code> specifying the covariance function for the Gaussian process. 
Available options:
</p>

<ul>
<li>
<p>"exponential": Exponential covariance function (using the parametrization of Diggle and Ribeiro, 2007) 
</p>
</li>
<li>
<p>"gaussian": Gaussian, aka squared exponential, covariance function (using the parametrization of Diggle and Ribeiro, 2007) 
</p>
</li>
<li>
<p> "matern": Matern covariance function with the smoothness specified by 
the <code>cov_fct_shape</code> parameter (using the parametrization of Rasmussen and Williams, 2006) 
</p>
</li>
<li>
<p>"powered_exponential": powered exponential covariance function with the exponent specified by 
the <code>cov_fct_shape</code> parameter (using the parametrization of Diggle and Ribeiro, 2007) 
</p>
</li>
<li>
<p> "wendland": Compactly supported Wendland covariance function (using the parametrization of Bevilacqua et al., 2019, AOS) 
</p>
</li>
<li>
<p> "matern_space_time": Spatio-temporal Matern covariance function with different range parameters for space and time. 
Note that the first column in <code>gp_coords</code> must correspond to the time dimension 
</p>
</li>
<li>
<p> "matern_ard": anisotropic Matern covariance function with Automatic Relevance Determination (ARD), 
i.e., with a different range parameter for every coordinate dimension / column of <code>gp_coords</code> 
</p>
</li>
<li>
<p> "gaussian_ard": anisotropic Gaussian, aka squared exponential, covariance function with Automatic Relevance Determination (ARD), 
i.e., with a different range parameter for every coordinate dimension / column of <code>gp_coords</code> 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_fct_shape</code></td>
<td>
<p>A <code>numeric</code> specifying the shape parameter of the covariance function 
(=smoothness parameter for Matern covariance)  
This parameter is irrelevant for some covariance functions such as the exponential or Gaussian</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_approx</code></td>
<td>
<p>A <code>string</code> specifying the large data approximation
for Gaussian processes. Available options: 
</p>

<ul>
<li>
<p>"none": No approximation 
</p>
</li>
<li>
<p>"vecchia": A Vecchia approximation; see Sigrist (2022, JMLR) for more details 
</p>
</li>
<li>
<p>"tapering": The covariance function is multiplied by 
a compactly supported Wendland correlation function 
</p>
</li>
<li>
<p>"fitc": Fully Independent Training Conditional approximation aka 
modified predictive process approximation; see Gyger, Furrer, and Sigrist (2024) for more details 
</p>
</li>
<li>
<p>"full_scale_tapering": A full scale approximation combining an 
inducing point / predictive process approximation with tapering on the residual process; 
see Gyger, Furrer, and Sigrist (2024) for more details 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_fct_taper_range</code></td>
<td>
<p>A <code>numeric</code> specifying the range parameter 
of the Wendland covariance function and Wendland correlation taper function. 
We follow the notation of Bevilacqua et al. (2019, AOS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_fct_taper_shape</code></td>
<td>
<p>A <code>numeric</code> specifying the shape (=smoothness) parameter 
of the Wendland covariance function and Wendland correlation taper function. 
We follow the notation of Bevilacqua et al. (2019, AOS)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_neighbors</code></td>
<td>
<p>An <code>integer</code> specifying the number of neighbors for 
the Vecchia approximation. Note: for prediction, the number of neighbors can 
be set through the 'num_neighbors_pred' parameter in the 'set_prediction_data'
function. By default, num_neighbors_pred = 2 * num_neighbors. Further, 
the type of Vecchia approximation used for making predictions is set through  
the 'vecchia_pred_type' parameter in the 'set_prediction_data' function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_ordering</code></td>
<td>
<p>A <code>string</code> specifying the ordering used in 
the Vecchia approximation. Available options:
</p>

<ul>
<li>
<p>"none": the default ordering in the data is used 
</p>
</li>
<li>
<p>"random": a random ordering 
</p>
</li>
<li>
<p>"time": ordering accorrding to time (only for space-time models) 
</p>
</li>
<li>
<p>"time_random_space": ordering according to time and randomly for all 
spatial points with the same time points (only for space-time models) 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_points_selection</code></td>
<td>
<p>A <code>string</code> specifying the method for choosing inducing points
Available options:
</p>

<ul>
<li>
<p>"kmeans++: the k-means++ algorithm 
</p>
</li>
<li>
<p>"cover_tree": the cover tree algorithm 
</p>
</li>
<li>
<p>"random": random selection from data points 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_ind_points</code></td>
<td>
<p>An <code>integer</code> specifying the number of inducing 
points / knots for, e.g., a predictive process approximation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cover_tree_radius</code></td>
<td>
<p>A <code>numeric</code> specifying the radius (= "spatial resolution") 
for the cover tree algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matrix_inversion_method</code></td>
<td>
<p>A <code>string</code> specifying the method used for inverting covariance matrices. 
Available options:
</p>

<ul>
<li>
<p>"cholesky": Cholesky factorization 
</p>
</li>
<li>
<p>"iterative": iterative methods. A combination of conjugate gradient, Lanczos algorithm, and other methods. 
</p>
<p>This is currently only supported for the following cases: 
</p>

<ul>
<li>
<p>likelihood != "gaussian" and gp_approx == "vecchia" (non-Gaussian likelihoods with a Vecchia-Laplace approximation) 
</p>
</li>
<li>
<p>likelihood == "gaussian" and gp_approx == "full_scale_tapering" (Gaussian likelihood with a full-scale tapering approximation) 
</p>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An <code>integer</code> specifying the seed used for model creation 
(e.g., random ordering in Vecchia approximation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_pred_type</code></td>
<td>
<p>A <code>string</code> specifying the type of Vecchia approximation used for making predictions.
Default value if vecchia_pred_type = NULL: "order_obs_first_cond_obs_only". 
Available options:
</p>

<ul>
<li>
<p>"order_obs_first_cond_obs_only": Vecchia approximation for the observable process and observed training data is 
ordered first and the neighbors are only observed training data points 
</p>
</li>
<li>
<p>"order_obs_first_cond_all": Vecchia approximation for the observable process and observed training data is 
ordered first and the neighbors are selected among all points (training + prediction) 
</p>
</li>
<li>
<p>"latent_order_obs_first_cond_obs_only": Vecchia approximation for the latent process and observed data is 
ordered first and neighbors are only observed points
</p>
</li>
<li>
<p>"latent_order_obs_first_cond_all": Vecchia approximation 
for the latent process and observed data is ordered first and neighbors are selected among all points 
</p>
</li>
<li>
<p>"order_pred_first": Vecchia approximation for the observable process and prediction data is 
ordered first for making predictions. This option is only available for Gaussian likelihoods 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_neighbors_pred</code></td>
<td>
<p>an <code>integer</code> specifying the number of neighbors for the Vecchia approximation 
for making predictions. Default value if NULL: num_neighbors_pred = 2 * num_neighbors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cg_delta_conv_pred</code></td>
<td>
<p>a <code>numeric</code> specifying the tolerance level for L2 norm of residuals for 
checking convergence in conjugate gradient algorithms when being used for prediction
Default value if NULL: 1e-3</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim_var_pred</code></td>
<td>
<p>an <code>integer</code> specifying the number of samples when simulation 
is used for calculating predictive variances
Default value if NULL: 1000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank_pred_approx_matrix_lanczos</code></td>
<td>
<p>an <code>integer</code> specifying the rank 
of the matrix for approximating predictive covariances obtained using the Lanczos algorithm
Default value if NULL: 1000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_ids</code></td>
<td>
<p>A <code>vector</code> with elements indicating independent realizations of 
random effects / Gaussian processes (same values = same process realization).
The elements of 'cluster_ids' can be integer, double, or character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>free_raw_data</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, the data (groups, coordinates, covariate data for random coefficients) 
is freed in R after initialization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A <code>vector</code> with response variable data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A <code>matrix</code> with numeric covariate data for the 
fixed effects linear regression term (if there is one)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>A <code>list</code> with parameters for the estimation / optimization
</p>

<ul>
<li>
<p>optimizer_cov: <code>string</code> (default = "lbfgs"). 
Optimizer used for estimating covariance parameters. 
Options: "gradient_descent", "lbfgs", "fisher_scoring", "newton", "nelder_mead", "adam".
If there are additional auxiliary parameters for non-Gaussian likelihoods, 
'optimizer_cov' is also used for those 
</p>
</li>
<li>
<p>optimizer_coef: <code>string</code> (default = "wls" for Gaussian likelihoods and "lbfgs" for other likelihoods). 
Optimizer used for estimating linear regression coefficients, if there are any 
(for the GPBoost algorithm there are usually none). 
Options: "gradient_descent", "lbfgs", "wls", "nelder_mead", "adam". Gradient descent steps are done simultaneously 
with gradient descent steps for the covariance parameters. 
"wls" refers to doing coordinate descent for the regression coefficients using weighted least squares.
If 'optimizer_cov' is set to "nelder_mead", "lbfgs", or "adam", 
'optimizer_coef' is automatically also set to the same value.
</p>
</li>
<li>
<p>maxit: <code>integer</code> (default = 1000). 
Maximal number of iterations for optimization algorithm 
</p>
</li>
<li>
<p>delta_rel_conv: <code>numeric</code> (default = 1E-6 except for "nelder_mead" for which the default is 1E-8). 
Convergence tolerance. The algorithm stops if the relative change 
in either the (approximate) log-likelihood or the parameters is below this value. 
For "adam", the L2 norm of the gradient is used instead of the relative change in the log-likelihood. 
If &lt; 0, internal default values are used 
</p>
</li>
<li>
<p>convergence_criterion: <code>string</code> (default = "relative_change_in_log_likelihood"). 
The convergence criterion used for terminating the optimization algorithm.
Options: "relative_change_in_log_likelihood" or "relative_change_in_parameters" 
</p>
</li>
<li>
<p>init_coef: <code>vector</code> with <code>numeric</code> elements (default = NULL). 
Initial values for the regression coefficients (if there are any, can be NULL) 
</p>
</li>
<li>
<p>init_cov_pars: <code>vector</code> with <code>numeric</code> elements (default = NULL). 
Initial values for covariance parameters of Gaussian process and 
random effects (can be NULL). The order it the same as the order 
of the parameters in the summary function: first is the error variance 
(only for "gaussian" likelihood), next follow the variances of the 
grouped random effects (if there are any, in the order provided in 'group_data'), 
and then follow the marginal variance and the range of the Gaussian process. 
If there are multiple Gaussian processes, then the variances and ranges follow alternatingly.
If 'init_cov_pars = NULL', an internal choice is used that depends on the 
likelihood and the random effects type and covariance function. 
If you select the option 'trace = TRUE' in the 'params' argument, 
you will see the first initial covariance parameters in iteration 0. 
</p>
</li>
<li>
<p>lr_coef: <code>numeric</code> (default = 0.1). 
Learning rate for fixed effect regression coefficients if gradient descent is used 
</p>
</li>
<li>
<p>lr_cov: <code>numeric</code> (default = 0.1 for "gradient_descent" and 1. otherwise). 
Initial learning rate for covariance parameters if a gradient-based optimization method is used 
</p>

<ul>
<li>
<p>If lr_cov &lt; 0, internal default values are used (0.1 for "gradient_descent" and 1. otherwise) 
</p>
</li>
<li>
<p>If there are additional auxiliary parameters for non-Gaussian likelihoods, 
'lr_cov' is also used for those 
</p>
</li>
<li>
<p>For "lbfgs", this is divided by the norm of the gradient in the first iteration </p>
</li>
</ul>
</li>
<li>
<p>use_nesterov_acc: <code>boolean</code> (default = TRUE). 
If TRUE Nesterov acceleration is used.
This is used only for gradient descent 
</p>
</li>
<li>
<p>acc_rate_coef: <code>numeric</code> (default = 0.5). 
Acceleration rate for regression coefficients (if there are any) 
for Nesterov acceleration 
</p>
</li>
<li>
<p>acc_rate_cov: <code>numeric</code> (default = 0.5). 
Acceleration rate for covariance parameters for Nesterov acceleration 
</p>
</li>
<li>
<p>momentum_offset: <code>integer</code> (Default = 2). 
Number of iterations for which no momentum is applied in the beginning.
</p>
</li>
<li>
<p>trace: <code>boolean</code> (default = FALSE). 
If TRUE, information on the progress of the parameter
optimization is printed
</p>
</li>
<li>
<p>std_dev: <code>boolean</code> (default = TRUE). 
If TRUE, approximate standard deviations are calculated for the covariance and linear regression parameters 
(= square root of diagonal of the inverse Fisher information for Gaussian likelihoods and 
square root of diagonal of a numerically approximated inverse Hessian for non-Gaussian likelihoods) 
</p>
</li>
<li>
<p>init_aux_pars: <code>vector</code> with <code>numeric</code> elements (default = NULL). 
Initial values for additional parameters for non-Gaussian likelihoods 
(e.g., shape parameter of a gamma or negative_binomial likelihood) 
</p>
</li>
<li>
<p>estimate_aux_pars: <code>boolean</code> (default = TRUE). 
If TRUE, additional parameters for non-Gaussian likelihoods 
are also estimated (e.g., shape parameter of a gamma or negative_binomial likelihood) 
</p>
</li>
<li>
<p>cg_max_num_it: <code>integer</code> (default = 1000). 
Maximal number of iterations for conjugate gradient algorithms 
</p>
</li>
<li>
<p>cg_max_num_it_tridiag: <code>integer</code> (default = 1000). 
Maximal number of iterations for conjugate gradient algorithm 
when being run as Lanczos algorithm for tridiagonalization 
</p>
</li>
<li>
<p>cg_delta_conv: <code>numeric</code> (default = 1E-2).
Tolerance level for L2 norm of residuals for checking convergence 
in conjugate gradient algorithm when being used for parameter estimation 
</p>
</li>
<li>
<p>num_rand_vec_trace: <code>integer</code> (default = 50). 
Number of random vectors (e.g., Rademacher) for stochastic approximation of the trace of a matrix 
</p>
</li>
<li>
<p>reuse_rand_vec_trace: <code>boolean</code> (default = TRUE). 
If true, random vectors (e.g., Rademacher) for stochastic approximations 
of the trace of a matrix are sampled only once at the beginning of 
the parameter estimation and reused in later trace approximations.
Otherwise they are sampled every time a trace is calculated 
</p>
</li>
<li>
<p>seed_rand_vec_trace: <code>integer</code> (default = 1). 
Seed number to generate random vectors (e.g., Rademacher) 
</p>
</li>
<li>
<p>piv_chol_rank: <code>integer</code> (default = 50). 
Rank of the pivoted Cholesky decomposition used as 
preconditioner in conjugate gradient algorithms 
</p>
</li>
<li>
<p>cg_preconditioner_type: <code>string</code>.
Type of preconditioner used for conjugate gradient algorithms.
</p>

<ul>
<li>
<p> Options for non-Gaussian likelihoods and gp_approx = "vecchia": 
</p>

<ul><li>
<p>"Sigma_inv_plus_BtWB" (= default): (B^T * (D^-1 + W) * B) as preconditioner for inverting (B^T * D^-1 * B + W), 
where B^T * D^-1 * B approx= Sigma^-1 
</p>
</li></ul>
</li>
<li>
<p>"piv_chol_on_Sigma": (Lk * Lk^T + W^-1) as preconditioner for inverting (B^-1 * D * B^-T + W^-1), 
where Lk is a low-rank pivoted Cholesky approximation for Sigma and B^-1 * D * B^-T approx= Sigma 
</p>
</li>
<li>
<p> Options for likelihood = "gaussian" and gp_approx = "full_scale_tapering": 
</p>

<ul>
<li>
<p>"predictive_process_plus_diagonal" (= default): predictive process preconditiioner 
</p>
</li>
<li>
<p>"none": no preconditioner 
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> with 
additional fixed effects contributions that are added to the linear predictor (= offset). 
The length of this vector needs to equal the number of training data points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_effects</code></td>
<td>
<p>This is discontinued. Use the renamed equivalent argument <code>offset</code> instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_data_pred</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with elements being group levels 
for which predictions are made (if there are grouped random effects in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_rand_coef_data_pred</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with covariate data 
for grouped random coefficients (if there are some in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_coords_pred</code></td>
<td>
<p>A <code>matrix</code> with prediction coordinates (=features) for 
Gaussian process (if there is a GP in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gp_rand_coef_data_pred</code></td>
<td>
<p>A <code>vector</code> or <code>matrix</code> with covariate data for 
Gaussian process random coefficients (if there are some in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_ids_pred</code></td>
<td>
<p>A <code>vector</code> with elements indicating the realizations of 
random effects / Gaussian processes for which predictions are made 
(set to NULL if you have not specified this when creating the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_pred</code></td>
<td>
<p>A <code>matrix</code> with prediction covariate data for the 
fixed effects linear regression term (if there is one in the <code>GPModel</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict_cov_mat</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, the (posterior) 
predictive covariance is calculated in addition to the (posterior) predictive mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict_var</code></td>
<td>
<p>A <code>boolean</code>. If TRUE, the (posterior) 
predictive variances are calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vecchia_approx</code></td>
<td>
<p>Discontinued. Use the argument <code>gp_approx</code> instead</p>
</td>
</tr>
</table>
</div>