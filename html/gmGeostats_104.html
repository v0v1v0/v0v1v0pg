<div class="container">

<table style="width: 100%;"><tr>
<td>gmApply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply Functions Over Array or DataFrameStack Margins</h2>

<h3>Description</h3>

<p>Returns a vector or array or list of values obtained by
applying a function to the margins of an array or matrix.
Method <code>gmApply.default()</code> is just a wrapper on <code>base::apply()</code>.
Method <code>gmApply()</code> reimplements the functionality
with future access to parallel computing and appropriate default
values for the MARGIN. ALWAYS use named arguments here!
</p>


<h3>Usage</h3>

<pre><code class="language-R">gmApply(X, ...)

## Default S3 method:
gmApply(X, MARGIN, FUN, ...)

## S3 method for class 'DataFrameStack'
gmApply(X, MARGIN = stackDim(X), FUN, ..., .parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a <code>DataFrameStack()</code> object (see <code>base::apply()</code> for other options)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to <code>FUN</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MARGIN</code></td>
<td>
<p>a name or an index of the dimension along which should
the calculations be done; defaults to the stacking dimension of the
<code>DataFrameStack()</code>, i.e. to the output of <code>stackDim(X)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>function to apply; the default behaviour being that this function
is applied to each element of the stack <code>X</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.parallel</code></td>
<td>
<p>currently ignored</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>In principle, if <code>MARGIN==stackDim(X)</code> (the default), the oputput is a list
with the result of using <code>FUN</code> on each element of the stack. If <code>FUN</code> returns a
matrix or a data.frame assimilable to one element of the stack, a transformation of
this output to a DataFrameStack is attempted.
</p>
<p>For <code>X</code> non-DataFrameStack or <code>MARGIN!=stackDim(X)</code> see <code>base::apply()</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: wrapper around <code>base::apply()</code>
</p>
</li>
<li> <p><code>DataFrameStack</code>: Apply Functions Over DataFrameStack Margins
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">dm = list(point=1:100, var=LETTERS[1:2], rep=paste("r",1:5, sep=""))
ar = array(rnorm(1000), dim=c(100,2,5), dimnames = dm)
dfs = DataFrameStack(ar, stackDim="rep")
gmApply(dfs, FUN=colMeans)
rs = gmApply(dfs, FUN=function(x) x+1)
class(rs)
getStackElement(rs,1)
getStackElement(dfs,1)
</code></pre>


</div>