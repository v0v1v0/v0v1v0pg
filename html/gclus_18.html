<div class="container">

<table style="width: 100%;"><tr>
<td>order.clusters</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Orders clustered objects using hierarchical clustering</h2>

<h3>Description</h3>

<p>Reorders objects so that  similar (or high-merit) object pairs are adjacent.
The clusters argument specifies (possibly ordered) groups, and objects
within a group are kept together.
</p>


<h3>Usage</h3>

<pre><code class="language-R">order.clusters(merit,clusters,within.order = order.single, 
    between.order= order.single,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>merit</code></td>
<td>
<p>is either a symmetric matrix of merit or similarity score, 
or a <code>dist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>specifies a partial grouping. It should either be a list whose 
ith element contains 
the indices of the  objects in the ith cluster, or a vector of integers whose ith element 
gives the cluster membership of the ith object. Either representation may 
be used to specify grouping, the first is preferrable to specify 
adjacencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>within.order</code></td>
<td>
<p>is a function used to order the objects within each 
cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>between.order</code></td>
<td>
<p>is a function used to order the clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments are passed to <code>within.order</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>within.order</code> may be NULL, in which case objects within a 
cluster are assumed to be in order. Otherwise, <code>within.order</code>
should be one of the ordering functions 
<code>order.single</code>,<code>order.endlink</code> or <code>order.hclust</code>.
</p>
<p><code>between.order</code> may be NULL, in which case cluster order
is preserved. 
Otherwise, <code>betweem.order</code>
should be one of the ordering functions that uses a partial ordering,
<code>order.single</code> or <code>order.endlink</code>.
</p>


<h3>Value</h3>

<p>A permutation of the objects represented by <code>merit</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>See Also</h3>

<p>order.single,order.endlink,order.hclust.</p>


<h3>Examples</h3>

<pre><code class="language-R">data(state)
state.d &lt;- dist(state.x77)


# Order the states, keeping states in a division together.
state.o &lt;- order.clusters(-state.d, as.numeric(state.division))
cmat &lt;- dmat.color(as.matrix(state.d), rev(cm.colors(5)))


op &lt;- par(mar=c(1,6,1,1))
rlabels &lt;- state.name[state.o]
plotcolors(cmat[state.o,state.o], rlabels=rlabels)
par(op)


# Alternatively, use kmeans to place the  states into 6 clusters
state.km &lt;- kmeans(state.d,6)$cluster

# An ordering obtained from the kmeans clustering...
state.o &lt;- unlist(memship2clus(state.km))


layout(matrix(1:2,nrow=1,ncol=2),widths=c(0.1,1))
op &lt;- par(mar=c(1,1,1,.2))
state.colors &lt;- cbind(state.km,state.km)
plotcolors(state.colors[state.o,])

par(mar=c(1,6,1,1))
rlabels &lt;- state.name[state.o]
plotcolors(cmat[state.o,state.o], rlabels=rlabels)

par(op)
layout(matrix(1,1))



# In the ordering above, the ordering of clusters and the
# ordering of objects within the clusters is arbitrary.
# order.clusters gives an improved order but preserves the kmeans clusters.

state.o &lt;- order.clusters(-state.d, state.km)

# and replot
layout(matrix(1:2,nrow=1,ncol=2),widths=c(0.1,1))
op &lt;- par(mar=c(1,1,1,.2))
state.colors &lt;- cbind(state.km,state.km)
plotcolors(state.colors[state.o,])

par(mar=c(1,6,1,1))
rlabels &lt;- state.name[state.o]
plotcolors(cmat[state.o,state.o], rlabels=rlabels)

par(op)
layout(matrix(1,1))

</code></pre>


</div>