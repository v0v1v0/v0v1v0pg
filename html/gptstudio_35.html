<div class="container">

<table style="width: 100%;"><tr>
<td>OpenaiStreamParser</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stream handler for chat completions</h2>

<h3>Description</h3>

<p>Stream handler for chat completions
</p>
<p>Stream handler for chat completions
</p>


<h3>Details</h3>

<p>R6 class that allows to handle chat completions chunk by chunk.
It also adds methods to retrieve relevant data. This class DOES NOT make the request.
</p>
<p>Because <code>curl::curl_fetch_stream</code> blocks the R console until the stream finishes,
this class can take a shiny session object to handle communication with JS
without recurring to a <code>shiny::observe</code> inside a module server.
</p>


<h3>Super class</h3>

<p><code>SSEparser::SSEparser</code> -&gt; <code>OpenaiStreamParser</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>shinySession</code></dt>
<dd>
<p>Holds the <code>session</code> provided at initialization</p>
</dd>
<dt><code>user_prompt</code></dt>
<dd>
<p>The <code>user_prompt</code> provided at initialization,
after being formatted with markdown.</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>The content of the stream. It updates constantly until the stream ends.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OpenaiStreamParser-new"><code>OpenaiStreamParser$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OpenaiStreamParser-append_parsed_sse"><code>OpenaiStreamParser$append_parsed_sse()</code></a>
</p>
</li>
<li> <p><a href="#method-OpenaiStreamParser-clone"><code>OpenaiStreamParser$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="SSEparser" data-topic="SSEparser" data-id="parse_sse"><a href="../../SSEparser/html/SSEparser.html#method-SSEparser-parse_sse"><code>SSEparser::SSEparser$parse_sse()</code></a></span></li>
</ul></details><hr>
<a id="method-OpenaiStreamParser-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Start a StreamHandler. Recommended to be assigned to the <code>stream_handler</code> name.
</p>


<h5>Usage</h5>

<div class="r"><pre>OpenaiStreamParser$new(session = NULL, user_prompt = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>session</code></dt>
<dd>
<p>The shiny session it will send the message to (optional).</p>
</dd>
<dt><code>user_prompt</code></dt>
<dd>
<p>The prompt for the chat completion.
Only to be displayed in an HTML tag containing the prompt. (Optional).</p>
</dd>
</dl>
</div>


<hr>
<a id="method-OpenaiStreamParser-append_parsed_sse"></a>



<h4>Method <code>append_parsed_sse()</code>
</h4>

<p>Overwrites <code>SSEparser$append_parsed_sse()</code> to be able to send a custom message
to a shiny session, escaping shiny's reactivity.
</p>


<h5>Usage</h5>

<div class="r"><pre>OpenaiStreamParser$append_parsed_sse(parsed_event)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parsed_event</code></dt>
<dd>
<p>An already parsed server-sent event to append to the events field.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-OpenaiStreamParser-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OpenaiStreamParser$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




</div>