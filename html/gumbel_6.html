<div class="container">

<table style="width: 100%;"><tr>
<td>Gumbel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Gumbel Hougaard Copula</h2>

<h3>Description</h3>

<p>Density function, distribution function, random generation,
generator and inverse generator function for the Gumbel Copula with
parameters <code>alpha</code>. The 4 classic estimation methods for copulas.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dgumbel(u, v=NULL, alpha, dim=2, warning = FALSE)
pgumbel(u, v=NULL, alpha, dim=2)
rgumbel(n, alpha, dim=2, method=1)
phigumbel(t, alpha=1)
invphigumbel(t, alpha=1)
gumbel.MBE(x, y, marg = "exp")
gumbel.EML(x, y, marg = "exp")
gumbel.IFM(x, y, marg = "exp")
gumbel.CML(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>vector of quantiles if argument <code>v</code> is provided
or matrix of quantiles if argument <code>v</code> is not provided</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>vector of quantiles, needed if <code>u</code> is not a matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>parameter of the Copula. Must be greater than <code class="reqn">1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>an integer specifying the dimension of the copula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>dummy variable of the generator <code class="reqn">\phi</code> or the inverse generator <code class="reqn">\phi^-1</code>.
could be a n-dimensional array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>an integer code for the method used in simulation. 1 is the common
frailty approach, 2 uses the K function (only valid with <code>dim</code>=2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>vectors of observations, realizations of random variable <code class="reqn">X</code> and <code class="reqn">Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marg</code></td>
<td>
<p>a character string specifying the marginals of vector <code class="reqn">(X,Y)</code>. It must be either 
"exp"(default value) or "gamma".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warning</code></td>
<td>
<p>a logical (default value <code>FALSE</code>) if you want warnings.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Gumbel Hougaard Copula with parameter <code>alpha</code> is defined by
its generator </p>
<p style="text-align: center;"><code class="reqn">\phi(t) = (-ln(t))^alpha.</code>
</p>
<p> The generator and inverse generator are
implemented in <code>phigumbel</code> and <code>invphigumbel</code> respectively. 
As an Archimedean copula, its
distribution function is </p>
<p style="text-align: center;"><code class="reqn"> C(u_1, ...,u_n) = \phi^{-1}(\phi(u_1)+...+\phi(u_n)) 
	= exp(-( (-ln(u_1))^alpha+...+(-ln(u_n))^alpha )^1/\alpha).</code>
</p>

<p><code>pgumbel</code> and <code>dgumbel</code> computes the distribution function (expression above) and
the density (<code class="reqn">n</code> times differentiation of expression above with respect to <code class="reqn">u_i</code>). 
As there is no explicit
formulas for the density of a Gumbel copula, <code>dgumbel</code> is not yet impemented 
for argument <code>dim&gt;3</code>. This two functions works with a <code>dim</code>-dimensional array with
the last dimension being equalled to <code>dim</code> or with a matrix with <code>dim</code> 
columns (see examples).
</p>
<p>Random generation is carried out with 2 algorithms the common frailty 
algorithm (method=1) and the 'K' algorithm (method=2).
The common frailty algorithm (cf. Marshall &amp; Olkin(1988)) can be sum up in three lines
</p>
 
<ul>
<li>
<p>generate <code class="reqn">y_1</code>, <code class="reqn">y_2</code> from exponential distribution of mean 1,
</p>
</li>
<li>
<p>generate <code class="reqn">\theta</code> from a stable distribution with parameter<code class="reqn">(1/alpha,1,1,0)</code>, 
</p>
</li>
<li>
<p><code class="reqn">u_1 &lt;- phi(y_1/\theta)</code> and <code class="reqn">u_2 &lt;- phi(y_2/\theta)</code>.
</p>
</li>
</ul>
<p>This algorithm works with any dimension. See Chambers et al(1976) for stable random generation.
The 'K' algorithm use the fact the distribution function of random variable <code class="reqn">C(U,V)</code>
is <code class="reqn">K(t) = t-\phi(y)/\phi'(t)</code>. The algorithm is
</p>

<ul>
<li>
<p>generate <code class="reqn">v_1</code>, <code class="reqn">t</code> from uniform distribution
</p>
</li>
<li>
<p>generate <code class="reqn">v_2</code> from the <code class="reqn">K</code> distribution i.e. <code class="reqn">v_2&lt;-K^{-1}(t)</code>. 
</p>
</li>
<li>
<p><code class="reqn">u_1&lt;-\phi^{-1}(\phi(v_1)v_2)</code> and <code class="reqn">u_2&lt;-\phi^{-1}(\phi(v_1)(1-v_2)) </code>.
</p>
</li>
</ul>
<p>Warning, the 'K' algorithm does NOT work with <code>dim&gt;2</code>. 
</p>
<p>We implements the 4 usual method of estimation for copulas, namely the Exact Maximum
Likelihood (<code>gumbel.EML</code>), the Inference for Margins (<code>gumbel.IFM</code>), the
Moment-base Estimation (<code>gumbel.MBE</code>) and the Canonical Maximum 
Likelihood (<code>gumbel.CML</code>). For the moment, only two types of marginals are 
available : exponential distribution (<code>marg="exp"</code>) and gamma distribution
(<code>marg="gamma"</code>).
</p>


<h3>Value</h3>

<p><code>dgumbel</code> gives the density,
<code>pgumbel</code> gives the distribution function,
<code>rgumbel</code> generates random deviates,
<code>phigumbel</code> gives the generator,
<code>invphigumbel</code> gives the inverse generator.
</p>
<p><code>gumbel.EML</code>, <code>gumbel.IFM</code>, <code>gumbel.MBE</code> and <code>gumbel.CML</code>
returns the vector of estimates.	
</p>
<p>Invalid arguments will result in return value <code>NaN</code>.
</p>


<h3>Author(s)</h3>

<p>A.-L. Caillat, C. Dutang, M. V. Larrieu and T. Nguyen
</p>


<h3>References</h3>

<p>Nelsen, R. (2006),
<em>An Introduction to Copula, Second Edition</em>, Springer.
</p>
<p>Marshall &amp; Olkin(1988),
<em>Families of multivariate distributions</em>, Journal of the American Statistical Association.
</p>
<p>Chambers et al (1976),
<em>A method for simulating stable random variables</em>, Journal of the American Statistical Association.
</p>
<p>Nelsen, R. (2005),
<em>Dependence Modeling with Archimedean Copulas</em>,
booklet available at www.lclark.edu/~mathsci/brazil2.pdf.
</p>


<h3>Examples</h3>

<pre><code class="language-R">	#dim=2
	u&lt;-seq(0,1, .1)
	v&lt;-u
	#classic parametrization
	#independance case (alpha=1)
	dgumbel(u,v,1)
	pgumbel(u,v,1)
	#another parametrization
	dgumbel(cbind(u,v), alpha=1)
	pgumbel(cbind(u,v), alpha=1)

	#dim=3 - equivalent parametrization
	x &lt;- cbind(u,u,u)
	y &lt;- array(u, c(1,11,3))
	pgumbel(x, alpha=2, dim=3)
	pgumbel(y, alpha=2, dim=3)
	dgumbel(x, alpha=2, dim=3)
	dgumbel(y, alpha=2, dim=3)

	#dim=4
	x &lt;- cbind(x,u)
	pgumbel(x, alpha=3, dim=4)
	y &lt;- array(u, c(2,1,11,4))
	pgumbel(y, alpha=3, dim=4)
	
	
	#independence case
	rand &lt;- t(rgumbel(200,1))
	plot(rand[1,], rand[2,], col="green", main="Gumbel copula")
	
	#positive dependence
	rand &lt;- t(rgumbel(200,2))
	plot(rand[1,], rand[2,], col="red", main="Gumbel copula")
	
	#comparison of random generation algorithms
	nbsimu &lt;- 10000
	#Marshall Olkin algorithm
	system.time(rgumbel(nbsimu, 2, dim=2, method=1))[3]
	#K algortihm
	system.time(rgumbel(nbsimu, 2, dim=2, method=2))[3]
	
	#pseudo animation
	## Not run: 
	anim &lt;-function(n, max=50)
	{
	for(i in seq(1,max,length.out=n)) 
	{
		u &lt;- t(rgumbel(10000, i, method=2))
		plot(u[1,], u[2,], col="green", main="Gumbel copula",
            xlim=c(0,1), ylim=c(0,1), pch=".")
		cat()
	}	
	}
	anim(20, 20)
	
## End(Not run)
	
	#3D plots

	#plot the density
 	x &lt;- seq(.05, .95, length = 30)
	y &lt;- x
	z &lt;- outer(x, y, dgumbel, alpha=2)
		
	persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
      ltheta = 100, shade = 0.25, ticktype = "detailed",
      xlab = "x", ylab = "y", zlab = "density")
	
	#with wonderful colors
	#code of P. Soutiras
	zlim &lt;- c(0, max(z))
	ncol &lt;- 100
	nrz &lt;- nrow(z)
	ncz &lt;- ncol(z)
	jet.colors &lt;- colorRampPalette(c("#00007F", "blue", "#007FFF", 
	"cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")) 
	couleurs &lt;- tail(jet.colors(1.2*ncol),ncol)
	fcol &lt;- couleurs[trunc(z/zlim[2]*(ncol-1))+1]
	dim(fcol) &lt;- c(nrz,ncz)
	fcol &lt;- fcol[-nrz,-ncz]
	persp(x, y, z, col=fcol, zlim=zlim, theta=30, phi=30, ticktype = "detailed",
        box = TRUE, 	xlab = "x", ylab = "y", zlab = "density")
	

	#plot the distribution function
	z &lt;- outer(x, y, pgumbel, alpha=2)
	persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
        ltheta = 100, shade = 0.25, ticktype = "detailed",
        xlab = "u", ylab = "v", zlab = "cdf")
	
	

	#parameter estimation
	#true value : lambdaX=lambdaY=1, alpha=2
	simu &lt;- qexp(rgumbel(200, 2))
	gumbel.MBE(simu[,1], simu[,2])
	gumbel.IFM(simu[,1], simu[,2])
	gumbel.EML(simu[,1], simu[,2])
	gumbel.CML(simu[,1], simu[,2])

	#true value : lambdaX=lambdaY=1, alphaX=alphaY=2, alpha=3
	simu &lt;- qgamma(rgumbel(200, 3), 2, 1)
	gumbel.MBE(simu[,1], simu[,2], "gamma")
	gumbel.IFM(simu[,1], simu[,2], "gamma")
	gumbel.EML(simu[,1], simu[,2], "gamma")
	gumbel.CML(simu[,1], simu[,2])
		

		
</code></pre>


</div>