<div class="container">

<table style="width: 100%;"><tr>
<td>bilinear</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bilinear transformation</h2>

<h3>Description</h3>

<p>Transform a s-plane (analog) filter specification into a z-plane (digital)
specification.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bilinear(Sz, ...)

## S3 method for class 'Zpg'
bilinear(Sz, T = 2 * tan(1/2), ...)

## S3 method for class 'Arma'
bilinear(Sz, T = 2 * tan(1/2), ...)

## Default S3 method:
bilinear(Sz, Sp, Sg, T = 2 * tan(1/2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Sz</code></td>
<td>
<p>In the generic case, a model to be transformed. In the default
case, a vector containing the zeros in a pole-zero-gain model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to the generic function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p>the sampling frequency represented in the z plane. Default:
<code>2 * tan(1 / 2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sp</code></td>
<td>
<p>a vector containing the poles in a pole-zero-gain model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sg</code></td>
<td>
<p>a vector containing the gain in a pole-zero-gain model.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a piecewise flat filter design, you can transform it from the s-plane
to the z-plane while maintaining the band edges by means of the bilinear
transform. This maps the left hand side of the s-plane into the interior of
the unit circle. The mapping is highly non-linear, so you must design your
filter with band edges in the s-plane positioned at <code class="reqn">2/T tan(wT / 2)</code> so
that they will be positioned at <code>w</code> after the bilinear transform is
complete.
</p>
<p>The bilinear transform is:
</p>
<p style="text-align: center;"><code class="reqn">z = (1 + sT / 2) / (1 - sT / 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">s = (T / 2) (z - 1) / (z + 1)</code>
</p>

<p>Please note that a pole and a zero at the same place exactly cancel. This is
significant since the bilinear transform creates numerous extra poles and
zeros, most of which cancel. Those which do not cancel have a “fill-in”
effect, extending the shorter of the sets to have the same number of as the
longer of the sets of poles and zeros (or at least split the difference in
the case of the band pass filter). There may be other opportunistic
cancellations, but it will not check for them.
</p>
<p>Also note that any pole on the unit circle or beyond will result in an
unstable filter. Because of cancellation, this will only happen if the number
of poles is smaller than the number of zeros. The analytic design methods all
yield more poles than zeros, so this will not be a problem.
</p>


<h3>Value</h3>

<p>For the default case or for bilinear.Zpg, an object of class
<code>'Zpg'</code>, containing the list elements:
</p>

<dl>
<dt>z</dt>
<dd>
<p>complex vector of the zeros of the transformed model</p>
</dd>
<dt>p</dt>
<dd>
<p>complex vector of the poles of the transformed model</p>
</dd>
<dt>g</dt>
<dd>
<p>gain of the transformed model</p>
</dd>
</dl>
<p>For bilinear.Arma, an object of class <code>'Arma'</code>, containing the list
elements:
</p>

<dl>
<dt>b</dt>
<dd>
<p>moving average (MA) polynomial coefficients</p>
</dd>
<dt>a</dt>
<dd>
<p>autoregressive (AR) polynomial coefficients</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Paul Kienzle <a href="mailto:pkienzle@users.sf.net">pkienzle@users.sf.net</a>. Conversion to R by Tom
Short, adapted by Geert van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bilinear_transform">https://en.wikipedia.org/wiki/Bilinear_transform</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 6th order Bessel low-pass analog filter
zp &lt;- besselap(6)
w &lt;- seq(0, 4, length.out = 128)
freqs(zp, w)
zzp &lt;- bilinear(zp)
freqz(zzp)

</code></pre>


</div>