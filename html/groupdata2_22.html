<div class="container">

<table style="width: 100%;"><tr>
<td>partition</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create balanced partitions</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>Splits data into partitions.
Balances a given categorical variable and/or numerical variable between partitions and keeps (if possible)
all data points with a shared ID (e.g. participant_id) in the same partition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">partition(
  data,
  p = 0.2,
  cat_col = NULL,
  num_col = NULL,
  id_col = NULL,
  id_aggregation_fn = sum,
  extreme_pairing_levels = 1,
  force_equal = FALSE,
  list_out = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code>. Can be <em>grouped</em>, in which case
the function is applied group-wise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>List or vector of partition sizes.
Given as whole number(s) and/or percentage(s) (<code>0</code> &lt; <code>`p`</code> &lt; <code>1</code>).
</p>
<p>E.g. <code class="reqn">c(0.2, 3, 0.1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cat_col</code></td>
<td>
<p>Name of categorical variable to balance between partitions.
</p>
<p>E.g. when training and testing a model for predicting a binary variable (a or b),
we usually want both classes represented in both the training set and the test set.
</p>
<p>N.B. If also passing an <code>`id_col`</code>, <code>`cat_col`</code> should be constant within each ID.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_col</code></td>
<td>
<p>Name of numerical variable to balance between partitions.
</p>
<p>N.B. When used with <code>`id_col`</code>, values in <code>`num_col`</code> for each ID are
aggregated using <code>`id_aggregation_fn`</code> before being balanced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_col</code></td>
<td>
<p>Name of factor with IDs. Used to keep all rows that share an ID in
the same partition (if possible).
</p>
<p>E.g. If we have measured a participant multiple times and want to see the
effect of time, we want to have all observations of this participant in
the same partition.
</p>
<p>N.B. When <code>`data`</code> is a <em>grouped</em> <code>data.frame</code>
(see <code>dplyr::group_by()</code>), IDs that appear in multiple
groupings might end up in different partitions in those groupings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_aggregation_fn</code></td>
<td>
<p>Function for aggregating values in <code>`num_col`</code> for each ID,
before balancing <code>`num_col`</code>.
</p>
<p>N.B. Only used when <code>`num_col`</code> and <code>`id_col`</code> are both specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extreme_pairing_levels</code></td>
<td>
<p>How many levels of extreme pairing to do
when balancing partitions by a numerical column (i.e. <code>`num_col`</code> is specified).
</p>
<p><strong>Extreme pairing</strong>: Rows/pairs are ordered as <em>smallest, largest,
second smallest, second largest</em>, etc. If <code>`extreme_pairing_levels` &gt; 1</code>,
this is done "recursively" on the extreme pairs. See <code>`Details/num_col`</code> for more.
</p>
<p>N.B. Larger values work best with large datasets. If set too high,
the result might not be stochastic. Always check if an increase
actually makes the partitions more balanced. See <code>`Examples`</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_equal</code></td>
<td>
<p>Whether to discard excess data. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list_out</code></td>
<td>
<p>Whether to return partitions in a <code>list</code>. (Logical)
</p>
<p><strong>N.B.</strong> When <code>`data`</code> is a grouped <code>data.frame</code>, the output is always a <code>data.frame</code>
with partition identifiers.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>cat_col</h4>


<ol>
<li> <p><code>`data`</code> is subset by <code>`cat_col`</code>.
</p>
</li>
<li>
<p> Subsets are partitioned and merged.
</p>
</li>
</ol>
<h4>id_col</h4>


<ol><li>
<p> Partitions are created from unique IDs.
</p>
</li></ol>
<h4>num_col</h4>


<ol>
<li>
<p>Rows are shuffled. <strong>Note</strong> that this will only affect rows with the same value in <code>`num_col`</code>.
</p>
</li>
<li>
<p>Extreme pairing 1: Rows are ordered as <em>smallest, largest, second smallest, second largest</em>, etc.
Each pair get a group identifier.
</p>
</li>
<li>
<p>If <code>`extreme_pairing_levels` &gt; 1</code>: The group identifiers are reordered as <em>smallest,
largest, second smallest, second largest</em>, etc., by the sum of <code>`num_col`</code> in the represented rows.
These pairs (of pairs) get a new set of group identifiers, and the process is repeated
<code>`extreme_pairing_levels`-2</code> times. Note that the group identifiers at the last level will represent
<code>2^`extreme_pairing_levels`</code> rows, why you should be careful when choosing that setting.
</p>
</li>
<li>
<p>The final group identifiers are shuffled, and their order is applied to the full dataset.
</p>
</li>
<li>
<p>The ordered dataset is split by the sizes in <code>`p`</code>.
</p>
</li>
</ol>
<p>N.B. When doing extreme pairing of an unequal number of rows,
the row with the largest value is placed in a group by itself, and the order is instead:
<em>smallest, second largest, second smallest, third largest, ...</em> , largest.
</p>



<h4>cat_col AND id_col</h4>


<ol>
<li> <p><code>`data`</code> is subset by <code>`cat_col`</code>.
</p>
</li>
<li>
<p> Partitions are created from unique IDs in each subset.
</p>
</li>
<li>
<p> Subsets are merged.
</p>
</li>
</ol>
<h4>cat_col AND num_col</h4>


<ol>
<li> <p><code>`data`</code> is subset by <code>`cat_col`</code>.
</p>
</li>
<li>
<p> Subsets are partitioned by <code>`num_col`</code>.
</p>
</li>
<li>
<p> Subsets are merged.
</p>
</li>
</ol>
<h4>num_col AND id_col</h4>


<ol>
<li>
<p> Values in <code>`num_col`</code> are aggregated for each ID, using <code>id_aggregation_fn</code>.
</p>
</li>
<li>
<p> The IDs are partitioned, using the aggregated values as "<code>num_col</code>".
</p>
</li>
<li>
<p> The partition identifiers are transferred to the rows of the IDs.
</p>
</li>
</ol>
<h4>cat_col AND num_col AND id_col</h4>


<ol>
<li>
<p> Values in <code>`num_col`</code> are aggregated for each ID, using <code>id_aggregation_fn</code>.
</p>
</li>
<li>
<p> IDs are subset by <code>`cat_col`</code>.
</p>
</li>
<li>
<p> The IDs for each subset are partitioned,
by using the aggregated values as "<code>num_col</code>".
</p>
</li>
<li>
<p> The partition identifiers are transferred to the rows of the IDs.
</p>
</li>
</ol>
<h3>Value</h3>

<p>If <code>`list_out`</code> is <code>TRUE</code>:
</p>
<p>A <code>list</code> of partitions where partitions are <code>data.frame</code>s.
</p>
<p>If <code>`list_out`</code> is <code>FALSE</code>:
</p>
<p>A <code>data.frame</code> with grouping factor for subsetting.
</p>
<p><strong>N.B.</strong> When <code>`data`</code> is a grouped <code>data.frame</code>,
the output is always a <code>data.frame</code> with a grouping factor.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other grouping functions: 
<code>all_groups_identical()</code>,
<code>collapse_groups_by</code>,
<code>collapse_groups()</code>,
<code>fold()</code>,
<code>group_factor()</code>,
<code>group()</code>,
<code>splt()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Attach packages
library(groupdata2)
library(dplyr)

# Create data frame
df &lt;- data.frame(
  "participant" = factor(rep(c("1", "2", "3", "4", "5", "6"), 3)),
  "age" = rep(sample(c(1:100), 6), 3),
  "diagnosis" = factor(rep(c("a", "b", "a", "a", "b", "b"), 3)),
  "score" = sample(c(1:100), 3 * 6)
)
df &lt;- df %&gt;% arrange(participant)
df$session &lt;- rep(c("1", "2", "3"), 6)

# Using partition()

# Without balancing
partitions &lt;- partition(data = df, p = c(0.2, 0.3))

# With cat_col
partitions &lt;- partition(data = df, p = 0.5, cat_col = "diagnosis")

# With id_col
partitions &lt;- partition(data = df, p = 0.5, id_col = "participant")

# With num_col
partitions &lt;- partition(data = df, p = 0.5, num_col = "score")

# With cat_col and id_col
partitions &lt;- partition(
  data = df,
  p = 0.5,
  cat_col = "diagnosis",
  id_col = "participant"
)

# With cat_col, num_col and id_col
partitions &lt;- partition(
  data = df,
  p = 0.5,
  cat_col = "diagnosis",
  num_col = "score",
  id_col = "participant"
)

# Return data frame with grouping factor
# with list_out = FALSE
partitions &lt;- partition(df, c(0.5), list_out = FALSE)

# Check if additional extreme_pairing_levels
# improve the numerical balance
set.seed(2) # try with seed 1 as well
partitions_1 &lt;- partition(
  data = df,
  p = 0.5,
  num_col = "score",
  extreme_pairing_levels = 1,
  list_out = FALSE
)
partitions_1 %&gt;%
  dplyr::group_by(.partitions) %&gt;%
  dplyr::summarise(
    sum_score = sum(score),
    mean_score = mean(score)
  )
set.seed(2) # try with seed 1 as well
partitions_2 &lt;- partition(
  data = df,
  p = 0.5,
  num_col = "score",
  extreme_pairing_levels = 2,
  list_out = FALSE
)
partitions_2 %&gt;%
  dplyr::group_by(.partitions) %&gt;%
  dplyr::summarise(
    sum_score = sum(score),
    mean_score = mean(score)
  )
</code></pre>


</div>