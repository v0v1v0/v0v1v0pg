<div class="container">

<table style="width: 100%;"><tr>
<td>grouped</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Grouped operator</h2>

<h3>Description</h3>

<p>Make a function applicable to grouped data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grouped(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Deprecated. Additional arguments to <code>f</code> that should <em>not</em> be
treated as grouped.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A function like <code>f</code> with a new argument <code>group</code>. This accepts a factor to
split all other arguments in <code>f</code> into groups before applying <code>f</code> to each
group and combining the results. It is similar to <code>ave()</code>, but more general.
</p>


<h3>See Also</h3>

<p>Other operators: 
<code>balanced()</code>,
<code>quantity_index()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">p1 &lt;- price6[[3]]
p0 &lt;- price6[[2]]
q1 &lt;- quantity6[[3]]
q0 &lt;- quantity6[[2]]

# Calculate Tornqvist weights for two groups

f &lt;- factor(rep(letters[1:2], each = 3))
tornqvist_weights &lt;- grouped(index_weights("Tornqvist"))
tornqvist_weights(p1, p0, q1, q0, group = f)

# Calculate a mean like ave(), but with weights

x &lt;- 1:6
w &lt;- c(1:5, NA)
grouped_mean &lt;- grouped(\(x, w) geometric_mean(x, w, na.rm = TRUE))
grouped_mean(x, w, group = f)

# Redistribute weights

w1 &lt;- c(2, 4)
w2 &lt;- 1:6

harmonic_mean(mapply(harmonic_mean, split(x, f), split(w2, f)), w1)

wr &lt;- grouped(scale_weights)(w2, group = f) * w1[f]
harmonic_mean(x, wr)

</code></pre>


</div>