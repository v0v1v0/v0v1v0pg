<div class="container">

<table style="width: 100%;"><tr>
<td>glmmTMBControl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Control parameters for glmmTMB optimization</h2>

<h3>Description</h3>

<p>Control parameters for glmmTMB optimization
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmmTMBControl(
  optCtrl = NULL,
  optArgs = list(),
  optimizer = nlminb,
  profile = FALSE,
  collect = FALSE,
  parallel = list(n = getOption("glmmTMB.cores", 1L), autopar =
    getOption("glmmTMB.autopar", NULL)),
  eigval_check = TRUE,
  zerodisp_val = log(.Machine$double.eps)/4,
  start_method = list(method = NULL, jitter.sd = 0),
  rank_check = c("adjust", "warning", "stop", "skip"),
  conv_check = c("warning", "skip")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>optCtrl</code></td>
<td>
<p>Passed as argument <code>control</code> to optimizer. Default value (if default <code>nlminb</code> optimizer is used): <code>list(iter.max=300, eval.max=400)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optArgs</code></td>
<td>
<p>additional arguments to be passed to optimizer function (e.g.: <code>list(method="BFGS")</code> when <code>optimizer=optim</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>Function to use in model fitting. See <code>Details</code> for required properties of this function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>profile</code></td>
<td>
<p>(logical) Experimental option to improve speed and
robustness when a model has many fixed effects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collect</code></td>
<td>
<p>(logical) Experimental option to improve speed by
recognizing duplicated observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>(named list with an integer value <code>n</code> and a logical value <code>autopar</code>,
e.g. <code>list(n=4L, autopar=TRUE)</code>) Set number of OpenMP threads to evaluate
the negative log-likelihood in parallel, and determine whether to use auto-parallelization
(see <code>openmp</code>). The default is to evaluate
models serially (i.e. single-threaded); users can set default values
for an R session via <code>options(glmmTMB.cores=&lt;value&gt;, glmmTMB.autopar=&lt;value&gt;)</code>.
An integer number of cores (only) can be passed instead of a list, in which case the default or
previously set value of <code>autopar</code> will be used.
At present reduced-rank models (i.e., a covariance structure using <code>rr(...)</code>)
cannot be fitted in parallel unless <code>autopar=TRUE</code>; the number of threads will be automatically
set to 1, with a warning if this overrides the user-specified value.
To trace OpenMP settings, use <code>options(glmmTMB_openmp_debug = TRUE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigval_check</code></td>
<td>
<p>Check eigenvalues of variance-covariance matrix? (This test may be very slow for models with large numbers of fixed-effect parameters.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zerodisp_val</code></td>
<td>
<p>value of the dispersion parameter when <code>dispformula=~0</code> is specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_method</code></td>
<td>
<p>(list) Options to initialize the starting values when fitting models with reduced-rank (<code>rr</code>) covariance structures; <code>jitter.sd</code> adds variation to the starting values of latent variables when <code>method = "res"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank_check</code></td>
<td>
<p>Check whether all parameters in fixed-effects models are identifiable? This test may be slow for models with large numbers of fixed-effect parameters, therefore default value is 'warning'. Alternatives include 'skip' (no check), 'stop' (throw an error), and 'adjust' (drop redundant columns from the fixed-effect model matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv_check</code></td>
<td>
<p>Do basic checks of convergence (check for non-positive definite Hessian and non-zero convergence code from optimizer). Default is 'warning'; 'skip' ignores these tests (not recommended for general use!)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default, <code>glmmTMB</code> uses the nonlinear optimizer
<code>nlminb</code> for parameter estimation. Users may sometimes
need to adjust optimizer settings in order to get models to
converge. For instance, the warning ‘iteration limit reached
without convergence’ may be fixed by increasing the number of
iterations using (e.g.)
</p>
<p><code>glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3))</code>.
</p>
<p>Setting <code>profile=TRUE</code> allows <code>glmmTMB</code> to use some special
properties of the optimization problem in order to speed up estimation
in cases with many fixed effects.
</p>
<p>Control parameters may depend on the model specification. The value
of the controls is evaluated inside an R object that is derived from
the output of the <code>mkTMBStruc</code> function. For example,
to specify that <code>profile</code> should be enabled if the model has
more than 5 fixed-effect parameters, specify
</p>
<p><code>profile=quote(length(parameters$beta)&gt;=5)</code>
</p>
<p>The <code>optimizer</code> argument can be any optimization (minimizing) function, provided that:
</p>

<ul>
<li>
<p> the first three arguments, in order, are the starting values, objective function, and gradient function;
</p>
</li>
<li>
<p> the function also takes a <code>control</code> argument;
</p>
</li>
<li>
<p> the function returns a list with elements (at least) <code>par</code>, <code>objective</code>, <code>convergence</code> (0 if convergence is successful) and <code>message</code>
(<code>glmmTMB</code> automatically handles output from <code>optim()</code>, by renaming the <code>value</code> component to <code>objective</code>)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## fit with default (nlminb) and alternative (optim/BFGS) optimizer
m1 &lt;- glmmTMB(count~ mined, family=poisson, data=Salamanders)
m1B &lt;- update(m1, control=glmmTMBControl(optimizer=optim,
               optArgs=list(method="BFGS")))
## estimates are *nearly* identical:
all.equal(fixef(m1), fixef(m1B))
</code></pre>


</div>