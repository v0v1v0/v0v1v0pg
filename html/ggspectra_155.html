<div class="container">

<table style="width: 100%;"><tr>
<td>stat_peaks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find peaks and valleys.</h2>

<h3>Description</h3>

<p><code>stat_peaks</code> finds at which x positions local maxima are located. If
you want find local minima, you can use <code>stat_valleys</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_peaks(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  span = 5,
  ignore_threshold = 0.01,
  strict = is.null(span),
  refine.wl = FALSE,
  method = "spline",
  chroma.type = "CMF",
  label.fmt = "%.3g",
  x.label.fmt = label.fmt,
  y.label.fmt = label.fmt,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE
)

stat_valleys(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  span = 5,
  ignore_threshold = -0.01,
  strict = is.null(span),
  refine.wl = FALSE,
  method = "spline",
  chroma.type = "CMF",
  label.fmt = "%.3g",
  x.label.fmt = label.fmt,
  y.label.fmt = label.fmt,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code> or <code>aes_</code>. Only needs to be set
at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points
on this layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This can
include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>span</code></td>
<td>
<p>integer A peak is defined as an element in a sequence which is
greater than all other elements within a window of width <code>span</code>
centered at that element. Use <code>NULL</code> for the global peak. Valleys are
the reverse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_threshold</code></td>
<td>
<p>numeric For peaks, value between 0.0 and 1.0
indicating the relative size of peaks compared to tallest peak threshold
below which peaks will be ignored, while negative values between 0.0 and
-1.0 set a threshold so that the tallest peaks are ignored, instead of the
shortest. For valleys, value between 0.0 and 1.0 indicating the relative
depth of valleys below which valleys will be ignored, while negative values
between 0.0 and -1.0 set a threshold so that the deeper valleys are
ignored, instead of the shallower ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>logical If <code>TRUE</code>, an element must be strictly greater
than all other values in its window to be considered a peak.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine.wl</code></td>
<td>
<p>logical Flag indicating if peak or valleys locations should
be refined by fitting a function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character String with the name of a method used for peak
fitting. Currently only spline interpolation is implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chroma.type</code></td>
<td>
<p>character one of "CMF" (color matching function) or "CC"
(color coordinates) or a <code>chroma_spct</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
values into character strings by means of function <code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
$x$-values into character strings by means of function <code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
$y$-values into character strings by means of function <code>sprintf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These stats use <code>geom_point</code> by default as it is the geom most
likely to work well in almost any situation without need of tweaking. The
default aesthetics set by these stats allow their direct use with
<code>geom_text</code>, <code>geom_label</code>, <code>geom_line</code>, <code>geom_rug</code>,
<code>geom_hline</code> and <code>geom_vline</code>. The formatting of the labels
returned can be controlled by the user.
</p>


<h3>Value</h3>

<p>A data frame with one row for each peak (or valley) found in the
data.
</p>


<h3>Computed variables</h3>


<dl>
<dt>x</dt>
<dd>
<p>x-value at the peak (or valley) as numeric</p>
</dd>
<dt>y</dt>
<dd>
<p>y-value at the peak (or valley) as numeric</p>
</dd>
<dt>x.label</dt>
<dd>
<p>x-value at the peak (or valley) formatted as character</p>
</dd>
<dt>y.label</dt>
<dd>
<p>y-value at the peak (or valley) formatted as character</p>
</dd>
<dt>wl.color</dt>
<dd>
<p>color definition calculated by assuming that x-values are
wavelengths expressed in nanometres.</p>
</dd>
<dt>BW.color</dt>
<dd>
<p>color definition, either "black" or "white", as needed to
ensure high contrast to <code>wl.color</code>.</p>
</dd>
</dl>
<h3>Default aesthetics</h3>

<p>Set by the statistic and available to geoms.
</p>

<dl>
<dt>label</dt>
<dd>
<p>stat(x.label)</p>
</dd>
<dt>xintercept</dt>
<dd>
<p>stat(x)</p>
</dd>
<dt>yintercept</dt>
<dd>
<p>stat(y)</p>
</dd>
<dt>fill</dt>
<dd>
<p>stat(wl.color)</p>
</dd>
</dl>
<h3>Required aesthetics</h3>

<p>Required by the statistic and need to be set with <code>aes()</code>.
</p>

<dl>
<dt>x</dt>
<dd>
<p>numeric, wavelength in nanometres</p>
</dd>
<dt>y</dt>
<dd>
<p>numeric, a spectral quantity</p>
</dd>
</dl>
<h3>Note</h3>

<p>These stats work nicely together with geoms
<code>geom_text_repel</code> and
<code>geom_label_repel</code> from package
<code>ggrepel</code> to solve the problem of overlapping labels
by displacing them. To discard overlapping labels use <code>check_overlap =
  TRUE</code> as argument to <code>geom_text</code>.
By default the labels are character values suitable to be plotted as is, but
with a suitable <code>label.fmt</code> labels suitable for parsing by the geoms
(e.g. into expressions containing greek letters or super or subscripts) can
be also easily obtained.
</p>


<h3>See Also</h3>

<p><code>find_peaks</code>, which is used internally.
</p>
<p>Other stats functions: 
<code>stat_color()</code>,
<code>stat_find_qtys()</code>,
<code>stat_find_wls()</code>,
<code>stat_label_peaks()</code>,
<code>stat_spikes()</code>,
<code>stat_wb_box()</code>,
<code>stat_wb_column()</code>,
<code>stat_wb_contribution()</code>,
<code>stat_wb_hbar()</code>,
<code>stat_wb_irrad()</code>,
<code>stat_wb_label()</code>,
<code>stat_wb_mean()</code>,
<code>stat_wb_relative()</code>,
<code>stat_wb_sirrad()</code>,
<code>stat_wb_total()</code>,
<code>stat_wl_strip()</code>,
<code>stat_wl_summary()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# ggplot() methods for spectral objects set a default mapping for x and y.
ggplot(sun.spct) +
  geom_line() +
  stat_peaks()

ggplot(sun.spct) +
  geom_line() +
  stat_valleys()

ggplot(sun.spct) +
  geom_line() +
  stat_peaks(span = 51, geom = "point", colour = "red") +
  stat_peaks(span = 51, geom = "text", colour = "red",
             vjust = -0.4, label.fmt = "%3.2f nm")

ggplot(sun.spct) +
  geom_line() +
  stat_peaks(span = 51, geom = "point", colour = "red", refine.wl = TRUE) +
  stat_peaks(span = 51, geom = "text", colour = "red",
             vjust = -0.4, label.fmt = "%3.2f nm",
             refine.wl = TRUE)

ggplot(sun.spct) +
  geom_line() +
  stat_peaks(span = 51, geom = "point", colour = "red", refine.wl = TRUE) +
  stat_peaks(mapping = aes(fill = after_stat(wl.colour), color = after_stat(BW.colour)),
             span = 51, geom = "label",
             size = 3, vjust = -0.2, label.fmt = "%.3g nm",
             refine.wl = TRUE) +
  stat_valleys(span = 71, geom = "point", colour = "blue", refine.wl = TRUE) +
  stat_valleys(mapping = aes(fill = after_stat(wl.colour), color = after_stat(BW.colour)),
               span = 71, geom = "label",
               size = 3, vjust = 1.2, label.fmt = "%.3g nm",
               refine.wl = TRUE) +
  expand_limits(y = 0.85) + # make room for label
  scale_fill_identity() +
  scale_color_identity()

</code></pre>


</div>