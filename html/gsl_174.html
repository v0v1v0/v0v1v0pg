<div class="container">

<table style="width: 100%;"><tr>
<td>Gamma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>gamma functions</h2>

<h3>Description</h3>

<p>Gamma functions as per the Gnu Scientific Library reference manual
section 7.19.  These functions are declared in header file
<code>gsl_sf_gamma.h</code> 
</p>


<h3>Usage</h3>

<pre><code class="language-R">gsl_sf_gamma(x,give=FALSE,strict=TRUE)
lngamma(x,give=FALSE,strict=TRUE)
lngamma_sgn(x,give=FALSE,strict=TRUE)
gammastar(x,give=FALSE,strict=TRUE)
gammainv(x,give=FALSE,strict=TRUE)
lngamma_complex(zr, zi=NULL, r.and.i=TRUE, give=FALSE, strict=TRUE)
taylorcoeff(n,x,give=FALSE,strict=TRUE)
fact(n,give=FALSE,strict=TRUE)
doublefact(n,give=FALSE,strict=TRUE)
lnfact(n,give=FALSE,strict=TRUE)
lndoublefact(n,give=FALSE,strict=TRUE)
gsl_sf_choose(n,m,give=FALSE,strict=TRUE)
lnchoose(n,m,give=FALSE,strict=TRUE)
poch(a,x,give=FALSE,strict=TRUE)
lnpoch(a,x,give=FALSE,strict=TRUE)
lnpoch_sgn(a,x,give=FALSE,strict=TRUE)
pochrel(a,x,give=FALSE,strict=TRUE)
gamma_inc_Q(a,x,give=FALSE,strict=TRUE)
gamma_inc_P(a,x,give=FALSE,strict=TRUE)
gamma_inc(a,x,give=FALSE,strict=TRUE)
gsl_sf_beta(a,b,give=FALSE,strict=TRUE)
lnbeta(a,b,give=FALSE,strict=TRUE)
beta_inc(a,b,x,give=FALSE,strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x,a,b</code></td>
<td>
<p>input: real values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m,n</code></td>
<td>
<p>input: integer value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zr</code></td>
<td>
<p>In <code>gamma_complex()</code>, the real part of the argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zi</code></td>
<td>
<p>In <code>gamma_complex()</code>, the imaginary part of the
argument.  If missing (ie takes the default value of <code>NULL</code>),
interpret <code>zr</code> as complex, even if real</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.and.i</code></td>
<td>
<p>In <code>gamma_complex()</code>, Boolean variable with
default value of <code>TRUE</code> meaning to return a complex variable as
per the details section below; and <code>FALSE</code> meaning to return
the values as advertised in the <abbr><span class="acronym">GSL</span></abbr> manual</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All functions as documented in the <abbr><span class="acronym">GSL</span></abbr> reference manual section 7.19.
</p>
<p>Note that <code>gamma_inc_P()</code> gives the area of the left tail of the
gamma distribution so, for example, <code>gamma_inc_P(1.8, 5) =
  pgamma(5, 1.8)</code> to numerical accuracy.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class="language-R">gsl_sf_gamma(3)

lngamma_complex(1+seq(from=0,to=5,by=0.1)*1i)  #table 6.7, p 277 (LH col)
                                               #note 2pi phase diff


jj &lt;- expand.grid(1:10,2:5)
x &lt;- taylorcoeff(jj$Var1,jj$Var2)
dim(x) &lt;- c(10,4)
x    #table 23.5, p818


jj &lt;- expand.grid(36:50,9:13)
x &lt;- gsl_sf_choose(jj$Var1,jj$Var2)
dim(x) &lt;- c(15,5)
x     #table 24.1, p829  (bottom bit)

gamma_inc(1.2,1.3)
beta(1.2, 1.3)
lnbeta(1.2,1.55)
beta_inc(1.2,1.4,1.6)

gamma_inc_P(1.8, 5) - pgamma(5, 1.8)  # should be small

</code></pre>


</div>