<div class="container">

<table style="width: 100%;"><tr>
<td>rotations</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rotations</h2>

<h3>Description</h3>

<p>Optimize factor loading rotation objective.
</p>


<h3>Usage</h3>

<pre><code class="language-R">    oblimin(A, Tmat=diag(ncol(A)), gam=0, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    quartimin(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    targetT(A, Tmat=diag(ncol(A)), Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    targetQ(A, Tmat=diag(ncol(A)), Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    pstT(A, Tmat=diag(ncol(A)), W=NULL, Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    pstQ(A, Tmat=diag(ncol(A)), W=NULL, Target=NULL, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0, L=NULL)
    oblimax(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    entropy(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    quartimax(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5,maxit=1000,randomStarts=0)
    Varimax(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    simplimax(A, Tmat=diag(ncol(A)), k=nrow(A), normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    bentlerT(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    bentlerQ(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    tandemI(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    tandemII(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    geominT(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    geominQ(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    bigeominT(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    bigeominQ(A, Tmat=diag(ncol(A)), delta=.01, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    cfT(A, Tmat=diag(ncol(A)), kappa=0, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    cfQ(A, Tmat=diag(ncol(A)), kappa=0, normalize=FALSE, eps=1e-5, 
    		maxit=1000, randomStarts=0)
    equamax(A, Tmat=diag(ncol(A)), kappa=ncol(A)/(2*nrow(A)), normalize=FALSE,
    		eps=1e-5, maxit=1000, randomStarts = 0)
    parsimax(A, Tmat=diag(ncol(A)), kappa=(ncol(A)-1)/(ncol(A)+nrow(A)-2), 
    		normalize=FALSE, eps=1e-5, maxit=1000, randomStarts = 0)
    infomaxT(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    infomaxQ(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    mccammon(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    varimin(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000, randomStarts=0)
    bifactorT(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000,randomStarts=0)
    bifactorQ(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000,randomStarts=0)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>an initial loadings matrix to be rotated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam</code></td>
<td>
<p>0=Quartimin, .5=Biquartimin, 1=Covarimin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Target</code></td>
<td>
<p>rotation target for objective calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>weighting of each element in target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of close to zero loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>constant added to Lambda^2 in objective calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>parameter passed to optimization routine (GPForth or GPFoblq).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>parameter passed to optimization routine (GPForth or GPFoblq).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>parameter passed to optimization routine (GPForth or GPFoblq).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomStarts</code></td>
<td>
<p>parameter passed to optimization routine (GPFRSorth or GPFRSoblq).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>provided for backward compatibility in target rotations only. Use A going forward.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions optimize a rotation objective. They can be used directly or the
function name can be passed to factor analysis functions like <code>factanal</code>.
Several of the function names end in T or Q, which indicates if they are
orthogonal or oblique rotations (using <code>GPFRSorth</code> or <code>GPFRSoblq</code>
respectively).  
</p>
<p>Rotations which are available are 
</p>

<table>
<tr>
<td style="text-align: left;">
 <code>oblimin</code>   </td>
<td style="text-align: left;"> oblique    </td>
<td style="text-align: left;">  oblimin family 			</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>quartimin</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>targetT</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>targetQ</code>   </td>
<td style="text-align: left;"> oblique    </td>
<td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>pstT</code>	   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>pstQ</code>	   </td>
<td style="text-align: left;"> oblique    </td>
<td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>oblimax</code>   </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>entropy</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  minimum entropy			</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>quartimax</code> </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 					</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>varimax</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 					</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>simplimax</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         				</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>bentlerT</code>  </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>bentlerQ</code>  </td>
<td style="text-align: left;"> oblique    </td>
<td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>tandemI</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Tandem principle I criterion		   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>tandemII</code>  </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Tandem principle II criterion		   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>geominT</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>geominQ</code>   </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         			   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>bigeominT</code> </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>bigeominQ</code> </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         			   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>cfT</code>	   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>cfQ</code>	   </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>equamax</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>parsimax</code>  </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>infomaxT</code>  </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>infomaxQ</code>  </td>
<td style="text-align: left;"> oblique	   </td>
<td style="text-align: left;">         			   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>mccammon</code>  </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  McCammon minimum entropy ratio    </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>varimin</code>   </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;"> 				   </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>bifactorT</code> </td>
<td style="text-align: left;"> orthogonal </td>
<td style="text-align: left;">  Jennrich and Bentler bifactor rotation</td>
</tr>
<tr>
<td style="text-align: left;">
 <code>bifactorQ</code> </td>
<td style="text-align: left;"> oblique    </td>
<td style="text-align: left;">  Jennrich and Bentler biquartimin rotation</td>
</tr>
<tr>
<td style="text-align: left;">
 </td>
</tr>
</table>
<p>Note that <code>Varimax</code> defined here uses <code>vgQ.varimax</code> and 
is not <code>varimax</code>
defined in the <code>stats</code> package. <code>stats:::varimax</code> does Kaiser 
normalization by default whereas <code>Varimax</code> defined here does not.
</p>
<p>The argument <code>kappa</code> parameterizes the family for the Crawford-Ferguson 
method. If <code>m</code> is the number of factors and <code>p</code> is the number of 
indicators then <code>kappa</code> values having special names are 0=Quartimax, 
1/p=Varimax, m/(2*p)=Equamax, (m-1)/(p+m-2)=Parsimax, 1=Factor parsimony.
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>factanal</code>) with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>Lh from <code>GPFRSorth</code> or <code>GPFRSoblq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th</code></td>
<td>
<p>Th from <code>GPFRSorth</code> or <code>GPFRSoblq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Table</code></td>
<td>
<p>Table from <code>GPForth</code> or <code>GPFoblq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>Convergence indicator from <code>GPFRSorth</code> or <code>GPFRSoblq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPFRSorth and GPForth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randStartChar</code></td>
<td>
<p>Vector indicating results from random starts 
from <code>GPFRSorth</code> or <code>GPFRSoblq</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676–696.
</p>
<p>Bifactor rotation, bifactorT and bifactorQ are called bifactor and
biquartimin in Jennrich, R.I. and Bentler, P.M. 
(2011) Exploratory bi-factor analysis. <em>Psychometrika</em>, <b>76</b>. 
</p>


<h3>See Also</h3>

<p><code>GPFRSorth</code>, 
<code>GPFRSoblq</code>, 
<code>vgQ</code>,
<code>eiv</code>, 
<code>echelon</code>, 
<code>WansbeekMeijer</code>, 
<code>factanal</code>, 
<code>varimax</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  # see GPFRSorth and GPFRSoblq for more examples
  
  # getting loadings matrices
  data("Harman", package="GPArotation")
  qHarman  &lt;- GPFRSorth(Harman8, Tmat=diag(2), method="quartimax")
  qHarman &lt;- quartimax(Harman8) 
  loadings(qHarman) - qHarman$loadings   #2 ways to get the loadings

  # factanal loadings used in GPArotation
  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 2, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  quartimax(loadings(fa.unrotated), normalize=TRUE)
  geominQ(loadings(fa.unrotated), normalize=TRUE, randomStarts=100)

  # passing arguments to factanal (See vignette for a caution)
  # vignette("GPAguide", package = "GPArotation")
  data(ability.cov)
  factanal(factors = 2, covmat = ability.cov, rotation="infomaxT")
  factanal(factors = 2, covmat = ability.cov, rotation="infomaxT", 
    control=list(rotate=list(normalize = TRUE, eps = 1e-6)))
  # when using factanal for oblique rotation it is best to use the rotation command directly
  # instead of including it in the factanal command (see Vignette).  
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  quartimin(loadings(fa.unrotated), normalize=TRUE)

  # oblique target rotation of 2 varimax rotated matrices towards each other
  # See vignette for additional context and computation,
  trBritain &lt;- matrix( c(.783,-.163,.811,.202,.724,.209,.850,.064,
    -.031,.592,-.028,.723,.388,.434,.141,.808,.215,.709), byrow=TRUE, ncol=2)
  trGermany &lt;- matrix( c(.778,-.066, .875,.081, .751,.079, .739,.092,
    .195,.574, -.030,.807, -.135,.717, .125,.738, .060,.691), byrow=TRUE, ncol = 2)
  trx &lt;- targetQ(trGermany, Target = trBritain)
  # Difference between rotated loadings matrix and target matrix 
  y &lt;- trx$loadings - trBritain
  
  # partially specified target; See vignette for additional method
  A &lt;- matrix(c(.664, .688, .492, .837, .705, .82, .661, .457, .765, .322, 
    .248, .304, -0.291, -0.314, -0.377, .397, .294, .428, -0.075,.192,.224,
    .037, .155,-.104,.077,-.488,.009), ncol=3)  
  SPA &lt;- matrix(c(rep(NA, 6), .7,.0,.7, rep(0,3), rep(NA, 7), 0,0, NA, 0, rep(NA, 4)), ncol=3)
  targetT(A, Target=SPA)

  # using random starts
  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, normalize=TRUE, rotation="none")
  # single rotation with a random start
  oblimin(loadings(fa.unrotated), Tmat=Random.Start(3))
  oblimin(loadings(fa.unrotated), randomStarts=1)
  # multiple random starts
  oblimin(loadings(fa.unrotated), randomStarts=100)

  # assessing local minima for box26 data
  data(Thurstone, package = "GPArotation")
  infomaxQ(box26, normalize = TRUE, randomStarts = 150)
  geominQ(box26, normalize = TRUE, randomStarts = 150)
  # for detailed investigation of local minima, consult package 'fungible' 
  # library(fungible)
  # faMain(urLoadings=box26, rotate="geominQ", rotateControl=list(numberStarts=150))
  # library(psych) # package 'psych' with random starts:
  # faRotations(box26, rotate = "geominQ", hyper = 0.15, n.rotations = 150)

  </code></pre>


</div>