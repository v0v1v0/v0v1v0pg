<div class="container">

<table style="width: 100%;"><tr>
<td>convmtx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convolution matrix</h2>

<h3>Description</h3>

<p>Returns the convolution matrix for a filter kernel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">convmtx(h, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Input, coerced to a vector, representing the filter kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Length of vector(s) that <code>h</code> is to be convolved with.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computing a convolution using <code>conv</code> when the signals are vectors is
generally more efficient than using <code>convmtx</code>. For multichannel signals,
however, when  a large number of vectors are to be convolved with the same
filter kernel, <code>convmtx</code> might be more efficient.
</p>
<p>The code <code>cm &lt;- convmtx(h, n)</code> computes the convolution matrix of the
filter kernel <code>h</code> with a vector of length <code>n</code>. Then, <code>cm 
x</code> gives the convolution of <code>h</code> and <code>x</code>.
</p>


<h3>Value</h3>

<p>Convolution matrix of input <code>h</code> for a vector of length <code>n</code>.
If <code>h</code> is a vector of length <code>m</code>, then the convolution matrix has
<code>m + n - 1</code> rows and <code>n</code> columns.
</p>


<h3>Author(s)</h3>

<p>David Bateman <a href="mailto:adb014@gmail.com">adb014@gmail.com</a>.<br> Conversion to R by Geert
van Boxtel <a href="mailto:G.J.M.vanBoxtel@gmail.com">G.J.M.vanBoxtel@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code>conv</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 1000
a &lt;- runif(N)
b &lt;- runif(N)
cm &lt;- convmtx(b, N)
d &lt;- cm %*% a

cref = conv(a, b)
all.equal(max(d - cref), 0)

</code></pre>


</div>