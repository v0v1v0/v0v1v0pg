<div class="container">

<table style="width: 100%;"><tr>
<td>fn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function Declarations with Quasiquotation</h2>

<h3>Description</h3>

<p><code>fn()</code> enables you to create (anonymous) functions, of arbitrary call
signature. Use it in place of the usual <code>function()</code> invocation whenever you
want to:
</p>

<ul>
<li> <p><strong>Be concise</strong>: The function declarations
</p>
<div class="sourceCode"><pre>  fn(x, y = 1 ~ x + y)

  function(x, y = 1) x + y
</pre></div>
<p>are equivalent.
</p>
</li>
<li> <p><strong>Enforce immutability</strong>: By enabling Tidyverse
quasiquotation, <code>fn()</code> allows you to “burn
in” values at the point of function creation. This guards against changes
in a function's enclosing environment. (See ‘Use Unquoting to Make
Robust Functions’.)
</p>
</li>
</ul>
<p><code>fn_()</code> is a variant of <code>fn()</code> that does <em>not</em> comprehend quasiquotation. It
is useful when you want unquoting (<code>`!!`</code>) or splicing (<code>`!!!`</code>)
operators in the function body to be literally interpreted, rather than
immediately invoked. (See ‘Quasiquotation’ for a complementary way to
literally interpret unquoting and splicing operators in <code>fn()</code>.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">fn(..., ..env = parent.frame())

fn_(..., ..env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Function declaration, which supports
quasiquotation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>..env</code></td>
<td>
<p>Environment in which to create the function (i.e., the
function's enclosing environment).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A function whose enclosing environment is <code>..env</code>.
</p>


<h3>Function Declarations</h3>

<p>A <strong>function declaration</strong> is an expression
that specifies a function's arguments and body, as a comma-separated
expression of the form
</p>
<div class="sourceCode"><pre>  arg1, arg2, ..., argN ~ body
</pre></div>
<p>or
</p>
<div class="sourceCode"><pre>  arg1, arg2, ..., argN, ~body
</pre></div>
<p>(Note in the second form that the body is a one-sided formula. This
distinction is relevant for argument splicing, see
‘Quasiquotation’.)
</p>

<ul>
<li>
<p> To the left of <code>~</code>, you write a conventional function-argument
declaration, just as in <code style="white-space: pre;">⁠function(&lt;arguments&gt;)⁠</code>: each of <code>arg1</code>, <code>arg2</code>,
..., <code>argN</code> is either a bare argument (e.g., <code>x</code> or <code>...</code>) or an
argument with default value (e.g., <code>x = 1</code>).
</p>
</li>
<li>
<p> To the right of <code>~</code>, you write the function body, i.e., an expression of
the arguments.
</p>
</li>
</ul>
<h3>Quasiquotation</h3>

<p>All parts of a function declaration support Tidyverse
quasiquotation:
</p>

<ul>
<li>
<p> To unquote values (of arguments or parts of the body), use <code style="white-space: pre;">⁠!!⁠</code>:
</p>
<div class="sourceCode"><pre>  z &lt;- 0
  fn(x, y = !!z ~ x + y)
  fn(x ~ x &gt; !!z)
</pre></div>
</li>
<li>
<p> To unquote argument names (with default value), use <code style="white-space: pre;">⁠:=⁠</code> (definition
operator):
</p>
<div class="sourceCode"><pre>  arg &lt;- "y"
  fn(x, !!arg := 0 ~ x + !!as.name(arg))
</pre></div>
</li>
<li>
<p> To splice in a (formal) list of arguments, use <code style="white-space: pre;">⁠!!!⁠</code>:
</p>
<div class="sourceCode"><pre>  # NB: Body is a one-sided formula
  fn(!!!alist(x, y = 0), ~ x + y)
</pre></div>
<p>Splicing allows you to treat a complete function declaration as a unit:
</p>
<div class="sourceCode"><pre>  soma &lt;- alist(x, y = 0, ~ x + y)
  fn(!!!soma)
</pre></div>
</li>
<li>
<p> To write literal unquoting operators, use <code>QUQ()</code>, <code>QUQS()</code>, which read
as “quoted unquoting,” “quoted unquote-splicing,” resp. (cf.
<code>fn_()</code>):
</p>
<div class="sourceCode"><pre>  library(dplyr)

  my_summarise &lt;- fn(df, ... ~ {
    groups &lt;- quos(...)
    df %&gt;%
      group_by(QUQS(groups)) %&gt;%
      summarise(a = mean(a))
  })
</pre></div>
<p>(Source: <a href="https://dplyr.tidyverse.org/articles/programming.html">Programming with dplyr</a>)
</p>
</li>
</ul>
<h3>Use Unquoting to Make Robust Functions</h3>

<p>Functions in R are generally
<a href="https://en.wikipedia.org/wiki/Pure_function">impure</a>, i.e., the return
value of a function will <em>not</em> in general be determined by the value of its
inputs alone. This is because, by design, a function may depend on objects
in its
<a href="https://adv-r.hadley.nz/functions.html#lexical-scoping">lexical scope</a>, and
these objects may mutate between function calls. Normally this isn't a
hazard.
</p>
<p>However, if you are working interactively and sourcing files into the
global environment, or using a notebook interface like
<a href="https://jupyter.org">Jupyter</a> or
<a href="https://bookdown.org/yihui/rmarkdown/notebook.html">R Notebook</a>, it can be
tricky to ensure that you haven't unwittingly mutated an object that an
earlier function depends upon.
</p>
<p>You can use unquoting to guard against such mutations.
</p>


<h4>Example</h4>

<p>Consider the following function:
</p>
<div class="sourceCode"><pre>  a &lt;- 1
  foo &lt;- function(x) x + a
</pre></div>
<p>What is the value of <code>foo(1)</code>? It is not necessarily <code>2</code>, because the value
of <code>a</code> may have changed between the <em>creation</em> of <code>foo()</code> and the <em>calling</em>
of <code>foo(1)</code>:
</p>
<div class="sourceCode"><pre>  foo(1)  #&gt; [1] 2

  a &lt;- 0

  foo(1)  #&gt; [1] 1
</pre></div>
<p>In other words, <code>foo()</code> is impure because the value of <code>foo(x)</code> depends not
only on the value of <code>x</code> but also on the <em>externally mutable</em> value of <code>a</code>.
</p>
<p>With <code>fn()</code>, you can unquote <code>a</code> to “burn in” its value at the point
of creation:
</p>
<div class="sourceCode"><pre>  a &lt;- 1
  foo &lt;- fn(x ~ x + !!a)
</pre></div>
<p>Now <code>foo()</code> is a pure function, unaffected by changes to <code>a</code> in the lexical
scope:
</p>
<div class="sourceCode"><pre>  foo(1)  #&gt; [1] 2

  a &lt;- 0

  foo(1)  #&gt; [1] 2
</pre></div>



<h3>Examples</h3>

<pre><code class="language-R">fn(x ~ x + 1)
fn(x, y ~ x + y)
fn(x, y = 2 ~ x + y)
fn(x, y = 1, ... ~ log(x + y, ...))

# to specify '...' in the middle, write '... = '
fn(x, ... = , y ~ log(x + y, ...))

# use one-sided formula for constant functions or commands
fn(~ NA)
fn(~ message("!"))

# unquoting is supported (using `!!` from rlang)
zero &lt;- 0
fn(x = !!zero ~ x &gt; !!zero)

# formals and function bodies can also be spliced in
f &lt;- function(x, y) x + y
g &lt;- function(y, x, ...) x - y
frankenstein &lt;- fn(!!!formals(f), ~ !!body(g))
stopifnot(identical(frankenstein, function(x, y) x - y))

# mixing unquoting and literal unquoting is possible
# (Assume dplyr is available, which provides group_by() and `%&gt;%`.)
summariser &lt;- quote(mean)
my_summarise &lt;- fn(df, ... ~ {
  groups &lt;- quos(...)
  df %&gt;%
    group_by(QUQS(groups)) %&gt;%          # literal unquote-splice
    summarise(a = `!!`(summariser)(a))  # substitute `mean`
})
my_summarise

# Use fn_() with fn() as a concise way to force ("pin down") bindings
# For example, the 'x' is immutable in the function produced by call_upon():
call_upon &lt;- fn_(x ~ fn(f ~ f(!!x)))
sapply(list(sin, cos), call_upon(0))  # [1] 0 1

# Return-value checking, as a functional transformation
enforce &lt;- fn_(condition ~
  fn(x ~ {
    stopifnot(!!substitute(condition))
    x
  })
)
no_nan &lt;- enforce(!is.nan(x))
log_strict &lt;- fn(x ~ no_nan(log(x)))
log_strict(2)        # [1] 0.6931472
try(log_strict(-1))  # Error: !is.nan(x) is not TRUE

</code></pre>


</div>