<div class="container">

<table style="width: 100%;"><tr>
<td>Predict</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predict method for objects of class 'gmSpatialModel'</h2>

<h3>Description</h3>

<p>This is a one-entry function for several spatial prediction and simulation methods, for model objects
of class gmSpatialModel. The several methods are chosen by means of <code>pars</code> objects of the
appropriate class.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Predict(object, newdata, pars, ...)

predict(object, ...)

## S3 method for class 'gmSpatialModel'
predict(object, newdata, pars = NULL, ...)

## S4 method for signature 'gmSpatialModel'
predict(object, newdata, pars = NULL, ...)

## S4 method for signature 'gmSpatialModel,ANY,ANY'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmNeighbourhoodSpecification'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmTurningBands'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmCholeskyDecomposition'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmSequentialSimulation'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmDirectSamplingParameters'
Predict(object, newdata, pars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a complete "gmSpatialModel", containing conditioning data and unconditional model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a collection of locations where a prediction/simulation is desired; this is typically
a <code>sp::SpatialPoints()</code>, a data.frame or similar of X-Y(-Z) coordinates; or perhaps for gridded data
an object of class  <code>sp::GridTopology()</code>, <code>sp::SpatialGrid()</code> or <code>sp::SpatialPixels()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars</code></td>
<td>
<p>parameters describing the method to use, <em>enclosed in an object of appropriate class</em>
(according to the method; see below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters for generic functionality, currently ignored</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Package "gmGeostats" aims at providing a broad series of algorithms for geostatistical prediction
and simulation. All can be accesses through this interface, provided that arguments <code>object</code> and <code>pars</code> are of the
appropriate kind. In <code>object</code>, the most important criterion is the nature of its slot <code>model</code>. In <code>pars</code>
its class counts: for the creation of informative parameters in the appropriate format and class, a series
of accessory functions are provided as well.
</p>
<p>Classical (gaussian-based two-point) geostatistics are obtained if <code>object@model</code> contains a covariance function,
or a variogram model. Argument <code>pars</code> can be created with functions such as <code>KrigingNeighbourhood()</code>,
<code>SequentialSimulation()</code>, <code>TurningBands()</code> or <code>CholeskyDecomposition()</code> to respectively trigger a cokriging, as
sequential Gaussian simulation, a turning bands simulation, or a simulation via Cholesky decomposition.
The kriging neighbourhood can as well be incorporated in the "gmSpatialModel" <code>object</code> directly, or even be
nested in a "SequentialSimulation" parameter object.
</p>
<p>Conversely, to run a multipoint geostatistics algorithm, the first condition is that <code>object@model</code> contains a
training image. Additionally, <code>pars</code> must describe the characteristics of the algorithm to use. Currently, only
direct sampling is available: it can be obtained by providing some parameter object created with a call to
<code>DirectSamplingParameters()</code>. This method requires <code>newdata</code> to be on a gridded set of locations (acceptable
object classes are <code>sp::gridTopology</code>, <code>sp::SpatialGrid</code>, <code>sp::SpatialPixels</code>, <code>sp::SpatialPoints</code> or <code>data.frame</code>,
for the last two a forced conversion to a grid will be attempted).
</p>


<h3>Value</h3>

<p>Depending on the nature of <code>newdata</code>, the result will be a data container of the same kind,
extended with the predictions or simulations. For instance, if we want to obtain predictions on the
locations of a "SpatialPoints", the result will be a <code>sp::SpatialPointsDataFrame()</code>; if we want to obtain
simulations on the coordinates provided by a "data.frame", the result will be a <code>DataFrameStack()</code> with
the spatial coordinates stored as an extra attribute; or if the input for a simulation is a masked grid of class
<code>sp::SpatialPixels()</code>, the result will be of class <code>sp::SpatialPixelsDataFrame()</code> which <code>data</code> slot will be
a DataFrameStack.
</p>


<h3>See Also</h3>

<p>Other gmSpatialModel: 
<code>as.gmSpatialModel()</code>,
<code>gmSpatialModel-class</code>,
<code>make.gmCompositionalGaussianSpatialModel()</code>,
<code>make.gmCompositionalMPSSpatialModel()</code>,
<code>make.gmMultivariateGaussianSpatialModel()</code>
</p>


</div>