<div class="container">

<table style="width: 100%;"><tr>
<td>geoGAM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Select sparse geoadditive model
</h2>

<h3>Description</h3>

<p>Selects a parsimonious geoadditive model from a large set of covariates with the aim of (spatial) prediction.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geoGAM(response, covariates = names(data)[!(names(data) %in% c(response,coords))],
       data, coords = NULL, weights = rep(1, nrow(data)),
       offset = TRUE, max.stop = 300, non.stationary = FALSE,
       sets = NULL, seed = NULL, validation.data = NULL,
       verbose = 0, cores = min(detectCores(),10))

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p> name of response as character. Responses currently supported: gaussian, binary, ordered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p> character vector of all covariates (factor, continuous). If not given, all columns of <code>data</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> data frame containing response, coordinates and covariates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>character vector of column names indicating spatial coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> weights used for model fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p> logical, use offset for component wise gradient boosting algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.stop</code></td>
<td>
<p> maximal number of boosting iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>non.stationary</code></td>
<td>
<p>logical, include non-stationary effects in model selection. This allows for spatial varying coefficients for continuous covariates, but increases computational effort.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sets</code></td>
<td>
<p> give predefined cross validation sets. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p> set random seed for splitting of the cross validation sets, if no <code>sets</code> are given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validation.data</code></td>
<td>
<p>data frame containing response, coordinates and covariates to compute independent validation statistics. This data set is used to calculate predictive performance at the end of model selection only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Should screen output be generated? 0 = none, &gt;0 create output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p> number of cores to be used for parallel computing </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Summary</strong>
</p>
<p><code>geoGAM</code> models smooth nonlinear relations between responses and single covariates and combines these model terms additively. Residual spatial autocorrelation is captured by a smooth function of spatial coordinates and nonstationary effects are included by interactions between covariates and smooth spatial functions. The core of fully automated model building for geoGAM is componentwise gradient boosting. The model selection procedures aims at obtaining sparse models that are open to check feasibilty of modelled relationships (<cite>Nussbaum et al. 2017a</cite>).
</p>
<p><code>geoGAM</code> to date models continuous, binary and ordinal responses. It is able to cope with numerous continuous and categorical covariates.
</p>
<p><strong>Generic model representation</strong>
</p>
<p>GAM expand the (possibly transformed) conditional
expectation of a response at given covariates <code class="reqn">s</code> as an additive series

</p>
<p style="text-align: center;"><code class="reqn">
    g\left(\rule{0pt}{14pt}\mathrm{E}[Y(\mathbf{s})\,|\,\mathbf{x}(\mathbf{s})]\right)
        = \nu + f(\mathbf{x}(\mathbf{s}))
    = \nu +  \sum_{j} f_{j}(x_{j}(\mathbf{s})),
  </code>
</p>


<p>where <code class="reqn">\nu</code> is a constant and <code class="reqn">f_{j}(x_{j}(\mathbf{s}))</code> are linear
terms or unspecified “smooth” nonlinear functions of single covariates <code class="reqn">x_{j}(\mathbf{s})</code>
(e.g. smoothing spline, kernel or
any other scatterplot smoother) and <code class="reqn">g(\cdot)</code> is again a link function. A generalized additive model (GAM) is based on the following components (<cite>Hastie and Tibshirani 1990, Chapt. 6</cite>):
</p>


<ol>
<li> <p><em>Response distribution</em>: Given <code class="reqn">\mathbf{x}(\mathbf{s}) = x_1(\mathbf{s}), x_2(\mathbf{s}), ..., x_p(\mathbf{s})</code>, the
<code class="reqn">Y(\mathbf{s})</code> are conditionally independent observations from simple
exponential family distributions.

</p>
</li>
<li> <p><em>Link function</em>: <code class="reqn">g(\cdot)</code> relates the expectation
<code class="reqn">\mu(\mathbf{x}(\mathbf{s})) = \mathrm{E}[Y(\mathbf{s})|\mathbf{x}(\mathbf{s})]</code> of the response
distribution to

</p>
</li>
<li>
<p> the <em>additive predictor</em>  <code class="reqn">\sum_{j} f_{j}(x_{j}(\mathbf{s}))</code>.
</p>
</li>
</ol>
<p>geoGAM extend GAM by allowing a more complex form of the additive
predictor (<cite>Kneib et al. 2009, Hothorn et al. 2011</cite>): First, one can
add a smooth function <code class="reqn">f_{{\scriptstyle \mathbf{s}}}(\mathbf{s})</code> of the spatial
coordinates (smooth spatial surface) to the additive predictor to account for residual
autocorrelation.

More complex relationships between <code class="reqn">Y</code> and <code class="reqn">\mathbf{x}</code> can be modelled
by adding terms like <code class="reqn">f_{j}(x_{j}(\mathbf{s})) \cdot
  f_{k}(x_{k}(\mathbf{s}))</code> – capturing the effect of interactions
between covariates – and <code class="reqn">f_{{\scriptstyle \mathbf{s}}}(\mathbf{s}) \cdot
  f_{j}(x_{k}(\mathbf{s}))</code> – accounting for spatially changing
dependence between <code class="reqn">Y</code> and <code class="reqn">\mathbf{x}</code>.  Hence, in its full generality,
a generalized additive model for spatial data is represented by

</p>
<p style="text-align: center;"><code class="reqn">
    g(\mu(\mathbf{x}(\mathbf{s}))) = \nu + f(\mathbf{x}(\mathbf{s}))   =  \nonumber </code>
</p>

<p style="text-align: center;"><code class="reqn">
    \nu +
    \underbrace{
    \sum_{u} f_{j_{u}}(x_{j_{u}}(\mathbf{s})) + \sum_{v}
    f_{j_{v}}(x_{j_{v}}(\mathbf{s})) \cdot f_{k_{v}}(x_{k_{v}}(\mathbf{s}))
    }_{\mbox{global marginal and interaction effects}} \nonumber </code>
</p>

<p style="text-align: center;"><code class="reqn">
     +
    \underbrace{ \sum_{w} f_{{\scriptstyle \mathbf{{s}}_{w}}}(\mathbf{s}) \cdot
    f_{j_{w}}(x_{j_{w}}(\mathbf{s})) }_{\mbox{nonstationary effects}} +
    \underbrace{\hspace{5mm} f_{{\scriptstyle \mathbf{s} }}(\mathbf{s})
    \hspace{5mm}}_{\mbox{autocorrelation}}.
    </code>
</p>


<p><cite>Kneib et al. (2009)</cite> called the above equation a geoadditive model,
a name coined before by <cite>Kammann and Wand 2003</cite> for a combination
of additive models with a geostatistical error model.
It remains to specify what response distributions and link functions
should be used for the various response types: For (possibly
transformed) <em>continuous</em> responses one uses often a normal
response distribution combined with the identity link
<code class="reqn">g\left(\mu(\mathbf{x}(\mathbf{s}))\right) = \mu(\mathbf{x}(\mathbf{s}))</code>.
For binary data (coded as 0 and 1), one assumes a Bernoulli
distribution and uses often a logit link

</p>
<p style="text-align: center;"><code class="reqn">
     g\left(\mu(\mathbf{x}(\mathbf{s}))\right) =\log\left(
     \frac{\mu(\mathbf{x}(\mathbf{s}))}{1-\mu(\mathbf{x}(\mathbf{s}))} \right),
  </code>
</p>


<p>where

</p>
<p style="text-align: center;"><code class="reqn">
    \mu(\mathbf{x}(\mathbf{s})) =
    \mathrm{Prob}[Y(\mathbf{s})=1\,|\,\mathbf{x}(\mathbf{s})] =
    \frac{\exp(\nu +f(\mathbf{x}(\mathbf{s})))}{1+\exp(\nu +f(\mathbf{x}(\mathbf{s})))}.
  </code>
</p>


<p>For ordinal data, with ordered response levels, <code class="reqn">1, 2, \ldots, k</code>,
the cumulative logit or proportional odds model
(<cite>Tutz 2012</cite>, Sect. 9.1) is used.  For any given level <code class="reqn">r \in (1, 2,
  \ldots, k)</code>, the logarithm of the odds of the event <code class="reqn">Y(\mathbf{s}) \leq
  r \, | \, \mathbf{x}(\mathbf{s})</code> is then modelled by

</p>
<p style="text-align: center;"><code class="reqn">
    \log\left(
    \frac{\mathrm{Prob}[Y(\mathbf{s}) \leq
    r \, | \, \mathbf{x}(\mathbf{s}))]}{\mathrm{Prob}[Y(\mathbf{s}) &gt; r \, | \,
    \mathbf{x}(\mathbf{s}))]}\right) = \nu_{r} + f(\mathbf{x}(\mathbf{s})),
  </code>
</p>

<p>with <code class="reqn">\nu_{r}</code> a sequence of level-specific constants satisfying
<code class="reqn">\nu_{1} \leq \nu_{2} \leq \ldots \leq \nu_{r}</code>. Conversely,

</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Prob}[Y(\mathbf{s})\leq r\,|\,\mathbf{x}(\mathbf{s})] =
    \frac{\exp(\nu_{r} + f(\mathbf{x}(\mathbf{s})))}{1+\exp(\nu_{r} + f(\mathbf{x}(\mathbf{s})))}. </code>
</p>


<p>Note that <code class="reqn">\mathrm{Prob}[Y(\mathbf{s})\leq r\,|\,\mathbf{x}(\mathbf{s})]</code>
depends on <code class="reqn">r</code> only through the constant <code class="reqn">\nu_{r}</code>.  Hence, the ratio
of the odds of two events <code class="reqn">Y(\mathbf{s}) \leq r \, | \,
  \mathbf{x}(\mathbf{s})</code> and <code class="reqn">(\mathbf{s}) \leq r \, | \,
  \tilde{\mathbf{x}}(\mathbf{s})</code> is the same for all <code class="reqn">r</code>
(<cite>Tutz 2012</cite>, p. 245).
</p>
<p><strong>Model building (selection of covariates)</strong>
</p>
<p>To build parsimonious models that can readily be checked for agreement understanding in regards to the analized subject. The following steps 1–6 are implemented in <code>geoGAM</code> toa achieve sparse models in a fully automated way.
In several of these steps tuning parameters are optimized by 10-fold cross-validation with fixed subsets using either root mean squared error (RMSE), continuous responses), Brier score (BS), binary responses) or ranked probability score (RPS), ordinal responses) as optimization criteria (see <cite>Wilks, 2011</cite>).
To improve the stability of the algorithm continuous covariates are first scaled (by difference of maximum and minimum value) and centred.
</p>


<ol>
<li>
<p> Boosting (see step 2 below) is more stable and converges more quickly when the effects of categorical covariates (factors) are accounted for as model offset. Therefore, the group lasso (least absolute shrinkage and selection operator, <cite>Breheny and Huang 2015</cite>, <code>grpreg</code>))  – an algorithm that likely
excludes non-relevant covariates and treats factors
as groups – is used to select important factors for the offset. 
For ordinal responses
stepwise proportional odds logistic regression in both directions
with BIC (e. g. <cite>Faraway 2005</cite>, p. 126) is used to select the offset covariates because lasso cannot be
used for such responses.
</p>

</li>
<li>
<p> Next, a subset of
relevant factors, continuous covariates and spatial effects is selected by componentwise gradient boosting.
Boosting is a slow stagewise additive learning algorithm. It
expands <code class="reqn">f(\mathbf{x}(\mathbf{s}))</code> in a set of base procedures (baselearners)
and approximates the additive predictor by a finite sum of
them as follows (<cite>Buehlmann and Hothorn 2007</cite>):
</p>

<ol>
<li>
<p> Initialize <code class="reqn">\hat{f}( \mathbf{x}(\mathbf{s}))^{[m]}</code>
with offset of step 1 above and set <code class="reqn">m=0</code>.
</p>
</li>
<li>
<p> Increase <code class="reqn">m</code> by 1. Compute
the negative gradient vector <code class="reqn">\mathbf{U}^{[m]}</code> (e.g. residuals) for a loss
function <code class="reqn">l(\cdot)</code>.
</p>
</li>
<li>
<p> Fit all baselearners <code class="reqn">g(
			\mathbf{x}(\mathbf{s}))_{1..p}</code> to <code class="reqn">\mathbf{U}^{[m]}</code> and select the baselearner, say
<code class="reqn">g(\mathbf{x}(\mathbf{s}))_{j}^{[m]}</code> that minimizes <code class="reqn">l(\cdot)</code>.
</p>
</li>
<li>
<p> Update
<code class="reqn">\hat{f}( \mathbf{x}(\mathbf{s}))^{[m]} = \hat{f}( \mathbf{x}(\mathbf{s}))^{[m-1]} +
			v\cdot g( \mathbf{x}(\mathbf{s}))_{j}^{[m]}</code> with step size <code class="reqn">v\leq1</code>.
</p>
</li>
<li>
<p> Iterate steps (b) to (d) until <code class="reqn">m = m_{stop}</code> (main tuning
parameter).
</p>
</li>
</ol>
<p>The following settings are used in above algorithm: 
As loss functions <code class="reqn">l(\cdot)</code> <code class="reqn">L_2</code> is used for continuous,
negative binomial likelihood for binary
(<cite>Buehlmann and Hothorn 2007</cite>) and proportional odds likelihood
for ordinal responses (<cite>Schmid et al. 2011</cite>). 

Early stopping of the boosting algorithm is achieved by
determining optimal <code class="reqn">m_{stop}</code> by cross-validation. 
Default step length (<code class="reqn">\upsilon = 0.1</code>) is used. This is not a
sensitive parameter as long as it is clearly below 1 (<cite>Hofner et al. 2014</cite>).

For continuous covariates penalized smoothing
spline baselearners (<cite>Kneib et al. 2009</cite>) are used. Factors
are treated as linear baselearners. To capture residual autocorrelation
a bivariate tensor-product P-spline of spatial coordinates
(<cite>Wood 2006, pp. 162</cite>) is added to the additive predictor. Spatially varying effects
are modelled by baselearners formed by multiplication of
continuous covariates with tensor-product P-splines of spatial coordinates
(<cite>Wood 2006, pp. 168</cite>). Uneven degree of freedom of baselearners biases
baselearner selection (<cite>Hofner et al. 2011b</cite>). Therefore, each baselearner is penalized to 5 degrees of
freedom (<code class="reqn">df</code>). Factors with less than 6 levels (<code class="reqn">df&lt;5</code>)
are aggregated to grouped baselearners. By using an offset, effects of important factors with more than 6 levels
are implicitly accounted for without penalization.
</p>

</li>
<li>
<p> At <code class="reqn">m_{stop}</code> (see step 2 above), many included baselearners may have very small effects only. To remove these
the effect size <code class="reqn">e_j</code> of each baselearner <code class="reqn">f_j(x_j(\mathbf{s}))</code> is computed. 	For factors the effect size <code class="reqn">e_j</code> is the largest difference between effects of two levels and for continuous covariates it is equal to the maximum contrast of estimated partial effects (after removal of extreme values as in boxplots, <cite>Frigge et al. 1989</cite>). Generalized additive models (GAM, <cite>Wood 2011</cite>) are fitted including smooth and factor effects depending on the effect size <code class="reqn">e_j</code> of the corresponding baselearner <code class="reqn">j</code>. The procedure iterates through <code class="reqn">e_j</code> and excludes covariates with <code class="reqn">e_j</code> smaller than a threshold effect size <code class="reqn">e_t</code>. Optimal <code class="reqn">e_t</code> is determined by 10-fold cross-validation of GAM. In these GAM fits smooth effects are penalized to 5 degrees of freedom as imposed by componentwise gradient boosting (step 2 above). The factors selected as offset in step 1 are included in the main GAM, that is now fitted without offset.
</p>

</li>
<li>
<p> The GAM is further reduced by stepwise removal of
covariates by cross-validation. The candidate covariate to drop is chosen by largest <code class="reqn">p</code> value
of <code class="reqn">F</code> tests for linear factors and approximate <code class="reqn">F</code> test
(<cite>Wood 2011</cite>) for smooth terms. 


</p>

</li>
<li>
<p> Factor levels with similar estimated effects are merged stepwise again by cross-validation
based on largest <code class="reqn">p</code> values from two sample <code class="reqn">t</code>-tests of partial
residuals.
</p>

</li>
<li>
<p> The final model (used to compute spatial predictions) results ideally in a parsimonious
GAM. Because of step 5, factors have possibly a reduced number of coefficients.
Effects of continuous covariates are modelled by smooth functions and  – if at all present –
spatially structured residual variation (autocorrelation) is represented by a smooth spatial surface.
To avoid over-fitting both types of smooth effects are penalized to 5 degrees of freedom (as imposed by step 2).
</p>
</li>
</ol>
<h3>Value</h3>

<p>Object of class <code>geoGAM</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>offset.grplasso</code></td>
<td>
<p>Cross validation for grouped LASSO, object of class <code>cv.grpreg</code> of package <code>grpreg</code>). Empty for <code>offset = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset.factors</code></td>
<td>
<p>Character vector of factor names chosen for the offset computation. Empty for <code>offset = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamboost</code></td>
<td>
<p>Gradient boosting with smooth components, object of class <code>gamboost</code> of package <code>mboost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamboost.cv</code></td>
<td>
<p>Cross validation for gradient boosting, object of class <code>cvrisk</code> of package <code>mboost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamboost.mstop</code></td>
<td>
<p>Mstop used for gamboost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamback.cv</code></td>
<td>
<p>List of cross validation error for tuning parameter magnitude.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamback.backward</code></td>
<td>
<p>List of cross validation error path for backward selection of <code>gam</code> fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamback.aggregation</code></td>
<td>
<p>List(s) of cross validation error path for aggregation of factor levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam.final</code></td>
<td>
<p>Final selected geoadditive model fit, object of class <code>gam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam.final.cv</code></td>
<td>
<p>Data frame with original response and cross validation predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gam.final.extern</code></td>
<td>
<p>Data frame with original response data and predictions of <code>gam.final</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Original data frame for model calibration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>List of parameters handed to geoGAM (used for subsequent bootstrap of prediction intervals).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>M. Nussbaum
</p>


<h3>References</h3>

<p>Breheny, P. and Huang, J., 2015. Group descent algorithms for nonconvex penalized linear and logistic regression models with grouped predictors. Statistics and Computing, 25, 173–187.
</p>
<p>Buehlmann, P. and Hothorn, T., 2007. Boosting algorithms: Regularization, prediction and model fitting, Stat Sci, 22, 477–505, doi:10.1214/07-sts242.
</p>
<p>Faraway, J. J., 2005. Linear Models with R, vol. 63 of Texts in Statistical Science, Chapman &amp; Hall/CRC, Boca Raton.
</p>
<p>Frigge, M., Hoaglin, D. C., and Iglewicz, B., 1989. Some implementations of the boxplot. The American Statistician, 43(1), 50–54.
</p>
<p>Hastie, T. J. and Tibshirani, R. J., 1990. Generalized Additive Models, vol. 43 of Monographs on Statistics and Applied Probability, Chapman and Hall, London.
</p>
<p>Hofner, B., Hothorn, T., Kneib, T., and Schmid, M., 2011. A framework for unbiased model selection based on boosting. Journal of Computational and Graphical Statistics, 20(4), 956–971.
</p>
<p>Hofner, B., Mayr, A., Robinzonov, N., and Schmid, M., 2014. Model-based boosting in R: A hands-on tutorial using the R package mboost, Computation Stat, 29, 3–35, doi:10.1007/s00180-012-0382-5.
</p>
<p>Hothorn, T., Mueller, J., Schroder, B., Kneib, T., and Brandl, R., 2011. Decomposing environmental, spatial, and spatiotemporal components of species distributions, Ecol Monogr, 81, 329–347.
</p>
<p>Kneib, T., Hothorn, T., and Tutz, G., 2009. Variable selection and model choice in geoadditive regression models. Biometrics, 65(2), 626–634.
</p>
<p>Nussbaum, M., Walthert, L., Fraefel, M., Greiner, L., and Papritz, A.: Mapping of soil properties at high resolution in Switzerland using boosted geoadditive models, SOIL, 3, 191-210, doi:10.5194/soil-3-191-2017, 2017.
</p>
<p>Schmid, M., Hothorn, T., Maloney, K. O., Weller, D. E., and Potapov, S., 2011. Geoadditive regression modeling of stream biological condition, Environ Ecol Stat, 18, 709–733, doi:10.1007/s10651-010-0158-4.
</p>
<p>Tutz, G., 2012, Regression for Categorical Data, Cambridge University Press,
doi:10.1017/cbo9780511842061.
</p>
<p>Wilks, D. S., 2011. Statistical Methods in the Atmospheric Sciences, Academic Press, 3 edn.
</p>
<p>Wood, S. N., 2006. Generalized Additive Models: An Introduction with R, Chapman and Hall/CRC.
</p>
<p>Wood, S. N., 2011. Fast stable restricted maximum likelihood and marginal likelihood
estimation of semiparametric generalized linear models. Journal of the Royal Statistical
Society (B), 73(1), 3–36.
</p>


<h3>See Also</h3>

<p>The model selection is based on packages <code>grpreg</code> (function <code>cv.grpreg</code>), <code>MASS</code> (function <code>polr</code>), <code>mboost</code> (functions <code>gamboost</code>, <code>cv</code>, <code>cvrisk</code>) and <code>mgcv</code> (function <code>gam</code>). For further information please see documentation and vignettes for these packages.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### small examples with earthquake data

data(quakes)
set.seed(2)
quakes &lt;- quakes[ sample(1:nrow(quakes), 50), ]

quakes.geogam &lt;- geoGAM(response = "mag",
                        covariates = c("depth", "stations"),
                        data = quakes,
                        seed = 2,
                        max.stop = 5,
                        cores = 1)
summary(quakes.geogam)


data(quakes)

# create grouped factor with reduced number of levels
quakes$stations &lt;- factor( cut( quakes$stations, breaks = c(0,15,19,23,30,39,132)) )

quakes.geogam &lt;- geoGAM(response = "mag",
                        covariates = c("stations", "depth"),
                        coords = c("lat", "long"),
                        data = quakes,
                        max.stop = 10,
                        cores = 1)

summary(quakes.geogam)
summary(quakes.geogam, what = "path")




## Use soil data set of soil mapping study area near Berne

data(berne)
set.seed(1)

# Split data sets and
# remove rows with missing values in response and covariates

d.cal &lt;- berne[ berne$dataset == "calibration" &amp; complete.cases(berne), ]
d.val &lt;- berne[ berne$dataset == "validation" &amp; complete.cases(berne), ]


### Model selection for continuous response
ph10.geogam &lt;- geoGAM(response = "ph.0.10",
                      covariates = names(d.cal)[14:ncol(d.cal)],
                      coords = c("x", "y"),
                      data = d.cal,
                      offset = TRUE,
                      sets = mboost::cv(rep(1, nrow(d.cal)), type = "kfold"),
                      validation.data = d.val,
                      cores = 1)
summary(ph10.geogam)
summary(ph10.geogam, what = "path")


### Model selection for binary response
waterlog100.geogam &lt;- geoGAM(response = "waterlog.100",
                             covariates = names(d.cal)[c(14:54, 56:ncol(d.cal))],
                             coords = c("x", "y"),
                             data = d.cal,
                             offset = FALSE,
                             sets = sample( cut(seq(1,nrow(d.cal)),breaks=10,labels=FALSE) ),
                             validation.data = d.val,
                             cores = 1)
summary(waterlog100.geogam)
summary(waterlog100.geogam, what = "path")


### Model selection for ordered response
dclass.geogam &lt;- geoGAM(response = "dclass",
                        covariates = names(d.cal)[14:ncol(d.cal)],
                        coords = c("x", "y"),
                        data = d.cal,
                        offset = TRUE,
                        non.stationary = TRUE,
                        seed = 1,
                        validation.data = d.val,
                        cores = 1)
summary(dclass.geogam)
summary(dclass.geogam, what = "path")



</code></pre>


</div>