<div class="container">

<table style="width: 100%;"><tr>
<td>cv.grpsel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validated group subset selection</h2>

<h3>Description</h3>

<p>Fits the regularisation surface for a regression model with a group subset selection
penalty and then cross-validates this surface.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.grpsel(
  x,
  y,
  group = seq_len(ncol(x)),
  penalty = c("grSubset", "grSubset+grLasso", "grSubset+Ridge"),
  loss = c("square", "logistic"),
  lambda = NULL,
  gamma = NULL,
  nfold = 10,
  folds = NULL,
  cv.loss = NULL,
  cluster = NULL,
  interpolate = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a predictor matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a response vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>a vector of length <code>ncol(x)</code> with the jth element identifying the group that
the jth predictor belongs to; alternatively, a list of vectors with the kth vector identifying
the predictors that belong to the kth group (useful for overlapping groups)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>the type of penalty to apply; one of 'grSubset', 'grSubset+grLasso', or
'grSubset+Ridge'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>the type of loss function to use; 'square' for linear regression or 'logistic' for
logistic regression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>an optional list of decreasing sequences of group subset selection parameters; the
list should contain a vector for each value of <code>gamma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>an optional decreasing sequence of group lasso or ridge parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfold</code></td>
<td>
<p>the number of cross-validation folds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>an optional vector of length <code>nrow(x)</code> with the ith entry identifying the fold
that the ith observation belongs to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.loss</code></td>
<td>
<p>an optional cross-validation loss-function to use; should accept a vector of
predicted values and a vector of actual values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>an optional cluster for running cross-validation in parallel; must be set up using
<code>parallel::makeCluster</code>; each fold is evaluated on a different node of the cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>a logical indicating whether to interpolate the <code>lambda</code> sequence for
the cross-validation fits; see details below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>any other arguments for <code>grpsel()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>loss='logistic'</code> stratified cross-validation is used to balance
the folds. When fitting to the cross-validation folds, <code>interpolate=TRUE</code> cross-validates
the midpoints between consecutive <code>lambda</code> values rather than the original <code>lambda</code>
sequence. This new sequence retains the same set of solutions on the full data, but often leads
to superior cross-validation performance.
</p>


<h3>Value</h3>

<p>An object of class <code>cv.grpsel</code>; a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cv.mean</code></td>
<td>
<p>a list of vectors containing cross-validation means per value of <code>lambda</code>;
an individual vector in the list for each value of <code>gamma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cd.sd</code></td>
<td>
<p>a list of vectors containing cross-validation standard errors per value of
<code>lambda</code>; an individual vector in the list for each value of <code>gamma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a list of vectors containing the values of <code>lambda</code> used in the fit; an
individual vector in the list for each value of <code>gamma</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>a vector containing the values of <code>gamma</code> used in the fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>the value of <code>lambda</code> minimising <code>cv.mean</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.min</code></td>
<td>
<p>the value of <code>gamma</code> minimising <code>cv.mean</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>the fit from running <code>grpsel()</code> on the full data</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson@monash.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Grouped data
set.seed(123)
n &lt;- 100
p &lt;- 10
g &lt;- 5
group &lt;- rep(1:g, each = p / g)
beta &lt;- numeric(p)
beta[which(group %in% 1:2)] &lt;- 1
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n, x %*% beta)
newx &lt;- matrix(rnorm(p), ncol = p)

# Group subset selection
fit &lt;- cv.grpsel(x, y, group)
plot(fit)
coef(fit)
predict(fit, newx)

# Parallel cross-validation
cl &lt;- parallel::makeCluster(2)
fit &lt;- cv.grpsel(x, y, group, cluster = cl)
parallel::stopCluster(cl)
</code></pre>


</div>