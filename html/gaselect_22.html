<div class="container">

<table style="width: 100%;"><tr>
<td>genAlgControl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Set control arguments for the genetic algorithm</h2>

<h3>Description</h3>

<p>The population must be large enough to allow the algorithm to explore the whole solution space. If
the initial population is not diverse enough, the chance to find the global optimum is very small.
Thus the more variables to choose from, the larger the population has to be.
</p>


<h3>Usage</h3>

<pre><code class="language-R">genAlgControl(
  populationSize,
  numGenerations,
  minVariables,
  maxVariables,
  elitism = 10L,
  mutationProbability = 0.01,
  crossover = c("single", "random"),
  maxDuplicateEliminationTries = 0L,
  verbosity = 0L,
  badSolutionThreshold = 2,
  fitnessScaling = c("none", "exp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>populationSize</code></td>
<td>
<p>The number of "chromosomes" in the population (between 1 and 2^16)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numGenerations</code></td>
<td>
<p>The number of generations to produce (between 1 and 2^16)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minVariables</code></td>
<td>
<p>The minimum number of variables in the variable subset (between 0 and p - 1 where p is the total number of variables)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxVariables</code></td>
<td>
<p>The maximum number of variables in the variable subset (between 1 and p, and greater than <code>minVariables</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elitism</code></td>
<td>
<p>The number of absolute best chromosomes to keep across all generations (between 1 and min(<code>populationSize</code> * <code>numGenerations</code>, 2^16))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutationProbability</code></td>
<td>
<p>The probability of mutation (between 0 and 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crossover</code></td>
<td>
<p>The crossover type to use during mating (see details). Partial matching is performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxDuplicateEliminationTries</code></td>
<td>
<p>The maximum number of tries to eliminate duplicates
(a value of <code>0</code> or <code>NULL</code> means that no checks for duplicates are done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>
<p>The level of verbosity. 0 means no output at all, 2 is very verbose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>badSolutionThreshold</code></td>
<td>
<p>The worst child must not be more than <code>badSolutionThreshold</code> times worse than the worse parent.
If less than 0, the child must be even better than the worst parent. If the algorithm can't find a better child
in a long time it issues a warning and uses the last found child to continue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitnessScaling</code></td>
<td>
<p>How the fitness values are internally scaled before the selection probabilities are assigned
to the chromosomes. See the details for possible values and their meaning.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The initial population is generated randomly. Every chromosome uses between <code>minVariables</code> and
<code>maxVariables</code> (uniformly distributed).
</p>
<p>If the mutation probability (<code>mutationProbability</code> is greater than 0, a random number of
variables is added/removed according to a truncated geometric distribution to each offspring-chromosome.
The resulting distribution of the total number of variables in the subset is not uniform anymore, but almost (the smaller the
mutation probability, the more "uniform" the distribution). This should not be a problem for most
applications.
</p>
<p>The user can choose between <code>single</code> and <code>random</code> crossover for the mating process. If single crossover
is used, a single position is randomly chosen that marks the position to split both parent chromosomes. The child
chromosomes are than the concatenated chromosomes from the 1st part of the 1st parent and the 2nd part of the
2nd parent resp. the 2nd part of the 1st parent and the 1st part of the 2nd parent.
Random crossover is that a random number of random positions are drawn and these positions are transferred
from one parent to the other in order to generate the children.
</p>
<p>Elitism is a method of enhancing the GA by keeping track of very good solutions. The parameter <code>elitism</code>
specifies how many "very good" solutions should be kept.
</p>
<p>Before the selection probabilities are determined, the fitness values <code class="reqn">f</code> of the chromosomes are
standardized to the z-scores (<code class="reqn">z = (f - mu) / sd</code>). Scaling the fitness values afterwards with
the exponential function can help the algorithm to faster find good solutions. When setting
<code>fitnessScaling</code> to <code>"exp"</code>, the (standardized) fitness <code class="reqn">z</code> will be scaled by <code class="reqn">exp(z)</code>.
This promotes good solutions to get an even higher selection probability, while bad solutions
will get an even lower selection probability.
</p>


<h3>Value</h3>

<p>An object of type <code>GenAlgControl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluatorSRCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

evaluatorRDCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 5, outerSegments = 3,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

resultSRCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorSRCV, seed = 123)
resultRDCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorRDCV, seed = 123)

subsets(resultSRCV, 1:5)
subsets(resultRDCV, 1:5)
</code></pre>


</div>