<div class="container">

<table style="width: 100%;"><tr>
<td>georange</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>georange</h2>

<h3>Description</h3>

<p>Calculate range of distances (min-max) between all points in one or two
rectangular objects containing lon-lat coordinates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">georange(x, y, sequential = FALSE, measure = "cheap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Rectangular object (matrix, <code>data.frame</code>, <span class="pkg">tibble</span>,
whatever) containing longitude and latitude coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Optional second object which, if passed, results in distances
calculated between each object in <code>x</code> and each in <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequential</code></td>
<td>
<p>If <code>TRUE</code>, calculate (vector of) distances
sequentially along <code>x</code> (when no <code>y</code> is passed), otherwise calculate
matrix of pairwise distances between all points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measure</code></td>
<td>
<p>One of "haversine" "vincenty", "geodesic", or "cheap"
specifying desired method of geodesic distance calculation; see Notes.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A named vector of two numeric values: minimum and maximum, giving the
respective distances in metres.
</p>


<h3>Note</h3>

<p><code>measure = "cheap"</code> denotes the mapbox cheap ruler
<a href="https://github.com/mapbox/cheap-ruler-cpp">https://github.com/mapbox/cheap-ruler-cpp</a>; <code>measure = "geodesic"</code>
denotes the very accurate geodesic methods given in Karney (2013)
"Algorithms for geodesics" J Geod 87:43-55, and as provided by the
'st_dist()' function from the <span class="pkg">sf</span> package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 50
x &lt;- cbind (-10 + 20 * runif (n), -10 + 20 * runif (n))
y &lt;- cbind (-10 + 20 * runif (2 * n), -10 + 20 * runif (2 * n))
colnames (x) &lt;- colnames (y) &lt;- c ("x", "y")
# All of the following returns vector of two values: minimum and maximum:
d0 &lt;- georange (x)
d1 &lt;- georange (x, y)
d2 &lt;- georange (x, sequential = TRUE)
d0_2 &lt;- georange (x, measure = "geodesic") # nanometre-accurate version of d0
</code></pre>


</div>