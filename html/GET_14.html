<div class="container">

<table style="width: 100%;"><tr>
<td>GET.composite</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adjusted global envelope tests</h2>

<h3>Description</h3>

<p>Adjusted global envelope tests for composite null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GET.composite(
  X,
  X.ls = NULL,
  nsim = 499,
  nsimsub = nsim,
  simfun = NULL,
  fitfun = NULL,
  calcfun = function(X) {
     X
 },
  testfuns = NULL,
  ...,
  type = "erl",
  alpha = 0.05,
  alternative = c("two.sided", "less", "greater"),
  probs = c(0.025, 0.975),
  r_min = NULL,
  r_max = NULL,
  take_residual = FALSE,
  save.cons.envelope = savefuns,
  savefuns = FALSE,
  verbose = TRUE,
  MrkvickaEtal2017 = FALSE,
  mc.cores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An object containing the data in some form.
A <code>curve_set</code> object, or an <code>envelope</code> object of the <span class="pkg">spatstat</span> package,
as the <code>curve_sets</code> argument of <code>global_envelope_test</code>
(need to provide <code>X.ls</code>), or
a fitted point process model of <span class="pkg">spatstat</span> (e.g. object of class <code>ppm</code> or
<code>kppm</code>), or a point pattern object of class <code>ppp</code> of <span class="pkg">spatstat</span>,
or another data object (need to provide <code>simfun</code>, <code>fitfun</code>, <code>calcfun</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.ls</code></td>
<td>
<p>A list of objects as <code>curve_sets</code> argument of <code>global_envelope_test</code>,
giving the second stage simulations, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of simulations to be generated in the primary test.
Ignored if <code>X.ls</code> provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsimsub</code></td>
<td>
<p>Number of simulations in each basic test. There will be <code>nsim</code> repetitions
of the basic test, each involving <code>nsimsub</code> simulated realisations.
Total number of simulations will be nsim * (nsimsub + 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simfun</code></td>
<td>
<p>A function for generating simulations from the null model. If given, this function
is called by <code>replicate(n=nsim, simfun(simfun.arg), simplify=FALSE)</code> to make nsim
simulations. Here <code>simfun.arg</code> is obtained by <code>fitfun(X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitfun</code></td>
<td>
<p>A function for estimating the parameters of the null model.
The function should return the fitted model in the form that it can be directly
passed to <code>simfun</code> as its argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calcfun</code></td>
<td>
<p>A function for calculating a summary function from a simulation of the model.
The default is the identity function, i.e. the simulations from the model are functions themselves.
The use of <code>calcfun</code> is still experimental. Preferably provide <code>X</code> and
<code>X.ls</code> instead, if <code>X</code> is not a point pattern or fitted point process model object
of <span class="pkg">spatstat</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testfuns</code></td>
<td>
<p>A list of lists of parameters to be passed to the <code>envelope</code> function of <span class="pkg">spatstat</span>
if <code>X</code> is a point pattern of a fitted point process model of <span class="pkg">spatstat</span>.
A list of parameters should be provided for each test function that is to be used in the
combined test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to the <code>envelope</code> function of <span class="pkg">spatstat</span> in the case where
only one test function is used. In that case, this is an alternative to providing the parameters in the
argument testfuns. If <code>envelope</code> is also used to generate simulations under the null
hypothesis (if simfun not provided), then also recall to specify how to generate the simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of the global envelope with current options for 'rank', 'erl', 'cont', 'area',
'qdir', 'st' and 'unscaled'. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The significance level. The 100(1-alpha)% global envelope will be calculated
under the 'fwer' or 'fdr' control.
If a vector of values is provided, the global envelopes are calculated for each value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
Must be one of the following: "two.sided" (default), "less" or "greater".
The last two options only available for types <code>'rank'</code>, <code>'erl'</code>,
<code>'cont'</code> and <code>'area'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>A two-element vector containing the lower and upper
quantiles for the measure 'q' or 'qdir', in that order and on the interval [0, 1].
The default values are 0.025 and 0.975, suggested by Myllymäki et al. (2015, 2017).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_min</code></td>
<td>
<p>The minimum argument value to include in the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_max</code></td>
<td>
<p>The maximum argument value to include in the test.
in calculating functions by the <code>envelope</code> function of <span class="pkg">spatstat</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>take_residual</code></td>
<td>
<p>Logical. If TRUE (needed for visual reasons only) the mean of the simulated
functions is reduced from the functions in each first and second stage test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.cons.envelope</code></td>
<td>
<p>Logical flag indicating whether to save the unadjusted envelope test results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>savefuns</code></td>
<td>
<p>Logical flag indicating whether to save all the simulated function values.
Similar to the same argument of the <code>envelope</code> function of <span class="pkg">spatstat</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical flag indicating whether to print progress reports during the simulations.
Similar to the same argument of <code>envelope</code> function of <span class="pkg">spatstat</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MrkvickaEtal2017</code></td>
<td>
<p>Logical. If TRUE, type is "st" or "qdir" and several test functions are used,
then the combined scaled MAD envelope presented in Mrkvička et al. (2017) is calculated. Otherwise,
the two-step procedure described in <code>global_envelope_test</code> is used for combining the tests.
Default to FALSE. The option is kept for historical reasons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.
Must be at least one, and parallelization requires at least two cores. On a Windows computer mc.cores must be 1
(no parallelization). For details, see <code>mclapply</code>, for which the argument is passed.
Parallelization can be used in generating simulations and in calculating the second stage tests.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The specification of X, X.ls, fitfun, simfun is important:
</p>

<ul>
<li>
<p> If <code>X.ls</code> is provided, then the global envelope test is calculated based on
functions in these objects. <code>X</code> should be a <code>curve_set</code> object,
or an <code>envelope</code> object of <span class="pkg">spatstat</span>, including the observed function and simulations
from the tested model. <code>X.ls</code> should be a list of <code>curve_set</code> or
envelope (of R package <span class="pkg">spatstat</span>) objects, where each component contains an "observed"
function f that has been simulated from the model fitted to the data and the simulations
that have been obtained from the same model that has been fitted to the "observed" f.
The user has the responsibility that the functions have been generated correctly,
the test is done based on these provided simulations. See the examples.
</p>
</li>
<li>
<p> Otherwise, if <code>simfun</code> and <code>fitfun</code> are provided, <code>X</code> can be general.
The function <code>fitfun</code> is used for fitting the desired model M and the function <code>simfun</code>
for simulating from a fitted model M. These functions should be coupled with each other such
that the object returned by <code>fitfun</code> is directly accepted as the (single) argument in
<code>simfun</code>.
In the case, that the global envelope should not be calculated directly for <code>X</code> (<code>X</code> is
not a function), <code>calcfun</code> can be used to specify how to calculate the function from
<code>X</code> and from simulations generated by <code>simfun</code>.
Special attention is needed in the correct specification of the functions, see examples.
</p>
</li>
<li>
<p> Otherwise, <code>X</code> should be either a fitted (point process) model object or a <code>ppp</code>
object of the R package <span class="pkg">spatstat</span>.
</p>

<ul>
<li>
<p> If <code>X</code> is a fitted (point process) model object of the R package <span class="pkg">spatstat</span>,
then the simulations from this model are generated and summary functions for testing calculated
by the <code>envelope</code> function of <span class="pkg">spatstat</span>. Which summary function to use and how to calculate it,
can be passed to <code>envelope</code> either in <code>...</code> or <code>testfuns</code>.
Unless otherwise specified the default function of <code>envelope</code>,
i.g. the K-function, is used. The argument <code>testfuns</code> should be used to specify the
test functions in the case where one wants to base the test on several test functions.
</p>
</li>
<li>
<p> If <code>X</code> is a <code>ppp</code> object of <span class="pkg">spatstat</span>, then the <code>envelope</code> function
is used for simulations and model fitting and the complete spatial randomness (CSR) is tested
(with intensity parameter).
</p>
</li>
</ul>
</li>
</ul>
<p>For the rank envelope test, the global envelope test is the test described in
Myllymäki et al. (2017) with the adjustment of Baddeley et al. (2017).
For other test types, the test (also) uses the two-stage procedure of Dao and Genton (2014) with
the adjustment of Baddeley et al. (2017) as descripbed in Myllymäki and Mrkvička (2020).
</p>
<p>See examples also in <code>saplings</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>global_envelope</code> or <code>combined_global_envelope</code>, which can be
printed and plotted directly. See <code>global_envelope_test</code>.
</p>


<h3>References</h3>

<p>Baddeley, A., Hardegen, A., Lawrence, T., Milne, R. K., Nair, G. and Rakshit, S. (2017). On two-stage Monte Carlo tests of composite hypotheses. Computational Statistics and Data Analysis 114: 75-87. doi: http://dx.doi.org/10.1016/j.csda.2017.04.003
</p>
<p>Dao, N.A. and Genton, M. (2014). A Monte Carlo adjusted goodness-of-fit test for parametric models describing spatial point patterns. Journal of Graphical and Computational Statistics 23, 497-517.
</p>
<p>Mrkvička, T., Myllymäki, M. and Hahn, U. (2017) Multiple Monte Carlo testing, with applications in spatial point processes. Statistics &amp; Computing 27(5): 1239-1255. doi: 10.1007/s11222-016-9683-9
</p>
<p>Myllymäki, M., Mrkvička, T., Grabarnik, P., Seijo, H. and Hahn, U. (2017). Global envelope tests for spatial point patterns. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79: 381-404. doi: 10.1111/rssb.12172
</p>
<p>Myllymäki, M. and Mrkvička, T. (2020). GET: Global envelopes in R. arXiv:1911.06583 [stat.ME]. https://doi.org/10.48550/arXiv.1911.06583
</p>


<h3>See Also</h3>

<p><code>global_envelope_test</code>, <code>plot.global_envelope</code>, <code>saplings</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Graphical normality test (Myllymaki and Mrkvicka, 2020, Section 3.3.)
#=========================
if(require("fda.usc", quietly=TRUE)) {
  data("poblenou")
  dat &lt;- poblenou[['nox']][['data']][,'H10']
  n &lt;- length(dat)

  # The number of simulations
  nsim &lt;- nsimsub &lt;- 199
  

  set.seed(200127)
  # General setup
  #==============
  # 1. Fit the model
  mu &lt;- mean(dat)
  sigma &lt;- sd(dat)
  # 2. Simulate a sample from the fitted null model and
  #    compute the test vectors for data (obs) and each simulation (sim)
  r &lt;- seq(min(dat), max(dat), length=100)
  obs &lt;- stats::ecdf(dat)(r)
  sim &lt;- sapply(1:nsimsub, function(i) {
    x &lt;- rnorm(n, mean = mu, sd = sigma)
    stats::ecdf(x)(r)
  })
  cset &lt;- create_curve_set(list(r = r, obs = obs, sim_m = sim))

  # 3. Simulate another sample from the fitted null model.
  # 4. Fit the null model to each of the patterns,
  #    simulate a sample from the null model,
  #    and compute the test vectors for all.
  cset.ls &lt;- vector("list", nsim)
  for(rep in 1:nsim) {
    x &lt;- rnorm(n, mean = mu, sd = sigma)
    mu2 &lt;- mean(x)
    sigma2 &lt;- sd(x)
    obs2 &lt;- stats::ecdf(x)(r)
    sim2 &lt;- sapply(1:nsimsub, function(i) {
      x2 &lt;- rnorm(n, mean = mu2, sd = sigma2)
      stats::ecdf(x2)(r)
    })
    cset.ls[[rep]] &lt;- create_curve_set(list(r = r, obs = obs2, sim_m = sim2))
  }
  # Perform the adjusted test
  res &lt;- GET.composite(X = cset, X.ls = cset.ls, type = 'erl')
  plot(res) + ggplot2::labs(x = "NOx", y = "Ecdf")
}

# Example of a point pattern data
#================================
# Test the fit of a Matern cluster process.

if(require("spatstat.model", quietly=TRUE)) {
  data("saplings")
  saplings &lt;- as.ppp(saplings, W = square(75))

  # First choose the r-distances
  rmin &lt;- 0.3; rmax &lt;- 10; rstep &lt;- (rmax-rmin)/500
  r &lt;- seq(0, rmax, by = rstep)

  # Number of simulations
  nsim &lt;- 19 # Increase nsim for serious analysis!

  # Option 1: Give the fitted model object to GET.composite
  #--------------------------------------------------------
  # This can be done and is preferable when the model is
  # a point process model of spatstat.
  # 1. Fit the Matern cluster process to the pattern
  # (using minimum contrast estimation with the K-function)
  M1 &lt;- kppm(saplings~1, clusters = "MatClust", statistic = "K")
  summary(M1)
  # 2. Make the adjusted global area rank envelope test using the L(r)-r function
  adjenvL &lt;- GET.composite(X = M1, nsim = nsim,
              testfuns = list(L =list(fun="Lest", correction="translate",
                            transform=expression(.-r), r=r)), # passed to envelope
              type = "area", r_min = rmin, r_max = rmax)
  # Plot the test result
  plot(adjenvL)

  # Option 2: Generate the simulations "by yourself"
  #-------------------------------------------------
  # and provide them as curve_set or envelope objects
  # Preferable when you want to have a control
  # on the simulations yourself.
  # 1. Fit the model
  M1 &lt;- kppm(saplings~1, clusters = "MatClust", statistic = "K")
  # 2. Generate nsim simulations by the given function using the fitted model
  X &lt;- envelope(M1, nsim = nsim, savefuns = TRUE,
                fun = "Lest", correction = "translate",
                transform = expression(.-r), r = r)
  plot(X)
  # 3. Create another set of simulations to be used to estimate
  # the second-state p-value (as proposed by Baddeley et al., 2017).
  simpatterns2 &lt;- simulate(M1, nsim = nsim)
  # 4. Calculate the functions for each pattern
  simf &lt;- function(rep) {
    # Fit the model to the simulated pattern Xsims[[rep]]
    sim_fit &lt;- kppm(simpatterns2[[rep]], clusters = "MatClust", statistic = "K")
    # Generate nsim simulations from the fitted model
    envelope(sim_fit, nsim = nsim, savefuns = TRUE,
             fun = "Lest", correction = "translate",
             transform = expression(.-r), r = r)
  }
  X.ls &lt;- parallel::mclapply(X = 1:nsim, FUN = simf, mc.cores = 1) # list of envelope objects
  # 5. Perform the adjusted test
  res &lt;- GET.composite(X = X, X.ls = X.ls, type = "area",
                      r_min = rmin, r_max = rmax)
  plot(res)
}
</code></pre>


</div>