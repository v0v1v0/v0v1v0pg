<div class="container">

<table style="width: 100%;"><tr>
<td>glmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Generalised Linear Models Subject to Population Constraints</h2>

<h3>Description</h3>

<p><code>glmc</code> is used to fit generalised linear models
where the parameters are subject to population constraints.
The model is specified by giving a symbolic description of
the linear predictor, a description of the error distribution,
and a matrix of constraints on the parameters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glmc(formula,family = gaussian, data, na.action, 
     start = NULL,etastart, mustart, offset,control = glmc.control(...),
     model = TRUE,glm.method= "glm.fit",optim.method="Nelder-Mead",
     emplik.method="Owen",optim.hessian=FALSE,x = FALSE, y = TRUE,
     Amat=NULL, confn=NULL,...) 















</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a symbolic description of the model to be fit.
The details of model specification are given below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model. This can be a character string
naming a family function, a family function or the result of a call
to a family function.  (See <code>family</code> for details of
family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables
in the model.  By default the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>glmc</code> is called. All variables named <code>constraints</code> is automatically assumed to be the value of the population constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code>options</code>, and is
<code>na.fail</code> if that is unset.  The “factory-fresh”
default is <code>na.omit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em>
known component to be included in the linear predictor
during fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of parameters for controlling the fitting
process.  See the documentation for <code>glmc.control</code>
for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em>
should be included as a component of the returned value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm.method</code></td>
<td>
<p>the method to be used in fitting the model.
The default method <code>"glm.fit"</code> uses iteratively re-weighted
least squares (IWLS).  The only current alternative is
<code>"model.frame"</code> which returns the model frame and does no fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emplik.method</code></td>
<td>
<p>the method used to maximise the empirical likelihood to compute the weights. The default is <code>"Owen"</code>, due to Art Owen. Current alternative is <code>"CSW"</code>, due to Chen, Sitter and Wu.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p>the method used to maximise over the parameters. See <code>optim</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.hessian</code></td>
<td>
<p>Logical. If True returns a numerically calculated Hessian Matrix from the optim step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>For <code>glmc</code>:
logical values indicating whether the response
vector and model matrix used in the fitting process
should be returned as components of the returned value.
</p>
<p>For <code>glmc.fit</code>: <code>x</code> is a design matrix of dimension <code>n
      * p</code>, and <code>y</code> is a vector of observations of length <code>n</code>.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>Amat</code></td>
<td>
<p>a matrix of population constraints on the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confn</code></td>
<td>
<p>a function returning the value of the population constraints on the parameter.  Allows parameter dependent population constraints.</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>A typical predictor has the form <code>response ~ terms</code> where
<code>response</code> is the (numeric) response vector and <code>terms</code> is a
series of terms which specifies a linear predictor for <code>response</code>.
</p>




<p>A terms specification of the form
<code>first + second</code> indicates all the terms in <code>first</code> together
with all the terms in <code>second</code> with duplicates removed.  A specification of the form <code>first:second</code> indicates the
the set of terms obtained by taking the interactions of
all terms in <code>first</code> with all terms in <code>second</code>.
The specification <code>first*second</code> indicates the <em>cross</em>
of <code>first</code> and <code>second</code>.
This is the same as <code>first + second + first:second</code>.
</p>
<p><code>glmc</code> uses closely follows <code>glm</code>, uses <code>glm.fit</code>, <code>optim</code> and <code>el.test</code> form the <code>emplik</code> library. 
</p>


<p>If more than one of <code>etastart</code>, <code>start</code> and <code>mustart</code>
is specified, the first in the list will be used.
</p>


<h3>Value</h3>

<p><code>glmc</code> returns an object of class inheriting from <code>"glmc"</code>
which inherits from the class <code>"lm"</code>. See later in this section.
</p>




<p>The generic accessor functions <code>coefficients</code>,
<code>effects</code>, <code>fitted.values</code> and <code>residuals</code> can be used to
extract various useful features of the value returned by <code>glmc</code>.
</p>

<p>An object of class <code>"glmc"</code> is a list containing at least the
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the <em>working</em> residuals, that is the residuals
in the final iteration of the IWLS fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming
the linear predictors by the inverse of the link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the <code>family</code> object used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>
<p>up to a constant, minus twice the maximised
log-likelihood.  Where sensible, the constant is chosen so that a
saturated model has deviance zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aic</code></td>
<td>
<p>Akaike's <em>An Information Criterion</em>, minus twice the
maximised log-likelihood plus twice the number of coefficients (so
assuming that the dispersion is known.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model, comparable with
<code>deviance</code>. The null model will include the offset, and an
intercept if there is one in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>the number of iterations of IWLS used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>the <em>working</em> weights, that is the weights
in the final iteration of the IWLS fit from the glm step (if there is one).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final.weights</code></td>
<td>
<p>the weights maximising the empirical likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the <code>y</code> vector used. (It is a vector even for a binomial
model.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>logical. Was the IWLS algorithm judged to have converged?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>logical. Is the fitted value on the boundary of the
attainable values?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the <code>data argument</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>the value of the <code>control</code> argument used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm.method</code></td>
<td>
<p>the name of the fitter function used in the final <code>glm</code> call, in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> always
<code>"glm.fit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emplik.method</code></td>
<td>
<p>the name of the method used to maximise the empirical likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p>the name of the method supplied to the optim function for the outer maximisation over the parameters.</p>
</td>
</tr>
</table>
<p>.

</p>
<table><tr style="vertical-align: top;">
<td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors
used in fitting.</p>
</td>
</tr></table>
<p>In addition, non-empty fits will have components <code>qr</code>, <code>R</code>
and <code>effects</code> relating to the final weighted linear fit.
</p>
<p>Objects of class <code>"glmc"</code> are normally of class <code>c("glmc","glm",
    "lm")</code>, that is inherit from class <code>"lm"</code>, and well-designed
methods for class <code>"lm"</code> will be applied to the weighted linear
model at the final iteration of IWLS.  However, care is needed, as
extractor functions for class <code>"glmc"</code> such as
<code>residuals</code> and <code>weights</code> do <b>not</b> just pick out
the component of the fit with the same name.  In-fact no <code>"type"</code> specification in <code>weights</code> retirns the weights which maximises the empirical likelihood.  A call of wieghts with <code>type="prior"</code> returns a vector of 1 of length equaling the number of odsevations. 
</p>






<h3>Author(s)</h3>

<p>The <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> implementation of <code>glmc</code> is written by Sanjay Chaudhuri
and Mark S Handcock at National University of Singapore and University of Washington, Seattle respectively.
</p>


<h3>References</h3>

<p>Owen, A. B.  (2001)
<em>Empirical Likelihood.</em>
Boca Raton, Fla : Chapman \&amp; Hall/CRC.
</p>
<p>Dobson, A. J. (1990)
<em>An Introduction to Generalized Linear Models.</em>
London: Chapman and Hall.
</p>
<p>Hastie, T. J. and Pregibon, D. (1992)
<em>Generalized linear models.</em>
Chapter 6 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth \&amp; Brooks/Cole.
</p>
<p>McCullagh P. and Nelder, J. A. (1989)
<em>Generalized Linear Models.</em>
London: Chapman and Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em>
New York: Springer.
</p>


<h3>See Also</h3>


<p><code>glmc</code> methods,
and the generic functions <code>anova</code>, <code>summary</code>,
<code>effects</code>, <code>fitted.values</code>,
and <code>residuals</code>. <code>optim</code>, <code>el.test</code>, the fitting procedure used by <code>glmc</code>. Further, <code>lm</code> for non-generalised <em>linear</em> models.
</p>




<h3>Examples</h3>

<pre><code class="language-R">library(glmc)
#Specify the data. 

n &lt;- rbind(c(5903,230),c(5157,350))
mat &lt;- matrix(0,nrow=sum(n),ncol=2)
mat &lt;- rbind(matrix(1,nrow=n[1,1],ncol=1)%*%c(0,0),
             matrix(1,nrow=n[1,2],ncol=1)%*%c(0,1),
             matrix(1,nrow=n[2,1],ncol=1)%*%c(1,0),
             matrix(1,nrow=n[2,2],ncol=1)%*%c(1,1))

#Specifying the population constraints.

gfr &lt;- .06179*matrix(1,nrow=nrow(mat),ncol=1)
g &lt;- matrix(1,nrow=nrow(mat),ncol=1)
amat &lt;- matrix(mat[,2]*g-gfr,ncol=1)

# Method 1. Defining constraints in the data frame.

hrh &lt;- data.frame(birth=mat[,2], child=mat[,1], constraints=amat)

gfit &lt;- glmc(birth~child, data=hrh, family="binomial",emplik.method="Owen",
             control=glmc.control(maxit.glm=10,maxit.weights=200,
             itertrace.weights=TRUE,gradtol.weights=10^(-6)))

summary.glmc(gfit)

# Method 2. Defining constraints through a matrix.

gfit&lt;- glmc(mat[,2]~mat[,1],family=binomial(link=logit),
            emplik.method="Owen",control=glmc.control(maxit.glm=10,
            maxit.weights=200,itertrace.weights=TRUE,gradtol.weights=10^(-10)),
            Amat=amat,confn=NULL)

summary.glmc(gfit)

## Not run: 
# Method 3. Defining constraints through a function.

fn &lt;- function(t,Y,X){
grf &lt;- .06179*matrix(1,nrow=nrow(as.matrix(X)),ncol=1)
g &lt;- matrix(1,nrow=nrow(X),ncol=1)
amat &lt;- matrix(Y*g-grf,ncol=1)
return(amat)
}

gfit &lt;- glmc(birth~child,data=hrh,family=binomial(link=logit),
             optim.method="BFGS",emplik.method="Owen",
             control=glmc.control(maxit.glm=10,maxit.optim=10^(8),
             reltol.optim=10^(-10),trace.optim=9,REPORT.optim=1,
             maxit.weights=200,gradtol.weights=10^(-6),itertrace.weights=FALSE),
             optim.hessian=TRUE,Amat=NULL,confn=fn)

summary.glmc(gfit)
    
## End(Not run) 
</code></pre>


</div>