<div class="container">

<table style="width: 100%;"><tr>
<td>pick_Am</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pick coefficient matrices</h2>

<h3>Description</h3>

<p><code>pick_Am</code> picks the coefficient matrices <code class="reqn">A_{m,i} (i=1,..,p)</code>
from the given parameter vector so that they are arranged in a 3D array with the
third dimension indicating each lag.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pick_Am(p, M, d, params, m, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt>
<dd>
<p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt>
<dd>
<p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>number of time series in the system, i.e. the dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt>
<dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li>
<p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li>
</ul>
</dd>
<dt><strong>For constrained models:</strong></dt>
<dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul><li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>
</dd>
<dt><strong>For same_means models:</strong></dt>
<dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li>
<p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li>
</ul>
</dd>
<dt><strong>For models with weight_constraints:</strong></dt>
<dd>
<p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt>
<dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul><li>
<p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>
<dl>
<dt><strong>If AR parameters are constrained: </strong></dt>
<dd>
<p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt>
<dd>
<p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt>
<dd>
<p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt>
<dd>
<p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt>
<dd>
<p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>
</dd>
</dl>
<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>which component?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li>
</ul>
<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a 3D array containing the coefficient matrices of the given component.
A coefficient matrix <code class="reqn">A_{m,i}</code> can be obtained by choosing <code>[, , i]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li>
<p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li>
<p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li>
<p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li>
</ul>
<p>@keywords internal
</p>


</div>