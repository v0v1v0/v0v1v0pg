<div class="container">

<table style="width: 100%;"><tr>
<td>GenericML</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Machine Learning Inference</h2>

<h3>Description</h3>

<p>Performs generic machine learning inference on heterogeneous treatment effects as in <a href="https://arxiv.org/abs/1712.04802">Chernozhukov, Demirer, Duflo and Fern√°ndez-Val (2020)</a> with user-specified machine learning methods. Intended for randomized experiments.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GenericML(
  Z,
  D,
  Y,
  learners_GenericML,
  learner_propensity_score = "constant",
  num_splits = 100,
  Z_CLAN = NULL,
  HT = FALSE,
  quantile_cutoffs = c(0.25, 0.5, 0.75),
  X1_BLP = setup_X1(),
  X1_GATES = setup_X1(),
  diff_GATES = setup_diff(),
  diff_CLAN = setup_diff(),
  vcov_BLP = setup_vcov(),
  vcov_GATES = setup_vcov(),
  equal_variances_CLAN = FALSE,
  prop_aux = 0.5,
  stratify = setup_stratify(),
  significance_level = 0.05,
  min_variation = 1e-05,
  parallel = FALSE,
  num_cores = parallel::detectCores(),
  seed = NULL,
  store_learners = FALSE,
  store_splits = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>A numeric design matrix that holds the covariates in its columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>A binary vector of treatment assignment. Value one denotes assignment to the treatment group and value zero assignment to the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A numeric vector containing the response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learners_GenericML</code></td>
<td>
<p>A character vector specifying the machine learners to be used for estimating the baseline conditional average (BCA) and conditional average treatment effect (CATE). Either <code>'lasso'</code>, <code>'random_forest'</code>, <code>'tree'</code>, or a custom learner specified with <code>mlr3</code> syntax. In the latter case, do <em>not</em> specify in the <code>mlr3</code> syntax specification if the learner is a regression learner or classification learner. Example: <code>'mlr3::lrn("ranger", num.trees = 100)'</code> for a random forest learner with 100 trees. Note that this is a string and the absence of the <code>classif.</code> or <code>regr.</code> keywords. See <a href="https://mlr3learners.mlr-org.com">https://mlr3learners.mlr-org.com</a> for a list of <code>mlr3</code> learners.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learner_propensity_score</code></td>
<td>
<p>The estimator of the propensity scores. Either a numeric vector (which is then taken as estimates of the propensity scores) or a string specifying the estimator. In the latter case, the string must either be equal to <code>'constant'</code> (estimates the propensity scores by <code>mean(D)</code>), <code>'lasso'</code>, <code>'random_forest'</code>, <code>'tree'</code>, or <code>mlr3</code> syntax. Note that in case of <code>mlr3</code> syntax, do <em>not</em> specify if the learner is a regression learner or classification learner. Example: <code>'mlr3::lrn("ranger", num.trees = 100)'</code> for a random forest learner with 100 trees. Note that this is a string and the absence of the <code>classif.</code> or <code>regr.</code> keywords. See <a href="https://mlr3learners.mlr-org.com">https://mlr3learners.mlr-org.com</a> for a list of <code>mlr3</code> learners.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_splits</code></td>
<td>
<p>Number of sample splits. Default is 100. Must be larger than one. If you want to run <code>GenericML</code> on a single split, please use <code>GenericML_single()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z_CLAN</code></td>
<td>
<p>A numeric matrix holding variables on which classification analysis (CLAN) shall be performed. CLAN will be performed on each column of the matrix. If <code>NULL</code> (default), then <code>Z_CLAN = Z</code>, i.e. CLAN is performed for all variables in <code>Z</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HT</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a Horvitz-Thompson (HT) transformation is applied in the BLP and GATES regressions. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantile_cutoffs</code></td>
<td>
<p>The cutoff points of the quantiles that shall be used for GATES grouping. Default is <code>c(0.25, 0.5, 0.75)</code>, which corresponds to the four quartiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X1_BLP</code></td>
<td>
<p>Specifies the design matrix <code class="reqn">X_1</code> in the regression. Must be an object of class  <code>"setup_X1"</code>. See the documentation of <code>setup_X1()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X1_GATES</code></td>
<td>
<p>Same as <code>X1_BLP</code>, just for the GATES regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff_GATES</code></td>
<td>
<p>Specifies the generic targets of GATES. Must be an object of class <code>"setup_diff"</code>. See the documentation of <code>setup_diff()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff_CLAN</code></td>
<td>
<p>Same as <code>diff_GATES</code>, just for the CLAN generic targets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_BLP</code></td>
<td>
<p>Specifies the covariance matrix estimator in the BLP regression. Must be an object of class <code>"setup_vcov"</code>. See the documentation of <code>setup_vcov()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_GATES</code></td>
<td>
<p>Same as <code>vcov_BLP</code>, just for the GATES regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal_variances_CLAN</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then all within-group variances of the CLAN groups are assumed to be equal. Default is <code>FALSE</code>. This specification is required for heteroskedasticity-robust variance estimation on the difference of two CLAN generic targets (i.e. variance of the difference of two means). If <code>TRUE</code> (corresponds to homoskedasticity assumption), the pooled variance is used. If <code>FALSE</code> (heteroskedasticity), the variance of Welch's t-test is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop_aux</code></td>
<td>
<p>Proportion of samples that shall be in the auxiliary set in case of random sample splitting. Default is 0.5. The number of samples in the auxiliary set will be equal to <code>floor(prop_aux * length(Y))</code>. If the data set is large, you can save computing time by choosing <code>prop_aux</code> to be smaller than 0.5. In case of stratified sampling (controlled through the argument <code>stratify</code> via <code>setup_stratify()</code>), <code>prop_aux</code> does not have an effect, and the number of samples in the auxiliary set is specified via <code>setup_stratify()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stratify</code></td>
<td>
<p>A list that specifies whether or not stratified sample splitting shall be performed. It is recommended to use the returned object of <code>setup_stratify()</code> as this list. See the documentation of <code>setup_stratify()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>significance_level</code></td>
<td>
<p>Significance level for VEIN. Default is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_variation</code></td>
<td>
<p>Specifies a threshold for the minimum variation of the BCA/CATE predictions. If the variation of a BCA/CATE prediction falls below this threshold, random noise with distribution <code class="reqn">N(0, var(Y)/20)</code> is added to it. Default is <code>1e-05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical. If <code>TRUE</code>, parallel computing will be used. Default is <code>FALSE</code>. On Unix systems, this will be done via forking (shared memory across threads). On non-Unix systems, this will be done through parallel socket clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_cores</code></td>
<td>
<p>Number of cores to be used in parallelization (if applicable). Default is the number of cores of the user's machine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed. Default is <code>NULL</code> for no random seeding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_learners</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all intermediate results of the learners will be stored. That is, for each learner and each split, all BCA and CATE predictions as well as all BLP, GATES, CLAN, and <code class="reqn">\Lambda</code> estimates will be stored. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_splits</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the sample splits will be stored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The specifications <code>"lasso"</code>, <code>"random_forest"</code>, and <code>"tree"</code> in <code>learners_GenericML</code> and <code>learner_propensity_score</code> correspond to the following <code>mlr3</code> specifications (we omit the keywords <code>classif.</code> and <code>regr.</code>). <code>"lasso"</code> is a cross-validated Lasso estimator, which corresponds to <code>'mlr3::lrn("cv_glmnet", s = "lambda.min", alpha = 1)'</code>. <code>"random_forest"</code> is a random forest with 500 trees, which corresponds to <code>'mlr3::lrn("ranger", num.trees = 500)'</code>. <code>"tree"</code> is a tree learner, which corresponds to <code>'mlr3::lrn("rpart")'</code>. <strong>Warning:</strong> <code>GenericML()</code> can be quite memory-intensive, in particular when the data set is large. To alleviate memory usage, consider setting <code>store_learners = FALSE</code>, choosing a low number of cores via <code>num_cores</code> (at the expense of longer computing time), setting <code>prop_aux</code> to a value smaller than the default of 0.5, or using <code>GenericML_combine()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"GenericML"</code>. On this object, we recommend to use the accessor functions <code>get_BLP()</code>, <code>get_GATES()</code>, and <code>get_CLAN()</code> to extract the results of the analyses of BLP, GATES, and CLAN, respectively. An object of class <code>"GenericML"</code> contains the following components:
</p>

<dl>
<dt><code>VEIN</code></dt>
<dd>
<p>A list containing two sub-lists called <code>best_learners</code> and <code>all_learners</code>, respectively. Each of these two sub-lists contains the inferential VEIN results on the generic targets of the BLP, GATES, and CLAN analyses. <code>all_learners</code> does this for all learners specified in the argument <code>learners_GenericML</code>, <code>best_learners</code> only for the corresponding best learners. Which learner is best for which analysis is assessed by the <code class="reqn">\Lambda</code> criteria discussed in Sections 5.2 and 5.3 of the paper.</p>
</dd>
<dt><code>best</code></dt>
<dd>
<p>A list containing information on the evaluation of which learner is the best for which analysis. Contains four components. The first three contain the name of the best learner for BLP, GATES, and CLAN, respectively. The fourth component, <code>overview</code>, contains the two <code class="reqn">\Lambda</code> criteria used to determine the best learners (discussed in Sections 5.2 and 5.3 of the paper).</p>
</dd>
<dt><code>propensity_scores</code></dt>
<dd>
<p>The propensity score estimates as well as the <code>"mlr3"</code> objects used to estimate them (if <code>mlr3</code> was used for estimation).</p>
</dd>
<dt><code>GenericML_single</code></dt>
<dd>
<p>Only nonempty if <code>store_learners = TRUE</code>. Contains all intermediate results of each learners for each split. That is, for a given learner (first level of the list) and split (second level),  objects of classes <code>"BLP"</code>, <code>"GATES"</code>, <code>"CLAN"</code>, <code>"proxy_BCA"</code>, <code>"proxy_CATE"</code> as well as the <code class="reqn">\Lambda</code> criteria (<code>"best"</code>)) are listed, which were computed with the given learner and split.</p>
</dd>
<dt><code>splits</code></dt>
<dd>
<p>Only nonempty if <code>store_splits = TRUE</code>. Contains a character matrix of dimension <code>length(Y)</code> by <code>num_splits</code>. Contains the group membership (main or auxiliary) of each observation (rows) in each split (columns). <code>"M"</code> denotes the main set, <code>"A"</code> the auxiliary set.</p>
</dd>
<dt><code>generic_targets</code></dt>
<dd>
<p>A list of generic target estimates for each learner. More specifically, each component is a list of the generic target estimates pertaining to the BLP, GATES, and CLAN analyses. Each of those lists contains a three-dimensional array containing the generic targets of a single learner for all sample splits (except CLAN where there is one more layer of lists).</p>
</dd>
<dt><code>arguments</code></dt>
<dd>
<p>A list of arguments used in the function call.</p>
</dd>
</dl>
<h3>Note</h3>

<p>In an earlier development version, Lucas Kitzmueller alerted us to several minor bugs and proposed fixes. Many thanks to him!
</p>


<h3>References</h3>

<p>Chernozhukov V., Demirer M., Duflo E., Fern√°ndez-Val I. (2020). ‚ÄúGeneric Machine Learning Inference on Heterogenous Treatment Effects in Randomized Experiments.‚Äù <em>arXiv preprint arXiv:1712.04802</em>. URL: <a href="https://arxiv.org/abs/1712.04802">https://arxiv.org/abs/1712.04802</a>.
</p>
<p>Lang M., Binder M., Richter J., Schratz P., Pfisterer F., Coors S., Au Q., Casalicchio G., Kotthoff L., Bischl B. (2019). ‚Äúmlr3: A Modern Object-Oriented Machine Learning Framework in R.‚Äù <em>Journal of Open Source Software</em>, <b>4</b>(44), 1903. doi: <a href="https://doi.org/10.21105/joss.01903">10.21105/joss.01903</a>.
</p>


<h3>See Also</h3>

<p><code>plot.GenericML()</code>
<code>print.GenericML()</code>
<code>get_BLP()</code>,
<code>get_GATES()</code>,
<code>get_CLAN()</code>,
<code>setup_X1()</code>,
<code>setup_diff()</code>,
<code>setup_vcov()</code>,
<code>setup_stratify()</code>,
<code>GenericML_single()</code>,
<code>GenericML_combine()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (require("glmnet") &amp;&amp; require("ranger")) {

## generate data
set.seed(1)
n  &lt;- 150                                  # number of observations
p  &lt;- 5                                    # number of covariates
D  &lt;- rbinom(n, 1, 0.5)                    # random treatment assignment
Z  &lt;- matrix(runif(n*p), n, p)             # design matrix
Y0 &lt;- as.numeric(Z %*% rexp(p) + rnorm(n)) # potential outcome without treatment
Y1 &lt;- 2 + Y0                               # potential outcome under treatment
Y  &lt;- ifelse(D == 1, Y1, Y0)               # observed outcome

## column names of Z
colnames(Z) &lt;- paste0("V", 1:p)

## specify learners
learners &lt;- c("lasso", "mlr3::lrn('ranger', num.trees = 10)")

## glmnet v4.1.3 isn't supported on Solaris, so skip Lasso in this case
if(Sys.info()["sysname"] == "SunOS") learners &lt;- learners[-1]

## specify quantile cutoffs (the 4 quartile groups here)
quantile_cutoffs &lt;- c(0.25, 0.5, 0.75)

## specify the differenced generic targets of GATES and CLAN
# use G4-G1, G4-G2, G4-G3 as differenced generic targets in GATES
diff_GATES &lt;- setup_diff(subtract_from = "most",
                        subtracted = c(1,2,3))
# use G1-G3, G1-G2 as differenced generic targets in CLAN
diff_CLAN  &lt;- setup_diff(subtract_from = "least",
                         subtracted = c(3,2))

## perform generic ML inference
# small number of splits to keep computation time low
x &lt;- GenericML(Z, D, Y, learners, num_splits = 2,
               quantile_cutoffs = quantile_cutoffs,
               diff_GATES = diff_GATES,
               diff_CLAN = diff_CLAN,
               parallel = FALSE)

## access BLP generic targets for best learner and make plot
get_BLP(x, plot = TRUE)

## access GATES generic targets for best learner and make plot
get_GATES(x, plot = TRUE)

## access CLAN generic targets for "V1" &amp; best learner and make plot
get_CLAN(x, variable = "V1", plot = TRUE)

}

</code></pre>


</div>