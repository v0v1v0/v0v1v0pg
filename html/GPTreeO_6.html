<div class="container">

<table style="width: 100%;"><tr>
<td>WrappedmlegpGP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 class WrappedmlegpGP</h2>

<h3>Description</h3>

<p>Contains the GP created by mlegp::mlegp from the <code>mlegp</code> package
</p>


<h3>Details</h3>

<p>This package is by default not able to include individual uncertainties for input points. For this reason, all fields related to <code>y_var</code> are not used when updating the GP. No covariance kernel can be specified either. This implementation also assumes a vector for <code>y</code> (and not a matrix with multiple columns). Moreover, since no parameters can be specified for the GP, we will only update the GP parameters due to internal dependencies, but not use <code>init_covpars</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>gp</code></dt>
<dd>
<p>The mlegp GP object (mlegp::mlegp in the <code>mlegp</code> manual)</p>
</dd>
<dt><code>X_buffer</code></dt>
<dd>
<p>Buffer matrix to collect x points until first GP can be trained</p>
</dd>
<dt><code>y_buffer</code></dt>
<dd>
<p>Buffer vector to collect y points until first GP can be trained</p>
</dd>
<dt><code>y_var_buffer</code></dt>
<dd>
<p>Buffer vector to collect variance of y points until first GP can be trained</p>
</dd>
<dt><code>add_y_var</code></dt>
<dd>
<p>Small additional variance used to keep the covariance matrix condition number under control</p>
</dd>
<dt><code>n_points_train_limit</code></dt>
<dd>
<p>Number of points needed before we can create the GP</p>
</dd>
<dt><code>n_points</code></dt>
<dd>
<p>The number of collected points belonging to this GP</p>
</dd>
<dt><code>x_dim</code></dt>
<dd>
<p>Dimensionality of input points</p>
</dd>
<dt><code>gp_control</code></dt>
<dd>
<p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt>
<dd>
<p>The initial covariance parameters when training the mlegp GP object in self@gp</p>
</dd>
<dt><code>estimate_covpars</code></dt>
<dd>
<p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>retrain_buffer_length</code></dt>
<dd>
<p>Only retrain after this many new points have been added to the buffer</p>
</dd>
<dt><code>retrain_buffer_counter</code></dt>
<dd>
<p>Counter for the number of new points added since last retraining</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt>
<dd>
<p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>X_shared</code></dt>
<dd>
<p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt>
<dd>
<p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt>
<dd>
<p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>n_shared_points</code></dt>
<dd>
<p>The number of own points shared with the GP in the sibling node</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WrappedmlegpGP-new"><code>WrappedmlegpGP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-update_init_covpars"><code>WrappedmlegpGP$update_init_covpars()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_lengthscales"><code>WrappedmlegpGP$get_lengthscales()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_X_data"><code>WrappedmlegpGP$get_X_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_y_data"><code>WrappedmlegpGP$get_y_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_y_var_data"><code>WrappedmlegpGP$get_y_var_data()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-get_cov_mat"><code>WrappedmlegpGP$get_cov_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-update_add_y_var"><code>WrappedmlegpGP$update_add_y_var()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-store_point"><code>WrappedmlegpGP$store_point()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-delete_buffers"><code>WrappedmlegpGP$delete_buffers()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-train"><code>WrappedmlegpGP$train()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-predict"><code>WrappedmlegpGP$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-delete_gp"><code>WrappedmlegpGP$delete_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-create_mlegp_gp"><code>WrappedmlegpGP$create_mlegp_gp()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-call_mlegp_predict"><code>WrappedmlegpGP$call_mlegp_predict()</code></a>
</p>
</li>
<li> <p><a href="#method-WrappedmlegpGP-clone"><code>WrappedmlegpGP$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-WrappedmlegpGP-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new WrappedmlegpGP object
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$new(
  X,
  y,
  y_var,
  gp_control,
  init_covpars,
  retrain_buffer_length,
  add_buffer_in_prediction,
  estimate_covpars = TRUE,
  X_shared = NULL,
  y_shared = NULL,
  y_var_shared = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>Input data matrix with x_dim columns and at maximum Nbar rows. Is used to create the first iteration of the local GP.</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt>
<dd>
<p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>gp_control</code></dt>
<dd>
<p>A list of GP implementation-specific options, passed directly to the wrapped GP implementation</p>
</dd>
<dt><code>init_covpars</code></dt>
<dd>
<p>Initial covariance parameters of the local GP</p>
</dd>
<dt><code>retrain_buffer_length</code></dt>
<dd>
<p>Only retrain when the number of buffer points or collected points exceeds this value</p>
</dd>
<dt><code>add_buffer_in_prediction</code></dt>
<dd>
<p>If TRUE, points in the data buffers are added to the GP before prediction. They are added into a temporarily created GP which contains the not yet included points. The GP in the node is not yet updated.</p>
</dd>
<dt><code>estimate_covpars</code></dt>
<dd>
<p>If TRUE, the parameters are estimated by the package. Otherwise, the parameters from init_covpars are taken</p>
</dd>
<dt><code>X_shared</code></dt>
<dd>
<p>Matrix with x points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_shared</code></dt>
<dd>
<p>Vector of y points that this GP shares with the GP in the sibling node</p>
</dd>
<dt><code>y_var_shared</code></dt>
<dd>
<p>Vector of y_var points that this GP shares with the GP in the sibling node</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new WrappedmlegpGP object. Besides the local GP, information on the shared points and those stored in the buffer are collected. For more information on the GP, consult the method mlegp::mlegp in the <code>mlegp</code> package.
</p>


<hr>
<a id="method-WrappedmlegpGP-update_init_covpars"></a>



<h4>Method <code>update_init_covpars()</code>
</h4>

<p>Stores the initial covariance parameters (length-scales, standard deviation and trend coefficients) of the GP in the field <code>init_covpars</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$update_init_covpars()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-get_lengthscales"></a>



<h4>Method <code>get_lengthscales()</code>
</h4>

<p>Retrieves the length-scales of the kernel of the local GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_lengthscales()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-get_X_data"></a>



<h4>Method <code>get_X_data()</code>
</h4>

<p>Retrieves the design matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_X_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt>
<dd>
<p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>
</div>


<hr>
<a id="method-WrappedmlegpGP-get_y_data"></a>



<h4>Method <code>get_y_data()</code>
</h4>

<p>Retrieves the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_y_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt>
<dd>
<p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>
</div>


<hr>
<a id="method-WrappedmlegpGP-get_y_var_data"></a>



<h4>Method <code>get_y_var_data()</code>
</h4>

<p>Retrieves the individual variances from the response
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_y_var_data(include_shared = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>include_shared</code></dt>
<dd>
<p>If TRUE, shared points between this GP and its sibling GP are included</p>
</dd>
</dl>
</div>


<hr>
<a id="method-WrappedmlegpGP-get_cov_mat"></a>



<h4>Method <code>get_cov_mat()</code>
</h4>

<p>Retrieves the covariance matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$get_cov_mat()</pre></div>



<h5>Returns</h5>

<p>the covariance matrix
</p>


<hr>
<a id="method-WrappedmlegpGP-update_add_y_var"></a>



<h4>Method <code>update_add_y_var()</code>
</h4>

<p>Method for updating add_y_var based on a bound for the covariance matrix condition number, based on <a href="https://arxiv.org/abs/1602.00853">this paper</a>, Section 5.4
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$update_add_y_var(max_cond_num)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_cond_num</code></dt>
<dd>
<p>Max allowed condition number</p>
</dd>
</dl>
</div>


<hr>
<a id="method-WrappedmlegpGP-store_point"></a>



<h4>Method <code>store_point()</code>
</h4>

<p>Stores a new point into the respective buffer method
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$store_point(x, y, y_var, shared = FALSE, remove_shared = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Single input data point from the data stream; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt>
<dd>
<p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
<dt><code>shared</code></dt>
<dd>
<p>If TRUE, this point is shared between this GP and its sibling GP</p>
</dd>
<dt><code>remove_shared</code></dt>
<dd>
<p>If TRUE, the last of the shared points is removed</p>
</dd>
</dl>
</div>


<hr>
<a id="method-WrappedmlegpGP-delete_buffers"></a>



<h4>Method <code>delete_buffers()</code>
</h4>

<p>Method for clearing the buffers
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$delete_buffers()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-train"></a>



<h4>Method <code>train()</code>
</h4>

<p>Method for (re)creating / (re)training the GP
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$train(do_buffer_check = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>do_buffer_check</code></dt>
<dd>
<p>If TRUE, only train the GP if the number of stored points is larger than retrain_buffer_length</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>TRUE if training was performed, otherwise FALSE
</p>


<hr>
<a id="method-WrappedmlegpGP-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Method for prediction
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$predict(x, return_std = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector or row matrix with length equal to x_dim</p>
</dd>
<dt><code>return_std</code></dt>
<dd>
<p>If TRUE, the standard error is returned in addition to the prediction</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Prediction for input point x
</p>


<hr>
<a id="method-WrappedmlegpGP-delete_gp"></a>



<h4>Method <code>delete_gp()</code>
</h4>

<p>Method to delete the GP object in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$delete_gp()</pre></div>


<hr>
<a id="method-WrappedmlegpGP-create_mlegp_gp"></a>



<h4>Method <code>create_mlegp_gp()</code>
</h4>

<p>Method for calling the 'mlegp' function in mlegp to create a GP object, stored in self$gp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$create_mlegp_gp(X, y, y_var)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>Input data matrix with x_dim columns and at maximum Nbar rows for the local GP.</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>Value of target variable at input point x; has to be a one-dimensional matrix or a vector; any further columns will be ignored</p>
</dd>
<dt><code>y_var</code></dt>
<dd>
<p>Variance of the target variable; has to be a one-dimensional matrix or vector</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>TRUE
</p>


<hr>
<a id="method-WrappedmlegpGP-call_mlegp_predict"></a>



<h4>Method <code>call_mlegp_predict()</code>
</h4>

<p>Method for calling the 'predict' function in mlegp
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$call_mlegp_predict(x, use_gp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Single data point for which the predicted mean (and standard deviation) is computed; has to be a vector with length equal to x_dim</p>
</dd>
<dt><code>use_gp</code></dt>
<dd>
<p>Optional user-defined GP which is evaluated instead of the local GP</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The predictions for x from the specified GP, by default the local GP. The output needs to be a list with fields mean and sd for the prediction and prediction error, respectively.
</p>


<hr>
<a id="method-WrappedmlegpGP-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WrappedmlegpGP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




</div>