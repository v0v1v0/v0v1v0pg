<div class="container">

<table style="width: 100%;"><tr>
<td>GeoOutlier</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatio (temporal) outliers detection</h2>

<h3>Description</h3>

<p>Given a set of spatio (temporal) locations and data, the procedure select the spatial or spatiotemporal ouliers
using a specific algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GeoOutlier(data, coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL, 
             distance="Eucl", grid=FALSE,  neighb=10,alpha=0.001,
             method="Z-Median", radius=6371, bivariate=FALSE,X=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional <code class="reqn">d</code>-dimensional vector (a single spatial realisation)  or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or a (<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)   or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.
Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b>  of <code>GeoFit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhoodused for Z-Median algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric; a numeric value between 0 and 1 used for Z-Median algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>String; The name of the algorithm for detecting spatial ouliers. Default is Z-median proposed in Chen et al. (2008)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great 
circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bivariate</code></td>
<td>
<p>If TRUE then data  is considered as spatial  bivariate data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Numeric; an optional Matrix of spatio (temporal) covariates.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Return a  matrix or a list  containing the dected spatial or spatio-temporal outliers
</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian", Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Chen D, Lu C, Kou Y, Chen F (2008) On detecting spatial outliers. Geoinformatica 12:455–475
</p>
<p>Bevilacqua M., Caamaño C., Arellano-Valle R. B., Camilo Gomez C. (2022) A class of random fields with two-piece marginal distributions for modeling point-referenced data with spatial outliers. <em>Test</em>  10.1007/s11749-021-00797-5
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(GeoModels)
set.seed(1428)
NN = 1500
coords = cbind(runif(NN),runif(NN))
###
scale=0.5/3
corrmodel = "Matern"; 

param = list(mean=0,sill=1,nugget=0,scale=scale,smooth=0.5,skew=0)
data = GeoSim(coordx = coords,corrmodel = corrmodel,
                  model = "TwoPieceGaussian",param = param)$data

K=15         #parameter for outliers detection alghoritm
alpha=0.005  #parameter for outliers detection alghoritm
outlier=GeoOutlier(data=data, coordx = coords,neighb=K,alpha=alpha)
quilt.plot(coords,data)
for (i in 1:nrow(outlier))  plotrix::draw.circle(outlier[i,1], outlier[i,2],radius=0.02,lwd=2) 
nrow(outlier) # number of outliers

param = list(mean=0,sill=1,nugget=0.4,scale=scale,smooth=0.5)
data = GeoSim(coordx = coords,corrmodel = corrmodel,
                  model = "Gaussian",param = param)$data

K=15         #parameter for outliers detection alghoritm
alpha=0.005  #parameter for outliers detection alghoritm
outlier=GeoOutlier(data=data, coordx = coords,neighb=K,alpha=alpha)
quilt.plot(coords,data)
for (i in 1:nrow(outlier))  plotrix::draw.circle(outlier[i,1], outlier[i,2],radius=0.02,lwd=2)
nrow(outlier) # number of outliers
</code></pre>


</div>