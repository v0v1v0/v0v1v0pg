<div class="container">

<table style="width: 100%;"><tr>
<td>sgemd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Statistical Graph Empirical Mode Decomposition</h2>

<h3>Description</h3>

<p>This function performs statistical graph empirical mode decomposition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sgemd(graph, nimf, smoothing = FALSE, smlevels = c(1),  
    boundary = FALSE, reflperc = 0.3, reflaver = FALSE, 
    connperc = 0.05, connweight = "boundary", 
    tol = 0.1^3, max.sift = 50, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>an <span class="pkg">igraph</span> graph object with vertex attributes of coordinates <code>x</code>, <code>y</code>, a signal <code>z</code>, and edge attribute of <code>weight</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nimf</code></td>
<td>
<p>specifies the maximum number of intrinsic mode functions (IMF).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing</code></td>
<td>
<p>specifies whether intrinsic mode functions are constructed by interpolating or smoothing envelopes. 
When <code>smoothing =TRUE</code>, denoise envelopes utilizing the graph Fourier transform and empirical Bayes thresholding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smlevels</code></td>
<td>
<p>specifies which level of the IMF is obtained by smoothing other than interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>When <code>boundary=TRUE</code>, a given graph is reflected for boundary treatment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reflperc</code></td>
<td>
<p>expand a graph by adding specified percentage of a graph at the boundary when <code>boundary=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reflaver</code></td>
<td>
<p>specifies the method assigning signal to reflected vertices. 
When <code>reflaver=TRUE</code>, the signal on reflected vertices is produced by averaging signals on neighboring vertices on a given graph.
Otherwise, signal on reflected vertices is the same to the signal on a given graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connperc</code></td>
<td>
<p>specifies percentage of a graph for connecting a given graph and reflected graph when <code>boundary=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connweight</code></td>
<td>
<p>specifies the method assigning the edge weights for connecting a given graph and reflected graph 
when <code>boundary=TRUE</code>.
The edge weights are calculated by Gaussian kernel considering the relative distance between vertices.
When <code>connweight="graph"</code>, the relative distance is calculated based on the maximum distance of all the neighboring edges 
of a given graph.
When <code>connweight="boundary"</code>, the relative distance is calculated based on the maximum distance of the connected vertices 
between a given graph and reflected graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for stopping rule of sifting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.sift</code></td>
<td>
<p>the maximum number of sifting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>specifies whether sifting steps are displayed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs statistical graph empirical mode decomposition utilizing extrema detection of a graph signal.
</p>


<h3>Value</h3>

 
<table>
<tr style="vertical-align: top;">
<td><code>imf</code></td>
<td>
<p>list of IMF's according to the frequencies with <code>imf[[1]]</code> the highest-frequency IMF.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residue</code></td>
<td>
<p>residue signal after extracting IMF's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nimf</code></td>
<td>
<p>the number of IMF's.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_extrema</code></td>
<td>
<p>Each row specifies the number of local maxima and local minima of the remaining signal after extracting the i-th IMF. 
The first row represents the number of local maxima and local minima of a given signal.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Huang, N. E., Shen, Z., Long, S. R., Wu, M. C., Shih, H. H., Zheng, Q., Yen, N.- C., Tung, C. C., and Liu, H. H. (1998). The empirical mode decomposition and the Hilbert spectrum for nonlinear and non-stationary time series analysis. <em>Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences</em>, <b>454(1971)</b>, 903–-995.
<a href="https://doi.org/10.1098/rspa.1998.0193">doi:10.1098/rspa.1998.0193</a>
</p>
<p>Johnstone, I. and Silverman, B.~W. (2004).
Needles and straw in haystacks: empirical Bayes estimates of possibly sparse sequences. <em>The Annals of Statistics</em>, <b>32</b>, 594–1649.
<a href="https://doi.org/10.1214/009053604000000030">doi:10.1214/009053604000000030</a>
</p>
<p>Kim, D., Kim, K. O., and Oh, H.-S. (2012a). Extending the scope of empirical mode decomposition by smoothing. <em>EURASIP Journal on Advances in Signal Processing</em>, <b>2012</b>, 1–17.
<a href="https://doi.org/10.1186/1687-6180-2012-168">doi:10.1186/1687-6180-2012-168</a>
</p>
<p>Kim, D., Park, M., and Oh, H.-S. (2012b). Bidimensional statistical empirical mode decomposition. <em>IEEE Signal Processing Letters</em>, <b>19(4)</b>, 191–194.
<a href="https://doi.org/10.1109/LSP.2012.2186566">doi:10.1109/LSP.2012.2186566</a>
</p>
<p>Ortega, A., Frossard, P., Kovačević, J., Moura, J. M. F., and Vandergheynst, P. (2018).
Graph signal processing: overview, challenges, and applications. <em>Proceedings of the IEEE 106</em>, 808–828.
<a href="https://doi.org/10.1109/JPROC.2018.2820126">doi:10.1109/JPROC.2018.2820126</a>
</p>
<p>Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., and Vandergheynst, P. (2013). The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains. <em>IEEE Signal Processing Magazine</em>, <b>30(3)</b>, 83–98.
<a href="https://doi.org/10.1109/MSP.2012.2235192">doi:10.1109/MSP.2012.2235192</a>
</p>
<p>Tremblay, N., Borgnat, P., and Flandrin, P. (2014). Graph empirical mode decomposition. <em>22nd European Signal Processing Conference (EUSIPCO)</em>, 2350–2354
</p>
<p>Zeng, J., Cheung, G., and Ortega, A. (2017). Bipartite approximation for graph wavelet signal decomposition. <em>IEEE Transactions on Signal Processing</em>, <b>65(20)</b>, 5466–5480.
<a href="https://doi.org/10.1109/TSP.2017.2733489">doi:10.1109/TSP.2017.2733489</a>
</p>


<h3>See Also</h3>

<p><code>gextrema</code>, <code>gsmoothing</code>, <code>ginterpolating</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### example : composite of two components having different frequencies

## define vertex coordinate
x &lt;- y &lt;- seq(0, 1, length=30)
xy &lt;- expand.grid(x=x, y=y)

## weighted adjacency matrix by Gaussian kernel 
## for connecting vertices within distance 0.04
A &lt;- adjmatrix(xy, method = "dist", 0.04) 

## signal
# high-frequency component
signal1 &lt;- rep(sin(12.5*pi*x - 1.25*pi), 30)

# low-frequency component
signal2 &lt;- rep(sin(5*pi*x - 0.5*pi), 30)

# composite signal
signal0 &lt;- signal1 + signal2

# noisy signal with SNR(signal-to-noise ratio)=5
signal &lt;- signal0 + rnorm(900, 0, sqrt(var(signal0) / 5)) 

# graph with signal
gsig &lt;- gsignal(vertex = cbind(xy, signal), edge = A, edgetype = "matrix")

# graph empirical mode decomposition (GEMD) without boundary treatment
out1 &lt;- sgemd(gsig, nimf=3, smoothing=FALSE, boundary=FALSE)

# denoised signal by GEMD 
dsignal1 &lt;- out1$imf[[2]] + out1$imf[[3]] + out1$residue


# statistical graph empirical mode decomposition (SGEMD) with boundary treatment
out2 &lt;- sgemd(gsig, nimf=3, smoothing=TRUE, boundary=TRUE)
names(out2)

# denoised signal by SGEMD 
dsignal2 &lt;- out2$imf[[2]] + out2$imf[[3]] + out2$residue

# display of a signal, denoised signal, imf2, imf3 and residue by SGEMD
gplot(gsig, size=3) 
gplot(gsig, dsignal2, size=3) 
gplot(gsig, out2$imf[[2]], size=3) 
gplot(gsig, out2$imf[[3]], size=3) 
gplot(gsig, out2$residue, size=3) 

</code></pre>


</div>