<div class="container">

<table style="width: 100%;"><tr>
<td>make_sigma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate Sigma (<code class="reqn">\Sigma</code>) Matrix</h2>

<h3>Description</h3>

<p>Compute the Sigma (<code class="reqn">\Sigma</code>) matrix from an <code>igraph</code> structure 
or pre-computed matrix. These are compatible with <code>rmvnorm</code> and
<code>generate_expression</code>.
By default data is generated with a mean of 0 and standard deviation of 1 for 
each gene (with correlations between derived from the graph structure).
Thus where the Sigma (<code class="reqn">\Sigma</code>) matrix has diagonals of 1 (for the variance of each gene)
then the symmetric non-diagonal terms (for covariance) determine the correlations
between each gene in the output from <code>generate_expression</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_sigma_mat_adjmat(mat, state = NULL, cor = 0.8, sd = 1)

make_sigma_mat_comm(mat, state = NULL, cor = 0.8, sd = 1)

make_sigma_mat_laplacian(mat, state = NULL, cor = 0.8, sd = 1)

make_sigma_mat_graph(
  graph,
  state = NULL,
  cor = 0.8,
  sd = 1,
  comm = FALSE,
  laplacian = FALSE,
  directed = FALSE
)

make_sigma_mat_dist_adjmat(
  mat,
  state = NULL,
  cor = 0.8,
  sd = 1,
  absolute = FALSE
)

make_sigma_mat_dist_graph(
  graph,
  state = NULL,
  cor = 0.8,
  sd = 1,
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>precomputed adjacency, laplacian, commonlink, or scaled distance matrix (generated by <code>make_distance</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>numeric vector. Vector of length E(graph). Sign used to calculate 
state matrix, may be an integer state or inferred directly from expected correlations
for each edge. May be applied a scalar across all edges or as a vector for each edge
respectively. May also be entered as text for "activating" or "inhibiting" or as
integers for activating (0,1) or inhibiting (-1,2). Compatible with inputs for 
<code>plot_directed</code>. Also takes a pre-computed state matrix from
<code>make_state</code> if applied to the same graph multiple times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>numeric. Simulated maximum correlation/covariance of two adjacent nodes.
Default to 0.8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>standard deviations of each gene. Defaults to 1. May be entered as a scalar
applying to all genes or a vector with a separate value for each.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An <code>igraph</code> object. May be directed or weighted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comm</code></td>
<td>
<p>logical whether a common link matrix is used to compute sigma.
Defaults to FALSE (adjacency matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>laplacian</code></td>
<td>
<p>logical whether a Laplacian matrix is used to compute sigma.
Defaults to FALSE (adjacency matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>logical. Whether directed information is passed to the distance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>absolute</code></td>
<td>
<p>logical. Whether distances are scaled as the absolute difference from
the diameter (maximum possible). Defaults to TRUE. The alternative is to calculate a
relative difference from the diameter for a geometric decay in distance.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a numeric covariance matrix of values in the range [-1, 1]
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code>generate_expression</code> for computing the simulated data,
<code>make_distance</code> for computing distance from a graph object,
and
<code>make_state</code> for resolving inhibiting states.
</p>
<p>See also <code>plot_directed</code> for plotting graphs or 
<code>heatmap.2</code> for plotting matrices.
</p>
<p>See also <code>make_laplacian</code>, <code>make_commonlink</code>, 
or <code>make_adjmatrix</code> for computing input matrices.
</p>
<p>See also <code>igraph</code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code>generate_expression()</code>,
<code>make_adjmatrix</code>,
<code>make_commonlink</code>,
<code>make_distance</code>,
<code>make_laplacian</code>,
<code>make_state</code>,
<code>plot_directed()</code>
</p>
<p>Other generate simulated expression functions: 
<code>generate_expression()</code>,
<code>make_distance</code>,
<code>make_state</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)
# compute sigma (\eqn{\Sigma}) matrix for toy example
sigma_matrix &lt;- make_sigma_mat_graph(graph_test, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix  from adjacency matrix for toy example
adjacency_matrix &lt;- make_adjmatrix_graph(graph_test)
sigma_matrix &lt;- make_sigma_mat_adjmat(adjacency_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from shared edges for toy example
common_link_matrix &lt;- make_commonlink_graph(graph_test)
sigma_matrix &lt;- make_sigma_mat_comm(common_link_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from Laplacian for toy example
laplacian_matrix &lt;- make_laplacian_graph(graph_test)
sigma_matrix &lt;- make_sigma_mat_laplacian(laplacian_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from distance matrix for toy example
distance_matrix &lt;- make_distance_graph(graph_test, absolute = FALSE)
sigma_matrix &lt;- make_sigma_mat_dist_adjmat(distance_matrix, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from toy example graph
sigma_matrix &lt;- make_sigma_mat_dist_graph(graph_test, cor = 0.8)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from absolute distance directly from toy example graph
sigma_matrix &lt;- make_sigma_mat_dist_graph(graph_test, cor = 0.8, absolute = TRUE)
sigma_matrix

# compute sigma (\eqn{\Sigma}) matrix from geometric distance with sd = 2
sigma_matrix &lt;- make_sigma_mat_dist_graph(graph_test, cor = 0.8, sd = 2)
sigma_matrix

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from synthetic graph network
sigma_matrix_graph_structure &lt;- make_sigma_mat_dist_graph(graph_structure,
                                                          cor = 0.8, absolute = FALSE)
sigma_matrix_graph_structure
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_graph_structure, scale = "none", trace = "none",
                     col = colorpanel(50, "white", "red"))

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from
# synthetic graph network with inhibitions
edge_state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# pass edge state as a parameter
sigma_matrix_graph_structure_inhib &lt;- make_sigma_mat_dist_graph(graph_structure, 
                                                                state = edge_state,
                                                                cor = 0.8,
                                                                absolute = FALSE)
sigma_matrix_graph_structure_inhib
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_graph_structure_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from 
# synthetic graph network with inhibitions
E(graph_structure)$state &lt;-  c(1, 1, -1, 1, 1, 1, 1, -1)
# pass edge state as a graph attribute
sigma_matrix_graph_structure_inhib &lt;- make_sigma_mat_dist_graph(graph_structure,
                                                                cor = 0.8,
                                                                absolute = FALSE)
sigma_matrix_graph_structure_inhib
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_graph_structure_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from TGF-\eqn{\Beta} pathway
TFGBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
table(TFGBeta_Smad_state)
# states are edge attributes
 sigma_matrix_TFGBeta_Smad_inhib &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                              cor = 0.8,
                                                              absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from TGF-\eqn{\Beta} pathway
TGFBeta_Smad_graph &lt;- remove.edge.attribute(TGFBeta_Smad_graph, "state")
# compute with states removed (all negative)
sigma_matrix_TFGBeta_Smad &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                       state = -1,
                                                       cor = 0.8,
                                                       absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))
# compute with states removed (all positive)
sigma_matrix_TFGBeta_Smad &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                       state = 1,
                                                       cor = 0.8,
                                                       absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad, scale = "none", trace = "none",
          col = colorpanel(50, "white", "red"))

#restore edge attributes
TGFBeta_Smad_graph &lt;- set_edge_attr(TGFBeta_Smad_graph, "state",
                                    value = TFGBeta_Smad_state)
TFGBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
# states are edge attributes
 sigma_matrix_TFGBeta_Smad_inhib &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                              cor = 0.8,
                                                              absolute = FALSE)
# visualise matrix
library("gplots")
heatmap.2(sigma_matrix_TFGBeta_Smad_inhib, scale = "none", trace = "none",
          col = colorpanel(50, "blue", "white", "red"))

</code></pre>


</div>