<div class="container">

<table style="width: 100%;"><tr>
<td>get_results</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> using elts from <code>get_elts()</code> given one <code class="reqn">\lambda_{\mathbf{K}}</code> (and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code> if non-profiled non-centered) and applying warm-start with strong screening rules.</h2>

<h3>Description</h3>

<p>Estimate <code class="reqn">\mathbf{K}</code> and <code class="reqn">\boldsymbol{\eta}</code> using elts from <code>get_elts()</code> given one <code class="reqn">\lambda_{\mathbf{K}}</code> (and <code class="reqn">\lambda_{\boldsymbol{\eta}}</code> if non-profiled non-centered) and applying warm-start with strong screening rules.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_results(
  elts,
  symmetric,
  lambda1,
  lambda2 = 0,
  tol = 1e-06,
  maxit = 10000,
  previous_res = NULL,
  is_refit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>elts</code></td>
<td>
<p>A list, elements necessary for calculations returned by <code>get_elts()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>A string. If equals <code>"symmetric"</code>, estimates the minimizer <code class="reqn">\mathbf{K}</code> over all symmetric matrices; if <code>"and"</code> or <code>"or"</code>, use the "and"/"or" rule to get the support.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>A number, the penalty parameter for <code class="reqn">\mathbf{K}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>A number, the penalty parameter for <code class="reqn">\boldsymbol{\eta}</code>. Default to <code>0</code>. Cannot be <code>Inf</code> if non-profiled non-centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Optional. A number, the tolerance parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Optional. A positive integer, the maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>previous_res</code></td>
<td>
<p>Optional. A list or <code>NULL</code>, the returned list by this function run previously with another lambda value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_refit</code></td>
<td>
<p>A boolean, in the refit mode for BIC estimation if <code>TRUE</code>. If <code>TRUE</code>, <code>lambda1</code>, <code>previous_lambda1</code> and <code>lambda2</code> are all set to <code>0</code>, and estimation is restricted to entries in exclude that are <code>0</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>elts$domain_type == "simplex"</code>, <code>symmetric != "symmetric"</code> or <code>elts$centered == FALSE &amp;&amp; elts$profiled_if_noncenter</code> are currently not supported.
If <code>elts$domain_type == "simplex"</code> and <code>elts$setting</code> contains substring <code>"sum0"</code>, it is assumed that the column and row sums of <code>K</code> are all 0 and estimation will be done by profiling out the diagonal entries.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>A boolean indicating convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>A number, the final penalized loss.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edges</code></td>
<td>
<p>A vector of the indices of entries in the <code>K</code> estimate that are non-zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>A p-vector, the <code>eta</code> estimate. Returned only if <code>elts$centered == FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta_support</code></td>
<td>
<p>A vector of the indices of entries in the <code>eta</code> estimate that are non-zero. Returned only if <code>elts$centered == FALSE &amp;&amp; elts$profiled_if_noncenter == TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iters</code></td>
<td>
<p>An integer, number of iterations run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>A p*p matrix, the <code>K</code> estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>An integer, the number of samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>An integer, the dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_refit,lambda1,maxit,previous_lambda1,symmetric,tol</code></td>
<td>
<p>Same as in the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>Same as in the input, and returned only if <code>elts$centered == FALSE</code> and <br><code>elts$profiled_if_noncenter == FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()}, as the
#   way to call this function (\code{get_results()}) is exactly the same in those cases.
n &lt;- 50
p &lt;- 30
domain &lt;- make_domain("R+", p=p)
mu &lt;- rep(0, p)
K &lt;- diag(p)
x &lt;- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

h_hp &lt;- get_h_hp("min_pow", 1, 3)
dm &lt;- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
elts_gauss_np &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
                centered=FALSE, profiled=FALSE, scale="norm", diag=dm)
test_nc_np &lt;- get_results(elts_gauss_np, symmetric="symmetric", lambda1=0.35,
                lambda2=2, previous_res=NULL, is_refit=FALSE)
test_nc_np2 &lt;- get_results(elts_gauss_np, symmetric="and", lambda1=0.25,
                 lambda2=2, previous_res=test_nc_np, is_refit=FALSE)

elts_gauss_p &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
               centered=FALSE, profiled=TRUE, scale="norm", diag=dm)
test_nc_p &lt;- get_results(elts_gauss_p, symmetric="symmetric",
               lambda1=0.35, lambda2=NULL, previous_res=NULL, is_refit=FALSE)

elts_gauss_c &lt;- get_elts(h_hp, x, setting="gaussian", domain=domain,
               centered=TRUE, scale="norm", diag=dm)
test_c &lt;- get_results(elts_gauss_c, symmetric="or", lambda1=0.35,
               lambda2=NULL, previous_res=NULL, is_refit=FALSE)

</code></pre>


</div>