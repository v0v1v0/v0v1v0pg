<div class="container">

<table style="width: 100%;"><tr>
<td>glinternet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a linear interaction model with group-lasso regularization
that enforces 
strong hierarchy in the estimated coefficients</h2>

<h3>Description</h3>

<p>The regularization path is computed along a grid of values
for the regularization parameter lambda. Can deal with categorical
variables with arbitrary numbers of levels, continuous variables, and
combinations of the two. Accommodates squared error loss and logistic loss.
</p>
<p>The multicore option requires that the package be compiled with OpenMP support.
Examples of compilers that qualify include gcc (&gt;= 4.2) and icc. We also recommend
a higher level of optimization, such as -O3 in gcc.</p>


<h3>Usage</h3>

<pre><code class="language-R">glinternet(X, Y, numLevels, lambda = NULL, nLambda = 50, lambdaMinRatio = 0.01,
 interactionCandidates=NULL, interactionPairs=NULL, screenLimit = NULL, numToFind = NULL,
family = c("gaussian","binomial"), tol = 1e-05, maxIter=5000, verbose=FALSE,
numCores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of features or predictors with dimension nobs x nvars;
each row is an observation vector. Categorical variables must be coded
as 0, 1, 2, ...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Target variable of length nobs. Continuous for squared error
loss, 0-1 for logistic loss.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numLevels</code></td>
<td>
<p>Number of levels for each variable, of length
nvars. Set to 1 for continuous variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence. Typical usage
is to have the program compute its own <code>lambda</code> sequence based on
<code>nLambda</code> and <code>lambdaMinRatio</code>. Supplying a value of
<code>lambda</code> overrides this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nLambda</code></td>
<td>
<p>The number of <code>lambda</code> values. Default is 50.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMinRatio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a fraction of
<code>lambdaMax</code>, the (data derived) entry value (i.e. the smallest
value for which all coefficients are zero). The default is
<code>0.01</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactionCandidates</code></td>
<td>
<p>An optional vector of variable
indices. This will force the algorithm to only consider interactions
between <code>interactionCandidates</code> and all other variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interactionPairs</code></td>
<td>
<p>An optional nx2 matrix of variable
indices. This will force the algorithm to only consider the interaction
pairs defined by this matrix. For example, matrix(c(1,2,1,5),
ncol=2, byrow=TRUE) restricts the model to two interaction pairs:
one between variables 1 and 2, and another between 1 and 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>screenLimit</code></td>
<td>
<p>If not null (the default), limits the size of the interaction
search space to <code>screenLimit</code> x nvars by only considering
interactions with the best <code>screenLimit</code> candidate main effects
at each point along the regularization path. Set this accordingly for
large problems or if there are memory limitations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numToFind</code></td>
<td>
<p>Stops the program after <code>numToFind</code> interaction
pairs are found. Default is null - fit all values of <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A character string describing the target variable:
"gaussian" for continuous (the default), "binomial" for logistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Convergence tolerance in the adaptive FISTA algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>Maximum number of iterations in adaptive FISTA. Default 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Prints progress. False by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numCores</code></td>
<td>
<p>Number of threads to run. For this to work, the
package must be installed with OpenMP enabled. Default is 1 thread.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by FISTA (fast
iterative soft thresholding) with adaptive step size and adaptive
momentum restart. The continuous features are standardized to have
unit norm and mean zero before computing the <code>lambda</code> sequence
and fitting. The returned coefficients are unstandardized. Categorical
variables are not standardized.
</p>


<h3>Value</h3>

<p>An object of class <code>glinternet</code> with the components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The user function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>The fitted values, with dimension nobs x
<code>nLambda</code>. If <code>numToFind</code> is specified, the program is
likely to stop before all <code>nLambda</code> models have been fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual <code>lambda</code> sequence used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objValue</code></td>
<td>
<p>Objective values for each lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activeSet</code></td>
<td>
<p>A list (of length <code>nLambda</code>) of the variables found. Internally, the
categorical and continuous variables are separated into two groups,
and each has their own indexing system (1-based). For example, the
categorical-continuous interaction <code>c(i, j)</code> refers to the
interaction between the <code>i</code>-th categorical variable with the
<code>j</code>-th continuous variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betahat</code></td>
<td>
<p>List (of length <code>lambda</code>) of coefficients for the variables in
<code>activeSet</code>. The first component is the intercept. Subsequent entries correspond to the variables in activeSet. For example, if the first variable in activeSet is a 3-level categorical variable, then components 2-4 of betahat are the coefficients for this variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numLevels</code></td>
<td>
<p>The number of levels for each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The target variable type.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Michael Lim and Trevor Hastie<br> Maintainer: Michael Lim <a href="mailto:michael626@gmail.com">michael626@gmail.com</a></p>


<h3>References</h3>

<p>Michael Lim and Trevor Hastie (2013)<em>Learning interactions via hierarchical group-lasso
regularization</em>,
<a href="https://arxiv.org/abs/1308.2719">https://arxiv.org/abs/1308.2719</a>
</p>


<h3>See Also</h3>

<p><code>glinternet.cv</code>, <code>predict.glinternet</code>,
<code>predict.glinternet.cv</code>, <code>plot.glinternet.cv</code>, <code>coef.glinternet</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># gaussian response, continuous features
Y = rnorm(100)
X = matrix(rnorm(100*10), nrow=100)
numLevels = rep(1, 10)
fit = glinternet(X, Y, numLevels)

#binary response, continuous features
Y = rbinom(100, 1, 0.5)
fit = glinternet(X, Y, numLevels, family="binomial")

#binary response, categorical variables
X = matrix(sample(0:2, 100*10, replace=TRUE), nrow=100)
numLevels = rep(3, 10)
fit = glinternet(X, Y, numLevels, family="binomial")
</code></pre>


</div>