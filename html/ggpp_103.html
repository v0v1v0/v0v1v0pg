<div class="container">

<table style="width: 100%;"><tr>
<td>stat_dens1d_labels</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Replace labels in data based on 1D density</h2>

<h3>Description</h3>

<p><code>stat_dens1d_labels()</code> Sets values mapped to the
<code>label</code> aesthetic to <code>""</code> or a user provided character string
based on the local density in regions of a plot panel. Its main use is
together with repulsive geoms from package <code>ggrepel</code>
to restrict labeling to the low density tails of a distribution. By default
the data are handled all together, but it is also possible to control
labeling separately in each tail.
</p>
<p>If there is no mapping to <code>label</code> in <code>data</code>, the mapping is set
to <code>rownames(data)</code>, with a message.
</p>


<h3>Usage</h3>

<pre><code class="language-R">stat_dens1d_labels(
  mapping = NULL,
  data = NULL,
  geom = "text",
  position = "identity",
  ...,
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("x", "none"),
  xintercept = 0,
  invert.selection = FALSE,
  bw = "SJ",
  kernel = "gaussian",
  adjust = 1,
  n = 512,
  orientation = c("x", "y"),
  label.fill = "",
  return.density = FALSE,
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code>aes</code> or <code>aes_</code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed on to <code>layer</code>. This
can include aesthetics whose values you want to set, not map. See
<code>layer</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.fraction</code></td>
<td>
<p>numeric vector of length 1 or 2 [0..1]. The fraction of
the observations (or rows) in <code>data</code> to be retained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.number</code></td>
<td>
<p>integer vector of length 1 or 2. Set the maximum number of
observations to retain, effective only if obeying <code>keep.fraction</code>
would result in a larger number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.sparse</code></td>
<td>
<p>logical If <code>TRUE</code>, the default, observations from the
more sparse regions are retained, if <code>FALSE</code> those from the densest
regions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.these, exclude.these</code></td>
<td>
<p>character vector, integer vector, logical
vector or function that takes one or more variables in data selected by
<code>these.target</code>. Negative integers behave as in R's extraction methods.
The rows from <code>data</code> indicated by <code>keep.these</code> and
<code>exclude.these</code> are kept or excluded irrespective of the local
density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>these.target</code></td>
<td>
<p>character, numeric or logical selecting one or more
column(s) of <code>data</code>. If <code>TRUE</code> the whole <code>data</code> object is
passed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pool.along</code></td>
<td>
<p>character, one of <code>"none"</code> or <code>"x"</code>,
indicating if selection should be done pooling the observations along the
<em>x</em> aesthetic, or separately on either side of <code>xintercept</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xintercept</code></td>
<td>
<p>numeric The split point for the data filtering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert.selection</code></td>
<td>
<p>logical If <code>TRUE</code>, the complement of the
selected rows are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>numeric or character The smoothing bandwidth to be used. If
numeric, the standard deviation of the smoothing kernel. If character, a
rule to choose the bandwidth, as listed in <code>bw.nrd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>character See <code>density</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>numeric A multiplicative bandwidth adjustment. This makes it
possible to adjust the bandwidth while still using the a bandwidth
estimator through an argument passed to <code>bw</code>. The larger the value
passed to <code>adjust</code> the stronger the smoothing, hence decreasing
sensitivity to local changes in density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>numeric Number of equally spaced points at which the density is to
be estimated for applying the cut point. See <code>density</code> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>character The aesthetic along which density is computed.
Given explicitly by setting orientation to either "x" or "y".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.fill</code></td>
<td>
<p>character vector of length 1 or a function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.density</code></td>
<td>
<p>logical vector of lenght 1. If <code>TRUE</code> add columns
<code>"density"</code> and <code>"keep.obs"</code> to the returned data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code>borders</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>stat_dens1d_labels()</code> is designed to work together with
geometries from package 'ggrepel'. To avoid text labels being plotted over
unlabelled points the corresponding rows in data need to be retained but
labels replaced with the empty character string, <code>""</code>. Function
<code>stat_dens1d_filter</code> cannot be used with the repulsive geoms
from 'ggrepel' because it drops the observations.
</p>
<p><code>stat_dens1d_labels()</code> can be useful also in other situations, as the
substitution character string can be set by the user by passing an argument
to <code>label.fill</code>. If this argument is <code>NULL</code> the unselected rows
are filtered out.
</p>
<p>The local density of observations along <em>x</em> or <em>y</em> is computed
with function <code>density</code> and used to select observations,
passing to the geom all the rows in its <code>data</code> input but with with the
text of labels replaced in those "not kept". The default is to select
observations in sparse regions of the plot, but the selection can be
inverted so that only observations in the densest regions are returned.
Specific observations can be protected from having the label replaced by
passing a suitable argument to <code>keep.these</code>. Logical and integer
vectors function as indexes to rows in <code>data</code>, while a character
vector is compared to values in the variable mapped to the <code>label</code>
aesthetic. A function passed as argument to keep.these will receive as
argument the values in the variable mapped to <code>label</code> and should
return a character, logical or numeric vector as described above.
</p>
<p>How many labels are retained intact in addition to those in
<code>keep.these</code> is controlled with arguments passed to <code>keep.number</code>
and <code>keep.fraction</code>. <code>keep.number</code> sets the maximum number of
observations selected, whenever <code>keep.fraction</code> results in fewer
observations selected, it is obeyed. If <code>xintercept</code> is a finite value
within the <em>x</em> range of the data and <code>pool.along</code> is passed
<code>"none"</code> the data are split into two groups and <code>keep.number</code> and
<code>keep.fraction</code> are applied separately to each tail with density still
computed jointly from all observations. If the length of <code>keep.number</code>
and <code>keep.fraction</code> is one, half this value is used each tail, if
their length is two, the first value is use for the left tail and the
second value for the right tail (or if using <code>orientation = "y"</code> the
lower and upper tails, respectively).
</p>
<p>Computation of density and of the default bandwidth require at least
two observations with different values. If data do not fulfill this
condition, they are kept only if <code>keep.fraction = 1</code>. This is correct
behavior for a single observation, but can be surprising in the case of
multiple observations.
</p>
<p>Parameters <code>keep.these</code> and <code>exclude.these</code> make it possible to
force inclusion or exclusion of labels after the density is computed.
In case of conflict, <code>exclude.these</code> overrides <code>keep.these</code>.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> the input
<code>data</code> after value substitution based on a 1D the filtering criterion.
</p>


<h3>Note</h3>

<p>Which points are kept and which not depends on how dense and flexible
is the density curve estimate. This depends on the values passed as
arguments to parameters <code>n</code>, <code>bw</code> and <code>kernel</code>. It is
also important to be aware that both <code>geom_text()</code> and
<code>geom_text_repel()</code> can avoid overplotting by discarding labels at
the plot rendering stage, i.e., what is plotted may differ from what is
returned by this statistic.
</p>


<h3>See Also</h3>

<p><code>density</code> used internally.
</p>
<p>Other statistics returning a subset of data: 
<code>stat_dens1d_filter()</code>,
<code>stat_dens2d_filter()</code>,
<code>stat_dens2d_labels()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
random_string &lt;-
  function(len = 6) {
    paste(sample(letters, len, replace = TRUE), collapse = "")
  }

# Make random data.
set.seed(1005)
d &lt;- tibble::tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)

# using defaults
ggplot(data = d, aes(x, y, label = lab)) +
  geom_point() +
  stat_dens1d_labels()

ggrepel.installed &lt;- requireNamespace("ggrepel", quietly = TRUE)
if (ggrepel.installed) {
  library(ggrepel)

# using defaults
  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel")

# if no mapping to label is found, it is set row names
  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel")

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel", pool.along = "none")

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel",
                       keep.number = c(0, 10), pool.along = "none")

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel",
                       keep.fraction = c(0, 0.2), pool.along = "none")

# using defaults, along y-axis
  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(orientation = "y", geom = "text_repel")

# example labelling with coordiantes
  ggplot(data = d, aes(x, y, label = sprintf("x = %.2f\ny = %.2f", x, y))) +
    geom_point() +
    stat_dens1d_filter(colour = "red") +
    stat_dens1d_labels(geom = "text_repel", colour = "red", size = 3)

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel")

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel", label.fill = NA)

# we keep labels starting with "a" across the whole plot, but all in sparse
# regions. To achieve this we pass as argument to label.fill a fucntion
# instead of a character string.
  label.fun &lt;- function(x) {ifelse(grepl("^a", x), x, "")}
  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel", label.fill = label.fun)
}

# Using geom_debug() we can see that all 100 rows in \code{d} are
# returned. But only those labelled in the previous example still contain
# the original labels.

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug")

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", label.fill = NULL, return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", label.fill = NA, return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", label.fill = FALSE, return.density = TRUE)
}

</code></pre>


</div>