<div class="container">

<table style="width: 100%;"><tr>
<td>GNE.nseq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Non smooth equation reformulation of the GNE problem.</h2>

<h3>Description</h3>

<p>Non smooth equation reformulation via the extended KKT system of the GNE problem.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GNE.nseq(init, dimx, dimlam, grobj, arggrobj, heobj, argheobj, 
	constr, argconstr, grconstr, arggrconstr, heconstr, argheconstr,
	compl, gcompla, gcomplb, argcompl, 
	dimmu, joint, argjoint, grjoint, arggrjoint, hejoint, arghejoint, 
	method="default", control=list(), silent=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Initial values for the parameters to be optimized over: <code class="reqn">z=(x, lambda, mu)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimlam</code></td>
<td>
<p>a vector of dimension for <code class="reqn">lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grobj</code></td>
<td>
<p>gradient of the objective function (to be minimized), see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr</code></td>
<td>
<p>constraint function (<code class="reqn">g^i(x)&lt;=0</code>), see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argconstr</code></td>
<td>
<p>a list of additional arguments of the constraint function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grconstr</code></td>
<td>
<p>gradient of the constraint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrconstr</code></td>
<td>
<p>a list of additional arguments of the constraint gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heconstr</code></td>
<td>
<p>Hessian of the constraint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argheconstr</code></td>
<td>
<p>a list of additional arguments of the constraint Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compl</code></td>
<td>
<p>the complementarity function with (at least) two arguments: <code>compl(a,b)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argcompl</code></td>
<td>
<p>list of possible additional arguments for <code>compl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcompla</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the first argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcomplb</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the second argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimmu</code></td>
<td>
<p>a vector of dimension for <code class="reqn">mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p>joint function (<code class="reqn">h(x)&lt;=0</code>), see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrjoint</code></td>
<td>
<p>a list of additional arguments of the joint gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hejoint</code></td>
<td>
<p>Hessian of the joint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arghejoint</code></td>
<td>
<p>a list of additional arguments of the joint Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string specifying the method <code>"Newton"</code>,
<code>"Broyden"</code>, <code>"Levenberg-Marquardt"</code> or <code>"default"</code> 
which is <code>"Newton"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list with control parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to the optimization routine. 
NOT to the functions <code>phi</code> and <code>jacphi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>a logical to get some traces. Default to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions in argument must respect the following template:
</p>

<ul>
<li>
<p><code>constr</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code> 
and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>grobj</code>, <code>grconstr</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>heobj</code>, <code>heconstr</code> must have arguments the current iterate <code>z</code>, the player number <code>i</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>compl</code>, <code>gcompla</code>, <code>gcomplb</code> must have two arguments <code>a</code>, <code>b</code> and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>joint</code> must have arguments the current iterate <code>z</code>
and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>grjoint</code> must have arguments the current iterate <code>z</code>,
the derivative index <code>j</code> and optionnally additional arguments given in a list.
</p>
</li>
<li>
<p><code>hejoint</code> must have arguments the current iterate <code>z</code>, 
the derivative indexes <code>j</code>, <code>k</code> and optionnally additional arguments given in a list.
</p>
</li>
</ul>
<p><code>GNE.nseq</code> solves the GNE problem via a non smooth reformulation of the KKT system. 
<code>bench.GNE.nseq</code> carries out a benchmark of the computation methods (Newton and Broyden 
direction with all possible global schemes) for a given initial point.
<code>bench.GNE.nseq.LM</code> carries out a benchmark of the Levenberg-Marquardt computation method.
</p>
<p>This approach consists in solving the extended Karush-Kuhn-Tucker 
(KKT) system denoted by <code class="reqn">\Phi(z)=0</code>, where eqnz is formed by the players strategy 
<code class="reqn">x</code> and the Lagrange multiplier <code class="reqn">\lambda</code>.
The root problem <code class="reqn">\Phi(z)=0</code> is solved by an iterative scheme <code class="reqn">z_{n+1} = z_n + d_n</code>,
where the direction <code class="reqn">d_n</code> is computed in three different ways. Let <code class="reqn">J(x)=Jac\Phi(x)</code>.
</p>

<dl>
<dt>(a) Newton:</dt>
<dd>
<p>The direction solves the system <code class="reqn">J(z_n) d = - \Phi(z_n)
		</code>, 
generally called the Newton equation.</p>
</dd>
<dt>(b) Broyden:</dt>
<dd>
<p>It is a quasi-Newton method aiming to solve an approximate version
of the Newton equation <code class="reqn">d = -\Phi(z_n) W_n</code> where <code class="reqn">W_n</code> is computed
by an iterative scheme. In the current implementation, <code class="reqn">W_n</code> is updated
by the Broyden method. </p>
</dd>
<dt>(c) Levenberg-Marquardt:</dt>
<dd>
<p>The direction solves the system 
</p>
<p style="text-align: center;"><code class="reqn"> \left[ J(z_n)^T J(z_n) + \lambda_n^\delta I \right] d = - J(z_n)^T\Phi(x_n)
			</code>
</p>

<p>where <code class="reqn">I</code> denotes the identity matrix, <code class="reqn">\delta</code> is a parameter in [1,2] 
and <code class="reqn">\lambda_n = ||\Phi(z_n)|| </code> if <code>LM.param="merit"</code>,
<code class="reqn">||J(z_n)^T \Phi(z_n)|| </code> if <code>LM.param="jacmerit"</code>,
the minimum of both preceding quantities if <code>LM.param="min"</code>, or an adatpive
parameter according to Fan(2003) if <code>LM.param="adaptive"</code>.
</p>
</dd>
</dl>
<p>In addition to the computation method, a globalization scheme can be choosed using the <code>global</code>
argument, via the <code>...</code> argument. Available schemes are 
</p>

<dl>
<dt>(1) Line search:</dt>
<dd>
<p> if <code>global</code> is set to <code>"qline"</code> or <code>"gline"</code>, a line search
is used with the merit function being half of the L2 norm of <code class="reqn">Phi</code>, respectively with a
quadratic or a geometric implementation.</p>
</dd>
<dt>(2) Trust region:</dt>
<dd>
<p> if <code>global</code> is set to <code>"dbldog"</code> or <code>"pwldog"</code>, a trust
region is used respectively with a double dogleg or a Powell (simple) dogleg implementation.
This global scheme is not available for the Levenberg-Marquardt direction.</p>
</dd>
<dt>(3) None:</dt>
<dd>
<p> if  <code>global</code> is set to <code>"none"</code>, no globalization is done. </p>
</dd>
</dl>
<p>The default value of <code>global</code> is <code>"gline"</code>. Note that in the special case of 
the Levenberg-Marquardt direction with adaptive parameter, the global scheme must be <code>"none"</code>.
</p>
<p>In the GNEP context, details on the methods can be found in Facchinei, Fischer &amp; Piccialli (2009), <code>"Newton"</code>
corresponds to method 1 and <code>"Levenberg-Marquardt"</code> to method 3. In a general nonlinear
equation framework, see Dennis &amp; Moree (1977), Dennis &amp; Schnabel (1996) or Nocedal &amp; Wright (2006), 
</p>
<p>The implementation relies heavily on the 
<code>nleqslv</code> function of the package of the same name. So full details on the control parameters are
to be found in the help page of this function. We briefly recall here the main parameters.
The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>xtol</code></dt>
<dd>
<p>The relative steplength tolerance.
When the relative  steplength of all scaled x values is smaller than this value
convergence is declared. The default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>ftol</code></dt>
<dd>
<p>The function value tolerance.
Convergence is declared when the largest absolute function value is smaller than <code>ftol</code>.
The	default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>delta</code></dt>
<dd>
<p>A numeric <code>delta</code> in [1, 2], default to 2, for
the Levenberg-Marquardt method only.
</p>
</dd>
<dt><code>LM.param</code></dt>
<dd>
<p>A character string, default to <code>"merit"</code>, for
the Levenberg-Marquardt method only.
</p>
</dd>
<dt><code>maxit</code></dt>
<dd>
<p>The maximum number of major iterations. The default value is 150 if a 
global strategy has been specified.</p>
</dd>
<dt><code>trace</code></dt>
<dd>
<p>Non-negative integer. A value of 1 will give a detailed report of the
progress of the iteration, default 0.</p>
</dd>
</dl>
<p><code>...</code> are further arguments to be passed to the optimization routine, 
that is <code>global</code>, <code>xscalm</code>, <code>silent</code>. See above for the globalization scheme. 
The <code>xscalm</code> is a scaling parameter to used, either <code>"fixed"</code> (default)
or <code>"auto"</code>, for which scaling factors are calculated from the euclidean norms of the 
columns of the jacobian matrix. See <code>nleqslv</code> for details.
The <code>silent</code> argument is a logical to report or not the optimization process, default
to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p><code>GNE.nseq</code> returns a list with components:
</p>

<dl>
<dt><code>par</code></dt>
<dd>
<p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>The value of the merit function.</p>
</dd>
<dt><code>counts</code></dt>
<dd>
<p>A two-element integer vector giving the number of calls to 
<code>phi</code> and <code>jacphi</code> respectively.</p>
</dd>			
<dt><code>iter</code></dt>
<dd>
<p>The outer iteration number.</p>
</dd>
<dt><code>code</code></dt>
<dd>
<p>The values returned are
</p>

<dl>
<dt><code>1</code></dt>
<dd>
<p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>2</code></dt>
<dd>
<p>x-values within tolerance. This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code>.</p>
</dd>
<dt><code>3</code></dt>
<dd>
<p>No better point found.
This means that the algorithm has stalled and cannot find an acceptable new point.
This may or may not indicate acceptably small function values.</p>
</dd>
<dt><code>4</code></dt>
<dd>
<p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>5</code></dt>
<dd>
<p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>6</code></dt>
<dd>
<p>Jacobian is singular.</p>
</dd>
<dt><code>100</code></dt>
<dd>
<p>an error in the execution.</p>
</dd>
</dl>
</dd>
<dt><code>message</code></dt>
<dd>
<p>a string describing the termination code.</p>
</dd>	
<dt><code>fvec</code></dt>
<dd>
<p>a vector with function values.</p>
</dd>
</dl>
<p><code>bench.GNE.nseq</code> returns a list with components:
</p>

<dl>
<dt><code>compres</code></dt>
<dd>
<p>a data.frame summarizing the different computations.</p>
</dd>
<dt><code>reslist</code></dt>
<dd>
<p>a list with the different results from <code>GNE.nseq</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>J.E. Dennis and J.J. Moree (1977), 
<em>Quasi-Newton methods, Motivation and Theory</em>,
SIAM review.
</p>
<p>J.E. Dennis and R.B. Schnabel (1996), 
<em>Numerical methods for unconstrained optimization and nonlinear equations</em>,
SIAM.
</p>
<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>
<p>J.-Y. Fan (2003),
<em>A modified Levenberg-Marquardt algorithm for singular 
system of nonlinear equations</em>,
Journal of Computational Mathematics.
</p>
<p>B. Hasselman (2011), 
<em>nleqslv: Solve systems of non linear equations</em>,
R package.
</p>
<p>A. von Heusinger and C. Kanzow (2009),
<em>Optimization reformulations of the generalized Nash equilibrium problem 
using Nikaido-Isoda-type functions</em>,
Comput Optim Appl .
</p>
<p>J. Nocedal and S.J. Wright (2006), 
<em>Numerical Optimization</em>, 
Springer Science+Business Media
</p>


<h3>See Also</h3>

<p>See <code>GNE.fpeq</code>, <code>GNE.ceq</code> and <code>GNE.minpb</code> 
for other approaches; <code>funSSR</code> and
<code>jacSSR</code> for template functions of <code class="reqn">\Phi</code> and <code class="reqn">Jac\Phi</code> and
<code>complementarity</code> for complementarity functions.
</p>
<p>See also <code>nleqslv</code> for some optimization details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

#-------------------------------------------------------------------------------
# (1) Example 5 of von Facchinei et al. (2007)
#-------------------------------------------------------------------------------

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j)
{
	if(i == 1)
		res &lt;- c(2*(x[1]-1), 0)
	if(i == 2)
		res &lt;- c(0, 2*(x[2]-1/2))
	res[j]	
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k)
	2 * (i == j &amp;&amp; j == k)

dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	sum(x[1:2]) - 1
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	1
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0



#true value is (3/4, 1/4, 1/2, 1/2)

z0 &lt;- rep(0, sum(dimx)+sum(dimlam))

funSSR(z0, dimx, dimlam, grobj=grobj, constr=g, grconstr=grg, compl=phiFB, echo=FALSE)

	
jacSSR(z0, dimx, dimlam, heobj=heobj, constr=g, grconstr=grg, 
	heconstr=heg, gcompla=GrAphiFB, gcomplb=GrBphiFB)


GNE.nseq(z0, dimx, dimlam, grobj=grobj, NULL, heobj=heobj, NULL, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Newton", 
	control=list(trace=1))

GNE.nseq(z0, dimx, dimlam, grobj=grobj, NULL, heobj=heobj, NULL, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Broyden", 
	control=list(trace=1))



#-------------------------------------------------------------------------------
# (2) Duopoly game of Krawczyk and Stanislav Uryasev (2000)
#-------------------------------------------------------------------------------


#constants
myarg &lt;- list(d= 20, lambda= 4, rho= 1)

dimx &lt;- c(1, 1)
#Gr_x_j O_i(x)
grobj &lt;- function(x, i, j, arg)
{
	res &lt;- -arg$rho * x[i]
	if(i == j)
		res &lt;- res + arg$d - arg$lambda - arg$rho*(x[1]+x[2])
	-res
}
#Gr_x_k Gr_x_j O_i(x)
heobj &lt;- function(x, i, j, k, arg)
	arg$rho * (i == j) + arg$rho * (j == k)	


dimlam &lt;- c(1, 1)
#constraint function g_i(x)
g &lt;- function(x, i)
	-x[i]
#Gr_x_j g_i(x)
grg &lt;- function(x, i, j)
	-1*(i == j)
#Gr_x_k Gr_x_j g_i(x)
heg &lt;- function(x, i, j, k)
	0

#true value is (16/3, 16/3, 0, 0) 

z0 &lt;- rep(0, sum(dimx)+sum(dimlam))

funSSR(z0, dimx, dimlam, grobj=grobj, myarg, constr=g, grconstr=grg, compl=phiFB, echo=FALSE)

jacSSR(z0, dimx, dimlam, heobj=heobj, myarg, constr=g, grconstr=grg, 
	heconstr=heg, gcompla=GrAphiFB, gcomplb=GrBphiFB)


GNE.nseq(z0, dimx, dimlam, grobj=grobj, myarg, heobj=heobj, myarg, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Newton", 
	control=list(trace=1))

GNE.nseq(z0, dimx, dimlam, grobj=grobj, myarg, heobj=heobj, myarg, 
	constr=g, NULL, grconstr=grg, NULL, heconstr=heg, NULL, 
	compl=phiFB, gcompla=GrAphiFB, gcomplb=GrBphiFB, method="Broyden", 
	control=list(trace=1))


	

</code></pre>


</div>