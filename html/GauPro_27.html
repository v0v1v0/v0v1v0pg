<div class="container">

<table style="width: 100%;"><tr>
<td>GauPro_kernel_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gaussian process model with kernel</h2>

<h3>Description</h3>

<p>Class providing object with methods for fitting a GP model.
Allows for different kernel and trend functions to be used.
The object is an R6 object with many methods that can be called.
</p>
<p>'gpkm()' is equivalent to 'GauPro_kernel_model$new()', but is easier to type
and gives parameter autocomplete suggestions.
</p>


<h3>Format</h3>

<p><code>R6Class</code> object.
</p>


<h3>Value</h3>

<p>Object of <code>R6Class</code> with methods for fitting GP model.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(X, Z, corr="Gauss", verbose=0, separable=T, useC=F,
                  useGrad=T,
         parallel=T, nug.est=T, ...)</code></dt>
<dd>
<p>This method is used to create object of this
class with <code>X</code> and <code>Z</code> as the data.</p>
</dd>
<dt><code>update(Xnew=NULL, Znew=NULL, Xall=NULL, Zall=NULL,
restarts = 0,
param_update = T, nug.update = self$nug.est)</code></dt>
<dd>
<p>This method updates the
model, adding new data if given, then running optimization again.</p>
</dd>
</dl>
<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>X</code></dt>
<dd>
<p>Design matrix</p>
</dd>
<dt><code>Z</code></dt>
<dd>
<p>Responses</p>
</dd>
<dt><code>N</code></dt>
<dd>
<p>Number of data points</p>
</dd>
<dt><code>D</code></dt>
<dd>
<p>Dimension of data</p>
</dd>
<dt><code>nug.min</code></dt>
<dd>
<p>Minimum value of nugget</p>
</dd>
<dt><code>nug.max</code></dt>
<dd>
<p>Maximum value of the nugget.</p>
</dd>
<dt><code>nug.est</code></dt>
<dd>
<p>Should the nugget be estimated?</p>
</dd>
<dt><code>nug</code></dt>
<dd>
<p>Value of the nugget, is estimated unless told otherwise</p>
</dd>
<dt><code>param.est</code></dt>
<dd>
<p>Should the kernel parameters be estimated?</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>0 means nothing printed, 1 prints some, 2 prints most.</p>
</dd>
<dt><code>useGrad</code></dt>
<dd>
<p>Should grad be used?</p>
</dd>
<dt><code>useC</code></dt>
<dd>
<p>Should C code be used?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should the code be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>How many cores are there? By default it detects.</p>
</dd>
<dt><code>kernel</code></dt>
<dd>
<p>The kernel to determine the correlations.</p>
</dd>
<dt><code>trend</code></dt>
<dd>
<p>The trend.</p>
</dd>
<dt><code>mu_hatX</code></dt>
<dd>
<p>Predicted trend value for each point in X.</p>
</dd>
<dt><code>s2_hat</code></dt>
<dd>
<p>Variance parameter estimate</p>
</dd>
<dt><code>K</code></dt>
<dd>
<p>Covariance matrix</p>
</dd>
<dt><code>Kchol</code></dt>
<dd>
<p>Cholesky factorization of K</p>
</dd>
<dt><code>Kinv</code></dt>
<dd>
<p>Inverse of K</p>
</dd>
<dt><code>Kinv_Z_minus_mu_hatX</code></dt>
<dd>
<p>K inverse times Z minus the predicted
trend at X.</p>
</dd>
<dt><code>restarts</code></dt>
<dd>
<p>Number of optimization restarts to do when updating.</p>
</dd>
<dt><code>normalize</code></dt>
<dd>
<p>Should the inputs be normalized?</p>
</dd>
<dt><code>normalize_mean</code></dt>
<dd>
<p>If using normalize, the mean of each column.</p>
</dd>
<dt><code>normalize_sd</code></dt>
<dd>
<p>If using normalize, the standard
deviation of each column.</p>
</dd>
<dt><code>optimizer</code></dt>
<dd>
<p>What algorithm should be used to optimize the
parameters.</p>
</dd>
<dt><code>track_optim</code></dt>
<dd>
<p>Should it track the parameters evaluated
while optimizing?</p>
</dd>
<dt><code>track_optim_inputs</code></dt>
<dd>
<p>If track_optim is TRUE,
this will keep a list of parameters evaluated.
View them with plot_track_optim.</p>
</dd>
<dt><code>track_optim_dev</code></dt>
<dd>
<p>If track_optim is TRUE,
this will keep a vector of the deviance values calculated
while optimizing parameters.
View them with plot_track_optim.</p>
</dd>
<dt><code>formula</code></dt>
<dd>
<p>Formula</p>
</dd>
<dt><code>convert_formula_data</code></dt>
<dd>
<p>List for storing data to convert data
using the formula</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro-new"><code>GauPro_kernel_model$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-fit"><code>GauPro_kernel_model$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_K_and_estimates"><code>GauPro_kernel_model$update_K_and_estimates()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-predict"><code>GauPro_kernel_model$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred"><code>GauPro_kernel_model$pred()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_one_matrix"><code>GauPro_kernel_model$pred_one_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_mean"><code>GauPro_kernel_model$pred_mean()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_meanC"><code>GauPro_kernel_model$pred_meanC()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var"><code>GauPro_kernel_model$pred_var()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_LOO"><code>GauPro_kernel_model$pred_LOO()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_after_adding_points"><code>GauPro_kernel_model$pred_var_after_adding_points()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_after_adding_points_sep"><code>GauPro_kernel_model$pred_var_after_adding_points_sep()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_reduction"><code>GauPro_kernel_model$pred_var_reduction()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_reductions"><code>GauPro_kernel_model$pred_var_reductions()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot"><code>GauPro_kernel_model$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-cool1Dplot"><code>GauPro_kernel_model$cool1Dplot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot1D"><code>GauPro_kernel_model$plot1D()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot2D"><code>GauPro_kernel_model$plot2D()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotmarginal"><code>GauPro_kernel_model$plotmarginal()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotmarginalrandom"><code>GauPro_kernel_model$plotmarginalrandom()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotkernel"><code>GauPro_kernel_model$plotkernel()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotLOO"><code>GauPro_kernel_model$plotLOO()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot_track_optim"><code>GauPro_kernel_model$plot_track_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-loglikelihood"><code>GauPro_kernel_model$loglikelihood()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-AIC"><code>GauPro_kernel_model$AIC()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-get_optim_functions"><code>GauPro_kernel_model$get_optim_functions()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_lower"><code>GauPro_kernel_model$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_upper"><code>GauPro_kernel_model$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_start"><code>GauPro_kernel_model$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_start0"><code>GauPro_kernel_model$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_start_mat"><code>GauPro_kernel_model$param_optim_start_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optim"><code>GauPro_kernel_model$optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optimRestart"><code>GauPro_kernel_model$optimRestart()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update"><code>GauPro_kernel_model$update()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_fast"><code>GauPro_kernel_model$update_fast()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_params"><code>GauPro_kernel_model$update_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_data"><code>GauPro_kernel_model$update_data()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_corrparams"><code>GauPro_kernel_model$update_corrparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_nugget"><code>GauPro_kernel_model$update_nugget()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance"><code>GauPro_kernel_model$deviance()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance_grad"><code>GauPro_kernel_model$deviance_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance_fngr"><code>GauPro_kernel_model$deviance_fngr()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad"><code>GauPro_kernel_model$grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm"><code>GauPro_kernel_model$grad_norm()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_dist"><code>GauPro_kernel_model$grad_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_sample"><code>GauPro_kernel_model$grad_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm2_mean"><code>GauPro_kernel_model$grad_norm2_mean()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm2_dist"><code>GauPro_kernel_model$grad_norm2_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm2_sample"><code>GauPro_kernel_model$grad_norm2_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-hessian"><code>GauPro_kernel_model$hessian()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-gradpredvar"><code>GauPro_kernel_model$gradpredvar()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-sample"><code>GauPro_kernel_model$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optimize_fn"><code>GauPro_kernel_model$optimize_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-EI"><code>GauPro_kernel_model$EI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-maxEI"><code>GauPro_kernel_model$maxEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-maxqEI"><code>GauPro_kernel_model$maxqEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-KG"><code>GauPro_kernel_model$KG()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-AugmentedEI"><code>GauPro_kernel_model$AugmentedEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-CorrectedEI"><code>GauPro_kernel_model$CorrectedEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-importance"><code>GauPro_kernel_model$importance()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-print"><code>GauPro_kernel_model$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-summary"><code>GauPro_kernel_model$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-clone"><code>GauPro_kernel_model$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-GauPro-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create kernel_model object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$new(
  X,
  Z,
  kernel,
  trend,
  verbose = 0,
  useC = TRUE,
  useGrad = TRUE,
  parallel = FALSE,
  parallel_cores = "detect",
  nug = 1e-06,
  nug.min = 1e-08,
  nug.max = 100,
  nug.est = TRUE,
  param.est = TRUE,
  restarts = 0,
  normalize = FALSE,
  optimizer = "L-BFGS-B",
  track_optim = FALSE,
  formula,
  data,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>Matrix whose rows are the input points</p>
</dd>
<dt><code>Z</code></dt>
<dd>
<p>Output points corresponding to X</p>
</dd>
<dt><code>kernel</code></dt>
<dd>
<p>The kernel to use. E.g., Gaussian$new().</p>
</dd>
<dt><code>trend</code></dt>
<dd>
<p>Trend to use. E.g., trend_constant$new().</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>Amount of stuff to print. 0 is little, 2 is a lot.</p>
</dd>
<dt><code>useC</code></dt>
<dd>
<p>Should C code be used when possible? Should be faster.</p>
</dd>
<dt><code>useGrad</code></dt>
<dd>
<p>Should the gradient be used?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should code be run in parallel? Make optimization
faster but uses more computer resources.</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>When using parallel, how many cores should
be used?</p>
</dd>
<dt><code>nug</code></dt>
<dd>
<p>Value for the nugget. The starting value if estimating it.</p>
</dd>
<dt><code>nug.min</code></dt>
<dd>
<p>Minimum allowable value for the nugget.</p>
</dd>
<dt><code>nug.max</code></dt>
<dd>
<p>Maximum allowable value for the nugget.</p>
</dd>
<dt><code>nug.est</code></dt>
<dd>
<p>Should the nugget be estimated?</p>
</dd>
<dt><code>param.est</code></dt>
<dd>
<p>Should the kernel parameters be estimated?</p>
</dd>
<dt><code>restarts</code></dt>
<dd>
<p>How many optimization restarts should be used when
estimating parameters?</p>
</dd>
<dt><code>normalize</code></dt>
<dd>
<p>Should the data be normalized?</p>
</dd>
<dt><code>optimizer</code></dt>
<dd>
<p>What algorithm should be used to optimize the
parameters.</p>
</dd>
<dt><code>track_optim</code></dt>
<dd>
<p>Should it track the parameters evaluated
while optimizing?</p>
</dd>
<dt><code>formula</code></dt>
<dd>
<p>Formula for the data if giving in a data frame.</p>
</dd>
<dt><code>data</code></dt>
<dd>
<p>Data frame of data. Use in conjunction with formula.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Not used</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-fit"></a>



<h4>Method <code>fit()</code>
</h4>

<p>Fit model
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$fit(X, Z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>Inputs</p>
</dd>
<dt><code>Z</code></dt>
<dd>
<p>Outputs</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update_K_and_estimates"></a>



<h4>Method <code>update_K_and_estimates()</code>
</h4>

<p>Update covariance matrix and estimates
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_K_and_estimates()</pre></div>


<hr>
<a id="method-GauPro-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$predict(
  XX,
  se.fit = F,
  covmat = F,
  split_speed = F,
  mean_dist = FALSE,
  return_df = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt>
<dd>
<p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt>
<dd>
<p>Should covariance matrix be returned?</p>
</dd>
<dt><code>split_speed</code></dt>
<dd>
<p>Should the matrix be split for faster predictions?</p>
</dd>
<dt><code>mean_dist</code></dt>
<dd>
<p>Should the error be for the distribution of the mean?</p>
</dd>
<dt><code>return_df</code></dt>
<dd>
<p>When returning se.fit, should it be returned in
a data frame? Otherwise it will be a list, which is faster.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred"></a>



<h4>Method <code>pred()</code>
</h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred(
  XX,
  se.fit = F,
  covmat = F,
  split_speed = F,
  mean_dist = FALSE,
  return_df = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt>
<dd>
<p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt>
<dd>
<p>Should covariance matrix be returned?</p>
</dd>
<dt><code>split_speed</code></dt>
<dd>
<p>Should the matrix be split for faster predictions?</p>
</dd>
<dt><code>mean_dist</code></dt>
<dd>
<p>Should the error be for the distribution of the mean?</p>
</dd>
<dt><code>return_df</code></dt>
<dd>
<p>When returning se.fit, should it be returned in
a data frame? Otherwise it will be a list, which is faster.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_one_matrix"></a>



<h4>Method <code>pred_one_matrix()</code>
</h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_one_matrix(
  XX,
  se.fit = F,
  covmat = F,
  return_df = FALSE,
  mean_dist = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt>
<dd>
<p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt>
<dd>
<p>Should covariance matrix be returned?</p>
</dd>
<dt><code>return_df</code></dt>
<dd>
<p>When returning se.fit, should it be returned in
a data frame? Otherwise it will be a list, which is faster.</p>
</dd>
<dt><code>mean_dist</code></dt>
<dd>
<p>Should the error be for the distribution of the mean?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_mean"></a>



<h4>Method <code>pred_mean()</code>
</h4>

<p>Predict mean
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_mean(XX, kx.xx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to predict at</p>
</dd>
<dt><code>kx.xx</code></dt>
<dd>
<p>Covariance of X with XX</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_meanC"></a>



<h4>Method <code>pred_meanC()</code>
</h4>

<p>Predict mean using C
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_meanC(XX, kx.xx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to predict at</p>
</dd>
<dt><code>kx.xx</code></dt>
<dd>
<p>Covariance of X with XX</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_var"></a>



<h4>Method <code>pred_var()</code>
</h4>

<p>Predict variance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var(XX, kxx, kx.xx, covmat = F)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to predict at</p>
</dd>
<dt><code>kxx</code></dt>
<dd>
<p>Covariance of XX with itself</p>
</dd>
<dt><code>kx.xx</code></dt>
<dd>
<p>Covariance of X with XX</p>
</dd>
<dt><code>covmat</code></dt>
<dd>
<p>Should the covariance matrix be returned?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_LOO"></a>



<h4>Method <code>pred_LOO()</code>
</h4>

<p>leave one out predictions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_LOO(se.fit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>se.fit</code></dt>
<dd>
<p>Should standard errors be included?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_var_after_adding_points"></a>



<h4>Method <code>pred_var_after_adding_points()</code>
</h4>

<p>Predict variance after adding points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_after_adding_points(add_points, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_points</code></dt>
<dd>
<p>Points to add</p>
</dd>
<dt><code>pred_points</code></dt>
<dd>
<p>Points to predict at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_var_after_adding_points_sep"></a>



<h4>Method <code>pred_var_after_adding_points_sep()</code>
</h4>

<p>Predict variance reductions after adding each point separately
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_after_adding_points_sep(add_points, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_points</code></dt>
<dd>
<p>Points to add</p>
</dd>
<dt><code>pred_points</code></dt>
<dd>
<p>Points to predict at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_var_reduction"></a>



<h4>Method <code>pred_var_reduction()</code>
</h4>

<p>Predict variance reduction for a single point
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_reduction(add_point, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_point</code></dt>
<dd>
<p>Point to add</p>
</dd>
<dt><code>pred_points</code></dt>
<dd>
<p>Points to predict at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-pred_var_reductions"></a>



<h4>Method <code>pred_var_reductions()</code>
</h4>

<p>Predict variance reductions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_reductions(add_points, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_points</code></dt>
<dd>
<p>Points to add</p>
</dd>
<dt><code>pred_points</code></dt>
<dd>
<p>Points to predict at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plot"></a>



<h4>Method <code>plot()</code>
</h4>

<p>Plot the object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Parameters passed to cool1Dplot(), plot2D(), or plotmarginal()</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-cool1Dplot"></a>



<h4>Method <code>cool1Dplot()</code>
</h4>

<p>Make cool 1D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$cool1Dplot(
  n2 = 20,
  nn = 201,
  col2 = "green",
  xlab = "x",
  ylab = "y",
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  gg = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n2</code></dt>
<dd>
<p>Number of things to plot</p>
</dd>
<dt><code>nn</code></dt>
<dd>
<p>Number of things to plot</p>
</dd>
<dt><code>col2</code></dt>
<dd>
<p>color</p>
</dd>
<dt><code>xlab</code></dt>
<dd>
<p>x label</p>
</dd>
<dt><code>ylab</code></dt>
<dd>
<p>y label</p>
</dd>
<dt><code>xmin</code></dt>
<dd>
<p>xmin</p>
</dd>
<dt><code>xmax</code></dt>
<dd>
<p>xmax</p>
</dd>
<dt><code>ymin</code></dt>
<dd>
<p>ymin</p>
</dd>
<dt><code>ymax</code></dt>
<dd>
<p>ymax</p>
</dd>
<dt><code>gg</code></dt>
<dd>
<p>Should ggplot2 be used to make plot?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plot1D"></a>



<h4>Method <code>plot1D()</code>
</h4>

<p>Make 1D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot1D(
  n2 = 20,
  nn = 201,
  col2 = 2,
  col3 = 3,
  xlab = "x",
  ylab = "y",
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  gg = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n2</code></dt>
<dd>
<p>Number of things to plot</p>
</dd>
<dt><code>nn</code></dt>
<dd>
<p>Number of things to plot</p>
</dd>
<dt><code>col2</code></dt>
<dd>
<p>Color of the prediction interval</p>
</dd>
<dt><code>col3</code></dt>
<dd>
<p>Color of the interval for the mean</p>
</dd>
<dt><code>xlab</code></dt>
<dd>
<p>x label</p>
</dd>
<dt><code>ylab</code></dt>
<dd>
<p>y label</p>
</dd>
<dt><code>xmin</code></dt>
<dd>
<p>xmin</p>
</dd>
<dt><code>xmax</code></dt>
<dd>
<p>xmax</p>
</dd>
<dt><code>ymin</code></dt>
<dd>
<p>ymin</p>
</dd>
<dt><code>ymax</code></dt>
<dd>
<p>ymax</p>
</dd>
<dt><code>gg</code></dt>
<dd>
<p>Should ggplot2 be used to make plot?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plot2D"></a>



<h4>Method <code>plot2D()</code>
</h4>

<p>Make 2D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot2D(se = FALSE, mean = TRUE, horizontal = TRUE, n = 50)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>se</code></dt>
<dd>
<p>Should the standard error of prediction be plotted?</p>
</dd>
<dt><code>mean</code></dt>
<dd>
<p>Should the mean be plotted?</p>
</dd>
<dt><code>horizontal</code></dt>
<dd>
<p>If plotting mean and se, should they be next to each
other?</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>Number of points along each dimension</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plotmarginal"></a>



<h4>Method <code>plotmarginal()</code>
</h4>

<p>Plot marginal. For each input, hold all others at a constant
value and adjust it along it's range to see how the prediction changes.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotmarginal(npt = 5, ncol = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npt</code></dt>
<dd>
<p>Number of lines to make. Each line represents changing a
single variable while holding the others at the same values.</p>
</dd>
<dt><code>ncol</code></dt>
<dd>
<p>Number of columnsfor the plot</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plotmarginalrandom"></a>



<h4>Method <code>plotmarginalrandom()</code>
</h4>

<p>Plot marginal prediction for random sample of inputs
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotmarginalrandom(npt = 100, ncol = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npt</code></dt>
<dd>
<p>Number of random points to evaluate</p>
</dd>
<dt><code>ncol</code></dt>
<dd>
<p>Number of columns in the plot</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plotkernel"></a>



<h4>Method <code>plotkernel()</code>
</h4>

<p>Plot the kernel
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotkernel(X = self$X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt>
<dd>
<p>X matrix for kernel plot</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-plotLOO"></a>



<h4>Method <code>plotLOO()</code>
</h4>

<p>Plot leave one out predictions for design points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotLOO()</pre></div>


<hr>
<a id="method-GauPro-plot_track_optim"></a>



<h4>Method <code>plot_track_optim()</code>
</h4>

<p>If track_optim, this will plot the parameters
in the order they were evaluated.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot_track_optim(minindex = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>minindex</code></dt>
<dd>
<p>Minimum index to plot.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-loglikelihood"></a>



<h4>Method <code>loglikelihood()</code>
</h4>

<p>Calculate loglikelihood of parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$loglikelihood(mu = self$mu_hatX, s2 = self$s2_hat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mu</code></dt>
<dd>
<p>Mean parameters</p>
</dd>
<dt><code>s2</code></dt>
<dd>
<p>Variance parameter</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-AIC"></a>



<h4>Method <code>AIC()</code>
</h4>

<p>AIC (Akaike information criterion)
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$AIC()</pre></div>


<hr>
<a id="method-GauPro-get_optim_functions"></a>



<h4>Method <code>get_optim_functions()</code>
</h4>

<p>Get optimization functions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$get_optim_functions(param_update, nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_update</code></dt>
<dd>
<p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Should nugget be updated?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code>
</h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_lower(nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt>
<dd>
<p>Is the nugget being updated?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code>
</h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_upper(nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt>
<dd>
<p>Is the nugget being updated?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code>
</h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_start(nug.update, jitter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt>
<dd>
<p>Is nugget being updated?</p>
</dd>
<dt><code>jitter</code></dt>
<dd>
<p>Should there be a jitter?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code>
</h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_start0(nug.update, jitter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt>
<dd>
<p>Is nugget being updated?</p>
</dd>
<dt><code>jitter</code></dt>
<dd>
<p>Should there be a jitter?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-param_optim_start_mat"></a>



<h4>Method <code>param_optim_start_mat()</code>
</h4>

<p>Get matrix for starting points of optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_start_mat(restarts, nug.update, l)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restarts</code></dt>
<dd>
<p>Number of restarts to use</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Is nugget being updated?</p>
</dd>
<dt><code>l</code></dt>
<dd>
<p>Not used</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-optim"></a>



<h4>Method <code>optim()</code>
</h4>

<p>Optimize parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$optim(
  restarts = self$restarts,
  n0 = 5 * self$D,
  param_update = T,
  nug.update = self$nug.est,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restarts</code></dt>
<dd>
<p>Number of restarts to do</p>
</dd>
<dt><code>n0</code></dt>
<dd>
<p>This many starting parameters are chosen and evaluated.
The best ones are used as the starting points for optimization.</p>
</dd>
<dt><code>param_update</code></dt>
<dd>
<p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Should nugget be updated?</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>Should restarts be done in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt>
<dd>
<p>If running parallel, how many cores should be used?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-optimRestart"></a>



<h4>Method <code>optimRestart()</code>
</h4>

<p>Run a single optimization restart.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$optimRestart(
  start.par,
  start.par0,
  param_update,
  nug.update,
  optim.func,
  optim.grad,
  optim.fngr,
  lower,
  upper,
  jit = T,
  start.par.i
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>start.par</code></dt>
<dd>
<p>Starting parameters</p>
</dd>
<dt><code>start.par0</code></dt>
<dd>
<p>Starting parameters</p>
</dd>
<dt><code>param_update</code></dt>
<dd>
<p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Should nugget be updated?</p>
</dd>
<dt><code>optim.func</code></dt>
<dd>
<p>Function to optimize.</p>
</dd>
<dt><code>optim.grad</code></dt>
<dd>
<p>Gradient of function to optimize.</p>
</dd>
<dt><code>optim.fngr</code></dt>
<dd>
<p>Function that returns the function value
and its gradient.</p>
</dd>
<dt><code>lower</code></dt>
<dd>
<p>Lower bounds for optimization</p>
</dd>
<dt><code>upper</code></dt>
<dd>
<p>Upper bounds for optimization</p>
</dd>
<dt><code>jit</code></dt>
<dd>
<p>Is jitter being used?</p>
</dd>
<dt><code>start.par.i</code></dt>
<dd>
<p>Starting parameters for this restart</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update"></a>



<h4>Method <code>update()</code>
</h4>

<p>Update the model. Should only give in
(Xnew and Znew) or (Xall and Zall).
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL,
  restarts = self$restarts,
  param_update = self$param.est,
  nug.update = self$nug.est,
  no_update = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt>
<dd>
<p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt>
<dd>
<p>New Z values to add.</p>
</dd>
<dt><code>Xall</code></dt>
<dd>
<p>All X values to be used. Will replace existing X.</p>
</dd>
<dt><code>Zall</code></dt>
<dd>
<p>All Z values to be used. Will replace existing Z.</p>
</dd>
<dt><code>restarts</code></dt>
<dd>
<p>Number of optimization restarts.</p>
</dd>
<dt><code>param_update</code></dt>
<dd>
<p>Are the parameters being updated?</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Is the nugget being updated?</p>
</dd>
<dt><code>no_update</code></dt>
<dd>
<p>Are no parameters being updated?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update_fast"></a>



<h4>Method <code>update_fast()</code>
</h4>

<p>Fast update when adding new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_fast(Xnew = NULL, Znew = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt>
<dd>
<p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt>
<dd>
<p>New Z values to add.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update_params"></a>



<h4>Method <code>update_params()</code>
</h4>

<p>Update the parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_params(..., nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Passed to optim.</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Is the nugget being updated?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update_data"></a>



<h4>Method <code>update_data()</code>
</h4>

<p>Update the data. Should only give in
(Xnew and Znew) or (Xall and Zall).
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_data(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt>
<dd>
<p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt>
<dd>
<p>New Z values to add.</p>
</dd>
<dt><code>Xall</code></dt>
<dd>
<p>All X values to be used. Will replace existing X.</p>
</dd>
<dt><code>Zall</code></dt>
<dd>
<p>All Z values to be used. Will replace existing Z.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update_corrparams"></a>



<h4>Method <code>update_corrparams()</code>
</h4>

<p>Update correlation parameters. Not the nugget.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_corrparams(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Passed to self$update()</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-update_nugget"></a>



<h4>Method <code>update_nugget()</code>
</h4>

<p>Update nugget Not the correlation parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_nugget(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Passed to self$update()</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-deviance"></a>



<h4>Method <code>deviance()</code>
</h4>

<p>Calculate the deviance.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$deviance(
  params = NULL,
  nug = self$nug,
  nuglog,
  trend_params = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt>
<dd>
<p>Kernel parameters</p>
</dd>
<dt><code>nug</code></dt>
<dd>
<p>Nugget</p>
</dd>
<dt><code>nuglog</code></dt>
<dd>
<p>Log of nugget. Only give in nug or nuglog.</p>
</dd>
<dt><code>trend_params</code></dt>
<dd>
<p>Parameters for the trend.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-deviance_grad"></a>



<h4>Method <code>deviance_grad()</code>
</h4>

<p>Calculate the gradient of the deviance.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$deviance_grad(
  params = NULL,
  kernel_update = TRUE,
  X = self$X,
  nug = self$nug,
  nug.update,
  nuglog,
  trend_params = NULL,
  trend_update = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt>
<dd>
<p>Kernel parameters</p>
</dd>
<dt><code>kernel_update</code></dt>
<dd>
<p>Is the kernel being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>Input matrix</p>
</dd>
<dt><code>nug</code></dt>
<dd>
<p>Nugget</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Is the nugget being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>nuglog</code></dt>
<dd>
<p>Log of the nugget.</p>
</dd>
<dt><code>trend_params</code></dt>
<dd>
<p>Trend parameters</p>
</dd>
<dt><code>trend_update</code></dt>
<dd>
<p>Is the trend being updated? If yes,
it's part of the gradient.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-deviance_fngr"></a>



<h4>Method <code>deviance_fngr()</code>
</h4>

<p>Calculate the deviance along with its gradient.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$deviance_fngr(
  params = NULL,
  kernel_update = TRUE,
  X = self$X,
  nug = self$nug,
  nug.update,
  nuglog,
  trend_params = NULL,
  trend_update = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt>
<dd>
<p>Kernel parameters</p>
</dd>
<dt><code>kernel_update</code></dt>
<dd>
<p>Is the kernel being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>Input matrix</p>
</dd>
<dt><code>nug</code></dt>
<dd>
<p>Nugget</p>
</dd>
<dt><code>nug.update</code></dt>
<dd>
<p>Is the nugget being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>nuglog</code></dt>
<dd>
<p>Log of the nugget.</p>
</dd>
<dt><code>trend_params</code></dt>
<dd>
<p>Trend parameters</p>
</dd>
<dt><code>trend_update</code></dt>
<dd>
<p>Is the trend being updated? If yes,
it's part of the gradient.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad"></a>



<h4>Method <code>grad()</code>
</h4>

<p>Calculate gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad(XX, X = self$X, Z = self$Z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
<dt><code>X</code></dt>
<dd>
<p>X points</p>
</dd>
<dt><code>Z</code></dt>
<dd>
<p>output points</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad_norm"></a>



<h4>Method <code>grad_norm()</code>
</h4>

<p>Calculate norm of gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad_dist"></a>



<h4>Method <code>grad_dist()</code>
</h4>

<p>Calculate distribution of gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_dist(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad_sample"></a>



<h4>Method <code>grad_sample()</code>
</h4>

<p>Sample gradient at points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_sample(XX, n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>Number of samples</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad_norm2_mean"></a>



<h4>Method <code>grad_norm2_mean()</code>
</h4>

<p>Calculate mean of gradient norm squared
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm2_mean(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad_norm2_dist"></a>



<h4>Method <code>grad_norm2_dist()</code>
</h4>

<p>Calculate distribution of gradient norm squared
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm2_dist(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-grad_norm2_sample"></a>



<h4>Method <code>grad_norm2_sample()</code>
</h4>

<p>Get samples of squared norm of gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm2_sample(XX, n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to sample at</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>Number of samples</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-hessian"></a>



<h4>Method <code>hessian()</code>
</h4>

<p>Calculate Hessian
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$hessian(XX, as_array = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>Points to calculate Hessian at</p>
</dd>
<dt><code>as_array</code></dt>
<dd>
<p>Should result be an array?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-gradpredvar"></a>



<h4>Method <code>gradpredvar()</code>
</h4>

<p>Calculate gradient of the predictive variance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$gradpredvar(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>points to calculate at</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-sample"></a>



<h4>Method <code>sample()</code>
</h4>

<p>Sample at rows of XX
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$sample(XX, n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt>
<dd>
<p>Input matrix</p>
</dd>
<dt><code>n</code></dt>
<dd>
<p>Number of samples</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-optimize_fn"></a>



<h4>Method <code>optimize_fn()</code>
</h4>

<p>Optimize any function of the GP prediction over the
valid input space.
If there are inputs that should only be optimized over a discrete set
of values, specify 'mopar' for all parameters.
Factor inputs will be handled automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$optimize_fn(
  fn = NULL,
  lower = apply(self$X, 2, min),
  upper = apply(self$X, 2, max),
  n0 = 100,
  minimize = FALSE,
  fn_args = NULL,
  gr = NULL,
  fngr = NULL,
  mopar = NULL,
  groupeval = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt>
<dd>
<p>Function to optimize</p>
</dd>
<dt><code>lower</code></dt>
<dd>
<p>Lower bounds to search within</p>
</dd>
<dt><code>upper</code></dt>
<dd>
<p>Upper bounds to search within</p>
</dd>
<dt><code>n0</code></dt>
<dd>
<p>Number of points to evaluate in initial stage</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Are you trying to minimize the output?</p>
</dd>
<dt><code>fn_args</code></dt>
<dd>
<p>Arguments to pass to the function fn.</p>
</dd>
<dt><code>gr</code></dt>
<dd>
<p>Gradient of function to optimize.</p>
</dd>
<dt><code>fngr</code></dt>
<dd>
<p>Function that returns list with names elements "fn" for the
function value and "gr" for the gradient. Useful when it is slow to
evaluate and fn/gr would duplicate calculations if done separately.</p>
</dd>
<dt><code>mopar</code></dt>
<dd>
<p>List of parameters using mixopt</p>
</dd>
<dt><code>groupeval</code></dt>
<dd>
<p>Can a matrix of points be evaluated? Otherwise just
a single point at a time.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-EI"></a>



<h4>Method <code>EI()</code>
</h4>

<p>Calculate expected improvement
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$EI(x, minimize = FALSE, eps = 0, return_grad = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Vector to calculate EI of, or matrix for whose rows it should
be calculated</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>Exploration parameter</p>
</dd>
<dt><code>return_grad</code></dt>
<dd>
<p>Should the gradient be returned?</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional args</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-maxEI"></a>



<h4>Method <code>maxEI()</code>
</h4>

<p>Find the point that maximizes the expected improvement.
If there are inputs that should only be optimized over a discrete set
of values, specify 'mopar' for all parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$maxEI(
  lower = apply(self$X, 2, min),
  upper = apply(self$X, 2, max),
  n0 = 100,
  minimize = FALSE,
  eps = 0,
  dontconvertback = FALSE,
  EItype = "corrected",
  mopar = NULL,
  usegrad = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lower</code></dt>
<dd>
<p>Lower bounds to search within</p>
</dd>
<dt><code>upper</code></dt>
<dd>
<p>Upper bounds to search within</p>
</dd>
<dt><code>n0</code></dt>
<dd>
<p>Number of points to evaluate in initial stage</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>Exploration parameter</p>
</dd>
<dt><code>dontconvertback</code></dt>
<dd>
<p>If data was given in with a formula, should
it converted back to the original scale?</p>
</dd>
<dt><code>EItype</code></dt>
<dd>
<p>Type of EI to calculate. One of "EI", "Augmented",
or "Corrected"</p>
</dd>
<dt><code>mopar</code></dt>
<dd>
<p>List of parameters using mixopt</p>
</dd>
<dt><code>usegrad</code></dt>
<dd>
<p>Should the gradient be used when optimizing?
Can make it faster.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-maxqEI"></a>



<h4>Method <code>maxqEI()</code>
</h4>

<p>Find the multiple points that maximize the expected
improvement. Currently only implements the constant liar method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$maxqEI(
  npoints,
  method = "pred",
  lower = apply(self$X, 2, min),
  upper = apply(self$X, 2, max),
  n0 = 100,
  minimize = FALSE,
  eps = 0,
  EItype = "corrected",
  dontconvertback = FALSE,
  mopar = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npoints</code></dt>
<dd>
<p>Number of points to add</p>
</dd>
<dt><code>method</code></dt>
<dd>
<p>Method to use for setting the output value for the points
chosen as a placeholder.
Can be one of: "CL" for constant liar,
which uses the best value seen yet; or "pred", which uses the predicted
value, also called the Believer method in literature.</p>
</dd>
<dt><code>lower</code></dt>
<dd>
<p>Lower bounds to search within</p>
</dd>
<dt><code>upper</code></dt>
<dd>
<p>Upper bounds to search within</p>
</dd>
<dt><code>n0</code></dt>
<dd>
<p>Number of points to evaluate in initial stage</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>Exploration parameter</p>
</dd>
<dt><code>EItype</code></dt>
<dd>
<p>Type of EI to calculate. One of "EI", "Augmented",
or "Corrected"</p>
</dd>
<dt><code>dontconvertback</code></dt>
<dd>
<p>If data was given in with a formula, should
it converted back to the original scale?</p>
</dd>
<dt><code>mopar</code></dt>
<dd>
<p>List of parameters using mixopt</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-KG"></a>



<h4>Method <code>KG()</code>
</h4>

<p>Calculate Knowledge Gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$KG(x, minimize = FALSE, eps = 0, current_extreme = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Point to calculate at</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Is the objective to minimize?</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>Exploration parameter</p>
</dd>
<dt><code>current_extreme</code></dt>
<dd>
<p>Used for recursive solving</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-AugmentedEI"></a>



<h4>Method <code>AugmentedEI()</code>
</h4>

<p>Calculated Augmented EI
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$AugmentedEI(
  x,
  minimize = FALSE,
  eps = 0,
  return_grad = F,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Vector to calculate EI of, or matrix for whose rows it should
be calculated</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>Exploration parameter</p>
</dd>
<dt><code>return_grad</code></dt>
<dd>
<p>Should the gradient be returned?</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional args</p>
</dd>
<dt><code>f</code></dt>
<dd>
<p>The reference max, user shouldn't change this.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-CorrectedEI"></a>



<h4>Method <code>CorrectedEI()</code>
</h4>

<p>Calculated Augmented EI
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$CorrectedEI(
  x,
  minimize = FALSE,
  eps = 0,
  return_grad = F,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>Vector to calculate EI of, or matrix for whose rows it should
be calculated</p>
</dd>
<dt><code>minimize</code></dt>
<dd>
<p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>Exploration parameter</p>
</dd>
<dt><code>return_grad</code></dt>
<dd>
<p>Should the gradient be returned?</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Additional args</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-importance"></a>



<h4>Method <code>importance()</code>
</h4>

<p>Feature importance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$importance(plot = TRUE, print_bars = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot</code></dt>
<dd>
<p>Should the plot be made?</p>
</dd>
<dt><code>print_bars</code></dt>
<dd>
<p>Should the importances be printed as bars?</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$print()</pre></div>


<hr>
<a id="method-GauPro-summary"></a>



<h4>Method <code>summary()</code>
</h4>

<p>Summary
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>Additional arguments</p>
</dd>
</dl>
</div>


<hr>
<a id="method-GauPro-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p>https://scikit-learn.org/stable/modules/permutation_importance.html#id2
</p>


<h3>Examples</h3>

<pre><code class="language-R">n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel="gauss")
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()

n &lt;- 200
d &lt;- 7
x &lt;- matrix(runif(n*d), ncol=d)
f &lt;- function(x) {x[1]*x[2] + cos(x[3]) + x[4]^2}
y &lt;- apply(x, 1, f)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Gaussian)
</code></pre>


</div>