<div class="container">

<table style="width: 100%;"><tr>
<td>fit_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate mean and covariance parameters</h2>

<h3>Description</h3>

<p>Given a response, set of locations, (optionally) a design matrix,
and a specified covariance function, return the maximum
Vecchia likelihood estimates, obtained with a Fisher scoring algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_model(
  y,
  locs,
  X = NULL,
  covfun_name = "matern_isotropic",
  NNarray = NULL,
  start_parms = NULL,
  reorder = TRUE,
  group = TRUE,
  m_seq = c(10, 30),
  max_iter = 40,
  fixed_parms = NULL,
  silent = FALSE,
  st_scale = NULL,
  convtol = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locs</code></td>
<td>
<p>matrix of locations. Each row is a single 
spatial or spatial-temporal
location. If using one of the covariance functions for data on a sphere,
the first column should be longitudes (-180,180) and the second column
should be latitudes (-90,90). 
If using a spatial-temporal covariance function,
the last column should contain the times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>design matrix. Each row contains covariates for the corresponding
observation in <code>y</code>. If not specified, the function sets <code>X</code> to be a
matrix with a single column of ones, that is, a constant mean function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covfun_name</code></td>
<td>
<p>string name of a covariance function. 
See <code>GpGp</code> for information about supported covariance funtions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NNarray</code></td>
<td>
<p>Optionally specified array of nearest neighbor indices, 
usually from the output of <code>find_ordered_nn</code>. If <code>NULL</code>, 
fit_model will compute the nearest neighbors. We recommend that the user
not specify this unless there is a good reason to (e.g. if doing a comparison
study where one wants to control 
<code>NNarray</code> across different approximations).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_parms</code></td>
<td>
<p>Optionally specified starting values for parameters. 
If <code>NULL</code>,
fit_model will select default starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reorder</code></td>
<td>
<p>TRUE/FALSE indicating whether maxmin ordering should be used
(TRUE) or whether no reordering should be done before fitting (FALSE). 
If you want
to use a customized reordering, then manually reorder <code>y</code>, <code>locs</code>, 
and <code>X</code>,
and then set <code>reorder</code> to <code>FALSE</code>. A random reordering is used
when <code>nrow(locs) &gt; 1e5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>TRUE/FALSE for whether to use the grouped version of
the approximation (Guinness, 2018) or not.  The grouped version
is used by default and is always recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m_seq</code></td>
<td>
<p>Sequence of values for number of neighbors. By default, 
a 10-neighbor
approximation is maximized, then a 30-neighbor approximation is 
maximized using the
10 neighbor estimates as starting values. 
However, one can specify any sequence
of numbers of neighbors, e.g. <code>m_seq = c(10,30,60,90)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>maximum number of Fisher scoring iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_parms</code></td>
<td>
<p>Indices of covariance parameters you would like to fix
at specific values. If you decide to fix any parameters, you must specify
their values in <code>start_parms</code>, along with the starting values for
all other parameters. For example, to fix the nugget at zero in 
<code>exponential_isotropic</code>, set <code>fixed_parms</code> to <code>c(3)</code>, and set
<code>start_parms</code> to <code>c(4.7,3.1,0)</code>. The
last element of <code>start_parms</code> (the nugget parameter) is set to zero,
while the starting values for the other two parameters are 4.7 and 3.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>TRUE/FALSE for whether to print some information during fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st_scale</code></td>
<td>
<p>Scaling for spatial and temporal ranges. Only applicable for
spatial-temporal models, where it is used in distance
calculations when selecting neighbors. <code>st_scale</code> must be specified
when <code>covfun_name</code> is a spatial-temporal covariance. 
See Argo vignette for an example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convtol</code></td>
<td>
<p>Tolerance for exiting the optimization. 
Fisher scoring is stopped
when the dot product between the step and the gradient 
is less than <code>convtol</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>fit_model</code> is a user-friendly model fitting function
that automatically performs many of the auxiliary tasks needed for
using Vecchia's approximation, including reordering, computing
nearest neighbors, grouping, and optimization. The likelihoods use a small
penalty on small nuggets, large spatial variances, 
and small smoothness parameter.
</p>
<p>The Jason-3 windspeed vignette and the Argo temperature 
vignette are useful sources for a
use-cases of the <code>fit_model</code> function for data on sphere. 
The example below shows a very small example with a simulated dataset in 2d.
</p>


<h3>Value</h3>

<p>An object of class <code>GpGp_fit</code>, which is a list containing
covariance parameter estimates, regression coefficients,
covariance matrix for mean parameter estimates, as well as some other
information relevant to the model fit.
</p>


<h3>Examples</h3>

<pre><code class="language-R">n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
covparms &lt;- c(2,0.1,1/2,0)
y &lt;- 7 + fast_Gp_sim(covparms, "matern_isotropic", locs)
X &lt;- as.matrix( rep(1,n) )
## not run
# fit &lt;- fit_model(y, locs, X, "matern_isotropic")
# fit


</code></pre>


</div>