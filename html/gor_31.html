<div class="container">

<table style="width: 100%;"><tr>
<td>improve_cover_flip</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Improving a cover with local search</h2>

<h3>Description</h3>

<p>Local search to improve a cover by using "neighboring" vertex
subsets differing in just one element from the initial subset.
</p>


<h3>Usage</h3>

<pre><code class="language-R">improve_cover_flip(G, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>A graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A cover list with components $set, $size as returned by
routines build_cover_greedy or build_cover_approx.  X
represents the cover to be improved</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given some cover specified by a vertex subset X in a graph, this
routine scans the neighboring subsets obtained from X by
removing a vertex from X looking for a smaller cover.  If such
a cover is found, it replaces the starting cover and the
search starts again.  This iterative procedure continues until
no smaller cover can be found.  Of course, the resulting cover
is only a local minimum.
</p>


<h3>Value</h3>

<p>A list with two components: $set contains the subset of
V(g) representing the cover and $size contains the number of
vertices of the cover.
</p>


<h3>Author(s)</h3>

<p>Cesar Asensio
</p>


<h3>See Also</h3>

<p>is_cover checks if a vertex subset is a vertex cover,
build_cover_greedy builds a cover using a greedy heuristic,
build_cover_approx builds a cover using a 2-approximation
algorithm, search_cover_random looks for a random cover of
fixed size, search_cover_ants looks for a random cover using
a version of the ant-colony optimization heuristic,
find_cover_BB finds covers using a branch-and-bound
technique, plot_cover plots a cover.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n &lt;- 25
g &lt;- sample_gnp(n, p=0.25)  # Random graph

X1 &lt;- build_cover_greedy(g)
X1$size    # 17
plot_cover(X1, g)

X2 &lt;- build_cover_approx(g)
X2$size    # 20
plot_cover(X2, g)

X3 &lt;- improve_cover_flip(g, X1)
X3$size    # 17 : Not improved
plot_cover(X3,g)

X4 &lt;- improve_cover_flip(g, X2)
X4$size    # 19 : It is improved by a single vertex
plot_cover(X4,g)

# Vertex subsets or n-1 elements are always vertex covers:
for (i in 1:25) {
   X3 &lt;- improve_cover_flip(g, list(set = setdiff(1:25,i), size = 24))
   print(X3$size)
} # 19 18 18 18 18 18 17 20 19 17 17 18 18 18 17 19 20 19 19 17 19 19 19 19 19
 
</code></pre>


</div>