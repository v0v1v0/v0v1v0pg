<div class="container">

<table style="width: 100%;"><tr>
<td>surface_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct a set of (x, y, z) matrices for surface plotting a
<code>gg_partial_coplot</code> object</h2>

<h3>Description</h3>

<p>Construct a set of (x, y, z) matrices for surface plotting a
<code>gg_partial_coplot</code> object
</p>


<h3>Usage</h3>

<pre><code class="language-R">surface_matrix(dta, xvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dta</code></td>
<td>
<p>a gg_partial_coplot object containing at least 3 numeric columns
of data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xvar</code></td>
<td>
<p>a vector of 3 column names from the data object, in (x, y, z)
order</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To create a surface plot, the <code>plot3D::surf3D</code> function expects
3 matrices of n.x by n.y. Take the p+1 by n <code>gg_partial_coplot</code> object,
and extract and construct the x, y and z matrices from the provided
<code>xvar</code> column names.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## From vignette(randomForestRegression, package="ggRandomForests")
data(Boston, package="MASS")
rfsrc_boston &lt;- randomForestSRC::rfsrc(medv~., Boston)

varsel_boston &lt;- var.select(rfsrc_boston)

 rm_pts &lt;- quantile_pts(rfsrc_boston$xvar$rm,
    groups = 9, 
    intervals = TRUE)

 partial_boston_surf &lt;- lapply(rm_pts, function(ct) {
  rfsrc_boston$xvar$rm &lt;- ct
  randomForestSRC::plot.variable(
    rfsrc_boston,
    xvar.names = "lstat", 
    time = 1,
    npts = 10,
    show.plots = FALSE,
    partial = TRUE
   )
 })
   
# Instead of groups, we want the raw rm point values,
# To make the dimensions match, we need to repeat the values
# for each of the 50 points in the lstat direction
rm.tmp &lt;- do.call(c,lapply(rm_pts,
                           function(grp) {rep(grp,
                           length(partial_boston_surf))}))

# Convert the list of plot.variable output to
partial_surf &lt;- do.call(rbind,lapply(partial_boston_surf, gg_partial))

# attach the data to the gg_partial_coplot
partial_surf$rm &lt;- rm.tmp

# Transform the gg_partial_coplot object into a list of three named matrices
# for surface plotting with plot3D::surf3D
srf &lt;- surface_matrix(partial_surf, c("lstat", "rm", "yhat"))

## End(Not run)

## Not run: 
# surf3D is in the plot3D package.
library(plot3D)
# Generate the figure.
surf3D(x=srf$x, y=srf$y, z=srf$z, col=topo.colors(10),
       colkey=FALSE, border = "black", bty="b2",
       shade = 0.5, expand = 0.5,
       lighting = TRUE, lphi = -50,
       xlab="Lower Status", ylab="Average Rooms", zlab="Median Value"
)

## End(Not run)

</code></pre>


</div>