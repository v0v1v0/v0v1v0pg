<div class="container">

<table style="width: 100%;"><tr>
<td>princals</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Categorical principal component analysis (PRINCALS). 
</h2>

<h3>Description</h3>

<p>Fits a categorical PCA. The default is to take each input variable as ordinal but it works for mixed scale levels (incl. nominal) as well. Through a proper spline specification various continuous transformation functions can be specified: linear, polynomials, and (monotone) splines. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">princals(data, ndim = 2, levels = "ordinal", ordinal, knots, ties = "s", 
degrees = 1, copies = 1, missing = "s", normobj.z = TRUE, active = TRUE,
itmax = 1000, eps = 1e-06, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Input data frame: n observations, m variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>Number of dimensions to be computed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>A vector of length m denoting basic scale levels (<code>"nominal"</code>, <code>"ordinal"</code>, <code>"metric"</code>; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordinal</code></td>
<td>
<p>If knots are specified manually, a boolean vector of length m denotes which variables should be ordinally restricted or not (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>Scale levels can be specified manually using splines (see <code>knotsGifi</code>). If knots is set, this overrides <code>level</code> (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ties</code></td>
<td>
<p>How ties should be handled: primary (<code>"p"</code>), secondary (<code>"s"</code>), or tertiary (<code>"t"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degrees</code></td>
<td>
<p>Spline degrees. If different degrees should be used across variables, a vector of length m can be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copies</code></td>
<td>
<p>Number of copies for each variables (also as vector of length m). If <code>copies</code> is a scalar the function creates a copies vector internally with a value of 2 for each nominal variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>How missing values should be handled: multiple (<code>"m"</code>), single (<code>"s"</code>), or average (<code>"a"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active</code></td>
<td>
<p>Which variables should be active or inactive (also as vector of length m)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normobj.z</code></td>
<td>
<p>If <code>TRUE</code>, object scores are z-scores, if <code>FALSE</code>, they are restricted to SS of 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Iteration printout</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The measurement (or scale) levels of the variables are incorporated via spline transformations. If the user only needs simple scale levels like nominal, ordinal, and metric, a corresponding vector can be specified in the <code>levels</code> argument without setting <code>knots</code> and <code>ordinal</code>. The corresponding spline transformations (unrestricted, monotone, and linear) are then created internally. If all scale level transformations are the same, <code>ordinal</code> can be a single value. For more advanced transformations such as polynomial or more flexible splines, the <code>knots</code> and <code>ordinal</code> arguments need to be specified instead of <code>levels</code>.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>Optimally transformed scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhat</code></td>
<td>
<p>Induced correlation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evals</code></td>
<td>
<p>Eigenvalues of induced correlation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objectscores</code></td>
<td>
<p>Object scores (rows)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoremat</code></td>
<td>
<p>Optimally scaled data matrix (first dimension)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantifications</code></td>
<td>
<p>Category quantifications</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmeasures</code></td>
<td>
<p>Discimination matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Average discrimination matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Component weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>Component loadings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntel</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Loss function value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Original data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datanum</code></td>
<td>
<p>Numerical data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndim</code></td>
<td>
<p>Number of extracted dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Function call</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Gifi, A. (1990). Nonlinear Multivariate Analysis. New York: Wiley.
</p>
<p>De Leeuw, J., Mair, P., Groenen, P. J. F. (2017). Multivariate Analysis with Optimal Scaling. 
</p>


<h3>See Also</h3>

<p><code>homals</code>, <code>plot.princals</code></p>


<h3>Examples</h3>

<pre><code class="language-R">ABC6 &lt;- ABC[,6:11]

## ordinal PCA
fitord &lt;- princals(ABC6)  ## ordinal PCA
fitord
summary(fitord)

plot(fitord, plot.type = "transplot")
plot(fitord, "loadplot", main = "Loadings Plot ABC Data")  ## aspect ratio = 1
plot(fitord, "biplot", main = "Biplot ABC Data")
plot(fitord, "screeplot")

## linear restrictions (mimics standard PCA)
abc_knots &lt;- knotsGifi(ABC6, "E")     ## 0 interior knots
fitlin &lt;- princals(ABC6, knots = abc_knots, ordinal = TRUE)  
fitlin 
fitlin$evals
plot(fitlin, plot.type = "transplot")

## compare with standard PCA
ABCnum &lt;- makeNumeric(ABC6)
fitpca &lt;- prcomp(ABCnum, scale = TRUE)
fitpca$sdev^2   

## more complicated specifications
## Not run: 
data(epi.bfi, package = "psychTools")
epi6 &lt;- epi.bfi[,1:6]
fitepi1 &lt;- princals(epi6, knots = knotsGifi(epi6, "Q"))    ## monotone splines (degree 2)
fitepi1
plot(fitepi1, "transplot")

## no interior knots vars 1 and 2; data knots vars 3 and 4; 5 
## interior percentile knots var 5; no interior knots var 6)
knotList &lt;- c(knotsGifi(epi6[,1:2], "E"), 
              knotsGifi(epi6[,3:4], "D"), 
              knotsGifi(epi6[,5], "Q", n = 5),
              knotsGifi(epi6[,6], "E"))
knotList  
ordvec &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE) ## ordinal restrictions
degvec &lt;- c(3, -1, 2, 2, 3, 1)                     ## spline degrees (second variable nominal)
fitepi2 &lt;- princals(epi6, knots = knotList, ordinal = ordvec, degrees = degvec)
fitepi2
plot(fitepi2, "transplot")

## End(Not run)

</code></pre>


</div>