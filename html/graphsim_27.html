<div class="container">

<table style="width: 100%;"><tr>
<td>make_state</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make State Matrix</h2>

<h3>Description</h3>

<p>Functions to compute the matrix of states (1 for activating and -1 for inhibiting) 
for link signed correlations, from a vector of edge states to a signed adjacency matrix for use
in <code>generate_expression</code>. This resolves edge states to determine the sign
of all correlations between nodes in a network. These are computed interally for sigma matrices
as required.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make_state_matrix(graph, state = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An <code>igraph</code> object. May be directed or weighted as long as
a shortest path can be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>numeric vector. Vector of length E(graph). Sign used to calculate state matrix,
may be an integer state or inferred directly from expected correlations for each edge. May be
applied a scalar across all edges or as a vector for each edge respectively. May also be
entered as text for "activating" or "inhibiting" or as integers for activating (0,1) or
inhibiting (-1,2). Compatible with inputs for <code>plot_directed</code>. Vector 
input is supported either directly calling the function with a value for each edge in 
<code>E(graph)</code> or as an edge "attribute" in the igraph object (using 
<code>E(g)$state &lt;- states</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An integer matrix indicating the resolved state
(activating or inhibiting for each edge or path between nodes)
</p>


<h3>Author(s)</h3>

<p>Tom Kelly <a href="mailto:tom.kelly@riken.jp">tom.kelly@riken.jp</a>
</p>


<h3>See Also</h3>

<p>See also <code>generate_expression</code> for computing the simulated data,
<code>make_sigma</code> for computing the Sigma (<code class="reqn">\Sigma</code>) matrix,
and
<code>make_distance</code> for computing distance from a graph object.
</p>
<p>See also <code>plot_directed</code> for plotting graphs or 
<code>heatmap.2</code> for plotting matrices.
</p>
<p>See also <code>make_laplacian</code>, <code>make_commonlink</code>, 
or <code>make_adjmatrix</code> for computing input matrices.
</p>
<p>See also <code>igraph</code> for handling graph objects.
</p>
<p>Other graphsim functions: 
<code>generate_expression()</code>,
<code>make_adjmatrix</code>,
<code>make_commonlink</code>,
<code>make_distance</code>,
<code>make_laplacian</code>,
<code>make_sigma</code>,
<code>plot_directed()</code>
</p>
<p>Other generate simulated expression functions: 
<code>generate_expression()</code>,
<code>make_distance</code>,
<code>make_sigma</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# construct a synthetic graph module
library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)

 # compute state matrix for toy example
state_matrix &lt;- make_state_matrix(graph_test)

# construct a synthetic graph network
graph_structure_edges &lt;- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"),
                               c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure &lt;- graph.edgelist(graph_structure_edges, directed = TRUE)

# compute state matrix for toy network
graph_structure_state_matrix &lt;- make_state_matrix(graph_structure)
graph_structure_state_matrix

# compute state matrix for toy network with inhibitions
edge_state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# edge states are a variable
graph_structure_state_matrix &lt;- make_state_matrix(graph_structure, state = edge_state)
graph_structure_state_matrix

# compute state matrix for toy network with inhibitions
E(graph_structure)$state &lt;- c(1, 1, -1, 1, 1, 1, 1, -1)
# edge states are a graph attribute
graph_structure_state_matrix &lt;- make_state_matrix(graph_structure)
graph_structure_state_matrix

library("igraph")
graph_test_edges &lt;- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_test &lt;- graph.edgelist(graph_test_edges, directed = TRUE)
state_matrix &lt;- make_state_matrix(graph_test)

# import graph from package for reactome pathway
# TGF-\eqn{\Beta} receptor signaling activates SMADs (R-HSA-2173789)
TGFBeta_Smad_graph &lt;- identity(TGFBeta_Smad_graph)

# compute sigma (\eqn{\Sigma}) matrix from geometric distance directly from TGF-\eqn{\Beta} pathway
TFGBeta_Smad_state &lt;- E(TGFBeta_Smad_graph)$state
table(TFGBeta_Smad_state)
# states are edge attributes
state_matrix_TFGBeta_Smad &lt;- make_state_matrix(TGFBeta_Smad_graph)
# visualise matrix
library("gplots")
heatmap.2(state_matrix_TFGBeta_Smad , scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))

# compare the states to the sign of expected correlations in the sigma matrix
sigma_matrix_TFGBeta_Smad_inhib &lt;- make_sigma_mat_dist_graph(TGFBeta_Smad_graph,
                                                             cor = 0.8,
                                                             absolute = FALSE)
# visualise matrix
heatmap.2(sigma_matrix_TFGBeta_Smad_inhib,
          scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))

# compare the states to the sign of final correlations in the simulated matrix
TFGBeta_Smad_data &lt;- generate_expression(100, TGFBeta_Smad_graph, cor = 0.8)
heatmap.2(cor(t(TFGBeta_Smad_data)), scale = "none", trace = "none",
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          col = colorpanel(50, "blue", "white", "red"))


</code></pre>


</div>