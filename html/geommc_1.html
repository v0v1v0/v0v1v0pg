<div class="container">

<table style="width: 100%;"><tr>
<td>geomc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov chain Monte Carlo for discrete and continuous
distributions using geometric MH algorithms.</h2>

<h3>Description</h3>

<p>geomc produces Markov chain samples from a target distribution.
The target can be a pdf or pmf. Users specify the target distribution by an R function that evaluates
the log un-normalized pdf or pmf. geomc uses the geometric approach of Roy (2024)  to move an uninformed
base density (e.g. a random walk proposal) towards different global/local approximations of the
target density. The base density can be specified along with its mean, covariance matrix, and a function
for sampling from it. Gaussian densities can be specified by mean and variance only, although it is preferred to supply its density
and sampling functions as well. If either or both of the mean and variance arguments and any of the density and sampling functions is
missing, then a base density corresponding to a random walk with an appropriate scale parameter is used. One or more approximate target densities
can be specified along with their means, covariance matrices, and a function for sampling from the densities.
Gaussian densities can be specified by mean and variance only, although it is preferred to supply their densities and sampling
functions as well. If either or both of the mean and variance
arguments and any of the density and sampling functions is missing for the approximate target density, then a normal distribution with mean computed from
a pilot run of a random walk Markov chain and a diagonal covariance matrix with a large variance is used.
If the Argument gaus is set as FALSE then both the base and the approximate target can be specified by their
densities and functions for sampling from it. That is, if gaus=FALSE, the functions specifying the means and variances of
both the base and the approximate target densities are not used.
If the target is a pmf (discrete distribution), then gaus=FALSE and imp <code class="reqn">[1]</code>=TRUE (not the default values) need to be specified.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geomc(
  log.target,
  initial,
  n.iter,
  eps = 0.5,
  ind = FALSE,
  gaus = TRUE,
  imp = c(FALSE, n.samp = 1000, samp.base = FALSE),
  a = 1,
  mean.base,
  var.base,
  dens.base,
  samp.base,
  mean.ap.tar,
  var.ap.tar,
  dens.ap.tar,
  samp.ap.tar
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>log.target</code></td>
<td>
<p>is the logarithm of the (un-normalized) target density function, needs to be written as a function of the current value <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>is the initial values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>is the no. of samples needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>is the value for epsilon perturbation. Default is 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>
<p>is False if either the base density, <code class="reqn">f</code> or the approximate target density, <code class="reqn">g</code> depends on
the current value <code class="reqn">x</code>. Default is False.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gaus</code></td>
<td>
<p>is True if both <code class="reqn">f</code> and <code class="reqn">g</code> are normal distributions. Default is True.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imp</code></td>
<td>
<p>is a vector of three elements. If gaus is TRUE, then the imp argument is not used.
imp <code class="reqn">[1]</code> is False  if numerical integration is used, otherwise, importance sampling is used to
compute <code class="reqn">\langle \sqrt{f}, \sqrt{g} \rangle</code>. Default is False.
imp <code class="reqn">[2]</code> (n.samp) is no of samples in importance sampling.
imp <code class="reqn">[3]</code> (samp.base) is True if samples from <code class="reqn">f</code> is used, otherwise samples from <code class="reqn">g</code> is used. Default is False.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>is the probability vector for the mixture proposal density. Default is the uniform distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.base</code></td>
<td>
<p>is the mean of the base density <code class="reqn">f</code>, needs to be written as a function of the current value <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.base</code></td>
<td>
<p>is the covariance matrix of the base density <code class="reqn">f</code>, needs to be written as a function of the current value <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dens.base</code></td>
<td>
<p>is the density function of the base density <code class="reqn">f</code>, needs to be written as a function <code class="reqn">(y,x)</code> (in this order) of the proposed value <code class="reqn">y</code> and the current value <code class="reqn">x</code>, although it may not depend on <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.base</code></td>
<td>
<p>is the function to draw from the base density <code class="reqn">f</code>, needs to be written as a function of the current value <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.ap.tar</code></td>
<td>
<p>is the vector of means of the densities <code class="reqn">g_i(y|x), i=1,\dots,k</code>. It needs to be written as a function of the current value <code class="reqn">x</code>. It must have the same dimension as <code class="reqn">k</code> times the length of initial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.ap.tar</code></td>
<td>
<p>is the matrix of covariance matrices of the densities <code class="reqn">g_i(y|x), i=1,\dots,k</code> formed by column concatenation. It needs to be written as a function of the current value <code class="reqn">x</code>. It must have the same dimension as the length of initial by <code class="reqn">k</code> times the length of initial.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dens.ap.tar</code></td>
<td>
<p>is the vector of densities <code class="reqn">g_i(y|x), i=1,\dots,k</code>. It needs to be written as a function <code class="reqn">(y,x)</code> (in this order) of the proposed value <code class="reqn">y</code> and the current value <code class="reqn">x</code>, although it may not depend on <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samp.ap.tar</code></td>
<td>
<p>is the function to draw from the densities <code class="reqn">g_i(y|x), i=1,\dots,k</code>. It needs to be written as a function of (current value <code class="reqn">x</code>, the indicator of mixing component <code class="reqn">kk</code>). It must return a vector of the length of that of the initial.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Using a geometric Metropolis-Hastings algorithm geom.mc produces Markov chains with the target as its stationary distribution. The details
of the method can be found in Roy (2024).
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>A matrix containing the MCMC samples. Each column is one sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acceptance.rate</code></td>
<td>
<p>The acceptance rate.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Vivekananda Roy <a href="mailto:vroy@iastate.edu">vroy@iastate.edu</a>
</p>


<h3>References</h3>

<p>Roy, V.(2024) A geometric approach to informative MCMC sampling https://arxiv.org/abs/2406.09010
</p>


<h3>Examples</h3>

<pre><code class="language-R">result &lt;- geomc(log.target=function(y) dnorm(y,log=TRUE),initial=0,n.iter=500) 
#target is univariate normal
result$samples # the MCMC samples.
result$acceptance.rate # the acceptance rate.
result&lt;-geomc(log.target=function(y) log(0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4)),
initial=0,n.iter=500) #target is mixture of univariate normals, default choices
hist(result$samples)
result&lt;-geomc(log.target=function(y) log(0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4)),
initial=0,n.iter=500, mean.base = function(x) x,var.base= function(x) 4,
dens.base=function(y,x) dnorm(y, mean=x,sd=2),samp.base=function(x) x+2*rnorm(1),
mean.ap.tar=function(x) c(0,10),var.ap.tar=function(x) c(1,1.4^2),
dens.ap.tar=function(y,x) c(dnorm(y),dnorm(y,mean=10,sd=1.4)),
samp.ap.tar=function(x,kk=1){if(kk==1){return(rnorm(1))} else{return(10+1.4*rnorm(1))}})
#target is mixture of univariate normals, random walk base density, an informed 
#choice for dens.ap.tar
hist(result$samples)
samp.ap.tar=function(x,kk=1){s.g=sample.int(2,1,prob=c(.5,.5))
if(s.g==1){return(rnorm(1))
}else{return(10+1.4*rnorm(1))}}
result&lt;-geomc(log.target=function(y) log(0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4)),
initial=0,n.iter=500,gaus=FALSE,imp=c(TRUE,n.samp=100,samp.base=TRUE),
dens.base=function(y,x) dnorm(y, mean=x,sd=2),samp.base=function(x) x+2*rnorm(1),
dens.ap.tar=function(y,x) 0.5*dnorm(y)+0.5*dnorm(y,mean=10,sd=1.4),
samp.ap.tar=samp.ap.tar)
#target is mixture of univariate normals, random walk base density, another 
#informed choice for dens.ap.tar
hist(result$samples)
result &lt;- geomc(log.target=function(y) -0.5*crossprod(y),initial=rep(0,4),
n.iter=500) #target is multivariate normal, default choices
rowMeans(result$samples)
size=5
result &lt;- geomc(log.target = function(y) dbinom(y, size, 0.3, log = TRUE),
initial=0,n.iter=500,ind=TRUE,gaus=FALSE,imp=c(TRUE,n.samp=1000,samp.base=TRUE),
dens.base=function(y,x) 1/(size+1), samp.base= function(x) sample(seq(0,size,1),1),
dens.ap.tar=function(y,x) dbinom(y, size, 0.7),samp.ap.tar=function(x,kk=1) rbinom(1, size, 0.7))
 #target is binomial
 table(result$samples)
</code></pre>


</div>