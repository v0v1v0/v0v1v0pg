<div class="container">

<table style="width: 100%;"><tr>
<td>compose</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compose Functions</h2>

<h3>Description</h3>

<p>To compose functions,
</p>

<ul>
<li>
<p> Use <code>compose()</code>:
</p>
<div class="sourceCode"><pre>  compose(f, g, h, ...)
</pre></div>
<p>This makes the function that applies <code>f</code>, then <code>g</code>, then <code>h</code>, etc.
It has the formals of the first function applied (namely
<code>f</code>). For example, if
</p>
<div class="sourceCode"><pre>  fun &lt;- compose(paste, toupper)
</pre></div>
<p>then the function <code>fun()</code> has the same signature as <code>paste()</code>, and the call
</p>
<div class="sourceCode"><pre>  fun(letters, collapse = ",")
</pre></div>
<p>is equivalent to the composite call
</p>
<div class="sourceCode"><pre>  toupper(paste(letters, collapse = ","))
</pre></div>
</li>
<li>
<p> Use <code>`%&gt;&gt;&gt;%`</code>:
</p>
<div class="sourceCode"><pre>  f %&gt;&gt;&gt;% g %&gt;&gt;&gt;% h %&gt;&gt;&gt;% ...
</pre></div>
<p>It comprehends both the semantics of the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator and quasiquotation. For example, if
</p>
<div class="sourceCode"><pre>  sep &lt;- ""
  fun &lt;- sample %&gt;&gt;&gt;% paste(collapse = !!sep)
</pre></div>
<p>then the function <code>fun()</code> has the same signature as <code>sample()</code>, and the
call
</p>
<div class="sourceCode"><pre>  fun(x, size, replace, prob)
</pre></div>
<p>is equivalent to the composite call
</p>
<div class="sourceCode"><pre>  paste(sample(x, size, replace, prob), collapse = "")
</pre></div>
</li>
</ul>
<p>Use <code>as.list()</code> to recover the list of composite functions. For example, both
</p>
<div class="sourceCode"><pre>  as.list(compose(paste, capitalize = toupper))

  as.list(paste %&gt;&gt;&gt;% capitalize: toupper)
</pre></div>
<p>return the (named) list of functions <code>list(paste, capitalize = toupper)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compose(...)

fst %&gt;&gt;&gt;% snd
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Functions or lists thereof to compose, in order of application.
Lists of functions are automatically spliced in.
Unquoting of names, via <code style="white-space: pre;">⁠!!⁠</code> on the left-hand side
of <code style="white-space: pre;">⁠:=⁠</code>, and splicing, via <code style="white-space: pre;">⁠!!!⁠</code>, are supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fst, snd</code></td>
<td>
<p>Functions. These may be optionally named using a colon (<code>:</code>),
e.g., <code>f %&gt;&gt;&gt;% nm: g</code> names the <code>g</code>-component <code>"nm"</code> (see
‘Exceptions to the Interpretation of Calls as Functions’).
Quasiquotation and the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
semantics are supported (see ‘Semantics of the Composition
Operator’, ‘Quasiquotation’ and ‘Examples’).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Function of class <code>CompositeFunction</code>, whose
formals are those of the first function applied (as a
closure).
</p>


<h3>Semantics of the Composition Operator</h3>

<p>The <code>`%&gt;&gt;&gt;%`</code> operator adopts the semantics of the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator:
</p>

<ol>
<li> <p><strong>Bare names are matched to functions</strong>: For example, in a composition
like
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% foo %&gt;&gt;&gt;% ...
</pre></div>
<p>the ‘<code>foo</code>’ is matched to the function of that name.
</p>
</li>
<li> <p><strong>Function calls are interpreted as a unary function of a point (<code>.</code>)</strong>:
A <em>call</em> is interpreted as a <em>function</em> (of a point) in one of two ways:
</p>

<ul>
<li>
<p> If the point matches an argument value, the call is literally
interpreted as the body of the function. For example, in the
compositions
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% foo(x, .) %&gt;&gt;&gt;% ...

  ... %&gt;&gt;&gt;% foo(x, y = .) %&gt;&gt;&gt;% ...
</pre></div>
<p>the ‘<code>foo(x, .)</code>’, resp. ‘<code>foo(x, y = .)</code>’, is
interpreted as the function <code>function(..., . = ..1) foo(x, .)</code>, resp.
<code>function(..., . = ..1) foo(x, y = .)</code>.
</p>
</li>
<li>
<p> Otherwise, the call is regarded as implicitly having the point as its
first argument before being interpreted as the body of the function.
For example, in the compositions
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% foo(x) %&gt;&gt;&gt;% ...

  ... %&gt;&gt;&gt;% foo(x, y(.)) %&gt;&gt;&gt;% ...
</pre></div>
<p>the ‘<code>foo(x)</code>’, resp. ‘<code>foo(x, y(.))</code>’, is interpreted
as the function <code>function(..., . = ..1) foo(., x)</code>, resp.
<code>function(..., . = ..1) foo(., x, y(.))</code>.
</p>
</li>
</ul>
</li>
<li> <p><strong>Expressions <code>{...}</code> are interpreted as a function of a point (<code>.</code>)</strong>:
For example, in a composition
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% {
    foo(.)
    bar(.)
  } %&gt;&gt;&gt;% ...
</pre></div>
<p>the ‘<code>{foo(.); bar(.)}</code>’ is interpreted as the function
<code>function(..., . = ..1) {foo(.); bar(.)}</code>.
</p>
<p>Curly braces are useful when you need to circumvent <code>`%&gt;&gt;&gt;%`</code>'s
usual interpretation of function calls. For example, in a composition
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% {foo(x, y(.))} %&gt;&gt;&gt;% ...
</pre></div>
<p>the ‘<code>{foo(x, y(.))}</code>’ is interpreted as the function
<code>function(..., . = ..1) foo(x, y(.))</code>. There is no point as first
argument to <code>foo</code>.
</p>
</li>
</ol>
<h4>Exceptions to the Interpretation of Calls as Functions</h4>

<p>As a matter of convenience, some exceptions are made to the above
interpretation of calls as functions:
</p>

<ul>
<li> <p><strong>Parenthesis</strong> (<code>(</code>) applies grouping. (In R, <code>`(`</code> is indeed a
function.) In particular, expressions within parentheses are literally
interpreted.
</p>
</li>
<li> <p><strong>Colon</strong> (<code>:</code>) applies <em>naming</em>, according to the syntax
‘<code style="white-space: pre;">⁠&lt;name&gt;: &lt;function&gt;⁠</code>’, where ‘<code style="white-space: pre;">⁠&lt;function&gt;⁠</code>’ is interpreted
according to the semantics of <code>`%&gt;&gt;&gt;%`</code>. For example, in
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% aName: foo %&gt;&gt;&gt;% ...
</pre></div>
<p>the function <code>foo</code> is named <code>"aName"</code>.
</p>
</li>
<li> <p><strong><code>fn()</code></strong>, namespace operators (<code>`::` </code>,
<code>`:::`</code>) and <strong>extractors</strong> (<code>`$`</code>, <code>`[[`</code>,
<code>`[`</code>) are literally interpreted. This allows for list extractors to
be applied to composite functions appearing in a <code>`%&gt;&gt;&gt;%`</code> call (see
'Operate on Composite Functions as List-Like Objects'). For example, the
compositions
</p>
<div class="sourceCode"><pre>  paste %&gt;&gt;&gt;% tolower

  paste %&gt;&gt;&gt;% base::tolower

  (paste %&gt;&gt;&gt;% toupper)[[1]] %&gt;&gt;&gt;% tolower
</pre></div>
<p>are equivalent functions.
</p>
</li>
</ul>
<h3>Quasiquotation</h3>

<p>The <code>`%&gt;&gt;&gt;%`</code> operator supports Tidyverse
unquoting (via <code style="white-space: pre;">⁠!!⁠</code>). Use it to:
</p>

<ul>
<li> <p><strong>Enforce immutability</strong>: For example, by unquoting <code>res</code> in
</p>
<div class="sourceCode"><pre>  res &lt;- "result"
  get_result &lt;- identity %&gt;&gt;&gt;% lapply(`[[`, !!res)
</pre></div>
<p>you ensure that the function <code>get_result()</code> always extracts the component
named <code>"result"</code>, even if the binding <code>res</code> changes its value or is
removed altogether.
</p>
</li>
<li> <p><strong>Interpret the point (<code>.</code>) in the lexical scope</strong>: Even though
<code>`%&gt;&gt;&gt;%`</code> interprets ‘<code>.</code>’ as a function argument, you can
still reference an object of that name via unquoting. For example,
</p>
<div class="sourceCode"><pre>  . &lt;- "point"
  is_point &lt;- identity %&gt;&gt;&gt;% {. == !!.}
</pre></div>
<p>determines a function that checks for equality with the string <code>"point"</code>.
</p>
</li>
<li> <p><strong>Name composite functions, programmatically</strong>: For example, unquoting
<code>nm</code> in
</p>
<div class="sourceCode"><pre>  nm &lt;- "aName"
  ... %&gt;&gt;&gt;% !!nm: foo %&gt;&gt;&gt;% ...
</pre></div>
<p>names the ‘<code>foo</code>’-component of the resulting composite function
<code>"aName"</code>.
</p>
</li>
<li> <p><strong>Accelerate functions by fixing constant dependencies</strong>: For example,
presuming the value of the call <code>f()</code> is <em>constant</em> and that <code>g</code> is a
<em>pure</em> function (meaning that its return value depends only on its
input), both
</p>
<div class="sourceCode"><pre>  ... %&gt;&gt;&gt;% g(f()) %&gt;&gt;&gt;% ...

  ... %&gt;&gt;&gt;% g(!!f()) %&gt;&gt;&gt;% ...
</pre></div>
<p>would be functions yielding the same values. But the first would compute
<code>f()</code> anew with each call, whereas the second would simply depend on a
fixed, pre-computed value of <code>f()</code>.
</p>
</li>
</ul>
<h3>Operate on Composite Functions as List-Like Objects</h3>

<p>You can think of a composite function as embodying the (possibly nested)
structure of its list of constituent functions. In fact, you can apply
familiar index and assignment operations to a composite function, as if it
were this list, getting a function in return. This enables you to leverage
composite functions as <em>structured computations</em>.
</p>


<h4>Indexing</h4>

<p>For instance, the ‘<code>sum</code>’ in the following composite function
</p>
<div class="sourceCode"><pre>  f &lt;- abs %&gt;&gt;&gt;% out: (log %&gt;&gt;&gt;% agg: sum)
</pre></div>
<p>can be extracted in the usual ways:
</p>
<div class="sourceCode"><pre>  f[[2]][[2]]
  f[[c(2, 2)]]

  f$out$agg
  f[["out"]][["agg"]]
  f[["out"]]$agg

  f$out[[2]]
  f[[list("out", 2)]]
</pre></div>
<p>The last form of indexing with a mixed list is handy when you need to
create an index programmatically.
</p>
<p>Additionally, you can excise sub-composite functions with
<code>[</code>, <code>head()</code>, <code>tail()</code>. For example:
</p>

<ul>
<li>
<p> Both <code>f[1]</code> and <code>head(f, 1)</code> get the ‘<code>abs</code>’ as a composite
function, namely <code>compose(abs)</code>
</p>
</li>
<li> <p><code>f[2:1]</code> reverses the order of the top-level functions to yield
</p>
<div class="sourceCode"><pre>  out: (log %&gt;&gt;&gt;% agg: sum) %&gt;&gt;&gt;% abs
</pre></div>
</li>
<li> <p><code>f$out[c(FALSE, TRUE)]</code> gets the ‘<code>sum</code>’ as a (named) composite
function
</p>
</li>
</ul>
<h4>Subset Assignment</h4>

<p>Similarily, subset assignment works as it does for lists. For instance, you
can replace the ‘<code>sum</code>’ with the identity function:
</p>
<div class="sourceCode"><pre>  f[[2]][[2]] &lt;- identity

  f$out$agg &lt;- identity
  f[["out"]][["agg"]] &lt;- identity

  f$out[[2]] &lt;- identity
  f[[list("out", 2)]] &lt;- identity
</pre></div>
<p>Multiple constituent functions can be reassigned using
<code>[&lt;-</code>. For example
</p>
<div class="sourceCode"><pre>  f[2] &lt;- list(log)

  f["out"] &lt;- list(log)

  f[c(FALSE, TRUE)] &lt;- list(log)
</pre></div>
<p>all replace the second constituent function with <code>log</code>, so that <code>f</code> becomes
<code>abs %&gt;&gt;&gt;% log</code>.
</p>



<h4>Other List Methods</h4>

<p>The generic methods <code>unlist()</code>, <code>length()</code>, <code>names()</code> also apply to
composite functions. In conjunction with <code>compose()</code>, you can use
<code>unlist()</code> to “flatten” compositions. For example
</p>
<div class="sourceCode"><pre>  compose(unlist(f, use.names = FALSE))
</pre></div>
<p>gives a function that is identical to
</p>
<div class="sourceCode"><pre>  abs %&gt;&gt;&gt;% log %&gt;&gt;&gt;% sum
</pre></div>



<h3>Composite Functions Balance Speed and Complexity</h3>

<p>The speed of a composite function made by <code>compose()</code> or <code>`%&gt;&gt;&gt;%`</code>
(regardless of its nested depth) is on par with a manually constructed
<em>serial</em> composition. This is because <code>compose()</code> and <code>`%&gt;&gt;&gt;%`</code> are
<strong>associative</strong>, semantically and operationally. For instance, triple
compositions,
</p>
<div class="sourceCode"><pre>  compose(f, g, h)
  f %&gt;&gt;&gt;% g %&gt;&gt;&gt;% h

  compose(f, compose(g, h))
  f %&gt;&gt;&gt;% (g %&gt;&gt;&gt;% h)

  compose(compose(f, g), h)
  (f %&gt;&gt;&gt;% g) %&gt;&gt;&gt;% h
</pre></div>
<p>are all implemented as the <em>same function</em>. Lists of functions are
automatically “flattened” when composed.
</p>
<p>Nevertheless, the original nested structure of constituent functions is
faithfully recovered by <code>as.list()</code>. In particular, <code>as.list()</code> and
<code>compose()</code> are <strong>mutually invertible</strong>: <code>as.list(compose(fs))</code> is the same
as <code>fs</code>, when <code>fs</code> is a (nested) list of functions. (But note that the
names of the list of composite functions is always a character vector; it
is never <code>NULL</code>.)
</p>


<h3>See Also</h3>

<p><code>constant()</code>; combined with <code>`%&gt;&gt;&gt;%`</code>, this provides a lazy,
structured alternative to the
<a href="https://cran.r-project.org/package=magrittr"><span class="pkg">magrittr</span></a> <code>`%&gt;%`</code>
operator.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Functions are applied in the order in which they are listed
inv &lt;- partial(`/`, 1)  # reciprocal
f0 &lt;- compose(abs, log, inv)
stopifnot(all.equal(f0(-2), 1 / log(abs(-2))))

# Alternatively, compose using the `%&gt;&gt;&gt;%` operator
f1 &lt;- abs %&gt;&gt;&gt;% log %&gt;&gt;&gt;% {1 / .}
stopifnot(all.equal(f1(-2), f0(-2)))

## Not run: 
# Transform a function to a JSON function
library(jsonlite)

# By composing higher-order functions:
jsonify &lt;- {fromJSON %&gt;&gt;&gt;% .} %&gt;&gt;&gt;% {. %&gt;&gt;&gt;% toJSON}

# By directly composing with input/output transformers:
jsonify &lt;- fn(f ~ fromJSON %&gt;&gt;&gt;% f %&gt;&gt;&gt;% toJSON)
## End(Not run)

# Formals of initial function are preserved
add &lt;- function(a, b = 0) a + b
stopifnot(identical(formals(compose(add, inv)), formals(add)))

# Compositions can be provided by lists, in several equivalent ways
f2 &lt;- compose(list(abs, log, inv))
f3 &lt;- compose(!!! list(abs, log, inv))
f4 &lt;- compose(abs, list(log, inv))
f5 &lt;- compose(abs, !!! list(log, inv))
stopifnot(
  all.equal(f2, f0), all.equal(f2(-2), f0(-2)),
  all.equal(f3, f0), all.equal(f3(-2), f0(-2)),
  all.equal(f4, f0), all.equal(f4(-2), f0(-2)),
  all.equal(f5, f0), all.equal(f5(-2), f0(-2))
)

# compose() and as.list() are mutally invertible
f6 &lt;- compose(abs, as.list(compose(log, inv)))
stopifnot(
  all.equal(f6, f0), all.equal(f6(-2), f0(-2))
)
fs &lt;- list(abs, log, inv)
stopifnot(all.equal(check.attributes = FALSE,
  as.list(compose(fs)), fs,
))

# `%&gt;&gt;&gt;%` supports names, magrittr `%&gt;%` semantics, and quasiquotation
sep &lt;- ""
scramble &lt;- shuffle: sample %&gt;&gt;&gt;% paste(collapse = !!sep)
nonsense &lt;- scramble(letters)
stopifnot(
  nchar(nonsense) == 26L,
  identical(letters, sort(strsplit(nonsense, sep)[[1]])),
  identical(scramble$shuffle, sample)
)

</code></pre>


</div>