<div class="container">

<table style="width: 100%;"><tr>
<td>quantSheets</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Quantile Sheets
</h2>

<h3>Description</h3>

<p>The quantile sheets function <code>quantSheets()</code> is based on the work of Sabine
Schnabe and Paul  Eiler (see references below). The estimation  of the quantile curves 
is done simultaneously by also smoothing in the direction of y as well as x. This avoids (but do not eliminate completely) the problem of crossing quantiles.
</p>


<h3>Usage</h3>

<pre><code class="language-R">quantSheets(y, x, x.lambda = 1, p.lambda = 1, data = NULL, 
            cent = 100 * pnorm((-4:4) * 2/3), 
            control = quantSheets.control(...), print = TRUE,  ...)

quantSheets.control(x.inter = 10, p.inter = 10, degree = 3, logit = FALSE, 
            order = 2, kappa = 0, n.cyc = 100, c.crit = 1e-05, plot = TRUE, 
            power = NULL, ...)

findPower(y, x, data = NULL, lim.trans = c(0, 1.5), prof = FALSE, 
            k = 2, c.crit = 0.01, step = 0.1)

z.scoresQS(object, y, x, plot = FALSE, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the y variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the x variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.lambda</code></td>
<td>
<p>smoothing parameter in the direction of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.lambda</code></td>
<td>
<p>smoothing parameter in the direction of y (probabilities)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cent</code></td>
<td>
<p>the centile values where the quantile sheets is evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>for the parameters controlling the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>whether to print the sample percentages</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.inter</code></td>
<td>
<p>number of intervals in the x direction for the B-splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.inter</code></td>
<td>
<p>number of intervals in the probabilities (y-direction) for the B-splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>the degree for the B-splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logit</code></td>
<td>
<p>whether to use <code>logit(p)</code> instead of <code>p</code> (probabilities) for the y-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>the order of the penalty</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>is a ridge parameter set to zero (for no ridge effect) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cyc</code></td>
<td>
<p>number of cycles of the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.crit</code></td>
<td>
<p>convergence criterion of the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>whether to plot the resulting quantile sheets</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>The value of the power transformation in the x axis if needed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lim.trans</code></td>
<td>
<p>the limits for looking for the power transformation 
parameter using <code>findPower()</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prof</code></td>
<td>
<p>whether to use the profile GAIC or <code>optim()</code> to the parameter
the power transformation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the  GAIC penalty</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>the steps for the profile GAIC if the argument <code>prof</code> of 
<code>findPower()</code> is TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted <code>quantSheets</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>how far out from the range of the y variable should go for 
estimating the distribution of y using the <code>flexDist()</code> 
function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for further arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The advantage  of quantile sheets is that they estimates simultaneously all the quantiles.
This almost eliminates the problem of crossing quantiles. The method is very fast and
useful for  exploratory  tool. The function needs two smoothing parameters. 
Those two parameters have to specified by the user. They are <em>not</em> estimated automatically. They can be selected by visual inspection.
</p>
<p>The disadvantages of quantile sheets comes from the fact that like all non-parametric techniques do not have a goodness of fit measure to change how good is the models and the residuals based diagnostics are not existence since it is difficult to define residuals in this set up.  
</p>
<p>In this implementation we do provide residuals by using the  <code>flexDist()</code> 
function from package <span class="pkg">gamlss.dist</span>. This is based on the idea that by 
knowing the quantiles of the distribution we can reconstruct non parametrically 
the distribution itself and this is what <code>flexDist()</code> is doing.
As a word of caution, such a construct is based on several assumptions and depends on 
several smoothing parameters.   Treat those residuals with caution. 
The same caution should apply to the function <code>z.scoresQS()</code>. 
</p>


<h3>Value</h3>

<p>Using the function <code>quantSheets()</code> a <code>quantSheets</code> object is returned having the following  methods:
<code>print()</code>, <code>fitted()</code>, <code>predict()</code> and <code>resid()</code>. 
</p>
<p>Using <code>findPower()</code> a single values of the power parameter is returned.
</p>
<p>Using <code>z.scoresQS</code> a vector of z-scores is returned.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos based on function provided by Paul Eiler and Sabine
Schnabe</p>


<h3>References</h3>

<p>Schnabel, S.K. (2011) <em>Expectile smoothing: new perspectives on asymmetric least squares. An application to life expectancy</em>, Utrecht University.
</p>
<p>Schnabel, S. K and Eilers, P. H. C.(2013) Simultaneous estimation of quantile curves using quantile sheets, <em>AStA Advances in Statistical Analysis</em>, <b>97</b>, 1, 
pp 77-87, Springer.
</p>
<p>Schnabel, S. K and Eilers, P. H. (2013) A location-scale model for non-crossing 
expectile curves, <em>Stat</em>, <b>2</b>, 1, pp 171-183.
</p>
<p>Rigby, R. A., Stasinopoulos, D. M.,  Heller, G. Z.,  and De Bastiani, F. (2019)
<em>Distributions for modeling location, scale, and shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. An older version can be found in <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, Vol. <b>23</b>, Issue 7, Dec 2007, <a href="https://www.jstatsoft.org/v23/i07/">https://www.jstatsoft.org/v23/i07/</a>.
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
<em>Flexible Regression and Smoothing: Using GAMLSS in R</em>,  Chapman and Hall/CRC.  
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

<p><code>lms</code>: for  a parametric equivalent results.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(abdom)
m1 &lt;- quantSheets(y,x, data=abdom)
head(fitted(m1))
p1 &lt;- predict(m1, newdata=c(20,30,40))
matpoints(c(20,30,40), p1)
z.scoresQS(m1,y=c(150, 300),x=c(20, 30) )
# If we needed a power transformation not appropriate for this data
findPower(y,x, data=abdom)
</code></pre>


</div>