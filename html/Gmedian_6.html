<div class="container">

<table style="width: 100%;"><tr>
<td>WeiszfeldCov</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>WeiszfeldCov</h2>

<h3>Description</h3>

<p>Estimation of the Geometric median covariation matrix  with Weiszfeld's algorithm. Weights (such as sampling weights) for statistical units are allowed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">WeiszfeldCov(X, weights=NULL, scores=2, epsilon=1e-08, nitermax = 100) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Data matrix, with n (rows) observations in dimension d (columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>When <code>NULL</code>, all observations have the same weight, say 1/n. Else, the user can provide a size n vector of weights (such as sampling weights). These weights are used in the estimating equation (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>An integer <code>q</code>, by default <code>q=2</code>. The function computes the eigenvectors of the median covariation matrix associated to the <code>q</code> largest eigenvalues and the corresponding principal component scores. No output if <code>scores=0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Numerical tolerance. By defaut 1e-08.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nitermax</code></td>
<td>
<p>Maxium number of iterations of the algorithm. By default set to 100.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This fast and accurate iterative algorithm can deal with moderate size datasets. For large datasets use preferably <code>GmedianCov</code>, if fast estimations are required.
Weights can be given for statistical units, allowing to deal with data drawn from  unequal probability sampling designs (see Lardin-Puech, Cardot and Goga, 2014). The principal components standard deviation is estimed robustly thanks to function <code>scaleTau2</code> from package <code>robustbase</code>.
</p>


<h3>Value</h3>

 
<table>
<tr style="vertical-align: top;">
<td><code>median</code></td>
<td>
<p>Vector of the geometric median</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covmedian</code></td>
<td>
<p>Median covariation matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectors</code></td>
<td>
<p>The <code>scores=q</code> eigenvectors of the median covariation matrix associated to the <code>q</code> largest eigenvalues</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>Principal component scores corresponding to the <code>scores=q</code> eigenvectors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdev</code></td>
<td>
<p>The <code>scores=q</code> robust estimates of the standard deviation of the principal components scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterm</code></td>
<td>
<p>Number of iterations needed to estimate the median</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itercov</code></td>
<td>
<p>Number of iterations needed to estimate the median covariation matrix.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Cardot, H. and Godichon-Baggioni, A. (2017). Fast Estimation of the Median Covariation Matrix with Application to Online Robust Principal Components Analysis.  TEST, 26, 461-480.
</p>
<p>Lardin-Puech, P., Cardot, H.  and Goga, C. (2014). Analysing large datasets of functional data: a survey sampling point of view,   Journal de la Soc. Fr. de Statis., 155(4), 70-94. 
</p>


<h3>See Also</h3>

<p>See also <code>Weiszfeld</code> and <code>GmedianCov</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulated data - Brownian paths
n &lt;- 1e3
d &lt;- 20
x &lt;- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x &lt;- t(apply(x,1,cumsum))

## Estimation
median.est &lt;- WeiszfeldCov(x)

par(mfrow=c(1,2))
image(median.est$covmedian) ## median covariation function
plot(c(1:d)/d,median.est$vectors[,1]*sqrt(d),type="l",xlab="Time",
ylab="Eigenvectors",ylim=c(-1.4,1.4))
lines(c(1:d)/d,median.est$vectors[,2]*sqrt(d),lty=2)
</code></pre>


</div>