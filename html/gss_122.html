<div class="container">

<table style="width: 100%;"><tr>
<td>drkpk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numerical Engine for ssden, sshzd, and sshzd1</h2>

<h3>Description</h3>

<p>Perform numerical calculations for the <code>ssden</code> and
<code>sshzd</code> suites.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sspdsty(s, r, q, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha, bias)
mspdsty(s, r, id.basis, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha,
bias, skip.iter)

sspdsty1(s, r, q, cnt, int, prec, maxiter, alpha)
mspdsty1(s, r, id.basis, cnt, int, prec, maxiter, alpha)

mspcdsty(s, r, id.basis, cnt, qd.s, qd.r, xx.wt, qd.wt, prec, maxiter, alpha, skip.iter)

mspcdsty1(s, r, id.basis, cnt, int.s, int.r, prec, maxiter, alpha, skip.iter)

msphzd(s, r, id.wk, Nobs, cnt, qd.s, qd.r, qd.wt, random, prec, maxiter, alpha, skip.iter)

msphzd1(s, r, id.wk, Nobs, cnt, int.s, int.r, rho, random, prec, maxiter, alpha,
        skip.iter)

sspcox(s, r, q, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha, random, bias)
mspcox(s, r, id.basis, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha, random, bias,
       skip.iter)

mspllrm(s, r, id.basis, cnt, qd.s, qd.r, xx.wt, qd.wt, random, prec, maxiter, alpha,
        skip.iter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Unpenalized terms evaluated at data points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Basis of penalized terms evaluated at data points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Penalty matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.basis</code></td>
<td>
<p>Index of observations to be used as "knots."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.wk</code></td>
<td>
<p>Index of observations to be used as "knots."</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nobs</code></td>
<td>
<p>Total number of lifetime observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cnt</code></td>
<td>
<p>Bin-counts for histogram data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qd.s</code></td>
<td>
<p>Unpenalized terms evaluated at quadrature nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qd.r</code></td>
<td>
<p>Basis of penalized terms evaluated at quadrature nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qd.wt</code></td>
<td>
<p>Quadrature weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bias</code></td>
<td>
<p>List of arrays incorporating possible sampling bias.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int</code></td>
<td>
<p>Integrals of basis terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.s</code></td>
<td>
<p>Integrals of unpenalized terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int.r</code></td>
<td>
<p>Integrals of basis of penalized terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>rho function value on failure times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xx.wt</code></td>
<td>
<p>Weights at unique x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sspdsty</code> is used by <code>ssden</code> to compute
cross-validated density estimate with a single smoothing
parameter. <code>mspdsty</code> is used by <code>ssden</code> to compute
cross-validated density estimate with multiple smoothing
parameters.
</p>
<p><code>msphzd</code> is used by <code>sshzd</code> to compute
cross-validated hazard estimate with single or multiple smoothing
parameters.
</p>


<h3>References</h3>

<p>Du, P. and Gu, C. (2006), Penalized likelihood hazard estimation:
efficient approximation and Bayesian confidence intervals.
<em>Statistics and Probability Letters</em>, <b>76</b>, 244–254.
</p>
<p>Du, P. and Gu, C. (2009), Penalized Pseudo-Likelihood Hazard
Estimation: A Fast Alternative to Penalized Likelihood.
<em>Journal of Statistical Planning and Inference</em>, <b>139</b>,
891–899.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. and Wang, J. (2003), Penalized likelihood density
estimation: Direct cross-validation and scalable approximation.
<em>Statistica Sinica</em>, <b>13</b>, 811–826.
</p>


</div>