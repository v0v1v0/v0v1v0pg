<div class="container">

<table style="width: 100%;"><tr>
<td>LD_SUREthresh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Level Dependent Stein's Unbiased Risk Estimate Thresholding</h2>

<h3>Description</h3>

<p>Adaptive threshold selection using the Level Dependent Stein's Unbiased Risk Estimate.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LD_SUREthresh(
  J,
  wcn,
  diagWWt,
  beta = 2,
  sigma,
  hatsigma = NA,
  policy = "uniform",
  keepSURE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>J</code></td>
<td>
<p>Integer. The finest scale, or the highest frequency. This parameter determines the total number of scales that the function will process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wcn</code></td>
<td>
<p>A numeric vector of noisy spectral graph wavelet coefficients that need to be thresholded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagWWt</code></td>
<td>
<p>Numeric vector of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Numeric. The type of thresholding to be used. If beta=1, soft thresholding is applied. If beta=2, James-Stein thresholding is applied (Default is 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Numeric. The standard deviation of the noise present in the wavelet coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hatsigma</code></td>
<td>
<p>Numeric. An optional estimator of the noise standard deviation. If provided, the function will also compute wavelet coefficient estimates using this estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>policy</code></td>
<td>
<p>The policy for threshold setting. It can be either "uniform" (default) or
"dependent".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepSURE</code></td>
<td>
<p>A logical flag. If <code>TRUE</code>, the function will also return a list containing the results of the SURE thresholding for each scale.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function applies SURE in a level dependent manner to wavelet coefficients, which aims to minimize SURE at each wavelet scale.
</p>
<p>In the "uniform" policy, the thresholds are set based on the absolute value of the wavelet coefficients. In the "dependent" policy, the thresholds are set based on the wavelet coefficients normalized by the weights from <code>diagWWt</code>.
</p>


<h3>Value</h3>

<p>A list containing the wavelet coefficient estimates after applying the SURE
thresholding.
</p>

<ul>
<li> <p><code>wcLDSURE</code>: The wavelet coefficient estimates obtained by minimizing SURE.
</p>
</li>
<li> <p><code>wcLDhatSURE</code>: If <code>hatsigma</code> is provided, this component contains the
wavelet coefficient estimates obtained using the <code>hatsigma</code> estimator.
</p>
</li>
<li> <p><code>lev_thresh</code>: If <code>keepSURE</code> is <code>TRUE</code>, this component contains a list of results similar to the output of <code>SUREthresh</code> for each scale.
</p>
</li>
</ul>
<h3>References</h3>

<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.
</p>
<p>de Loynes, B., Navarro, F., Olivier, B. (2021). Data-driven thresholding in denoising with
Spectral Graph Wavelet Transform. Journal of Computational and Applied Mathematics, Vol. 389.
</p>
<p>Stein, C. M. (1981). Estimation of the mean of a multivariate normal distribution. The annals of Statistics, 1135-1151.
</p>


<h3>See Also</h3>

<p><code>SUREthresh</code> for the underlying thresholding method used at each scale.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Compute the Laplacian matrix and its eigen-decomposition
L &lt;- laplacian_mat(grid1$sA)
U &lt;- eigensort(L)

# Compute the tight frame coefficients
tf &lt;- tight_frame(U$evalues, U$evectors)

# Generate some noisy observation
n &lt;- nrow(L)
f &lt;- randsignal(0.01, 3, grid1$sA)
sigma &lt;- 0.01
noise &lt;- rnorm(n, sd = sigma)
tilde_f &lt;- f + noise

# Compute the transform coefficients
wcn &lt;- forward_sgwt(f, U$evalues, U$evectors)
wcf &lt;- forward_sgwt(f, U$evalues, U$evectors)

# Compute the weights
diagWWt &lt;- colSums(t(tf)^2)

# Compute to optimal threshold
lmax &lt;- max(U$evalues)
J &lt;- floor(log(lmax)/log(b)) + 2
LD_opt_thresh_u &lt;- LD_SUREthresh(J=J,
                                 wcn=wcn,
                                 diagWWt=diagWWt,
                                 beta=2,
                                 sigma=sigma,
                                 hatsigma=NA,
                                 policy = "uniform",
                                 keepSURE = FALSE)

# Get the graph signal estimator
hatf_LD_SURE_u &lt;- synthesis(LD_opt_thresh_u$wcLDSURE, tf)

## End(Not run)

</code></pre>


</div>