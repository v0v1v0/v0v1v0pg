<div class="container">

<table style="width: 100%;"><tr>
<td>cells_body</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Location helper for targeting data cells in the table body</h2>

<h3>Description</h3>

<p><code>cells_body()</code> is used to target the data cells in the table
body. The function can be used to apply a footnote with <code>tab_footnote()</code>, to
add custom styling with <code>tab_style()</code>, or the transform the targeted cells
with <code>text_transform()</code>. The function is expressly used in each of those
functions' <code>locations</code> argument. The 'body' location is present by default in
every <strong>gt</strong> table.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cells_body(columns = everything(), rows = everything())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>The columns to which targeting operations are constrained. Can either
be a series of column names provided in <code>c()</code>, a vector of column indices,
or a select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, <code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p><em>Rows to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;row-targeting expression&gt;⁠</code> // <em>default:</em> <code>everything()</code>
</p>
<p>In conjunction with <code>columns</code>, we can specify which of their rows should
form a constraint for targeting operations. The default <code>everything()</code>
results in all rows in <code>columns</code> being formatted. Alternatively, we can
supply a vector of row IDs within <code>c()</code>, a vector of row indices, or a
select helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>, <code>contains()</code>,
<code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>). We can also use
expressions to filter down to the rows we need
(e.g., <code style="white-space: pre;">⁠[colname_1] &gt; 100 &amp; [colname_2] &lt; 50⁠</code>).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list object with the classes <code>cells_body</code> and <code>location_cells</code>.
</p>


<h3>Targeting cells with <code>columns</code> and <code>rows</code>
</h3>

<p>Targeting of values is done through <code>columns</code> and additionally by <code>rows</code> (if
nothing is provided for <code>rows</code> then entire columns are selected). The
<code>columns</code> argument allows us to target a subset of cells contained in the
resolved columns. We say resolved because aside from declaring column names
in <code>c()</code> (with bare column names or names in quotes) we can use
<strong>tidyselect</strong>-style expressions. This can be as basic as supplying a select
helper like <code>starts_with()</code>, or, providing a more complex incantation like
</p>
<p><code>where(~ is.numeric(.x) &amp; max(.x, na.rm = TRUE) &gt; 1E6)</code>
</p>
<p>which targets numeric columns that have a maximum value greater than
1,000,000 (excluding any <code>NA</code>s from consideration).
</p>
<p>Once the columns are targeted, we may also target the <code>rows</code> within those
columns. This can be done in a variety of ways. If a stub is present, then we
potentially have row identifiers. Those can be used much like column names in
the <code>columns</code>-targeting scenario. We can use simpler <strong>tidyselect</strong>-style
expressions (the select helpers should work well here) and we can use quoted
row identifiers in <code>c()</code>. It's also possible to use row indices (e.g.,
<code>c(3, 5, 6)</code>) though these index values must correspond to the row numbers of
the input data (the indices won't necessarily match those of rearranged rows
if row groups are present). One more type of expression is possible, an
expression that takes column values (can involve any of the available columns
in the table) and returns a logical vector.
</p>


<h3>Examples</h3>

<p>Let's use a subset of the <code>gtcars</code> dataset to create a <strong>gt</strong> table. Add a
footnote (with <code>tab_footnote()</code>) that targets a single data cell via the use
of <code>cells_body()</code> in <code>locations</code> (<code>rows = hp == max(hp)</code> will target a single
row in the <code>hp</code> column).
</p>
<div class="sourceCode r"><pre>gtcars |&gt;
  dplyr::filter(ctry_origin == "United Kingdom") |&gt;
  dplyr::select(mfr, model, year, hp) |&gt;
  gt() |&gt;
  tab_footnote(
    footnote = "Highest horsepower.",
    locations = cells_body(
      columns = hp,
      rows = hp == max(hp)
    ),
    placement = "right"
  ) |&gt;
  opt_footnote_marks(marks = c("*", "+"))
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cells_body_1.png" alt="This image of a table was generated from the first code example in the `cells_body()` help file." style="width:100%;"><h3>Function ID</h3>

<p>8-18
</p>


<h3>Function Introduced</h3>

<p><code>v0.2.0.5</code> (March 31, 2020)
</p>


<h3>See Also</h3>

<p>Other location helper functions: 
<code>cells_column_labels()</code>,
<code>cells_column_spanners()</code>,
<code>cells_footnotes()</code>,
<code>cells_grand_summary()</code>,
<code>cells_row_groups()</code>,
<code>cells_source_notes()</code>,
<code>cells_stub()</code>,
<code>cells_stub_grand_summary()</code>,
<code>cells_stub_summary()</code>,
<code>cells_stubhead()</code>,
<code>cells_summary()</code>,
<code>cells_title()</code>,
<code>location-helper</code>
</p>


</div>