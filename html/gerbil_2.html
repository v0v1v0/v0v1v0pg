<div class="container">

<table style="width: 100%;"><tr>
<td>gerbil</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>General Efficient Regression-Based Imputation with Latent processes</h2>

<h3>Description</h3>

<p>Coherent multiple imputation of general multivariate data as implemented through the GERBIL algorithm described by Robbins (2020).  The algorithm is
</p>

<ul>
<li> <p><strong>coherent</strong> in that imputations are sampled from a valid joint distribution, ensuring MCMC convergence;
</p>
</li>
<li> <p><strong>general</strong> in that data of general structure (binary, categorical, continuous, etc.) may be allowed;
</p>
</li>
<li> <p><strong>efficient</strong> in that computational performance is optimized using the SWEEP operator for both modeling and sampling;
</p>
</li>
<li> <p><strong>regression-based</strong> in that the joint distribution is built through a sequence of conditional regression models;
</p>
</li>
<li> <p><strong>latent</strong> in that a latent multivariate normal process underpins all variables; and
</p>
</li>
<li> <p><strong>flexible</strong> in that the user may specify which dependencies are enabled within the conditional models.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">gerbil(
  dat,
  m = 1,
  mcmciter = 25,
  predMat = NULL,
  type = NULL,
  visitSeq = NULL,
  ords = NULL,
  semi = NULL,
  bincat = NULL,
  cont.meth = "EMP",
  num.cat = 12,
  r = 5,
  verbose = TRUE,
  n.cores = NULL,
  cl.type = NULL,
  mass = rep(0, length(semi)),
  ineligible = NULL,
  trace = TRUE,
  seed = NULL,
  fully.syn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>The dataset that is to be imputed.  Missing values must be coded with <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The number of multiply imputed datasets to be created.  By default, <code>m = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmciter</code></td>
<td>
<p>The number of iterations of Markov chain Monte Carlo that will be used to create each imputed dataset. By default, <code>m = 25</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predMat</code></td>
<td>
<p>A numeric matrix of <code>ncol(dat)</code> columns and no more than <code>nrow(dat)</code> rows, containing 0/1 data specifying the set of predictors to be used for each target row. Each row corresponds to a variable. A value of 1 means that the column variable is used as a predictor for the variable in the target row. By default, <code>predMat</code> is a square matrix of <code>ncol(dat)</code> rows and columns with 1's below the diagonal and 0's on and above the diagonal.  Any non-zero value on or above the diagonal will be set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A named vector that gives the type of each variable contained in <code>dat</code>.  Possible types include <code>'binary'</code>, <code>'categorical'</code>, <code>'ordinal'</code>, <code>'semicont'</code> (semi-continuous), and <code>'continuous'</code>.  The vector type should be named where the names indicate the corresponding column of <code>dat</code>.  Types for variables not listed in type will be determined by default, in which case a variable with no more than <code>num.cat</code> possible values will be set as binary/categorical and is set as continuous otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>visitSeq</code></td>
<td>
<p>A vector of variable names that has (at least) contains all names of each column of <code>dat</code> that has missing values.  Within the I-Step and P-Step of gerbil, the variables will be modeled and imputed in the sequence given by <code>visitSeq</code>.   If <code>visitSeq = TRUE</code>, <code>visitSeq</code> is reset as being equal to the columns of <code>dat</code> ordered from least to most missingness.  If <code>visitSeq = NULL</code> (the default) or <code>visitSeq = FALSE</code> variables are ordered in accordance with the order of the rows of <code>predMat</code> or (if unavailable) the order in which they appear in the <code>dat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ords</code></td>
<td>
<p>A character string giving a set of the column names of <code>dat</code> that indicate which variables are to be treated as ordinal. Elements of <code>ords</code> are overridden by any conflicting information in <code>type</code>. By default, <code>ords = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>semi</code></td>
<td>
<p>A character string giving a set of the column names of <code>dat</code> that indicate which variables are to be treated as semi-continuous. Elements of <code>semi</code> are overridden by any conflicting information in <code>type</code>. By default, <code>semi = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bincat</code></td>
<td>
<p>A character string giving a set of the column names of <code>dat</code> that indicate which variables are to be treated as binary or unordered categorical. Elements of <code>bincat</code> are overridden by any conflicting information in <code>type</code>. By default, <code>bincat = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cont.meth</code></td>
<td>
<p>The type of marginal transformation used for continuous variables.  Set to <code>"EMP"</code> by default for the empirical distribution transformation of Robbins (2014). The current version also includes an option for no transformation (<code>cont.meth = "none"</code>). Other transformation types will be available in future versions of <code>gerbil</code>.  .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.cat</code></td>
<td>
<p>Any variable that does not have a type specified by any of the other parameters will be treated as categorical if it takes on no more than <code>num.cat</code> possible values and as continuous if it takes on more than <code>num.cat</code> possible values. By default, <code>num.cat = 12</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The number of pairwise completely observed cases that must be available for any pair of variables to have dependencies enabled within the conditional models for imputation. By default, <code>r = 5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> (the default), history is printed on console. Use <code>verbose = FALSE</code> for silent computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cores</code></td>
<td>
<p>The number of CPU cores to use for parallelization. If <code>n.cores</code> is not specified by the user, it is guessed using the <code>detectCores</code> function in the parallel package.  If <code>TRUE</code>  (the default), it is set as <code>detectCores()</code>.  If <code>NULL</code>, it is set as <code>floor((detectCores()+1)/2)</code>.  If <code>FALSE</code>, it is set as <code>1</code>, in which case parallelization is not invoked.  Note that the documentation for <code>detectCores</code> makes clear that it is not failsafe and could return a spurious number of available cores. By default, <code>n.cores</code> is set as <code>floor((n + 1)/2)</code>, where <code>n</code> is the number of available clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl.type</code></td>
<td>
<p>The cluster type that is passed into the <code>makeCluster()</code> function in the <code>parallel</code> package.  Defaults to <code>'PSOCK'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mass</code></td>
<td>
<p>A named vector of the same length as the number of semi-continuous variables in <code>dat</code> that gives the location (value) of the point mass for each such variable. The point of mass for each semicontinuous variable is set to zero by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ineligible</code></td>
<td>
<p>Either a scalar or a matrix that is used to determined which values are to be considered missing but ineligible for imputation. Such values will be imputed internally within <code>gerbil</code> to ensure a coherent imputation model but will be reset as missing after imputations have been created. If <code>ineligible</code> is a scalar, all data points that take on the respective value will be considered missing but ineligible for imputation. If <code>ineligible</code> is a matrix (with the same number of rows as <code>dat</code> and column names that overlap with <code>dat</code>), entries of <code>TRUE</code> or <code>1</code> in <code>ineligible</code> indicate values that are missing but ineligible for imputation. If <code>ineligible = NULL</code> (the default), all missing values will be considered eligible for imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>A logical that, if <code>TRUE</code>, implies that means and variances of variables are tracked across iterations. Set to <code>FALSE</code> to save computation time. However, trace plots and R hat statistics are disabled for <code>gerbil</code> objects created with <code>trace = FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An integer that, when specified, is used to set the random number generator via <code>set.seed()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fully.syn</code></td>
<td>
<p>A logical that, if <code>TRUE</code>, implies that a fully synthetic dataset will be created (although variables without missingness are not altered).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gerbil</code> is designed to handle the following classes of variables:
</p>

<ul>
<li> <p><code>'continuous'</code>: Variables are transformed to be (nearly) standard normal prior to imputation. The default transformation method is based on empirical distributions (see Robbins, 2014) and ensures that imputed values of a variable are sampled from the observed values of that variable.
</p>
</li>
<li> <p><code>'binary'</code>: Dichotomous variables are handled through probit-type models in that they are underpinned by a unit-variance normally distributed random variable.
</p>
</li>
<li> <p><code>'categorical'</code>: Unordered categorical variables are handled by creating nested binary variables that underpin the categorical data.  Missingness is artificially imposed in the nested variables in order to ensure conditional independence between them.  See Robbins (2020) for details.
</p>
</li>
<li> <p><code>'ordinal'</code>: Ordered categorical variables (ordinal) are handled through a probit-type model in that a latent normal distribution is assumed to underpin the ordinal observations.  See Robbins (2020) for details.
</p>
</li>
<li> <p><code>'semicont'</code>: Mixed discrete/continuous (semi-continuous) variables are assumed to observe a mass at a specific value (most often zero) and are continuous otherwise.  A binary variable is created that indicates whether the semi-continuous variable takes on the point-mass value; the continuous portion is set as missing when the observed semi-continuous variable takes on the value at the point-mass.  See Robbins et al. (2013) for details.
</p>
</li>
</ul>
<p>The parameter <code>type</code> allows the user to specify the class for each variable.  Routines are in place to establish the class by default for variables not stated in <code>type</code>. Note that it is not currently possible for a variable to be assigned a class of semi-continuous by default.
</p>
<p><code>gerbil</code> uses a joint modeling approach to imputation that builds a joint model using a sequence of conditional models, as outlined in Robbins et al. (2013).
This approach differs from fully conditional specification in that the regression model for any given variable is only allowed to depend upon variables that preceed it in an index ordering.
The order is established by the parameter <code>visitSeq</code>. <code>gerbil</code> contains the flexibility to allow its user to establish which of the permissible dependencies are enabled within the conditional models.
Enabled dependencies are stated within the parameter <code>predMat</code>.  Note that the data matrix used for imputation is an expanded version of the data that are fed into the algorithm (variables are created that underpin unordered categorical and semi-continuous variables).
Note also that conditional dependencies between the nested binary variables of a single undordered categorical variables or the discrete and continuous portions of a semi-continuous variable are not permitted.
</p>
<p>The output of <code>gerbil</code> is an object of class <code>gerbil</code> which is a list that contains the imputed datasets (<code>imputed</code>), missingness indicators (<code>missing</code> and <code>missing.latent</code>), summary information (<code>summary</code>), output used for MCMC convergence diagostics (<code>chainSeq</code> and <code>R.hat</code>),
and modeling summaries (<code>visitSeq.initial</code>, <code>visitSeq.final</code>, <code>predMat.initial</code>, <code>predMat.final</code>, <code>drops</code>, and <code>forms</code>).
Some output regarding convergence diagnostics and modeling regards the expanded dataset used for imputation (the expanded dataset includes binary indicators for unordered categorical and semi-continuous variables).
Note that the nested binary variables corresponding to an unordered categorical variable <code>X</code> with categories labeled <code>a</code>, <code>b</code>, <code>c</code>, etc., are named <code>X.a</code>, <code>X.b</code>, <code>X.c</code>, and so forth in the expanded dataset.
Likewise, the binary variable indicating the point mass of a semi-continuous variable <code>Y</code> is named <code>Y.B</code> in the expanded dataset, and the positive portion (with missingness imposed) is left as being named <code>Y</code>.
</p>
<p><code>gerbil</code> automatically checks each regression model for perfect collinearities and reduces the model as needed. 
Variables that have been dropped from a given model are listed in the element named <code>'drops'</code> in a <code>gerbil</code> object.
</p>


<h3>Value</h3>

<p><code>gerbil()</code> returns an object the class <code>gerbil</code> that contains the following slots:
</p>

<dl>
<dt>imputed</dt>
<dd>
<p>A list of length <code>m</code> that contains the imputed datasets.</p>
</dd>
<dt>missing</dt>
<dd>
<p>A matrix <code>0</code>s, <code>1</code>s, <code>2</code>s, and <code>4</code>s of the same dimension as <code>dat</code> that indicates which values were observed or missing.  A <code>0</code> indicates a fully observed value, a <code>1</code> indicates a missing value that was imputed, and a <code>4</code> indicates a missing value that was ineligible for imputation.</p>
</dd>
<dt>summary</dt>
<dd>
<p>A matrix with <code>ncol(dat)</code> number of rows that contains summary information, including the type of each variable and missingness rates. Note that for continuous variables, the type listed indicates the method of transformation used.</p>
</dd>
<dt>chainSeq</dt>
<dd>
<p>A list of six elements. Each element is a matrix with <code>mcmciter</code> columns and up to <code>ncol(dat)</code> rows. Objects <code>means.all</code> and <code>means.mis</code> give the variables means of data process across iterations of MCMC when all observations are incorporated and when only imputed values are incorporated, respectively. (Means of continuous variables are given on the transformed scale.) Similar objects are provided to track variances of variables. Variables are listed in the order provided by the <code>gerbil</code> object <code>visitSeq.latent</code>. Variables reported in this output are those contained in the dataset that has been expanded to include binary indicators for categorical and semi-continuous variables.</p>
</dd>
<dt>R.hat</dt>
<dd>
<p>The value of the R hat statistics of Gelman and Rubin (1992) for the means and variances of each variable. The R hat statistic is also provided for mean of binary variables.  Variables include those contained in the expanded dataset and are listed in the order provided by object <code>visitSeq.latent</code>. Only calculated if <code>m &gt; 2</code> and <code>mcmciter &gt;= 4</code>.</p>
</dd>
<dt>missing.latent</dt>
<dd>
<p>A matrix of the same dimensions as the expanded dataset, but used to indicate missingness in the expanded dataset. In this matrix, <code>0</code>s indicate fully observed values, <code>1</code>s indicate fully missing values, <code>3</code>s indicate values that have imposed missingness (for binary indicators corresponding to categorical or semi-continuous variables), and <code>4</code> indicates a missing value that is ineligible for imputation (as determined by the input <code>'ineligible'</code>)..</p>
</dd>
<dt>visitSeq.initial</dt>
<dd>
<p>A vector of variable names giving the sequential ordering of variables that is used for imputation prior to expanding the dataset include nested binary and point-mass indicators.  Variables without missing values are excluded.</p>
</dd>
<dt>visitSeq.final</dt>
<dd>
<p>A vector of variable names giving the sequential ordering of variables in the expanded dataset that is used for imputation.  Variables without missing values are excluded.</p>
</dd>
<dt>predMat.initial</dt>
<dd>
<p>A matrix of ones and zeros indicating the dependencies enabled in the conditional models used for imputation.  This matrix is determined from the input 'predMat'. Rows corresponding to variables with no missing values are removed.</p>
</dd>
<dt>predMat.final</dt>
<dd>
<p>A matrix of ones and zeros indicating the dependencies enabled in the conditional models used for imputation.  This is of a similar format to the input 'predMat' but pertains to the expanded dataset.  Rows corresponding to variables with no missing values are removed.</p>
</dd>
<dt>drops</dt>
<dd>
<p>A list of length equal to the number of variables in the expanded dataset that have missing values.  Elements of the list indicate which variables were dropped from the conditional model for the corresponding variable due to either insufficient pairwise complete observations (see the input 'r') or perfect collinearities.</p>
</dd>
<dt>forms</dt>
<dd>
<p>A list of length equal to the number of variables in the expanded dataset that have missing values.  Elements of the list indicate the regression formula used for imputation of the respective variable.</p>
</dd>
<dt>mass.final</dt>
<dd>
<p>The final version of the input parameter <code>mass</code>.</p>
</dd>
<dt>ineligibles</dt>
<dd>
<p>A logical matrix with the same number of rows and columns as <code>dat</code> that indicates which elements are considered missing but ineligible for imputation.</p>
</dd>
<dt>nams.out</dt>
<dd>
<p>A vector used to link column names in the expanded data to corresponding names in the original data.</p>
</dd>
</dl>
<h3>References</h3>

<p>Gelman, A., &amp; Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. <em>Statistical Science</em>, 7(4), 457-472.
</p>
<p>Robbins, M. W. (2014). The Utility of Nonparametric Transformations for Imputation of Survey Data. <em>Journal of Official Statistics</em>, 30(4), 675-700.
</p>
<p>Robbins, M. W. (2020). A flexible and efficient algorithm for joint imputation of general data. arXiv preprint arXiv:2008.02243.
</p>
<p>Robbins, M. W., Ghosh, S. K., &amp; Habiger, J. D. (2013). Imputation in high-dimensional economic data as applied to the Agricultural Resource Management Survey. <em>Journal of the American Statistical Association</em>, 108(501), 81-95.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Load the India Human Development Survey-II dataset
data(ihd_mcar) 

# Gerbil without types specified
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, mcmciter = 10)

# Gerbil with types specified (method #1)
types.gerbil &lt;- c(
       sex = "binary", age = "continuous", 
       marital_status = "binary", job_field = "categorical", 
       farm_labour_days = "semicont", own_livestock = "binary", 
       education_level = "ordinal", income = "continuous")
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, type = types.gerbil)

# Gerbil with types specified (method #2)
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, ords = "education_level", semi = "farm_labour_days", 
       bincat = c("sex", "marital_status", "job_field", "own_livestock"))

# Gerbil with types specified (method #3)
types.gerbil &lt;- c("binary", "continuous", "binary", "categorical", "semicont", 
       "binary", "ordinal", "continuous")
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, type = types.gerbil)

# Variables of class factor are treated as binary/categorical by default
ihd.fac &lt;- ihd_mcar
ihd.fac$sex &lt;- factor(ihd_mcar$sex)
ihd.fac$marital_status &lt;- factor(ihd_mcar$marital_status)
ihd.fac$job_field &lt;- factor(ihd_mcar$job_field)
ihd.fac$own_livestock &lt;- factor(ihd_mcar$own_livestock)
ihd.fac$education_level &lt;- ordered(ihd_mcar$education_level)
imps.gerbil &lt;- gerbil(ihd.fac, m = 1)

# Univariate plotting of one variable
plot(imps.gerbil, type = 1, y = "job_field")

# gerbil with predMat specified (method #1)
predMat &lt;- matrix(c(1, 0, 0, 1), 2, 2)
dimnames(predMat) &lt;- list(c("education_level", "income"), c("sex", "job_field"))
imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, type = types.gerbil, predMat = predMat)

# gerbil with predMat specified (method #2)
predMat &lt;- rbind(
       c(0, 0, 0, 0, 0, 0, 0, 0), 
       c(1, 0, 0, 0, 0, 0, 0, 0), 
       c(1, 1, 0, 0, 0, 0, 0, 0), 
       c(1, 1, 1, 0, 0, 0, 0, 0), 
       c(1, 1, 1, 1, 0, 0, 0, 0), 
       c(1, 1, 1, 1, 1, 0, 0, 0), 
       c(1, 1, 1, 0, 1, 1, 0, 0), 
       c(0, 1, 1, 1, 1, 1, 1, 0) 
       )
imps.gerbil &lt;- gerbil(ihd_mcar, type = types.gerbil, predMat = predMat)

# Multiple imputation with more iterations
imps.gerbil.5 &lt;- gerbil(ihd_mcar, m = 5, mcmciter = 100, ords = "education_level", 
       semi = "farm_labour_days", bincat = "job_field", n.cores = 1)

plot(imps.gerbil.5, type = 1, y = "job_field", imp = 1:5) 

# Extract the first imputed dataset
imputed.gerb &lt;- imputed(imps.gerbil.5, imp = 1)

# Write all imputed datasets to an Excel file
write.gerbil(imps.gerbil.5, file = file.path(tempdir(), "gerbil_example.xlsx"), imp = 1:5)


## Not run: 
if(requireNamespace('mice')){
# Impute using mice for comparison

types.mice &lt;- c("logreg", "pmm", "logreg", "polyreg", "pmm", "logreg", "pmm", "pmm")
imps.mice &lt;- mice(ihd.fac, m = 1, method = types.mice, maxit = 100)

imps.mice1 &lt;- mice(ihd.fac, m = 1, method = "pmm", maxit = 100)

imps.gerbil &lt;- gerbil(ihd_mcar, m = 1, mcmciter = 100, ords = "education_level", 
    semi = "farm_labour_days", bincat = "job_field")

# Compare the performance of mice and gerbil

# Replace some gerbil datasets with mice datasets
imps.gerbil.m &lt;- imps.gerbil.5
imps.gerbil.m$imputed[[2]] &lt;- complete(imps.mice, action = 1)
imps.gerbil.m$imputed[[3]] &lt;- complete(imps.mice1, action = 1)

# Perform comparative correaltion analysis
cor_gerbil(imps.gerbil.m, imp = 1, log = "income")
cor_gerbil(imps.gerbil.m, imp = 2, log = "income")
cor_gerbil(imps.gerbil.m, imp = 3, log = "income")

# Perform comparative univariate goodness-of-fit testing
gof_gerbil(imps.gerbil.m, type = 1, imp = 1)
gof_gerbil(imps.gerbil.m, type = 1, imp = 2)
gof_gerbil(imps.gerbil.m, type = 1, imp = 3)

# Perform comparative bivariate goodness-of-fit testing
gof_gerbil(imps.gerbil.m, type = 2, imp = 1)
gof_gerbil(imps.gerbil.m, type = 2, imp = 2)
gof_gerbil(imps.gerbil.m, type = 2, imp = 3)

# Produce univariate plots for comparisons 
plot(imps.gerbil.m, type = 1, file = file.path(tempdir(), "gerbil_vs_mice_univariate.pdf"), 
     imp = c(1, 2, 3), log = "income", lty = c(1, 2, 4, 5), col = c("blue4", "brown2", 
     "green3", "orange2"), legend = c("Observed", "gerbil", "mice: logistic", "mice: pmm"))

### Produce bivariate plots for comparisons 
plot(imps.gerbil.m, type = 2, file = file.path(tempdir(), "gerbil_vs_mice_bivariate.pdf"), 
    imp = c(1, 2, 3), log = "income", lty = c(1, 2, 4, 5), col = c("blue4", "brown2", 
    "green3", "orange2"), pch = c(1, 3, 4, 5), legend = c("Observed", "gerbil", 
    "mice: logistic", "mice: pmm"))

}

## End(Not run)
</code></pre>


</div>