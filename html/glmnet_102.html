<div class="container">

<table style="width: 100%;"><tr>
<td>predict.glmnetfit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get predictions from a <code>glmnetfit</code> fit object</h2>

<h3>Description</h3>

<p>Gives fitted values, linear predictors, coefficients and number of non-zero
coefficients from a fitted <code>glmnetfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'glmnetfit'
predict(
  object,
  newx,
  s = NULL,
  type = c("link", "response", "coefficients", "nonzero"),
  exact = FALSE,
  newoffset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Fitted "glmnetfit" object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newx</code></td>
<td>
<p>Matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix. This argument is not used for <code>type =
c("coefficients","nonzero")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>Value(s) of the penalty parameter lambda at which predictions are
required. Default is the entire sequence used to create the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of prediction required. Type "link" gives the linear
predictors (eta scale); Type "response" gives the fitted values (mu scale).
Type "coefficients" computes the coefficients at the requested values for s.
Type "nonzero" returns a list of the indices of the nonzero coefficients for
each value of s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>This argument is relevant only when predictions are made at values
of <code>s</code> (lambda) <em>different</em> from those used in the fitting of the
original model. If <code>exact=FALSE</code> (default), then the predict function
uses linear interpolation to make predictions for values of <code>s</code> (lambda)
that do not coincide with those used in the fitting algorithm. While this is
often a good approximation, it can sometimes be a bit coarse. With
<code>exact=TRUE</code>, these different values of <code>s</code> are merged (and sorted)
with <code>object$lambda</code>, and the model is refit before predictions are made.
In this case, it is required to supply the original data x= and y= as additional
named arguments to predict() or coef(). The workhorse <code>predict.glmnet()</code>
needs to update the model, and so needs the data used to create it. The same
is true of weights, offset, penalty.factor, lower.limits, upper.limits if
these were used in the original call. Failure to do so will result in an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newoffset</code></td>
<td>
<p>If an offset is used in the fit, then one must be supplied for
making predictions (except for type="coefficients" or type="nonzero").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code>x=</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The object returned depends on type.
</p>


</div>