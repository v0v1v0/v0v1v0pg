<div class="container">

<table style="width: 100%;"><tr>
<td>contributions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Percent-change contributions</h2>

<h3>Description</h3>

<p>Calculate additive percent-change contributions for generalized-mean price
indexes, and indexes that nest two levels of generalized means consisting of
an outer generalized mean and two inner generalized means (e.g., the Fisher
index).
</p>


<h3>Usage</h3>

<pre><code class="language-R">contributions(r)

arithmetic_contributions(x, w = NULL)

geometric_contributions(x, w = NULL)

harmonic_contributions(x, w = NULL)

nested_contributions(r1, r2, t = c(1, 1))

nested_contributions2(r1, r2, t = c(1, 1))

fisher_contributions(x, w1 = NULL, w2 = NULL)

fisher_contributions2(x, w1 = NULL, w2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A finite number giving the order of the generalized mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w, w1, w2</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length
as <code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r1</code></td>
<td>
<p>A finite number giving the order of the outer generalized mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r2</code></td>
<td>
<p>A pair of finite numbers giving the order of the inner generalized
means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>A pair of strictly positive weights for the inner generalized
means. The default is equal weights.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>contributions()</code> is a simple wrapper for
<code>transmute_weights(r, 1)()</code> to calculate
(additive) percent-change contributions for a price index based on a
generalized mean of order <code>r</code>. It returns a function to compute a
vector <code>v(x, w)</code> such that
</p>
<pre>generalized_mean(r)(x, w) - 1 == sum(v(x, w))</pre>
<p>This generalizes the approach for calculating percent-change contributions
in section 4.2 of Balk (2008) using the method by Martin (2021). The
<code>arithmetic_contributions()</code>, <code>geometric_contributions()</code> and
<code>harmonic_contributions()</code> functions cover the most important cases
(i.e., <code>r = 1</code>, <code>r = 0</code>, and <code>r = -1</code>).
</p>
<p>The <code>nested_contributions()</code> and <code>nested_contributions2()</code>
functions are the analog of <code>contributions()</code> for an index based on a
nested generalized mean with two levels, like a Fisher index. They return a
function that calculates the contribution of each element of <code>x</code> when a
generalized mean of order <code>r1</code> aggregates two generalized-mean indexes
of <code>x</code> with orders <code>r2</code>, and weights <code>w1</code> and <code>w2</code>.
</p>
<p>Unlike the case of a generalized-mean index, there are several ways to make
contributions for an index based on nested generalized means.
<code>nested_contributions()</code> uses a generalization of the algorithm in
section 6 of Reinsdorf et al. (2002) by Martin (2021).
<code>nested_contributions2()</code> generalizes the van IJzeren decomposition for
the Fisher index (Balk, 2008, section 4.2.2) by constructing a weighted
average of the contributions for both of the inner means with the approach
by Martin (2021). In most cases the results are broadly similar.
</p>
<p>The <code>fisher_contributions()</code> and <code>fisher_contributions2()</code>
functions correspond to <code>nested_contributions(0, c(1, -1))()</code> and
<code>nested_contributions2(0, c(1, -1))()</code>, and are appropriate for
calculating percent-change contributions for a Fisher index.
</p>


<h3>Value</h3>

<p><code>contributions()</code> returns a function:
</p>
<pre>function(x, w = NULL){...}</pre>
<p>This computes the additive contribution for each element of <code>x</code> in an
index based on the generalized mean of order <code>r</code> with weights <code>w</code>.
</p>
<p><code>nested_contributions()</code> and <code>nested_contributions2()</code> return a
function:
</p>
<pre>function(x, w1 = NULL, w2 = NULL){...}</pre>
<p>This computes the additive contribution for each element of <code>x</code> when a
generalized mean of order <code>r1</code> aggregates a generalized-mean index of
order <code>r2[1]</code> with weights <code>w1</code> and a generalized-mean index of
order <code>r2[2]</code> with weights <code>w2</code>.
</p>
<p><code>arithmetic_contributions()</code>, <code>geometric_contributions()</code>, and
<code>harmonic_contributions()</code> each return a numeric vector, the same
length as <code>x</code>, giving the contribution of each element of <code>x</code> in
an arithmetic, geometric, or harmonic index.
</p>
<p><code>fisher_contributions()</code> and <code>fisher_contributions2()</code> each return
a numeric vector, the same length as <code>x</code>, giving the contribution of
each element of <code>x</code> when a geometric mean aggregates an arithmetic mean
of <code>x</code> with weights <code>w1</code> and a harmonic mean of <code>x</code> with
weights <code>w2</code>.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Hallerbach, W. G. (2005). An alternative decomposition of the Fisher index.
<em>Economics Letters</em>, 86(2):147–152
</p>
<p>Martin, S. (2021). A note on general decompositions for price indexes.
<em>Prices Analytical Series</em>, Statistics Canada catalogue no. 62F0014M.
Statistics Canada, Ottawa.
</p>
<p>Reinsdorf, M. B., Diewert, W. E., and Ehemann, C. (2002). Additive
decompositions for Fisher, Törnqvist and geometric mean indexes.
<em>Journal of Economic and Social Measurement</em>, 28(1-2):51–61.
</p>
<p>Webster, M. and Tarnow-Mordi, R. C. (2019). Decomposing multilateral price
indexes into the contributions of individual commodities.
<em>Journal of Official Statistics</em>, 35(2):461–486.
</p>


<h3>See Also</h3>

<p><code>transmute_weights()</code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- 2:3

#---- Contributions for a geometric index ----

geometric_mean(x) - 1 # percent change in the Jevons index

geometric_contributions(x)

all.equal(geometric_mean(x) - 1, sum(geometric_contributions(x)))

# This works by first transmuting the weights in the geometric mean
# into weights for an arithmetic mean, then finding the contributions
# to the percent change

transmute_weights(0, 1)(x) * (x - 1)

# Not the only way to calculate contributions

transmute2 &lt;- function(x) {
  m &lt;- geometric_mean(x)
  (m - 1) / log(m) * log(x) / (x - 1) / length(x)
}

transmute2(x) * (x - 1) # not proportional to the method above
all.equal(sum(transmute2(x) * (x - 1)), geometric_mean(x) - 1)

# But these "transmuted" weights don't recover the geometric mean!
# Not a particularly good way to calculate contributions

isTRUE(all.equal(
  arithmetic_mean(x, transmute2(x)),
  geometric_mean(x)
))

# There are infinitely many ways to calculate contributions, but the
# weights from transmute_weights(0, 1)() are the *unique* weights that
# recover the geometric mean

perturb &lt;- function(w, e) {
  w + c(e, -e) / (x - 1)
}

perturb(transmute2(x), 0.1) * (x - 1)
all.equal(
  sum(perturb(transmute2(x), 0.1) * (x - 1)),
  geometric_mean(x) - 1
)
isTRUE(all.equal(
  arithmetic_mean(x, perturb(transmute2(x), 0.1)),
  geometric_mean(x)
))

#---- Contributions for a Fisher index ----

p1 &lt;- price6[[2]]
p0 &lt;- price6[[1]]
q1 &lt;- quantity6[[2]]
q0 &lt;- quantity6[[1]]

# Percent-change contributions for the Fisher index in section 6 of
# Reinsdorf et al. (2002)

(con &lt;- fisher_contributions(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
))

all.equal(sum(con), fisher_index(p1, p0, q1, q0) - 1)

# Not the only way

(con2 &lt;- fisher_contributions2(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
))

all.equal(sum(con2), fisher_index(p1, p0, q1, q0) - 1)

# The same as the van IJzeren decomposition in section 4.2.2 of
# Balk (2008)

Qf &lt;- quantity_index(fisher_index)(q1, q0, p1, p0)
Ql &lt;- quantity_index(laspeyres_index)(q1, q0, p0)
wl &lt;- scale_weights(index_weights("Laspeyres")(p0, q0))
wp &lt;- scale_weights(index_weights("HybridPaasche")(p0, q1))

(Qf / (Qf + Ql) * wl + Ql / (Qf + Ql) * wp) * (p1 / p0 - 1)

# Similar to the method in section 2 of Reinsdorf et al. (2002),
# although those contributions aren't based on weights that sum to 1

Pf &lt;- fisher_index(p1, p0, q1, q0)
Pl &lt;- laspeyres_index(p1, p0, q0)

(1 / (1 + Pf) * wl + Pl / (1 + Pf) * wp) * (p1 / p0 - 1)

# Also similar to the decomposition by Hallerbach (2005), noting that
# the Euler weights are close to unity

Pp &lt;- paasche_index(p1, p0, q1)

(0.5 * sqrt(Pp / Pl) * wl + 0.5 * sqrt(Pl / Pp) * wp) * (p1 / p0 - 1)

#---- Contributions for other types of indexes ----

# A function to get contributions for any superlative quadratic mean of
# order 'r' index

superlative_contributions &lt;- function(r) {
  nested_contributions(0, c(r / 2, -r / 2))
}

# Can be used to decompose the implict Walsh index

superlative_contributions(1)(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
)

# Works for other types of indexes, like the harmonic
# Laspeyres Paasche index

hlp_contributions &lt;- nested_contributions(-1, c(1, -1))
hlp_contributions(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
)

# Or the AG mean index (tau = 0.25)

agmean_contributions &lt;- nested_contributions(1, c(0, 1), c(0.25, 0.75))
agmean_contributions(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Laspeyres")(p0, q0)
)

# Or the Balk-Walsh index

bw_contributions &lt;- nested_contributions(0, c(0.5, -0.5))
bw_contributions(p1 / p0)

</code></pre>


</div>