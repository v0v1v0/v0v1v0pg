<div class="container">

<table style="width: 100%;"><tr>
<td>SSR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SemiSmooth Reformulation</h2>

<h3>Description</h3>

<p>functions of the SemiSmooth Reformulation of the GNEP
</p>


<h3>Usage</h3>

<pre><code class="language-R">funSSR(z, dimx, dimlam, grobj, arggrobj, constr, argconstr,  grconstr, arggrconstr, 
	compl, argcompl, dimmu, joint, argjoint, grjoint, arggrjoint, echo=FALSE)
jacSSR(z, dimx, dimlam, heobj, argheobj, constr, argconstr,  grconstr, arggrconstr, 
	heconstr, argheconstr, gcompla, gcomplb, argcompl, dimmu, joint, argjoint,
	grjoint, arggrjoint, hejoint, arghejoint, echo=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a numeric vector <code>z</code> containing <code class="reqn">(x, lambda, mu)</code> values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimx</code></td>
<td>
<p>a vector of dimension for <code class="reqn">x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimlam</code></td>
<td>
<p>a vector of dimension for <code class="reqn">lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grobj</code></td>
<td>
<p>gradient of the objective function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrobj</code></td>
<td>
<p>a list of additional arguments of the objective gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr</code></td>
<td>
<p>constraint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argconstr</code></td>
<td>
<p>a list of additional arguments of the constraint function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grconstr</code></td>
<td>
<p>gradient of the constraint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrconstr</code></td>
<td>
<p>a list of additional arguments of the constraint gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compl</code></td>
<td>
<p>the complementarity function with (at least) two arguments: <code>compl(a,b)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argcompl</code></td>
<td>
<p>list of possible additional arguments for <code>compl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimmu</code></td>
<td>
<p>a vector of dimension for <code class="reqn">mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>joint</code></td>
<td>
<p>joint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argjoint</code></td>
<td>
<p>a list of additional arguments of the joint function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grjoint</code></td>
<td>
<p>gradient of the joint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arggrjoint</code></td>
<td>
<p>a list of additional arguments of the joint gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heobj</code></td>
<td>
<p>Hessian of the objective function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argheobj</code></td>
<td>
<p>a list of additional arguments of the objective Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heconstr</code></td>
<td>
<p>Hessian of the constraint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argheconstr</code></td>
<td>
<p>a list of additional arguments of the constraint Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcompla</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the first argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcomplb</code></td>
<td>
<p>derivative of the complementarity function w.r.t. the second argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hejoint</code></td>
<td>
<p>Hessian of the joint function, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arghejoint</code></td>
<td>
<p>a list of additional arguments of the joint Hessian.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>echo</code></td>
<td>
<p>a logical to show some traces.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Compute the SemiSmooth Reformulation of the GNEP: the Generalized Nash equilibrium problem is defined
by objective functions <code class="reqn">Obj</code> with player variables <code class="reqn">x</code> defined in <code>dimx</code> and 
may have player-dependent constraint functions <code class="reqn">g</code> of dimension <code>dimlam</code> 
and/or a common shared joint function <code class="reqn">h</code> of dimension <code>dimmu</code>,
where the Lagrange multiplier are <code class="reqn">lambda</code> and <code class="reqn">mu</code>, respectively,
see F. Facchinei et al.(2009) where there is no joint function.
</p>

<dl>
<dt><b>Arguments of the Phi function</b></dt>
<dd>	
<p>The arguments which are functions must respect the following features
</p>

<dl>
<dt><code>grobj</code></dt>
<dd>
<p>The gradient <code class="reqn">Grad Obj</code> of an objective function <code class="reqn">Obj</code> (to be minimized) must have 3 arguments for <code class="reqn">Grad Obj(z, playnum, ideriv)</code>: vector <code>z</code>, player number, derivative index
, and optionnally additional arguments in <code>arggrobj</code>.
</p>
</dd>
<dt><code>constr</code></dt>
<dd>
<p>The constraint function <code class="reqn">g</code> must have 2 arguments: vector <code>z</code>, player number,
such that <code class="reqn">g(z, playnum) &lt;= 0</code>. Optionnally, <code class="reqn">g</code> may have additional arguments in <code>argconstr</code>.
</p>
</dd>
<dt><code>grconstr</code></dt>
<dd>
<p>The gradient of the constraint function <code class="reqn">g</code>  must have 3 arguments: vector <code>z</code>, player number, derivative index,
and optionnally additional arguments in <code>arggrconstr</code>.
</p>
</dd>
<dt><code>compl</code></dt>
<dd>
<p>It must have two arguments and optionnally additional arguments in <code>argcompl</code>. 
A typical example is the minimum function.</p>
</dd>
<dt><code>joint</code></dt>
<dd>
<p>The constraint function <code class="reqn">h</code> must have 1 argument: vector <code>z</code>,
such that <code class="reqn">h(z) &lt;= 0</code>. Optionnally, <code class="reqn">h</code> may have additional arguments in <code>argjoint</code>.
</p>
</dd>
<dt><code>grjoint</code></dt>
<dd>
<p>The gradient of the constraint function <code class="reqn">h</code>  must have 2 arguments: vector <code>z</code>, derivative index,
and optionnally additional arguments in <code>arggrjoint</code>.
</p>
</dd>		
</dl>
</dd>
<dt><b>Arguments of the Jacobian of Phi</b></dt>
<dd>	
<p>The arguments which are functions must respect the following features
</p>

<dl>
<dt><code>heobj</code></dt>
<dd>
<p>It must have 4 arguments: vector <code>z</code>, player number, two derivative indexes and optionnally additional arguments in <code>argheobj</code>.</p>
</dd>
<dt><code>heconstr</code></dt>
<dd>
<p>It must have 4 arguments: vector <code>z</code>, player number, two derivative indexes and optionnally additional arguments in <code>argheconstr</code>.</p>
</dd>
<dt>
<code>gcompla</code>,<code>gcomplb</code>
</dt>
<dd>
<p>It must have two arguments and optionnally additional arguments in <code>argcompl</code>.</p>
</dd>
<dt><code>hejoint</code></dt>
<dd>
<p>It must have 3 arguments: vector <code>z</code>, two derivative indexes and optionnally additional arguments in <code>arghejoint</code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>See the example	below.
</p>


<h3>Value</h3>

<p>A vector for <code>funSSR</code> or a matrix for <code>jacSSR</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>F. Facchinei, A. Fischer and V. Piccialli (2009), 
<em>Generalized Nash equilibrium problems and Newton methods</em>,
Math. Program.
</p>


<h3>See Also</h3>

<p>See also <code>GNE.nseq</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# (1) associated objective functions
#

dimx &lt;- c(2, 2, 3)

#Gr_x_j O_i(x)
grfullob &lt;- function(x, i, j)
{
	x &lt;- x[1:7]	
	if(i == 1)
	{
		grad &lt;- 3*(x - 1:7)^2
	}
	if(i == 2)
	{
		grad &lt;- 1:7*(x - 1:7)^(0:6)
	}
	if(i == 3)
	{
		s &lt;- x[5]^2 + x[6]^2 + x[7]^2 - 5	
		grad &lt;- c(1, 0, 1, 0, 4*x[5]*s, 4*x[6]*s, 4*x[7]*s)
			
	}
	grad[j]	
}


#Gr_x_k Gr_x_j O_i(x)
hefullob &lt;- function(x, i, j, k)
{
	x &lt;- x[1:7]
	if(i == 1)
	{
		he &lt;- diag( 6*(x - 1:7) )
	}
	if(i == 2)
	{
		he &lt;- diag( c(0, 2, 6, 12, 20, 30, 42)*(x - 1:7)^c(0, 0:5) )
	}
	if(i == 3)
	{
		s &lt;- x[5]^2 + x[6]^2 + x[7]^2	
		
		he &lt;- rbind(rep(0, 7), rep(0, 7), rep(0, 7), rep(0, 7),
			c(0, 0, 0, 0, 4*s+8*x[5]^2, 8*x[5]*x[6], 8*x[5]*x[7]),
			c(0, 0, 0, 0, 8*x[5]*x[6], 4*s+8*x[6]^2, 8*x[6]*x[7]),
			c(0, 0, 0, 0,  8*x[5]*x[7], 8*x[6]*x[7], 4*s+8*x[7]^2) )
	}
	he[j,k]	
}



# (2) constraint linked functions
#

dimlam &lt;- c(1, 2, 2)

#constraint function g_i(x)
g &lt;- function(x, i)
{
	x &lt;- x[1:7]
	if(i == 1)
		res &lt;- sum( x^(1:7) ) -7
	if(i == 2)
		res &lt;- c(sum(x) + prod(x) - 14, 20 - sum(x))
	if(i == 3)
		res &lt;- c(sum(x^2) + 1, 100 - sum(x))
	res
}


#Gr_x_j g_i(x)
grfullg &lt;- function(x, i, j)
{
	x &lt;- x[1:7]	
	if(i == 1)
	{
		grad &lt;- (1:7) * x ^ (0:6)
	}
	if(i == 2)
	{
		grad &lt;- 1 + sapply(1:7, function(i) prod(x[-i]))
		grad &lt;- cbind(grad, -1)
	}
	if(i == 3)
	{
		grad &lt;- cbind(2*x, -1)
	}


	if(i == 1)
		res &lt;- grad[j]	
	if(i != 1)
		res &lt;- grad[j,]	
	as.numeric(res)
}



#Gr_x_k Gr_x_j g_i(x)
hefullg &lt;- function(x, i, j, k)
{
	x &lt;- x[1:7]
	if(i == 1)
	{
		he1 &lt;- diag( c(0, 2, 6, 12, 20, 30, 42) * x ^ c(0, 0, 1:5) )
	}
	if(i == 2)
	{
		he1 &lt;- matrix(0, 7, 7)
		he1[1, -1] &lt;- sapply(2:7, function(i) prod(x[-c(1, i)]))
		he1[2, -2] &lt;- sapply(c(1, 3:7), function(i) prod(x[-c(2, i)]))
		he1[3, -3] &lt;- sapply(c(1:2, 4:7), function(i) prod(x[-c(3, i)]))
		he1[4, -4] &lt;- sapply(c(1:3, 5:7), function(i) prod(x[-c(4, i)]))
		he1[5, -5] &lt;- sapply(c(1:4, 6:7), function(i) prod(x[-c(5, i)]))
		he1[6, -6] &lt;- sapply(c(1:5, 7:7), function(i) prod(x[-c(6, i)]))
		he1[7, -7] &lt;- sapply(1:6, function(i) prod(x[-c(7, i)]))
						
						
		he2 &lt;- matrix(0, 7, 7)
		
	}
	if(i == 3)
	{
		he1 &lt;- diag(rep(2, 7))
		he2 &lt;- matrix(0, 7, 7)
	}
	if(i != 1)
		return( c(he1[j, k], he2[j, k])	)
	else				
		return( he1[j, k] )
}


# (3) compute Phi
#

z &lt;- rexp(sum(dimx) + sum(dimlam))

n &lt;- sum(dimx)
m &lt;- sum(dimlam)
x &lt;- z[1:n]
lam &lt;- z[(n+1):(n+m)]

resphi &lt;- funSSR(z, dimx, dimlam, grobj=grfullob, constr=g, grconstr=grfullg, compl=phiFB)


check &lt;- c(grfullob(x, 1, 1) + lam[1] * grfullg(x, 1, 1), 
	grfullob(x, 1, 2) + lam[1] * grfullg(x, 1, 2), 
	grfullob(x, 2, 3) + lam[2:3] %*% grfullg(x, 2, 3),
	grfullob(x, 2, 4) + lam[2:3] %*% grfullg(x, 2, 4), 	
	grfullob(x, 3, 5) + lam[4:5] %*% grfullg(x, 3, 5),
	grfullob(x, 3, 6) + lam[4:5] %*% grfullg(x, 3, 6),
	grfullob(x, 3, 7) + lam[4:5] %*% grfullg(x, 3, 7),
	phiFB( -g(x, 1), lam[1]), 
	phiFB( -g(x, 2)[1], lam[2]), 
	phiFB( -g(x, 2)[2], lam[3]), 
	phiFB( -g(x, 3)[1], lam[4]), 
	phiFB( -g(x, 3)[2], lam[5]))
	
	

#check
cat("\n\n________________________________________\n\n")

#part A
print(cbind(check, res=as.numeric(resphi))[1:n, ])
#part B
print(cbind(check, res=as.numeric(resphi))[(n+1):(n+m), ])
	
# (4) compute Jac Phi
#
	
resjacphi &lt;- jacSSR(z, dimx, dimlam, heobj=hefullob, constr=g, grconstr=grfullg, 
	heconstr=hefullg, gcompla=GrAphiFB, gcomplb=GrBphiFB)

	
#check
cat("\n\n________________________________________\n\n")


cat("\n\npart A\n\n")	


checkA &lt;- 
rbind(
c(hefullob(x, 1, 1, 1) + lam[1]*hefullg(x, 1, 1, 1), 
hefullob(x, 1, 1, 2) + lam[1]*hefullg(x, 1, 1, 2),
hefullob(x, 1, 1, 3) + lam[1]*hefullg(x, 1, 1, 3),
hefullob(x, 1, 1, 4) + lam[1]*hefullg(x, 1, 1, 4),
hefullob(x, 1, 1, 5) + lam[1]*hefullg(x, 1, 1, 5),
hefullob(x, 1, 1, 6) + lam[1]*hefullg(x, 1, 1, 6),
hefullob(x, 1, 1, 7) + lam[1]*hefullg(x, 1, 1, 7)
),
c(hefullob(x, 1, 2, 1) + lam[1]*hefullg(x, 1, 2, 1), 
hefullob(x, 1, 2, 2) + lam[1]*hefullg(x, 1, 2, 2),
hefullob(x, 1, 2, 3) + lam[1]*hefullg(x, 1, 2, 3),
hefullob(x, 1, 2, 4) + lam[1]*hefullg(x, 1, 2, 4),
hefullob(x, 1, 2, 5) + lam[1]*hefullg(x, 1, 2, 5),
hefullob(x, 1, 2, 6) + lam[1]*hefullg(x, 1, 2, 6),
hefullob(x, 1, 2, 7) + lam[1]*hefullg(x, 1, 2, 7)
),
c(hefullob(x, 2, 3, 1) + lam[2:3] %*% hefullg(x, 2, 3, 1), 
hefullob(x, 2, 3, 2) + lam[2:3] %*% hefullg(x, 2, 3, 2),
hefullob(x, 2, 3, 3) + lam[2:3] %*% hefullg(x, 2, 3, 3),
hefullob(x, 2, 3, 4) + lam[2:3] %*% hefullg(x, 2, 3, 4),
hefullob(x, 2, 3, 5) + lam[2:3] %*% hefullg(x, 2, 3, 5),
hefullob(x, 2, 3, 6) + lam[2:3] %*% hefullg(x, 2, 3, 6),
hefullob(x, 2, 3, 7) + lam[2:3] %*% hefullg(x, 2, 3, 7)
),
c(hefullob(x, 2, 4, 1) + lam[2:3] %*% hefullg(x, 2, 4, 1), 
hefullob(x, 2, 4, 2) + lam[2:3] %*% hefullg(x, 2, 4, 2), 
hefullob(x, 2, 4, 3) + lam[2:3] %*% hefullg(x, 2, 4, 3), 
hefullob(x, 2, 4, 4) + lam[2:3] %*% hefullg(x, 2, 4, 4), 
hefullob(x, 2, 4, 5) + lam[2:3] %*% hefullg(x, 2, 4, 5), 
hefullob(x, 2, 4, 6) + lam[2:3] %*% hefullg(x, 2, 4, 6), 
hefullob(x, 2, 4, 7) + lam[2:3] %*% hefullg(x, 2, 4, 7)
),
c(hefullob(x, 3, 5, 1) + lam[4:5] %*% hefullg(x, 3, 5, 1),  
hefullob(x, 3, 5, 2) + lam[4:5] %*% hefullg(x, 3, 5, 2),  
hefullob(x, 3, 5, 3) + lam[4:5] %*% hefullg(x, 3, 5, 3),  
hefullob(x, 3, 5, 4) + lam[4:5] %*% hefullg(x, 3, 5, 4),  
hefullob(x, 3, 5, 5) + lam[4:5] %*% hefullg(x, 3, 5, 5),  
hefullob(x, 3, 5, 6) + lam[4:5] %*% hefullg(x, 3, 5, 6),  
hefullob(x, 3, 5, 7) + lam[4:5] %*% hefullg(x, 3, 5, 7)
),
c(hefullob(x, 3, 6, 1) + lam[4:5] %*% hefullg(x, 3, 6, 1),   
hefullob(x, 3, 6, 2) + lam[4:5] %*% hefullg(x, 3, 6, 2),  
hefullob(x, 3, 6, 3) + lam[4:5] %*% hefullg(x, 3, 6, 3),  
hefullob(x, 3, 6, 4) + lam[4:5] %*% hefullg(x, 3, 6, 4),  
hefullob(x, 3, 6, 5) + lam[4:5] %*% hefullg(x, 3, 6, 5),  
hefullob(x, 3, 6, 6) + lam[4:5] %*% hefullg(x, 3, 6, 6),  
hefullob(x, 3, 6, 7) + lam[4:5] %*% hefullg(x, 3, 6, 7)
),
c(hefullob(x, 3, 7, 1) + lam[4:5] %*% hefullg(x, 3, 7, 1),   
hefullob(x, 3, 7, 2) + lam[4:5] %*% hefullg(x, 3, 7, 2),  
hefullob(x, 3, 7, 3) + lam[4:5] %*% hefullg(x, 3, 7, 3),  
hefullob(x, 3, 7, 4) + lam[4:5] %*% hefullg(x, 3, 7, 4),  
hefullob(x, 3, 7, 5) + lam[4:5] %*% hefullg(x, 3, 7, 5),  
hefullob(x, 3, 7, 6) + lam[4:5] %*% hefullg(x, 3, 7, 6),  
hefullob(x, 3, 7, 7) + lam[4:5] %*% hefullg(x, 3, 7, 7)
)
)


print(resjacphi[1:n, 1:n] - checkA)


cat("\n\n________________________________________\n\n")


cat("\n\npart B\n\n")	


checkB &lt;- 
rbind(
cbind(c(grfullg(x, 1, 1), grfullg(x, 1, 2)), c(0, 0), c(0, 0), c(0, 0), c(0, 0)),
cbind(c(0, 0), rbind(grfullg(x, 2, 3), grfullg(x, 2, 4)), c(0, 0), c(0, 0)),
cbind(c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), 
 rbind(grfullg(x, 3, 5), grfullg(x, 3, 6), grfullg(x, 3, 7)))
)


print(resjacphi[1:n, (n+1):(n+m)] - checkB)	


cat("\n\n________________________________________\n\n")
cat("\n\npart C\n\n")	


gx &lt;- c(g(x,1), g(x,2), g(x,3))

checkC &lt;- 
- t(
cbind(
rbind(
grfullg(x, 1, 1) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 2) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 3) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 4) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 5) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 6) * GrAphiFB(-gx, lam)[1],
grfullg(x, 1, 7) * GrAphiFB(-gx, lam)[1]
),
rbind(
grfullg(x, 2, 1) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 2) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 3) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 4) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 5) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 6) * GrAphiFB(-gx, lam)[2:3],
grfullg(x, 2, 7) * GrAphiFB(-gx, lam)[2:3]
),
rbind(
grfullg(x, 3, 1) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 2) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 3) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 4) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 5) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 6) * GrAphiFB(-gx, lam)[4:5],
grfullg(x, 3, 7) * GrAphiFB(-gx, lam)[4:5]
)
)
)



print(resjacphi[(n+1):(n+m), 1:n] - checkC)


cat("\n\n________________________________________\n\n")

cat("\n\npart D\n\n")	


checkD &lt;- diag(GrBphiFB(-gx, lam)) 

print(resjacphi[(n+1):(n+m), (n+1):(n+m)] - checkD)

</code></pre>


</div>