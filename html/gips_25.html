<div class="container">

<table style="width: 100%;"><tr>
<td>gips</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The constructor of a <code>gips</code> class.</h2>

<h3>Description</h3>

<p>Create a <code>gips</code> object.
This object will contain initial data and all other information
needed to find the most likely invariant permutation.
It will not perform optimization. One must call
the <code>find_MAP()</code> function to do it. See the examples below.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gips(
  S,
  number_of_observations,
  delta = 3,
  D_matrix = NULL,
  was_mean_estimated = TRUE,
  perm = ""
)

new_gips(
  list_of_gips_perm,
  S,
  number_of_observations,
  delta,
  D_matrix,
  was_mean_estimated,
  optimization_info
)

validate_gips(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>A matrix; empirical covariance matrix.
When <code>Z</code> is the observed data:
</p>

<ul>
<li>
<p> if one does not know the theoretical mean and has to
estimate it with the observed mean, use <code>S = cov(Z)</code>,
and leave parameter <code>was_mean_estimated = TRUE</code> as default;
</p>
</li>
<li>
<p> if one know the theoretical mean is 0, use
<code>S = (t(Z) %*% Z) / number_of_observations</code>, and set
parameter <code>was_mean_estimated = FALSE</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>number_of_observations</code></td>
<td>
<p>A number of data points
that <code>S</code> is based on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>A number, hyper-parameter of a Bayesian model.
It has to be strictly bigger than 1.
See the <strong>Hyperparameters</strong> section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D_matrix</code></td>
<td>
<p>Symmetric, positive-definite matrix of the same size as <code>S</code>.
Hyper-parameter of a Bayesian model.
When <code>NULL</code>, the (hopefully) reasonable one is derived from the data.
For more details, see the <strong>Hyperparameters</strong> section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>was_mean_estimated</code></td>
<td>
<p>A boolean.
</p>

<ul>
<li>
<p> Set <code>TRUE</code> (default) when your <code>S</code> parameter is a result of
a <code>stats::cov()</code> function.
</p>
</li>
<li>
<p> Set FALSE when your <code>S</code> parameter is a result of
a <code>(t(Z) %*% Z) / number_of_observations</code> calculation.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm</code></td>
<td>
<p>An optional permutation to be the base for the <code>gips</code> object.
It can be of a <code>gips_perm</code> or a <code>permutation</code> class, or anything
the function <code>permutations::permutation()</code> can handle.
It can also be of a <code>gips</code> class, but
it will be interpreted as the underlying <code>gips_perm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list_of_gips_perm</code></td>
<td>
<p>A list with a single element of
a <code>gips_perm</code> class. The base object for the <code>gips</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimization_info</code></td>
<td>
<p>For internal use only. <code>NULL</code> or the list with
information about the optimization process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Object to be checked whether it is a proper object of a <code>gips</code> class.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>gips()</code> returns an object of
a <code>gips</code> class after the safety checks.
</p>
<p><code>new_gips()</code> returns an object of
a <code>gips</code> class without the safety checks.
</p>
<p><code>validate_gips()</code> returns its argument unchanged.
If the argument is not a proper element of a <code>gips</code> class,
it produces an error.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>new_gips()</code>: Constructor. It is only intended for low-level use.
</p>
</li>
<li> <p><code>validate_gips()</code>: Validator. It is only intended for low-level use.
</p>
</li>
</ul>
<h3>Methods for a <code>gips</code> class</h3>


<ul>
<li> <p><code>summary.gips()</code>
</p>
</li>
<li> <p><code>plot.gips()</code>
</p>
</li>
<li> <p><code>print.gips()</code>
</p>
</li>
<li> <p><code>logLik.gips()</code>
</p>
</li>
<li> <p><code>AIC.gips()</code>
</p>
</li>
<li> <p><code>BIC.gips()</code>
</p>
</li>
<li> <p><code>as.character.gips()</code>
</p>
</li>
</ul>
<h3>Hyperparameters</h3>

<p>We encourage the user to try <code>D_matrix = d * I</code>, where <code>I</code> is an identity matrix of a size
<code style="white-space: pre;">⁠p x p⁠</code> and <code>d &gt; 0</code> for some different <code>d</code>.
When <code>d</code> is small compared to the data (e.g., <code>d=0.1 * mean(diag(S))</code>),
bigger structures will be found.
When <code>d</code> is big compared to the data (e.g., <code>d=100 * mean(diag(S))</code>),
the posterior distribution does not depend on the data.
</p>
<p>Taking <code>D_matrix = d * I</code> is equivalent to setting <code>S &lt;- S / d</code>.
</p>
<p>The default for <code>D_matrix</code> is <code>D_matrix = d * I</code>, where
<code>d = mean(diag(S))</code>, which is equivalent to modifying <code>S</code>
so that the mean value on the diagonal is 1.
</p>
<p>In the Bayesian model, the prior distribution for
the covariance matrix is a generalized case of
<a href="https://en.wikipedia.org/wiki/Wishart_distribution">Wishart distribution</a>.
</p>
<p>For a brief introduction, see the <strong>Bayesian model selection</strong>
section in <code>vignette("Theory", package = "gips")</code> or in its
<a href="https://przechoj.github.io/gips/articles/Theory.html">pkgdown page</a>).
</p>
<p>For analysis of the Hyperparameters influence, see <strong>Section 3.2.</strong>
of "Learning permutation symmetries with gips in R"
by <code>gips</code> developers Adam Chojecki, Paweł Morgen, and Bartosz Kołodziejek,
available on <a href="https://arxiv.org/abs/2307.00790">arXiv:2307.00790</a>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>stats::cov()</code> - The <code>S</code> parameter, as an empirical covariance matrix,
is most of the time a result of the <code>cov()</code> function.
For more information, see
<a href="https://en.wikipedia.org/wiki/Estimation_of_covariance_matrices">Wikipedia - Estimation of covariance matrices</a>.
</p>
</li>
<li> <p><code>find_MAP()</code> - The function that finds
the Maximum A Posteriori (MAP) Estimator
for a given <code>gips</code> object.
</p>
</li>
<li> <p><code>gips_perm()</code> - The constructor of a <code>gips_perm</code> class.
The <code>gips_perm</code> object is used as the base object for
the <code>gips</code> object. To be more precise, the base object
for <code>gips</code> is a one-element list of a <code>gips_perm</code> object.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">require("MASS") # for mvrnorm()

perm_size &lt;- 5
mu &lt;- runif(5, -10, 10) # Assume we don't know the mean
sigma_matrix &lt;- matrix(
  data = c(
    1.0, 0.8, 0.6, 0.6, 0.8,
    0.8, 1.0, 0.8, 0.6, 0.6,
    0.6, 0.8, 1.0, 0.8, 0.6,
    0.6, 0.6, 0.8, 1.0, 0.8,
    0.8, 0.6, 0.6, 0.8, 1.0
  ),
  nrow = perm_size, byrow = TRUE
) # sigma_matrix is a matrix invariant under permutation (1,2,3,4,5)
number_of_observations &lt;- 13
Z &lt;- MASS::mvrnorm(number_of_observations, mu = mu, Sigma = sigma_matrix)
S &lt;- cov(Z) # Assume we have to estimate the mean

g &lt;- gips(S, number_of_observations)

g_map &lt;- find_MAP(g, show_progress_bar = FALSE, optimizer = "brute_force")
g_map

summary(g_map)

if (require("graphics")) {
  plot(g_map, type = "both", logarithmic_x = TRUE)
}
</code></pre>


</div>