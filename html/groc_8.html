<div class="container">

<table style="width: 100%;"><tr>
<td>groc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>groc method</h2>

<h3>Description</h3>

<p>Generalized regression on orthogonal components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
groc(formula, ncomp, data, subset, na.action, plsrob =
                 FALSE, method = c("lm", "lo", "s", "lts"), D = NULL,
                 gamma = 0.75, Nc = 10, Ng = 20, scale = FALSE, Cpp =
                 TRUE, model = TRUE, x = FALSE, y = FALSE, sp = NULL, ...)
groc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a model formula.  Most of the <code>lm</code> formula
constructs are supported.  See below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>the number of components (orthogonal components) to include in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame with the data to fit the model from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plsrob</code></td>
<td>
<p>logical. If <code>TRUE</code>, we use the <code>D=covrob</code> measure of
dependence with the least trimmed squares method="lts".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character giving the name of the method to use. The
user can supply his own function. The methods available are linear
models, "lm", local polynomials, "lo", smoothing splines, "s", and least trimmed squares, "lts".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>function with two arguments, each one being a vector, which
measures the dependence between two variables using n observations from them. If <code>NULL</code>, the covariance measure will be used. The user can supply his own function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>parameter used with the option <code>plsrob=TRUE</code>. It defines the quantile used to compute the "lts" regression. The default <code>gamma=0.75</code> gives a breakdown of 25% for a good compromise between robustness and efficiency. The value <code>gamma=0.5</code> gives the maximal breakdown of 50%.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nc</code></td>
<td>
<p>Integer, Number of cycles in the grid algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ng</code></td>
<td>
<p>Integer, Number of points for the grid in the grid algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Logical, Should we scale the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cpp</code></td>
<td>
<p>Logical, if <code>TRUE</code> this function will use a C++
implementation of the grid algorithm. The <code>FALSE</code> value should not be
used, unless to get a better understanding of the grid algorithm
or to compare the speed of computation between R and C++ versions of
this algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the model frame is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the model matrix is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the response is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>

<p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the
smooth terms appear in the model formula. Negative elements
indicate that the parameter should be estimated, and hence a
mixture of fixed and estimated parameters is
possible. 'length(sp)' should be equal to 'ncomp' and
corresponds 
to the number of underlying smoothing parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>vector or matrix of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>an array of fitted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>residuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p>a matrix of orthogonal components (scores). Each column corresponds to a component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>a matrix of directions (loadings). Each column is a direction used to obtain the corresponding component (scores).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gobjects</code></td>
<td>
<p>contain the objects produced by the fit of the responses on the orthogonal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hobjects</code></td>
<td>
<p>contain the objects produced by the "lts" fit of each deflated predictors on the orthogonal components. <code>Hobjects</code> are produced when <code>plsrob=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>matrix of coefficients produced by the "lm" fit of  each deflated predictors on the last component. <code>B</code> is produced when <code>plsrob=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xmeans</code></td>
<td>
<p>a vector of means of the X variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ymeans</code></td>
<td>
<p>a vector of means of the Y variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>Dependence measure used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>a matrix whose columns contain the right singular vectors of
the data. Computed in the preprocessing to principal component scores when the number of
observations is less than the number of predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dnnames</code></td>
<td>
<p>dimnames of 'fitted.values'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>the number of components used in the modelling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Logical. <code>TRUE</code> if the responses have been scaled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the model terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plsrob</code></td>
<td>
<p>Logical. If <code>plsrob=TRUE</code>, a robust partial least squares fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>if <code>model=TRUE</code>, the model frame.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>) and
Smail Mahdi (<a href="mailto:smail.mahdi@cavehill.uwi.edu">smail.mahdi@cavehill.uwi.edu</a>)
</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br><a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
library(MASS)
########################
# Codes for Example 1  #
########################
require("groc")
data("wood")
out &lt;- groc(y ~ x1 + x2 + x3 + x4 + x5, ncomp = 1, data = wood, 
             D = corrob, method = "lts")
corrob(wood$y, fitted(out)) ^ 2
plot(out)

########################
# Codes for Example 2  #
########################
data("trees")
out &lt;- groc(Volume ~ Height + Girth, ncomp = 1, D = spearman, 
             method = "s", data = trees)
cor(trees$Volume, fitted(out)) ^ 2
plot(out$T, trees$Volume, xlab = "First component",
     ylab = "Volume", pch = 20)
lines(sort(out$T), fitted(out)[order(out$T)])
out &lt;- boxcox(Volume ~ Height + Girth, data = trees, 
              lambda = seq(-0.5, 0.5, length = 100), plotit = FALSE)
lambda &lt;- out$x[which.max(out$y)]
out &lt;- lm(Volume ^ lambda ~ Height + Girth, data = trees)
cor(trees$Volume, fitted(out)^(1/lambda)) ^ 2

########################
# Codes for Example 3  #
########################
data("wood")
plsr.out &lt;- plsr(y ~ x1 + x2 + x3 + x4 + x5, data = wood)
groc.out &lt;- groc(y ~ x1 + x2 + x3 + x4 + x5, data = wood)
apply(abs((fitted(plsr.out) - fitted(groc.out)) / 
          fitted(plsr.out)), 3, max) * 100

########################
# Codes for Example 4  #
########################
set.seed(1)
n &lt;- 200
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
y &lt;- x1 * x2 + rnorm(n, 0, sqrt(.04))
data &lt;- data.frame(x1 = x1, x2 = x2, y = y)
plsr.out &lt;- plsr(y ~ x1 + x2, data = data)
groc.out &lt;- groc(y ~ x1 + x2, D = dcov, method = "s", data = data)
plsr.v &lt;- crossval(plsr.out, segment.type = "consecutive")
groc.v &lt;- grocCrossval(groc.out, segment.type = "consecutive")
groc.v$validation$PRESS
plsr.v$validation$PRESS
gam.data &lt;- data.frame(y = y, t1 = groc.out$T[, 1], t2 = groc.out$T[, 2])
gam.out &lt;- gam(y ~ s(t1) + s(t2), data = gam.data)
par(mfrow = c(1, 2))
plot(gam.out)
par(mfrow = c(1, 1))
PRESS &lt;- 0
for(i in 1 : 10){
  data.in &lt;- data[-(((i - 1) * 20 + 1) : (i * 20)), ]
  data.out &lt;- data[((i - 1) * 20 + 1) : (i * 20), ]
  ppr.out &lt;- ppr(y ~ x1 + x2, nterms = 2, optlevel = 3, data = data.in)
  PRESS &lt;- PRESS + sum((predict(ppr.out, newdata = data.out)-data.out$y) ^ 2)
}
PRESS

########################
# Codes for Example 5  #
########################
data("yarn")
dim(yarn$NIR)
n &lt;- nrow(yarn)
system.time(plsr.out &lt;- plsr(density ~ NIR, ncomp = n - 2, data = yarn))
system.time(groc.out &lt;- groc(density ~ NIR, Nc = 20, ncomp = n - 2, data = yarn))
max(abs((fitted(plsr.out) - fitted(groc.out)) / fitted(plsr.out))) * 100
plsr.v &lt;- crossval(plsr.out, segments = n, trace = FALSE)
plsr.v$validation$PRESS
groc.v &lt;- grocCrossval(groc.out, segments = n, trace = FALSE)
groc.v$validation$PRESS
groc.v$validation$PREMAD

########################
# Codes for Example 6  #
########################
data("prim7")
prim7.out &lt;- groc(X1 ~ ., ncomp = 3, D = dcov, method = "s", data = prim7)
prim7.out$R
pca &lt;- princomp(~ ., data = as.data.frame(prim7[, -1]))
prim7.pca &lt;- data.frame(X1 = prim7$X1, scores = pca$scores)
prim7.pca.out &lt;- groc(X1 ~ ., ncomp = 3, D = dcov, method = "s", 
                       data = prim7.pca)
pca$loadings 
groc.v &lt;- grocCrossval(prim7.out, segment.type = "consecutive")
groc.v$validation$PRESS
plsr.out &lt;- plsr(X1 ~ ., ncomp = 3, data = prim7)
plsr.v &lt;- crossval(plsr.out, segment.type = "consecutive")
plsr.v$validation$PRESS
PRESS &lt;- 0
for(i in 1 : 10){
  data.in &lt;- prim7[-(((i - 1) * 50 + 1) : (i * 50)), ]
  data.out &lt;- prim7[((i - 1) * 50 + 1) : (i * 50), ]
  ppr.out &lt;- ppr(X1 ~ ., nterms = 3, optlevel = 3, data = data.in)
  PRESS &lt;- PRESS + sum((predict(ppr.out, newdata = data.out) - data.out$X1) ^ 2)
}
PRESS

########################
# Codes for Example 7  #
########################
n &lt;- 50 ; B &lt;- 30
mat.cor &lt;- matrix(0, nrow = B, ncol = 3) ; mat.time &lt;- matrix(0, nrow = B, ncol = 3)
for (i in 1:B) {
 X &lt;- matrix(runif(n * 5, -1, 1), ncol = 5)
 A &lt;- matrix(runif(n * 50, -1, 1), nrow = 5)
 y &lt;- (X[,1] + X[,2])^2 + (X[,1] + 5 * X[,2])^2 + rnorm(n)
 X &lt;- cbind(X, X 
 D &lt;- data.frame(X = X, y = y)
 mat.time[i,1] &lt;- system.time(out1 &lt;- plsr(y ~ X, , ncomp = 2, data = D))[1]
 mat.time[i,2] &lt;- system.time(out2 &lt;- ppr(y ~ X, , nterms = 2, data = D))[1]
 mat.time[i,3] &lt;- system.time(out3 &lt;- groc(y ~ X, D = dcov, method = "s", ncomp = 2, data = D))[1]
 mat.cor[i,] &lt;- cor(y, cbind(fitted(out1)[,,2], fitted(out2), fitted(out3)[,,2]))
}
colMeans(mat.cor)
colMeans(mat.time)

########################
# Codes for Example 8  #
########################
data("oliveoil")
n &lt;- nrow(oliveoil)
plsr.out &lt;- plsr(sensory ~ chemical, data = oliveoil, method = "simpls")
groc.out &lt;- groc(sensory ~ chemical, data = oliveoil)
max(abs((fitted(plsr.out) - fitted(groc.out)) / fitted(plsr.out))) * 100
groc.v &lt;- grocCrossval(groc.out, segments = n)
groc.v$validation$PRESS
colMeans(groc.v$validation$PRESS)
Y &lt;- oliveoil$sensory
for (j in 1 : ncol(Y)) print(cor(Y[, j], fitted(groc.out)[, j, 2]))

########################
# Codes for Example 9  #
########################
require("ppls")
data("cookie")
X &lt;- as.matrix(log(cookie[1 : 40, 51 : 651]))
Y &lt;- as.matrix(cookie[1 : 40, 701 : 704])
X &lt;- X[, 2 : 601] - X[, 1 : 600]
data &lt;- data.frame(Y = I(Y), X = I(X))
n &lt;- nrow(data)
q &lt;- ncol(Y)
xl &lt;- "Wavelength index"
yl &lt;- "First differences of log(1/reflectance)"
matplot(1:ncol(X), t(X), lty = 1, xlab = xl, ylab = yl, type = "l")
out1 &lt;- plsr(Y ~ X, ncomp = n - 2, data = data)
cv &lt;- crossval(out1, segments = n)
cv.mean &lt;- colMeans(cv$validation$PRESS)
plot(cv.mean, xlab = "h", ylab = "Average PRESS", pch = 20)
h &lt;- 3
for (j in 1 : q) print(cor(Y[, j], fitted(out1)[, j, h]))
set.seed(1)
out2 &lt;- groc(Y ~ X, ncomp = h, data = data, plsrob = TRUE)
for (j in 1 : q) print(corrob(Y[, j], fitted(out2)[, j, h]))
plot(out2)

########################
# Codes for Example 10 #
########################
set.seed(2)
n &lt;- 30
t1 &lt;- sort(runif(n, -1, 1))
y &lt;- t1 + rnorm(n, mean = 0, sd = .05)
y[c(14, 15, 16)] &lt;- y[c(14, 15, 16)] + .5
data &lt;- data.frame(x1 = t1, x2 = 2 * t1, x3 = -1.5 * t1, y = y)
out &lt;- groc(y ~ x1 + x2 + x3, ncomp = 1, data = data, plsrob = TRUE)
tau &lt;- scaleTau2(residuals(out), mu.too = TRUE)
std.res &lt;- scale(residuals(out), center = tau[1], scale = tau[2])
index &lt;- which(abs(std.res)&gt;3)
prm.res &lt;- read.table("prmresid.txt")
plot(t1, y, pch = 20)
matlines(t1, cbind(t1,fitted(out), y - prm.res), lty = 1 : 3)
legend(.4, -.5 , legend = c("true model","groc", "prm"), lty = 1 : 3)
text(t1[index], y[index], index, cex = .8, pos = 3)

########################
# Codes for Example 11 #
########################
data("pulpfiber")
X &lt;- as.matrix(pulpfiber[, 1:4])
Y &lt;- as.matrix(pulpfiber[, 5:8])
data &lt;- data.frame(X = I(X), Y = I(Y))
set.seed(55481)
out.rob &lt;- groc(Y ~ X, data = data, plsrob = TRUE)
plot(out.rob, cex = .6)
out.simpls &lt;- groc(Y ~ X, data = data)
cv.rob &lt;- grocCrossval(out.rob,segment.type = "consecutive")
PREMAD.rob &lt;- cv.rob$validation$PREMAD[,4]
PREMAD.rob
cv.simpls &lt;- grocCrossval(out.simpls,segment.type = "consecutive")
PREMAD.simpls &lt;- cv.simpls$validation$PREMAD[,4]
PREMAD.simpls
(PREMAD.rob - PREMAD.simpls) / PREMAD.simpls * 100

## End(Not run)

</code></pre>


</div>