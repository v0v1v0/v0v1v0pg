<div class="container">

<table style="width: 100%;"><tr>
<td>tab_spanner</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add a spanner label</h2>

<h3>Description</h3>

<p>With <code>tab_spanner()</code>, you can insert a spanner in the column labels part of a
<strong>gt</strong> table. This part of the table contains, at a minimum, column labels
and, optionally, an unlimited number of levels for spanners. A spanner will
occupy space over any number of contiguous column labels and it will have an
associated label and ID value. This function allows for mapping to be defined
by column names, existing spanner ID values, or a mixture of both. The
spanners are placed in the order of calling <code>tab_spanner()</code> so if a later call
uses the same columns in its definition (or even a subset) as the first
invocation, the second spanner will be overlaid atop the first. Options exist
for forcibly inserting a spanner underneath other (with <code>level</code> as space
permits) and with <code>replace</code>, which allows for full or partial spanner
replacement.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tab_spanner(
  data,
  label,
  columns = NULL,
  spanners = NULL,
  level = NULL,
  id = label,
  gather = TRUE,
  replace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><em>The gt table data object</em>
</p>
<p><code style="white-space: pre;">⁠obj:&lt;gt_tbl&gt;⁠</code> // <strong>required</strong>
</p>
<p>This is the <strong>gt</strong> table object that is commonly created through use of the
<code>gt()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p><em>Spanner label text</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <strong>required</strong>
</p>
<p>The text to use for the spanner label. We can optionally use <code>md()</code> or
<code>html()</code> to style the text as Markdown or to retain HTML elements
in the text.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns</code></td>
<td>
<p><em>Columns to target</em>
</p>
<p><code style="white-space: pre;">⁠&lt;column-targeting expression&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The columns to serve as components of the spanner. Can either be a series
of column names provided in <code>c()</code>, a vector of column indices, or a select
helper function (e.g. <code>starts_with()</code>, <code>ends_with()</code>, <code>contains()</code>,
<code>matches()</code>, <code>num_range()</code>, and <code>everything()</code>). This argument works in
tandem with the <code>spanners</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spanners</code></td>
<td>
<p><em>Spanners to target</em>
</p>
<p><code style="white-space: pre;">⁠vector&lt;character&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>The spanners that should be spanned over, should they already be defined.
One or more spanner ID values (in quotes) can be supplied here. This
argument works in tandem with the <code>columns</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p><em>Spanner level for insertion</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;numeric|integer&gt;⁠</code> // <em>default:</em> <code>NULL</code> (<code>optional</code>)
</p>
<p>An explicit level to which the spanner should be placed. If not provided,
<strong>gt</strong> will choose the level based on the inputs provided within <code>columns</code>
and <code>spanners</code>, placing the spanner label where it will fit. The first
spanner level (right above the column labels) is <code>1</code>.
</p>
<p>In combination with <code>opt_interactive()</code> or <code>ihtml.active = TRUE</code> in
<code>tab_options()</code> only level <code>1</code> is supported, additional levels would be
discarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p><em>Spanner ID</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;character&gt;⁠</code> // <em>default:</em> <code>label</code>
</p>
<p>The ID for the spanner. When accessing a spanner through the <code>spanners</code>
argument of <code>tab_spanner()</code> or <code>cells_column_spanners()</code> (when using
<code>tab_style()</code> or <code>tab_footnote()</code>) the <code>id</code> value is used as the reference
(and not the <code>label</code>). If an <code>id</code> is not explicitly provided here, it will
be taken from the <code>label</code> value. It is advisable to set an explicit <code>id</code>
value if you plan to access this cell in a later function call and the
label text is complicated (e.g., contains markup, is lengthy, or both).
Finally, when providing an <code>id</code> value you must ensure that it is unique
across all ID values set for spanner labels (the function will stop if <code>id</code>
isn't unique).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gather</code></td>
<td>
<p><em>Gather columns together</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>TRUE</code>
</p>
<p>An option to move the specified <code>columns</code> such that they are unified under
the spanner. Ordering of the moved-into-place columns will be preserved in
all cases. By default, this is set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p><em>Replace existing spanners</em>
</p>
<p><code style="white-space: pre;">⁠scalar&lt;logical&gt;⁠</code> // <em>default:</em> <code>FALSE</code>
</p>
<p>Should new spanners be allowed to partially or fully replace existing
spanners? (This is a possibility if setting spanners at an already
populated <code>level</code>.) By default, this is set to <code>FALSE</code> and an error will
occur if some replacement is attempted.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>gt_tbl</code>.
</p>


<h3>Targeting columns with the <code>columns</code> argument</h3>

<p>The <code>columns</code> argument allows us to target a subset of columns contained in
the table. We can declare column names in <code>c()</code> (with bare column names or
names in quotes) or we can use <strong>tidyselect</strong>-style expressions. This can be
as basic as supplying a select helper like <code>starts_with()</code>, or, providing a
more complex incantation like
</p>
<p><code>where(~ is.numeric(.x) &amp; max(.x, na.rm = TRUE) &gt; 1E6)</code>
</p>
<p>which targets numeric columns that have a maximum value greater than
1,000,000 (excluding any <code>NA</code>s from consideration).
</p>


<h3>Details on spanner placement</h3>

<p>Let's take a hypothetical table that includes the following column names in
order from left to right: <code>year</code>, <code>len.pop</code>, <code>m.pop</code>, <code>len.dens</code>, and
<code>m.dens</code>. We'd like to have some useful spanners, but don't want to have any
over the <code>year</code> column (so we'll avoid using that column when defining
spanners). Let's start by creating a schematic representation of what is
wanted in terms of spanners:
</p>
<div class="sourceCode default"><pre>       | ------- `"Two Provinces of Ireland"` ------ &lt;- level 2 spanner
       | ---- `"Leinster"` ---- | --- `"Munster"` -- &lt;- level 1 spanners
`year` | `len.pop` | `len.dens` | `m.pop` | `m.dens` &lt;- column names
----------------------------------------------------
</pre></div>
<p>To make this arrangement happen, we need three separate calls of
<code>tab_spanner()</code>:
</p>

<ul>
<li> <p><code>tab_spanner(., label = "Leinster", columns = starts_with("len"))</code>
</p>
</li>
<li> <p><code>tab_spanner(., label = "Munster", columns = starts_with("m"))</code>
</p>
</li>
<li> <p><code>tab_spanner(., label = "Two Provinces of Ireland", columns = -year)</code>
</p>
</li>
</ul>
<p>This will give us the spanners we need with the appropriate labels. The ID
values will be derived from the labels in this case, but they can directly
supplied via the <code>id</code> argument.
</p>
<p>An important thing to keep aware of is that the order of calls matters. The
first two can be in any order but the third one <em>must</em> happen last since we
build spanners from the bottom up. Also note that the first calls will
rearrange columns! This is by design as the <code>gather = TRUE</code> default will
purposefully gather columns together so that the columns will be united under
a single spanner. More complex definitions of spanners can be performed and
the <em>Examples</em> section demonstrates some of the more advanced calls of
<code>tab_spanner()</code>.
</p>
<p>As a final note, the column labels (by default deriving from the column
names) will likely need to change and that's especially true in the above
case. This can be done with either of <code>cols_label()</code> or <code>cols_label_with()</code>.
</p>


<h3>Incorporating units with <strong>gt</strong>'s units notation</h3>

<p>Measurement units are often seen as part of spanner labels and indeed it can
be much more straightforward to include them here rather than using other
devices to make readers aware of units for specific columns. Any text
pertaining units is to be defined alongside the spanner label. To do this, we
have to surround the portion of text in the label that corresponds to the
units definition with <code>"{{"</code>/<code>"}}"</code>.
</p>
<p>Now that we know how to mark text for units definition, we know need to know
how to write proper units with the notation. Such notation uses a succinct
method of writing units and it should feel somewhat familiar though it is
particular to the task at hand. Each unit is treated as a separate entity
(parentheses and other symbols included) and the addition of subscript text
and exponents is flexible and relatively easy to formulate. This is all best
shown with a few examples:
</p>

<ul>
<li> <p><code>"m/s"</code> and <code>"m / s"</code> both render as <code>"m/s"</code>
</p>
</li>
<li> <p><code>"m s^-1"</code> will appear with the <code>"-1"</code> exponent intact
</p>
</li>
<li> <p><code>"m /s"</code> gives the the same result, as <code>"/&lt;unit&gt;"</code> is equivalent to
<code>"&lt;unit&gt;^-1"</code>
</p>
</li>
<li> <p><code>"E_h"</code> will render an <code>"E"</code> with the <code>"h"</code> subscript
</p>
</li>
<li> <p><code>"t_i^2.5"</code> provides a <code>t</code> with an <code>"i"</code> subscript and a <code>"2.5"</code> exponent
</p>
</li>
<li> <p><code>"m[_0^2]"</code> will use overstriking to set both scripts vertically
</p>
</li>
<li> <p><code>"g/L %C6H12O6%"</code> uses a chemical formula (enclosed in a pair of <code>"%"</code>
characters) as a unit partial, and the formula will render correctly with
subscripted numbers
</p>
</li>
<li>
<p> Common units that are difficult to write using ASCII text may be implicitly
converted to the correct characters (e.g., the <code>"u"</code> in <code>"ug"</code>, <code>"um"</code>,
<code>"uL"</code>, and <code>"umol"</code> will be converted to the Greek <em>mu</em> symbol; <code>"degC"</code>
and <code>"degF"</code> will render a degree sign before the temperature unit)
</p>
</li>
<li>
<p> We can transform shorthand symbol/unit names enclosed in <code>":"</code> (e.g.,
<code>":angstrom:"</code>, <code>":ohm:"</code>, etc.) into proper symbols
</p>
</li>
<li>
<p> Greek letters can added by enclosing the letter name in <code>":"</code>; you can
use lowercase letters (e.g., <code>":beta:"</code>, <code>":sigma:"</code>, etc.) and uppercase
letters too (e.g., <code>":Alpha:"</code>, <code>":Zeta:"</code>, etc.)
</p>
</li>
<li>
<p> The components of a unit (unit name, subscript, and exponent) can be
fully or partially italicized/emboldened by surrounding text with <code>"*"</code> or
<code>"**"</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<p>Let's create a <strong>gt</strong> table using a small portion of the <code>gtcars</code> dataset.
Over several columns (<code>hp</code>, <code>hp_rpm</code>, <code>trq</code>, <code>trq_rpm</code>, <code>mpg_c</code>, <code>mpg_h</code>)
we'll use <code>tab_spanner()</code> to add a spanner with the label <code>"performance"</code>.
This effectively groups together several columns related to car performance
under a unifying label.
</p>
<div class="sourceCode r"><pre>gtcars |&gt;
  dplyr::select(
    -mfr, -trim, bdy_style,
    -drivetrain, -trsmn, -ctry_origin
  ) |&gt;
  dplyr::slice(1:8) |&gt;
  gt(rowname_col = "model") |&gt;
  tab_spanner(
    label = "performance",
    columns = c(
      hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h
    )
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_1.png" alt="This image of a table was generated from the first code example in the `tab_spanner()` help file." style="width:100%;"><p>With the default <code>gather = TRUE</code> option, columns selected for a particular
spanner will be moved so that there is no separation between them. This can
be seen with the example below that uses a subset of the <code>towny</code> dataset.
The starting column order is <code>name</code>, <code>latitude</code>, <code>longitude</code>,
<code>population_2016</code>, <code>density_2016</code>, <code>population_2021</code>, and <code>density_2021</code>. The
first two uses of <code>tab_spanner()</code> deal with making separate spanners for the
two population and two density columns. After their use, the columns are
moved to this new ordering: <code>name</code>, <code>latitude</code>, <code>longitude</code>,
<code>population_2016</code>, <code>population_2021</code>, <code>density_2016</code>, and <code>density_2021</code>. The
third and final call of <code>tab_spanner()</code> doesn't further affect the ordering
of columns.
</p>
<div class="sourceCode r"><pre>towny |&gt;
  dplyr::slice_max(population_2021, n = 5) |&gt;
  dplyr::select(
    name, latitude, longitude,
    ends_with("2016"), ends_with("2021")
  ) |&gt;
  gt() |&gt;
  tab_spanner(
    label = "Population",
    columns = starts_with("pop")
  ) |&gt;
  tab_spanner(
    label = "Density",
    columns = starts_with("den")
  ) |&gt;
  tab_spanner(
    label = md("*Location*"),
    columns = ends_with("itude"),
    id = "loc"
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_2.png" alt="This image of a table was generated from the second code example in the `tab_spanner()` help file." style="width:100%;"><p>While columns are moved, it is only the minimal amount of moving required
(pulling in columns from the right) to ensure that columns are gathered under
the appropriate spanners. With the last call, there are two more things to
note: (1) <code>label</code> values can use the <code>md()</code> (or <code>html()</code>) helper functions to
help create styled text, and (2) an <code>id</code> value may be supplied for reference
later (e.g., for styling with <code>tab_style()</code> or applying footnotes with
<code>tab_footnote()</code>).
</p>
<p>It's possible to stack multiple spanners atop each other with consecutive
calls of <code>tab_spanner()</code>. It's a bit like playing Tetris: putting a spanner
down anywhere there is another spanner (i.e., there are one or more shared
columns) means that second spanner will reside a level above the prior. Let's
look at a few examples to see how this works, and we'll also explore a few
lesser-known placement tricks. We'll use a cut down version of <code>exibble</code>
for this, set up a few level-<code>1</code> spanners, and then place a level-<code>2</code> spanner
over two other spanners.
</p>
<div class="sourceCode r"><pre>exibble_narrow &lt;- exibble |&gt; dplyr::slice_head(n = 3)

exibble_narrow |&gt;
  gt() |&gt;
  tab_spanner(
    label = "Row Information",
    columns = c(row, group)
  ) |&gt;
  tab_spanner(
    label = "Numeric Values",
    columns = where(is.numeric),
    id = "num_spanner"
  ) |&gt;
  tab_spanner(
    label = "Text Values",
    columns = c(char, fctr),
    id = "text_spanner"
  ) |&gt;
  tab_spanner(
    label = "Numbers and Text",
    spanners = c("num_spanner", "text_spanner")
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_3.png" alt="This image of a table was generated from the third code example in the `tab_spanner()` help file." style="width:100%;"><p>In the above example, we used the <code>spanners</code> argument to define where the
<code>"Numbers and Text"</code>-labeled spanner should reside. For that, we supplied the
<code>"num_spanner"</code> and <code>"text_spanner"</code> ID values for the two spanners
associated with the <code>num</code>, <code>currency</code>, <code>char</code>, and <code>fctr</code> columns.
Alternatively, we could have given those column names to the <code>columns</code>
argument and achieved the same result. You could actually use a combination
of <code>spanners</code> and <code>columns</code> to define where the spanner should be placed.
Here is an example of just that:
</p>
<div class="sourceCode r"><pre>exibble_narrow_gt &lt;-
  exibble_narrow |&gt;
  gt() |&gt;
  tab_spanner(
    label = "Numeric Values",
    columns = where(is.numeric),
    id = "num_spanner"
  ) |&gt;
  tab_spanner(
    label = "Text Values",
    columns = c(char, fctr),
    id = "text_spanner"
  ) |&gt;
  tab_spanner(
    label = "Text, Dates, Times, Datetimes",
    columns = contains(c("date", "time")),
    spanners = "text_spanner"
  )

exibble_narrow_gt
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_4.png" alt="This image of a table was generated from the fourth code example in the `tab_spanner()` help file." style="width:100%;"><p>And, again, we could have solely supplied all of the column names to
<code>columns</code> instead of using this hybrid approach, but it is interesting to
express the definition of spanners with this flexible combination.
</p>
<p>What if you wanted to extend the above example and place a spanner above the
<code>date</code>, <code>time</code>, and <code>datetime</code> columns? If you tried that in the manner as
exemplified above, the spanner will be placed in the third level of spanners:
</p>
<div class="sourceCode r"><pre>exibble_narrow_gt |&gt;
  tab_spanner(
    label = "Date and Time Columns",
    columns = contains(c("date", "time")),
    id = "date_time_spanner"
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_5.png" alt="This image of a table was generated from the fifth code example in the `tab_spanner()` help file." style="width:100%;"><p>Remember that the approach taken by <code>tab_spanner()</code> is to keep stacking atop
existing spanners. But, there is space next to the <code>"Text Values"</code> spanner on
the first level. You can either revise the order of <code>tab_spanner()</code> calls,
or, use the <code>level</code> argument to force the spanner into that level (so long
as there is space).
</p>
<div class="sourceCode r"><pre>exibble_narrow_gt |&gt;
  tab_spanner(
    label = "Date and Time Columns",
    columns = contains(c("date", "time")),
    level = 1,
    id = "date_time_spanner"
  )
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_6.png" alt="This image of a table was generated from the sixth code example in the `tab_spanner()` help file." style="width:100%;"><p>That puts the spanner in the intended level. If there aren't free locations
available in the <code>level</code> specified you'll get an error stating which columns
cannot be used for the new spanner (this can be circumvented, if necessary,
with the <code>replace = TRUE</code> option). If you choose a level higher than the
maximum occupied, then the spanner will be dropped down. Again, these
behaviors are indicative of Tetris-like rules which tend to work well for the
application of spanners.
</p>
<p>Using a subset of the <code>towny</code> dataset, we can create an interesting <strong>gt</strong>
table. First, only certain columns are selected from the dataset, some
filtering of rows is done, rows are sorted, and then only the first 10 rows
are kept. After the data is introduced to <code>gt()</code>, we then apply some spanner
labels using two calls of <code>tab_spanner()</code>. In the second of those, we
incorporate unit notation text (within <code>"{{"</code>/<code>"}}"</code>) in the <code>label</code> to get a
display of nicely-formatted units.
</p>
<div class="sourceCode r"><pre>towny |&gt;
  dplyr::select(
    name, ends_with(c("2001", "2006")), matches("2001_2006")
  ) |&gt;
  dplyr::filter(population_2001 &gt; 100000) |&gt;
  dplyr::slice_max(pop_change_2001_2006_pct, n = 10) |&gt;
  gt() |&gt;
  fmt_integer() |&gt;
  fmt_percent(columns = matches("change"), decimals = 1) |&gt;
  tab_spanner(
    label = "Population",
    columns = starts_with("population")
  ) |&gt;
  tab_spanner(
    label = "Density, {{*persons* km^-2}}",
    columns = starts_with("density")
  ) |&gt;
  cols_label(
    ends_with("01") ~ "2001",
    ends_with("06") ~ "2006",
    matches("change") ~ md("Population Change,&lt;br&gt;2001 to 2006")
  ) |&gt;
  cols_width(everything() ~ px(120))
</pre></div>

<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_tab_spanner_7.png" alt="This image of a table was generated from the seventh code example in the `tab_spanner()` help file." style="width:100%;"><h3>Function ID</h3>

<p>2-2
</p>


<h3>Function Introduced</h3>

<p><code>v0.2.0.5</code> (March 31, 2020)
</p>


<h3>See Also</h3>

<p><code>tab_spanner_delim()</code> to create spanners and new column labels with
delimited column names.
</p>
<p>Other part creation/modification functions: 
<code>tab_caption()</code>,
<code>tab_footnote()</code>,
<code>tab_header()</code>,
<code>tab_info()</code>,
<code>tab_options()</code>,
<code>tab_row_group()</code>,
<code>tab_source_note()</code>,
<code>tab_spanner_delim()</code>,
<code>tab_stub_indent()</code>,
<code>tab_stubhead()</code>,
<code>tab_style()</code>,
<code>tab_style_body()</code>
</p>


</div>