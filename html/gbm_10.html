<div class="container">

<table style="width: 100%;"><tr>
<td>gbm.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Boosted Regression Modeling (GBM)</h2>

<h3>Description</h3>

<p>Workhorse function providing the link between R and the C++ gbm engine.
<code>gbm</code> is a front-end to <code>gbm.fit</code> that uses the familiar R
modeling formulas. However, <code>model.frame</code> is very slow if
there are many predictor variables. For power-users with many variables use
<code>gbm.fit</code>. For general practice <code>gbm</code> is preferable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gbm.fit(
  x,
  y,
  offset = NULL,
  misc = NULL,
  distribution = "bernoulli",
  w = NULL,
  var.monotone = NULL,
  n.trees = 100,
  interaction.depth = 1,
  n.minobsinnode = 10,
  shrinkage = 0.001,
  bag.fraction = 0.5,
  nTrain = NULL,
  train.fraction = NULL,
  keep.data = TRUE,
  verbose = TRUE,
  var.names = NULL,
  response.name = "y",
  group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data frame or matrix containing the predictor variables. The 
number of rows in <code>x</code> must be the same as the length of <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector of outcomes. The number of rows in <code>x</code> must be the 
same as the length of <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A vector of offset values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>misc</code></td>
<td>
<p>An R object that is simply passed on to the gbm engine. It can be 
used for additional data for the specific distribution. Currently it is only 
used for passing the censoring indicator for the Cox proportional hazards 
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>Either a character string specifying the name of the
distribution to use or a list with a component <code>name</code> specifying the
distribution and any additional parameters needed. If not specified,
<code>gbm</code> will try to guess: if the response has only 2 unique values,
bernoulli is assumed; otherwise, if the response is a factor, multinomial is
assumed; otherwise, if the response has class <code>"Surv"</code>, coxph is 
assumed; otherwise, gaussian is assumed.
</p>
<p>Currently available options are <code>"gaussian"</code> (squared error), 
<code>"laplace"</code> (absolute loss), <code>"tdist"</code> (t-distribution loss), 
<code>"bernoulli"</code> (logistic regression for 0-1 outcomes), 
<code>"huberized"</code> (huberized hinge loss for 0-1 outcomes), 
<code>"adaboost"</code> (the AdaBoost exponential loss for 0-1 outcomes),
<code>"poisson"</code> (count outcomes), <code>"coxph"</code> (right censored 
observations), <code>"quantile"</code>, or <code>"pairwise"</code> (ranking measure 
using the LambdaMart algorithm).
</p>
<p>If quantile regression is specified, <code>distribution</code> must be a list of
the form <code>list(name = "quantile", alpha = 0.25)</code> where <code>alpha</code> is 
the quantile to estimate. The current version's quantile regression method 
does not handle non-constant weights and will stop.
</p>
<p>If <code>"tdist"</code> is specified, the default degrees of freedom is 4 and 
this can be controlled by specifying 
<code>distribution = list(name = "tdist", df = DF)</code> where <code>DF</code> is your 
chosen degrees of freedom.
</p>
<p>If "pairwise" regression is specified, <code>distribution</code> must be a list of
the form <code>list(name="pairwise",group=...,metric=...,max.rank=...)</code>
(<code>metric</code> and <code>max.rank</code> are optional, see below). <code>group</code> is
a character vector with the column names of <code>data</code> that jointly
indicate the group an instance belongs to (typically a query in Information
Retrieval applications). For training, only pairs of instances from the same
group and with different target labels can be considered. <code>metric</code> is
the IR measure to use, one of 
</p>
 
<dl>
<dt>list("conc")</dt>
<dd>
<p>Fraction of concordant pairs; for binary labels, this 
is equivalent to the Area under the ROC Curve</p>
</dd>
<dt>:</dt>
<dd>
<p>Fraction of concordant pairs; for binary labels, this is 
equivalent to the Area under the ROC Curve</p>
</dd> 
<dt>list("mrr")</dt>
<dd>
<p>Mean reciprocal rank of the highest-ranked positive 
instance</p>
</dd>
<dt>:</dt>
<dd>
<p>Mean reciprocal rank of the highest-ranked positive instance</p>
</dd>
<dt>list("map")</dt>
<dd>
<p>Mean average precision, a generalization of <code>mrr</code> 
to multiple positive instances</p>
</dd>
<dt>:</dt>
<dd>
<p>Mean average precision, a
generalization of <code>mrr</code> to multiple positive instances</p>
</dd>
<dt>list("ndcg:")</dt>
<dd>
<p>Normalized discounted cumulative gain. The score is 
the weighted sum (DCG) of the user-supplied target values, weighted 
by log(rank+1), and normalized to the maximum achievable value. This 
is the default if the user did not specify a metric.</p>
</dd> 
</dl>
<p><code>ndcg</code> and <code>conc</code> allow arbitrary target values, while binary
targets {0,1} are expected for <code>map</code> and <code>mrr</code>. For <code>ndcg</code>
and <code>mrr</code>, a cut-off can be chosen using a positive integer parameter
<code>max.rank</code>. If left unspecified, all ranks are taken into account.
</p>
<p>Note that splitting of instances into training and validation sets follows
group boundaries and therefore only approximates the specified
<code>train.fraction</code> ratio (the same applies to cross-validation folds).
Internally, queries are randomly shuffled before training, to avoid bias.
</p>
<p>Weights can be used in conjunction with pairwise metrics, however it is
assumed that they are constant for instances from the same group.
</p>
<p>For details and background on the algorithm, see e.g. Burges (2010).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A vector of weights of the same length as the <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.monotone</code></td>
<td>
<p>an optional vector, the same length as the number of
predictors, indicating which variables have a monotone increasing (+1),
decreasing (-1), or arbitrary (0) relationship with the outcome.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trees</code></td>
<td>
<p>the total number of trees to fit. This is equivalent to the
number of iterations and the number of basis functions in the additive
expansion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.depth</code></td>
<td>
<p>The maximum depth of variable interactions. A value
of 1 implies an additive model, a value of 2 implies a model with up to 2-way 
interactions, etc. Default is <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.minobsinnode</code></td>
<td>
<p>Integer specifying the minimum number of observations 
in the trees terminal nodes. Note that this is the actual number of 
observations not the total weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrinkage</code></td>
<td>
<p>The shrinkage parameter applied to each tree in the
expansion. Also known as the learning rate or step-size reduction; 0.001 to 
0.1 usually work, but a smaller learning rate typically requires more trees.
Default is <code>0.1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bag.fraction</code></td>
<td>
<p>The fraction of the training set observations randomly
selected to propose the next tree in the expansion. This introduces
randomnesses into the model fit. If <code>bag.fraction</code> &lt; 1 then running the
same model twice will result in similar but different fits. <code>gbm</code> uses
the R random number generator so <code>set.seed</code> can ensure that the model
can be reconstructed. Preferably, the user can save the returned
<code>gbm.object</code> using <code>save</code>. Default is <code>0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nTrain</code></td>
<td>
<p>An integer representing the number of cases on which to train.
This is the preferred way of specification for <code>gbm.fit</code>; The option
<code>train.fraction</code> in <code>gbm.fit</code> is deprecated and only maintained
for backward compatibility. These two parameters are mutually exclusive. If
both are unspecified, all data is used for training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train.fraction</code></td>
<td>
<p>The first <code>train.fraction * nrows(data)</code>
observations are used to fit the <code>gbm</code> and the remainder are used for
computing out-of-sample estimates of the loss function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>Logical indicating whether or not to keep the data and an 
index of the data stored with the object. Keeping the data and index makes 
subsequent calls to <code>gbm.more</code> faster at the cost of storing an 
extra copy of the dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical indicating whether or not to print out progress and 
performance indicators (<code>TRUE</code>). If this option is left unspecified for 
<code>gbm.more</code>, then it uses <code>verbose</code> from <code>object</code>. Default is
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.names</code></td>
<td>
<p>Vector of strings of length equal to the number of columns 
of <code>x</code> containing the names of the predictor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response.name</code></td>
<td>
<p>Character string label for the response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The <code>group</code> to use when <code>distribution = "pairwise"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This package implements the generalized boosted modeling framework. Boosting
is the process of iteratively adding basis functions in a greedy fashion so
that each additional basis function further reduces the selected loss
function. This implementation closely follows Friedman's Gradient Boosting
Machine (Friedman, 2001).
</p>
<p>In addition to many of the features documented in the Gradient Boosting
Machine, <code>gbm</code> offers additional features including the out-of-bag
estimator for the optimal number of iterations, the ability to store and
manipulate the resulting <code>gbm</code> object, and a variety of other loss
functions that had not previously had associated boosting algorithms,
including the Cox partial likelihood for censored data, the poisson
likelihood for count outcomes, and a gradient boosting implementation to
minimize the AdaBoost exponential loss function.
</p>


<h3>Value</h3>

<p>A <code>gbm.object</code> object.
</p>


<h3>Author(s)</h3>

<p>Greg Ridgeway <a href="mailto:gregridgeway@gmail.com">gregridgeway@gmail.com</a>
</p>
<p>Quantile regression code developed by Brian Kriegler
<a href="mailto:bk@stat.ucla.edu">bk@stat.ucla.edu</a>
</p>
<p>t-distribution, and multinomial code developed by Harry Southworth and
Daniel Edwards
</p>
<p>Pairwise code developed by Stefan Schroedl <a href="mailto:schroedl@a9.com">schroedl@a9.com</a>
</p>


<h3>References</h3>

<p>Y. Freund and R.E. Schapire (1997) “A decision-theoretic
generalization of on-line learning and an application to boosting,”
<em>Journal of Computer and System Sciences,</em> 55(1):119-139.
</p>
<p>G. Ridgeway (1999). “The state of boosting,” <em>Computing Science
and Statistics</em> 31:172-181.
</p>
<p>J.H. Friedman, T. Hastie, R. Tibshirani (2000). “Additive Logistic
Regression: a Statistical View of Boosting,” <em>Annals of Statistics</em>
28(2):337-374.
</p>
<p>J.H. Friedman (2001). “Greedy Function Approximation: A Gradient
Boosting Machine,” <em>Annals of Statistics</em> 29(5):1189-1232.
</p>
<p>J.H. Friedman (2002). “Stochastic Gradient Boosting,”
<em>Computational Statistics and Data Analysis</em> 38(4):367-378.
</p>
<p>B. Kriegler (2007). Cost-Sensitive Stochastic Gradient Boosting Within a 
Quantitative Regression Framework. Ph.D. Dissertation. University of 
California at Los Angeles, Los Angeles, CA, USA. Advisor(s) Richard A. Berk. 
<a href="https://dl.acm.org/doi/book/10.5555/1354603">https://dl.acm.org/doi/book/10.5555/1354603</a>.
</p>
<p>C. Burges (2010). “From RankNet to LambdaRank to LambdaMART: An
Overview,” Microsoft Research Technical Report MSR-TR-2010-82.
</p>


<h3>See Also</h3>

<p><code>gbm.object</code>, <code>gbm.perf</code>, 
<code>plot.gbm</code>, <code>predict.gbm</code>, <code>summary.gbm</code>, 
and <code>pretty.gbm.tree</code>.
</p>


</div>