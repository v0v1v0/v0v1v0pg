<div class="container">

<table style="width: 100%;"><tr>
<td>ogr_manage</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Utility functions for managing vector data sources</h2>

<h3>Description</h3>

<p>This set of functions can be used to create new vector datasets,
test existence of dataset/layer/field, test dataset and layer capabilities,
create new layers in an existing dataset, delete layers, create new
attribute and geometry fields on an existing layer, rename and delete
fields, and edit data with SQL statements.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ogr_ds_exists(dsn, with_update = FALSE)

ogr_ds_format(dsn)

ogr_ds_test_cap(dsn, with_update = TRUE)

ogr_ds_create(
  format,
  dsn,
  layer = NULL,
  layer_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  fld_name = NULL,
  fld_type = NULL,
  dsco = NULL,
  lco = NULL,
  overwrite = FALSE
)

ogr_ds_layer_count(dsn)

ogr_ds_layer_names(dsn)

ogr_layer_exists(dsn, layer)

ogr_layer_test_cap(dsn, layer, with_update = TRUE)

ogr_layer_create(
  dsn,
  layer,
  layer_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  lco = NULL
)

ogr_layer_field_names(dsn, layer)

ogr_layer_delete(dsn, layer)

ogr_field_index(dsn, layer, fld_name)

ogr_field_create(
  dsn,
  layer,
  fld_name,
  fld_defn = NULL,
  fld_type = "OFTInteger",
  fld_subtype = "OFSTNone",
  fld_width = 0L,
  fld_precision = 0L,
  is_nullable = TRUE,
  is_ignored = FALSE,
  is_unique = FALSE,
  default_value = ""
)

ogr_geom_field_create(
  dsn,
  layer,
  fld_name,
  geom_fld_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  is_nullable = TRUE,
  is_ignored = FALSE
)

ogr_field_rename(dsn, layer, fld_name, new_name)

ogr_field_delete(dsn, layer, fld_name)

ogr_execute_sql(dsn, sql, spatial_filter = NULL, dialect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dsn</code></td>
<td>
<p>Character string. The vector data source name, e.g., a filename
or database connection string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_update</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to request update access when
opening the dataset, or <code>FALSE</code> to open read-only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>GDAL short name of the vector format as character string.
Examples of some common output formats include: <code>"GPKG"</code>, <code>"FlatGeobuf"</code>,
<code>"ESRI Shapefile"</code>, <code>"SQLite"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layer</code></td>
<td>
<p>Character string for a layer name in a vector dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layer_defn</code></td>
<td>
<p>A feature class definition for <code>layer</code> as a list of
zero or more attribute field definitions, and at least one geometry field
definition (see ogr_define).
Each field definition is a list with named elements containing values for
the field <code style="white-space: pre;">⁠$type⁠</code> and other properties.
If <code>layer_defn</code> is given, it will be used and any additional parameters
passed that relate to the feature class definition will be ignored (i.e.,
<code>geom_type</code> and <code>srs</code>, as well as <code>fld_name</code> and <code>fld_type</code> in
<code>ogr_ds_create()</code>).
The first geometry field definition in <code>layer_defn</code> defines the
geometry type and spatial reference system for the layer (the geom field
definition must contain <code style="white-space: pre;">⁠$type⁠</code>, and should also contain <code style="white-space: pre;">⁠$srs⁠</code> when
creating a layer from a feature class definition).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom_type</code></td>
<td>
<p>Character string specifying a geometry type (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>srs</code></td>
<td>
<p>Character string containing a spatial reference system definition
as OGC WKT or other well-known format (e.g., the input formats usable with
<code>srs_to_wkt()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fld_name</code></td>
<td>
<p>Character string containing the name of an attribute field
in <code>layer</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fld_type</code></td>
<td>
<p>Character string containing the name of a field data type
(e.g., <code>OFTInteger</code>, <code>OFTReal</code>, <code>OFTString</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dsco</code></td>
<td>
<p>Optional character vector of format-specific creation options
for <code>dsn</code> (<code>"NAME=VALUE"</code> pairs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lco</code></td>
<td>
<p>Optional character vector of format-specific creation options
for <code>layer</code> (<code>"NAME=VALUE"</code> pairs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to overwrite <code>dsn</code> if it already
exists when calling <code>ogr_ds_create()</code>. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fld_defn</code></td>
<td>
<p>A field definition as list (see <code>ogr_def_field()</code>).
Additional arguments in <code>ogr_field_create()</code> will be ignored if a <code>fld_defn</code>
is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fld_subtype</code></td>
<td>
<p>Character string containing the name of a field subtype.
One of  <code>OFSTNone</code> (the default), <code>OFSTBoolean</code>, <code>OFSTInt16</code>, <code>OFSTFloat32</code>,
<code>OFSTJSON</code>, <code>OFSTUUID</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fld_width</code></td>
<td>
<p>Optional integer scalar specifying max number of characters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fld_precision</code></td>
<td>
<p>Optional integer scalar specifying number of digits
after the decimal point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_nullable</code></td>
<td>
<p>Optional NOT NULL field constraint (logical scalar).
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_ignored</code></td>
<td>
<p>Whether field is ignored when retrieving features (logical
scalar). Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_unique</code></td>
<td>
<p>Optional UNIQUE constraint on the field (logical scalar).
Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default_value</code></td>
<td>
<p>Optional default value for the field as a character
string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom_fld_defn</code></td>
<td>
<p>A geometry field definition as list
(see <code>ogr_def_geom_field()</code>).
Additional arguments in <code>ogr_geom_field_create()</code> will be ignored if a
<code>geom_fld_defn</code> is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_name</code></td>
<td>
<p>Character string containing a new name to assign.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sql</code></td>
<td>
<p>Character string containing an SQL statement (see Note).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial_filter</code></td>
<td>
<p>Either a numeric vector of length four containing a
bounding box (xmin, ymin, xmax, ymax), or a character string containing a
geometry as OGC WKT, representing a spatial filter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dialect</code></td>
<td>
<p>Character string specifying the SQL dialect to use.
The OGR SQL engine (<code>"OGRSQL"</code>) will be used by default if a value is not
given. The <code>"SQLite"</code> dialect can also be used (see Note).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions are complementary to <code>ogrinfo()</code> and <code>ogr2ogr()</code> for
vector data management. They are also intended to support vector I/O in a
future release of gdalraster. Bindings to OGR wrap portions of the GDAL
Vector API (ogr_core.h and ogr_api.h,
<a href="https://gdal.org/api/vector_c_api.html">https://gdal.org/api/vector_c_api.html</a>).
</p>
<p><code>ogr_ds_exists()</code> tests whether a vector dataset can be opened from the
given data source name (DSN), potentially testing for update access.
Returns a logical scalar.
</p>
<p><code>ogr_ds_format()</code> returns a character string containing the short name of
the format driver for a given DSN, or <code>NULL</code> if the dataset cannot be
opened as a vector source.
</p>
<p><code>ogr_ds_test_cap()</code> tests the capabilities of a vector data source,
attempting to open it with update access by default.
Returns a list of capabilities with values <code>TRUE</code> or <code>FALSE</code>, or <code>NULL</code> is
returned if <code>dsn</code> cannot be opened with the requested access.
Wrapper of <code>GDALDatasetTestCapability()</code> in the GDAL API.
The returned list contains the following named elements:
</p>

<ul>
<li> <p><code>CreateLayer</code>: <code>TRUE</code> if this datasource can create new layers
</p>
</li>
<li> <p><code>DeleteLayer</code>: <code>TRUE</code> if this datasource can delete existing layers
</p>
</li>
<li> <p><code>CreateGeomFieldAfterCreateLayer</code>: <code>TRUE</code> if the layers of this
datasource support geometry field creation just after layer creation
</p>
</li>
<li> <p><code>CurveGeometries</code>: <code>TRUE</code> if this datasource supports curve geometries
</p>
</li>
<li> <p><code>Transactions</code>: <code>TRUE</code> if this datasource supports (efficient)
transactions
</p>
</li>
<li> <p><code>EmulatedTransactions</code>: <code>TRUE</code> if this datasource supports transactions
through emulation
</p>
</li>
<li> <p><code>RandomLayerRead</code>: <code>TRUE</code> if this datasource has a dedicated
<code>GetNextFeature()</code> implementation, potentially returning features from
layers in a non-sequential way
</p>
</li>
<li> <p><code>RandomLayerWrite</code>: <code>TRUE</code> if this datasource supports calling
<code>CreateFeature()</code> on layers in a non-sequential way
</p>
</li>
</ul>
<p><code>ogr_ds_create()</code> creates a new vector datasource, optionally also creating
a layer, and optionally creating one or more fields on the layer.
The attribute fields and geometry field(s) to create can be specified as a
feature class definition (<code>layer_defn</code> as list, see ogr_define), or
alternatively, by giving the <code>geom_type</code> and <code>srs</code>, optionally along with
one <code>fld_name</code> and <code>fld_type</code> to be created in the layer. Returns a logical
scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_ds_layer_count()</code> returns the number of layers in a vector dataset.
</p>
<p><code>ogr_ds_layer_names()</code> returns a character vector of layer names in a
vector dataset, or <code>NULL</code> if no layers are found.
</p>
<p><code>ogr_layer_exists()</code> tests whether a layer can be accessed by name in a
given vector dataset. Returns a logical scalar.
</p>
<p><code>ogr_layer_test_cap()</code> tests whether a layer supports named capabilities,
attempting to open the dataset with update access by default.
Returns a list of capabilities with values <code>TRUE</code> or <code>FALSE</code>. <code>NULL</code> is
returned if <code>dsn</code> cannot be opened with the requested access, or <code>layer</code>
cannot be found. The returned list contains the following named elements:
<code>RandomRead</code>, <code>SequentialWrite</code>, <code>RandomWrite</code>, <code>UpsertFeature</code>,
<code>FastSpatialFilter</code>, <code>FastFeatureCount</code>, <code>FastGetExtent</code>,
<code>FastSetNextByIndex</code>, <code>CreateField</code>, <code>CreateGeomField</code>, <code>DeleteField</code>,
<code>ReorderFields</code>, <code>AlterFieldDefn</code>, <code>AlterGeomFieldDefn</code>, <code>DeleteFeature</code>,
<code>StringsAsUTF8</code>, <code>Transactions</code>, <code>CurveGeometries</code>.
See the GDAL documentation for
<a href="https://gdal.org/api/vector_c_api.html#_CPPv420OGR_L_TestCapability9OGRLayerHPKc"><code>OGR_L_TestCapability()</code></a>.
</p>
<p><code>ogr_layer_create()</code> creates a new layer in an existing vector data source,
with a specified geometry type and spatial reference definition.
This function also accepts a feature class definition given as a list of
field names and their definitions (see ogr_define).
(Note: use <code>ogr_ds_create()</code> to create single-layer formats such as "ESRI
Shapefile", "FlatGeobuf", "GeoJSON", etc.)
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_layer_field_names()</code> returns a character vector of field names on a
layer, or <code>NULL</code> if no fields are found.
</p>
<p><code>ogr_layer_delete()</code> deletes an existing layer in a vector dataset.
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_field_index()</code> tests for existence of an attribute field by name.
Returns the field index on the layer (0-based), or <code>-1</code> if the field does
not exist.
</p>
<p><code>ogr_field_create()</code> creates a new attribute field of specified data type in
a given DSN/layer. Several optional field properties can be specified in
addition to the type. Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_geom_field_create()</code> creates a new geometry field of specified type in
a given DSN/layer. Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_field_rename()</code> renames an existing field on a vector layer.
Not all format drivers support this function. Some drivers may only support
renaming a field while there are still no features in the layer.
<code>AlterFieldDefn</code> is the relevant layer capability to check.
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_field_delete()</code> deletes an existing field on a vector layer.
Not all format drivers support this function. Some drivers may only support
deleting a field while there are still no features in the layer.
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_execute_sql()</code> executes an SQL statement against the data store.
This function can be used to modify the schema or edit data using SQL
(e.g., <code style="white-space: pre;">⁠ALTER TABLE⁠</code>, <code style="white-space: pre;">⁠DROP TABLE⁠</code>, <code style="white-space: pre;">⁠CREATE INDEX⁠</code>, <code style="white-space: pre;">⁠DROP INDEX⁠</code>, <code>INSERT</code>,
<code>UPDATE</code>, <code>DELETE</code>). Currently, this function does not return a result set
for a <code>SELECT</code> statement. Returns <code>NULL</code> invisibly.
Wrapper of <code>GDALDatasetExecuteSQL()</code> in the GDAL C API.
</p>


<h3>Note</h3>

<p>The OGR SQL document linked under <strong>See Also</strong> contains information on the
SQL dialect supported internally by GDAL/OGR. Some format drivers (e.g.,
PostGIS) pass the SQL directly through to the underlying RDBMS (unless
<code>OGRSQL</code> is explicitly passed as the dialect). The SQLite dialect can also
be requested with the <code>SQLite</code> string passed as the <code>dialect</code> argument of
<code>ogr_execute_sql()</code>. This assumes that GDAL/OGR is built with support for
SQLite, and preferably also with Spatialite support to benefit from spatial
functions. The GDAL document for SQLite dialect has detailed information.
</p>
<p>Other SQL dialects may also be present for some vector formats.
For example, the <code>"INDIRECT_SQLITE"</code> dialect might potentially be used with
GeoPackage format (<a href="https://gdal.org/drivers/vector/gpkg.html#sql">https://gdal.org/drivers/vector/gpkg.html#sql</a>).
</p>
<p>The function <code>ogrinfo()</code> can also be used to edit data with SQL statements
(GDAL &gt;= 3.7).
</p>
<p>The name of the geometry column of a layer is empty (<code>""</code>) with some formats
such as ESRI Shapefile and FlatGeobuf. Implications for SQL may depend on the
dialect used. See the GDAL documentation for the "OGR SQL" and "SQLite"
dialects for details.
</p>


<h3>See Also</h3>

<p><code>gdal_formats()</code>, <code>has_spatialite()</code>, <code>ogr_def_field()</code>, <code>ogr_def_layer()</code>,
<code>ogrinfo()</code>, <code>ogr2ogr()</code>
</p>
<p>OGR SQL dialect and SQLite SQL dialect:<br><a href="https://gdal.org/user/ogr_sql_sqlite_dialect.html">https://gdal.org/user/ogr_sql_sqlite_dialect.html</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dsn &lt;- file.path(tempdir(), "test1.gpkg")
ogr_ds_create("GPKG", dsn)
ogr_ds_exists(dsn, with_update = TRUE)
ogr_ds_layer_count(dsn)
ogr_ds_test_cap(dsn)
ogr_layer_exists(dsn, "layer1")
if (ogr_ds_test_cap(dsn)$CreateLayer) {
  opt &lt;- c("GEOMETRY_NULLABLE=NO", "DESCRIPTION=test layer")
  ogr_layer_create(dsn, "layer1", geom_type = "Polygon", srs = "EPSG:5070",
                   lco = opt)
}
ogr_ds_layer_count(dsn)
ogr_layer_exists(dsn, "layer1")
ogr_ds_layer_names(dsn)

ogr_layer_field_names(dsn, "layer1")
ogr_field_index(dsn, "layer1", "field1")
if (ogr_layer_test_cap(dsn, "layer1")$CreateField) {
  ogr_field_create(dsn, "layer1", "field1",
                   fld_type = "OFTInteger64",
                   is_nullable = FALSE)
  ogr_field_create(dsn, "layer1", "field2",
                   fld_type = "OFTString")
}
ogr_field_index(dsn, "layer1", "field1")
ogr_layer_field_names(dsn, "layer1")

# delete a field
if (ogr_layer_test_cap(dsn, "layer1")$DeleteField) {
  ogr_field_delete(dsn, "layer1", "field2")
}
ogr_layer_field_names(dsn, "layer1")

# define a feature class (layer definition)
defn &lt;- ogr_def_layer("Point", srs = epsg_to_wkt(4326))
# add the attribute fields
defn$fld1_name &lt;- ogr_def_field("OFTInteger64",
                                is_nullable = FALSE,
                                is_unique = TRUE)
defn$fld2_name &lt;- ogr_def_field("OFTString",
                                fld_width = 25,
                                is_nullable = FALSE,
                                default_value = "'a default string'")
defn$third_field &lt;- ogr_def_field("OFTReal",
                                  default_value = "0.0")

ogr_layer_create(dsn, "layer2", layer_defn = defn)
ogr_ds_layer_names(dsn)
ogr_layer_field_names(dsn, "layer2")

# add a field using SQL instead
sql &lt;- "ALTER TABLE layer2 ADD field4 float"
ogr_execute_sql(dsn, sql)
ogr_layer_field_names(dsn, "layer2")

# rename a field
if (ogr_layer_test_cap(dsn, "layer1")$AlterFieldDefn) {
  ogr_field_rename(dsn, "layer2", "field4", "renamed_field")
}
ogr_layer_field_names(dsn, "layer2")

# GDAL &gt;= 3.7
if (as.integer(gdal_version()[2]) &gt;= 3070000)
  ogrinfo(dsn, "layer2")

deleteDataset(dsn)

# edit data using SQL
src &lt;- system.file("extdata/ynp_fires_1984_2022.gpkg", package="gdalraster")
perims_shp &lt;- file.path(tempdir(), "mtbs_perims.shp")
ogr2ogr(src, perims_shp, src_layers = "mtbs_perims")
ogr_ds_format(perims_shp)
ogr_ds_layer_names(perims_shp)
ogr_layer_field_names(perims_shp, "mtbs_perims")

if (ogr_layer_test_cap(perims_shp, "mtbs_perims")$CreateField) {
  sql &lt;- "ALTER TABLE mtbs_perims ADD burn_bnd_ha float"
  ogr_execute_sql(perims_shp, sql)
  # with GDAL &gt;= 3.7, equivalent to:
  # ogrinfo(perims_shp, cl_arg = c("-sql", sql), read_only = FALSE)
}

sql &lt;- "UPDATE mtbs_perims SET burn_bnd_ha = (burn_bnd_ac / 2.471)"
ogr_execute_sql(perims_shp, sql, dialect = "SQLite")
ogr_layer_field_names(perims_shp, "mtbs_perims")

# if GDAL &gt;= 3.7:
#   ogrinfo(perims_shp, "mtbs_perims")
# or, for output incl. the feature data (omit the default "-so" arg):
#   ogrinfo(perims_shp, "mtbs_perims", cl_arg = "-nomd")

deleteDataset(perims_shp)
</code></pre>


</div>