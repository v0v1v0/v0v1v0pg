<div class="container">

<table style="width: 100%;"><tr>
<td>printCrudeAndAdjustedModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Output crude and adjusted model data</h2>

<h3>Description</h3>

<p>Prints table for a fitted object. It prints by default a latex table but can
also be converted into a HTML table that should be more compatible with common
word processors. For details run <code>vignette("printCrudeAndAdjustedModel")</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">printCrudeAndAdjustedModel(
  model,
  order,
  digits = 2,
  ci_lim = c(-Inf, Inf),
  sprintf_ci_str = getOption("sprintf_ci_str", "%s to %s"),
  add_references,
  add_references_pos,
  reference_zero_effect,
  groups,
  rowname.fn,
  use_labels = TRUE,
  desc_column = FALSE,
  desc_args = caDescribeOpts(digits = digits),
  impute_args,
  ...
)

## S3 method for class 'printCrudeAndAdjusted'
rbind(..., alt.names, deparse.level = 1)

## S3 method for class 'printCrudeAndAdjusted'
print(x, ...)

## S3 method for class 'printCrudeAndAdjusted'
htmlTable(x, ...)

## S3 method for class 'printCrudeAndAdjusted'
x[i, j, ...]

## S3 method for class 'printCrudeAndAdjusted'
cbind(..., alt.names, deparse.level = 1)

## S3 method for class 'printCrudeAndAdjusted'
knit_print(x, ...)

## S3 method for class 'printCrudeAndAdjusted'
latex(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A regression model fit, i.e. the returned object from your
regression function, or the output from <code>getCrudeAndAdjustedModelData()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>A vector with regular expressions for each group, use if youe
want to reorder the groups in another way than what you've used in your original
function. You can also use this in order to skip certain variables from the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>The number of digits to round to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_lim</code></td>
<td>
<p>A limit vector number that specifies if any values should be
abbreviated above or below this value, for instance a value of 1000
would give a value of <code>&gt; -1000</code> for a value of 1001. This gives
a prettier table when you have very wide confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sprintf_ci_str</code></td>
<td>
<p>A string according to <code>sprintf()</code> to
write the confidence interval where the first %s is the lower and
the second the upper. You can choose to set this through setting the option
<code>sprintf_ci_str</code>, e.g. <code>options(sprintf_ci_str = "%s - %s")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_references</code></td>
<td>
<p>True if it should use the data set to look for
references, otherwise supply the function with a vector with names.
Sometimes you want to indicate the reference row for each group.
This needs to be just as many as the  groups as the order identified.
Use NA if you don't want to have a reference for that particular group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_zero_effect</code></td>
<td>
<p>Used with references, tells if zero effect
is in exponential form, i.e. <code>exp(0) = 1</code>, or in regular format,
i.e. <code>0 = 0</code> (can be set to any value)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>If you wish to have other than the default <code>rgroup</code> names
for the grouping parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowname.fn</code></td>
<td>
<p>A function that takes a row name and sees if it needs
beautifying. The function has only one parameter the coefficients name and
should return a string or expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_labels</code></td>
<td>
<p>If the rowname.fn function doesn't change the name then
the label should be used instead of the name, that is if there is a
label and it isn't a factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>desc_column</code></td>
<td>
<p>Add descriptive column to the crude and adjusted table</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>desc_args</code></td>
<td>
<p>The description arguments that are to be used for the
the description columns. The options/arguments should be generated by the
<code>caDescribeOpts</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impute_args</code></td>
<td>
<p>A list with additional arguments if the provided input is
a imputed object. Currently the list options <code>coef_change</code> and
<code>variance.inflation</code> are supported. If you want both columns then
the simplest way is to provide the list:
<code>list(coef_change = TRUE, variance.inflation = TRUE)</code>.
The <code>coef_change</code> adds a column with the change in coefficients due to
the imputation, the the "raw" model is subtracted from the imputed results.
The "raw" model is the unimputed model, <code>coef(imputed_model) - coef(raw_model)</code>.
The <code>variance.inflation</code> adds the <code>variance.inflation.impute</code> from the
<code>fit.mult.impute()</code> to a separate column. See the description
for the <code>variance.inflation.impute</code> in in the <code>fit.mult.impute()</code>
description.
Both arguments can be customized by providing a <code>list</code>. The list can have
the elements <code>type</code>, <code>name</code>, <code>out_str</code>, and/or <code>digits</code>.
The <code>type</code> can for <code>coef_change</code>/<code>variance.impute</code> be either
"percent" or "ratio", note that <code>variance.inflation.impute</code> was not
originally intended to be interpreted as %. The default for <code>coef_change</code> is to
have "diff", that gives the absolute difference in the coefficient.
The <code>name</code> provides the column name, the <code>out_str</code> should be a string
that is compatible with <code>sprintf()</code> and also contains an argument
for accepting a float value, e.g. "
column. The <code>digits</code> can be used if you are not using the <code>out_str</code>
argument, it simply specifies the number of digits to show. See the example
for how for a working example.
<em>Note</em> that currently only the <code>fit.mult.impute()</code>
is supported by this option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>outputs from <code>printCrudeAndAdjusted</code>. If mixed then it defaults to rbind.data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt.names</code></td>
<td>
<p>If you don't want to use named arguments for the <code>tspanner</code> attribute in the <code>rbind</code>
or the <code>cgroup</code> in the <code>cbind</code> but a vector with names then use this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deparse.level</code></td>
<td>
<p>backward compatibility</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The output object from the <code>printCrudeAndAdjustedModel</code> function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>The output object from the printCrudeAndAdjustedModel function</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>matrix</code> Returns a matrix of class printCrudeAndAdjusted that
has a default print method associated with
</p>


<h3>Warning</h3>

<p>If you call this function and you've changed any of the variables
used in the original call, i.e. the premises are changed, this function will not
remember the original values and the statistics will be faulty!
</p>


<h3>See Also</h3>

<p><code>latex()</code> for details.
</p>
<p>Other crudeAndAdjusted functions: 
<code>getCrudeAndAdjustedModelData()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulated data to use
set.seed(10)
ds &lt;- data.frame(
  ftime = rexp(200),
  fstatus = sample(0:1, 200, replace = TRUE),
  Variable1 = runif(200),
  Variable2 = runif(200),
  Variable3 = runif(200),
  Variable4 = factor(sample(LETTERS[1:4], size = 200, replace = TRUE))
)

library(rms)
dd &lt;- datadist(ds)
options(datadist = "dd")

fit &lt;- cph(Surv(ftime, fstatus) ~ Variable1 + Variable3 + Variable2 + Variable4,
  data = ds, x = TRUE, y = TRUE
)
printCrudeAndAdjustedModel(fit, order = c("Variable[12]", "Variable3"))
printCrudeAndAdjustedModel(fit,
  order = c("Variable3", "Variable4"),
  add_references = TRUE,
  desc_column = TRUE
)

# Now to a missing example
n &lt;- 500
ds &lt;- data.frame(
  x1 = factor(sample(LETTERS[1:4], size = n, replace = TRUE)),
  x2 = rnorm(n, mean = 3, 2),
  x3 = factor(sample(letters[1:3], size = n, replace = TRUE))
)

ds$Missing_var1 &lt;- factor(sample(letters[1:4], size = n, replace = TRUE))
ds$Missing_var2 &lt;- factor(sample(letters[1:4], size = n, replace = TRUE))
ds$y &lt;- rnorm(nrow(ds)) +
  (as.numeric(ds$x1) - 1) * 1 +
  (as.numeric(ds$Missing_var1) - 1) * 1 +
  (as.numeric(ds$Missing_var2) - 1) * .5

# Create a messy missing variable
non_random_missing &lt;- sample(which(ds$Missing_var1 %in% c("b", "d")),
  size = 150, replace = FALSE
)
# Restrict the non-random number on the x2 variables
non_random_missing &lt;- non_random_missing[non_random_missing %in%
  which(ds$x2 &gt; mean(ds$x2) * 1.5) &amp;
  non_random_missing %in%
    which(ds$x2 &gt; mean(ds$y))]
ds$Missing_var1[non_random_missing] &lt;- NA

# Simple missing variable
ds$Missing_var2[sample(1:nrow(ds), size = 50)] &lt;- NA

# Setup the rms environment
ddist &lt;- datadist(ds)
options(datadist = "ddist")

impute_formula &lt;-
  as.formula(paste(
    "~",
    paste(colnames(ds),
      collapse = "+"
    )
  ))

imp_ds &lt;- aregImpute(impute_formula, data = ds, n.impute = 10)

fmult &lt;- fit.mult.impute(y ~ x1 + x2 + x3 +
  Missing_var1 + Missing_var2,
fitter = ols, xtrans = imp_ds, data = ds
)

printCrudeAndAdjustedModel(fmult,
  impute_args = list(
    variance.inflation = TRUE,
    coef_change = list(
      type = "diff",
      digits = 3
    )
  )
)


# Use some labels and style to prettify the output
# fro the mtcars dataset
data("mtcars")

label(mtcars$mpg) &lt;- "Gas"
units(mtcars$mpg) &lt;- "Miles/(US) gallon"

label(mtcars$wt) &lt;- "Weight"
units(mtcars$wt) &lt;- "10^3 kg" # not sure the unit is correct

mtcars$am &lt;- factor(mtcars$am, levels = 0:1, labels = c("Automatic", "Manual"))
label(mtcars$am) &lt;- "Transmission"

mtcars$gear &lt;- factor(mtcars$gear)
label(mtcars$gear) &lt;- "Gears"

# Make up some data for making it slightly more interesting
mtcars$col &lt;- factor(sample(c("red", "black", "silver"), size = NROW(mtcars), replace = TRUE))
label(mtcars$col) &lt;- "Car color"

require(splines)
fit_mtcar &lt;- lm(mpg ~ wt + gear + col, data = mtcars)
printCrudeAndAdjustedModel(fit_mtcar,
  add_references = TRUE,
  ctable = TRUE,
  desc_column = TRUE,
  digits = 1,
  desc_args = caDescribeOpts(
    digits = 1,
    colnames = c("Avg.")
  )) |&gt;
  htmlTable::addHtmlTableStyle(css.rgroup = "",
                               css.header = "font-weight: normal")

printCrudeAndAdjustedModel(fit_mtcar,
  add_references = TRUE,
  desc_column = TRUE,
  order = c("Interc", "gear")
)

# Alterntive print - just an example, doesn't make sense to skip reference
printCrudeAndAdjustedModel(fit_mtcar,
  order = c("col", "gear"),
  groups = c("Color", "Gears"),
  add_references = c("black", NA),
  ctable = TRUE
)

# Now we can also combine models into one table using rbind()
mpg_model &lt;- printCrudeAndAdjustedModel(lm(mpg ~ wt + gear + col, data = mtcars),
  add_references = TRUE,
  ctable = TRUE,
  desc_column = TRUE,
  digits = 1,
  desc_args = caDescribeOpts(
    digits = 1,
    colnames = c("Avg.")
  )
)

wt_model &lt;- printCrudeAndAdjustedModel(lm(wt ~ mpg + gear + col, data = mtcars),
  add_references = TRUE,
  ctable = TRUE,
  desc_column = TRUE,
  digits = 1,
  desc_args = caDescribeOpts(
    digits = 1,
    colnames = c("Avg.")
  )
)

library(htmlTable)
rbind(Miles = mpg_model, Weight = wt_model) |&gt;
  addHtmlTableStyle(pos.caption = "bottom") |&gt;
  htmlTable(caption = paste("Combining models together with a table spanner element",
                            "separating each model"))
</code></pre>


</div>