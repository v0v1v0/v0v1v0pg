<div class="container">

<table style="width: 100%;"><tr>
<td>venn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot a Venn diagram</h2>

<h3>Description</h3>

<p>Plot a Venn diagrams for up to 5 sets
</p>


<h3>Usage</h3>

<pre><code class="language-R">venn(data, universe=NA, small=0.7, showSetLogicLabel=FALSE,
     simplify=FALSE, show.plot=TRUE, intersections=TRUE, names,
     ...)

## S3 method for class 'venn'
plot(x, y, ..., small=0.7, showSetLogicLabel=FALSE,
     simplify=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data,x</code></td>
<td>
<p>Either a list list containing vectors of names or indices
of group intersections, or a data frame containing boolean indicators of
group intersectionship (see below)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>universe</code></td>
<td>
<p>Subset of valid name/index elements. Values  ignore values
in <code>data</code> not in this list will be ignored. Use <code>NA</code> to
use all elements of <code>data</code> (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small</code></td>
<td>
<p>Character scaling of the smallest group counts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showSetLogicLabel</code></td>
<td>
<p>Logical flag indicating whether the internal
group label should be displayed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>Logical flag indicating whether unobserved groups
should be omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.plot</code></td>
<td>
<p>Logical flag indicating whether the plot should be
displayed.  If false, simply returns the group count matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intersections</code></td>
<td>
<p>Logical flag indicating
if the returned object should have the attribute
"individuals.in.intersections" featuring for every set a list of
individuals that are assigned to it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional graphical parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Optional vector of group names.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>data</code> should be either a named list of vectors containing
character string names ("GeneAABBB", "GeneBBBCY", .., "GeneXXZZ") or
indexes of group intersections (1, 2, .., N), or a data frame containing
indicator variables (TRUE, FALSE, TRUE, ..) for group intersectionship.
Group names will be taken from the component list element or column
names.
</p>


<h3>Value</h3>

<p>Invisibly returns an object of class "venn", containing:
</p>

<ul>
<li>
<p> A matrix of all possible sets of groups, and the observed count
of items belonging to each The fist column contains observed
counts, subsequent columns contain 0-1 indicators of group
intersectionship.
</p>
</li>
<li>
<p> If <code>intersections=TRUE</code>, the attribute <code>intersections</code>
will be a list of vectors containing the names of the elements
belonging to each subset.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Steffen Moeller, with cleanup and packaging by Gregory R. Warnes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
##
## Example using a list of item names belonging to the
## specified group.
##

## construct some fake gene names..
oneName &lt;- function() paste(sample(LETTERS,5,replace=TRUE),collapse="")
geneNames &lt;- replicate(1000, oneName())

##
GroupA &lt;- sample(geneNames, 400, replace=FALSE)
GroupB &lt;- sample(geneNames, 750, replace=FALSE)
GroupC &lt;- sample(geneNames, 250, replace=FALSE)
GroupD &lt;- sample(geneNames, 300, replace=FALSE)
input  &lt;-list(GroupA,GroupB,GroupC,GroupD)
input

tmp &lt;- venn(input)
attr(tmp, "intersections")

##
## Example using a list of item indexes belonging to the
## specified group.
##
GroupA.i &lt;- which(geneNames %in% GroupA)
GroupB.i &lt;- which(geneNames %in% GroupB)
GroupC.i &lt;- which(geneNames %in% GroupC)
GroupD.i &lt;- which(geneNames %in% GroupD)
input.i  &lt;-list(A=GroupA.i,B=GroupB.i,C=GroupC.i,D=GroupD.i)
input.i

venn(input.i)

##
## Example using a data frame of indicator ('f'lag) columns
##
GroupA.f &lt;- geneNames %in% GroupA
GroupB.f &lt;- geneNames %in% GroupB
GroupC.f &lt;- geneNames %in% GroupC
GroupD.f &lt;- geneNames %in% GroupD
input.df &lt;- data.frame(A=GroupA.f,B=GroupB.f,C=GroupC.f,D=GroupD.f)
head(input.df)
venn(input.df)

## smaller set to create empty groupings
small &lt;- input.df[1:20,]

venn(small, simplify=FALSE) # with empty groupings
venn(small, simplify=TRUE)  # without empty groupings

## Capture group counts, but don't plot
tmp &lt;- venn(input, show.plot=FALSE)
tmp

## Show internal binary group labels
venn(input, showSetLogicLabel=TRUE)

## Limit  universe
tmp &lt;- venn(input, universe=geneNames[1:100])
tmp

##
## Example to determine which elements are in A and B but not in
## C and D using the 'intersections' attribute.
##
tmp &lt;- venn(input, intersection=TRUE)
isect &lt;- attr(tmp, "intersection")

# Look at all of the subsets
str(isect)

# Extract and combine the subsets of interest..
AandB &lt;- unique(c(isect$A, isect$B, isect$'A:B'))

# and look at the results
str(AandB)

##
## The full set of elements of each intersection is provided in the
## "interesections" attribute.
##
a&lt;-venn(list(1:5,3:8), show.plot=FALSE)
intersections&lt;-attr(a,"intersections")
print(intersections)
# $A
# [1] "1" "2"
#
# $B
# [1] "6" "7" "8"
#
# $`A:B`
# [1] "3" "4" "5"
</code></pre>


</div>